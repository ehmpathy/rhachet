/**
 * mock rhachet-brains-test package for acceptance tests
 * provides claude-code adapter only
 */

const fs = require('fs');
const path = require('path');

const getConfigPath = (repoPath) => path.join(repoPath, '.claude', 'settings.json');

const readConfig = (repoPath) => {
  const configPath = getConfigPath(repoPath);
  if (!fs.existsSync(configPath)) return { hooks: {} };
  return JSON.parse(fs.readFileSync(configPath, 'utf-8'));
};

const writeConfig = (repoPath, config) => {
  const configPath = getConfigPath(repoPath);
  fs.mkdirSync(path.dirname(configPath), { recursive: true });
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
};

const eventMap = { onBoot: 'SessionStart', onTool: 'PreToolUse', onStop: 'Stop' };
const toClaudeEvent = (e) => eventMap[e] || e;
const toRhachetEvent = (e) => Object.entries(eventMap).find(([, v]) => v === e)?.[0] || e;

const getBrainHooks = ({ brain, repoPath }) => {
  if (brain !== 'claude-code') return null;

  return {
    slug: 'claude-code',
    dao: {
      get: {
        one: async ({ by }) => {
          const config = readConfig(repoPath);
          const hooks = config.hooks?.[toClaudeEvent(by.unique.event)] || [];
          const found = hooks.find((h) => h.command === by.unique.command && h.matcher === by.unique.author);
          if (!found) return null;
          return { author: found.matcher, event: by.unique.event, command: found.command, timeout: found.timeout || '30s' };
        },
        all: async (input) => {
          const config = readConfig(repoPath);
          const results = [];
          // support both by.author and by.filter.author for filter
          const by = input?.by;
          const authorFilter = by?.filter?.author ?? by?.author;
          for (const [claudeEvent, hooks] of Object.entries(config.hooks || {})) {
            for (const hook of hooks) {
              if (authorFilter && hook.matcher !== authorFilter) continue;
              results.push({ author: hook.matcher, event: toRhachetEvent(claudeEvent), command: hook.command, timeout: hook.timeout || '30s' });
            }
          }
          return results;
        },
      },
      set: {
        findsert: async ({ hook }) => {
          const config = readConfig(repoPath);
          const claudeEvent = toClaudeEvent(hook.event);
          if (!config.hooks) config.hooks = {};
          if (!config.hooks[claudeEvent]) config.hooks[claudeEvent] = [];
          if (config.hooks[claudeEvent].some((h) => h.command === hook.command && h.matcher === hook.author)) return hook;
          config.hooks[claudeEvent].push({ matcher: hook.author, command: hook.command, timeout: hook.timeout });
          writeConfig(repoPath, config);
          return hook;
        },
        upsert: async ({ hook }) => {
          const config = readConfig(repoPath);
          const claudeEvent = toClaudeEvent(hook.event);
          if (!config.hooks) config.hooks = {};
          if (!config.hooks[claudeEvent]) config.hooks[claudeEvent] = [];
          const entry = { matcher: hook.author, command: hook.command, timeout: hook.timeout };
          const idx = config.hooks[claudeEvent].findIndex((h) => h.command === hook.command && h.matcher === hook.author);
          if (idx >= 0) config.hooks[claudeEvent][idx] = entry;
          else config.hooks[claudeEvent].push(entry);
          writeConfig(repoPath, config);
          return hook;
        },
      },
      del: async ({ by }) => {
        const config = readConfig(repoPath);
        const claudeEvent = toClaudeEvent(by.unique.event);
        if (!config.hooks?.[claudeEvent]) return;
        config.hooks[claudeEvent] = config.hooks[claudeEvent].filter((h) => !(h.command === by.unique.command && h.matcher === by.unique.author));
        if (config.hooks[claudeEvent].length === 0) delete config.hooks[claudeEvent];
        writeConfig(repoPath, config);
      },
    },
  };
};

module.exports = { getBrainHooks };
