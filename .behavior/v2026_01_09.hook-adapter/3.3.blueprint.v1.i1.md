# blueprint = implementation plan for hook-adapter

## summary

this blueprint defines the implementation steps to fulfill the hook-adapter feature. each step includes location, purpose, dependencies, and test coverage requirements.

key principles:
- **declastruct pattern** — implement via idempotent get/set/del DAO operations
- **adapter contract** — brain suppliers implement `BrainHooksAdapter` interface
- **namespace isolation** — hooks scoped by `author` field (`repo=X/role=Y`)
- **test-driven** — each step includes unit, integration, or acceptance test requirements

---

## filediffs treestruct

```
src/
├── domain.objects/
│   ├── BrainHookEvent.ts                    [+] new
│   ├── BrainHookFilter.ts                   [+] new
│   ├── BrainHookFilter.test.ts              [+] new
│   ├── BrainHook.ts                         [+] new
│   ├── BrainHook.test.ts                    [+] new
│   ├── BrainHooksAdapter.ts                 [+] new
│   ├── BrainHooksAdapterDao.ts              [+] new
│   ├── BrainSpecifier.ts                    [+] new
│   ├── RoleHookOnBrain.ts                   [+] new
│   ├── RoleHookOnBrain.test.ts              [+] new
│   ├── RoleHooksOnBrain.ts                  [+] new
│   ├── RoleHooksOnBrain.test.ts             [+] new
│   ├── RoleHooks.ts                         [+] new
│   ├── RoleHooks.test.ts                    [+] new
│   ├── RoleHooksOnDispatch.ts               [~] rename from InvokeHooks.ts
│   └── Role.ts                              [~] modify (add hooks property)
│
├── domain.operations/
│   └── brains/
│       ├── discoverBrainPackages.ts                     [+] new
│       ├── discoverBrainPackages.test.ts                [+] new
│       ├── getBrainHooksAdapterByConfigImplicit.ts      [+] new
│       ├── getBrainHooksAdapterByConfigImplicit.test.ts [+] new
│       ├── getBrainHooksAdapterByConfigImplicit.integration.test.ts [+] new
│       ├── detectBrainReplsInRepo.ts                    [+] new
│       ├── detectBrainReplsInRepo.test.ts               [+] new
│       ├── syncRoleHooksIntoBrainRepl.ts                [+] new
│       ├── syncRoleHooksIntoBrainRepl.test.ts           [+] new
│       ├── syncRoleHooksIntoBrainRepl.integration.test.ts [+] new
│       ├── applyRoleHooksToDetectedBrains.ts            [+] new
│       └── applyRoleHooksToDetectedBrains.integration.test.ts [+] new
│
├── contract/
│   └── cli/
│       └── invokeInit.ts                    [~] modify (add --hooks option)
│
└── _topublish/
    ├── rhachet-brains-anthropic/
    │   ├── package.json                     [+] new
    │   └── src/
    │       ├── index.ts                     [+] new
    │       └── hooks/
    │           ├── getBrainHooks.ts         [+] new
    │           ├── claudeCodeAdapter.ts     [+] new
    │           ├── claudeCodeAdapter.test.ts [+] new
    │           ├── claudeCodeAdapter.integration.test.ts [+] new
    │           ├── translateHook.ts         [+] new
    │           ├── translateHook.test.ts    [+] new
    │           ├── config.dao.ts            [+] new
    │           └── config.dao.integration.test.ts [+] new
    │
    └── rhachet-brains-opencode/
        ├── package.json                     [+] new
        └── src/
            ├── index.ts                     [+] new
            └── hooks/
                ├── getBrainHooks.ts         [+] new
                ├── openCodeAdapter.ts       [+] new
                ├── openCodeAdapter.test.ts  [+] new
                ├── openCodeAdapter.integration.test.ts [+] new
                ├── translateHook.ts         [+] new
                ├── translateHook.test.ts    [+] new
                ├── plugin.dao.ts            [+] new
                └── plugin.dao.integration.test.ts [+] new

accept.blackbox/
├── cli/
│   └── init.hooks.acceptance.test.ts        [+] new
└── .test/
    └── assets/
        ├── with-claude-config/              [+] new fixture
        │   ├── package.json
        │   ├── rhachet.use.ts
        │   └── .claude/
        │       └── settings.json
        ├── with-role-hooks/                 [+] new fixture
        │   ├── package.json
        │   ├── rhachet.use.ts
        │   └── node_modules/
        │       └── rhachet-roles-test/
        │           └── (role with hooks.onBrain)
        └── with-brains-package/             [+] new fixture
            ├── package.json
            ├── rhachet.use.ts
            └── node_modules/
                └── rhachet-brains-anthropic/
                    └── (mock adapter)
```

**legend:**
- `[+] new` — file to create
- `[~] modify` — file to edit
- `[~] rename` — file to rename

**totals:**
- new files: ~49
- modified files: 2
- renamed files: 1
- new fixtures: 3

---

## codepaths treestruct

### cli entrypoint: `npx rhachet init --roles <role> --hooks [slug...]`

```
invokeInit(options)
│
├── [prior behavior] initRolesFromPackages({ specifiers, from })
│   └── (link + init roles as before)
│
└── [NEW] if options.hooks !== undefined
    │
    ├── getLinkedRoles({ from })
    │   └── scan .agent/repo=*/role=*/ for linked roles
    │
    └── applyRoleHooksToDetectedBrains({ roles, brains?, from })
        │
        ├── resolve brain slugs
        │   ├── if brains provided → use explicit slugs
        │   └── if brains undefined → detectBrainReplsInRepo({ from })
        │       ├── check .claude/settings.json → "claudecode"
        │       └── check .opencode/ directory → "opencode"
        │
        ├── resolve adapters for each slug
        │   └── getBrainHooksAdapterByConfigImplicit({ slug, from })
        │       ├── discoverBrainPackages({ from })
        │       │   └── scan package.json for rhachet-brains-*
        │       │
        │       ├── for each package: import → getBrainHooks({ slug })
        │       │   ├── rhachet-brains-anthropic → claudeCodeAdapter | null
        │       │   └── rhachet-brains-opencode → openCodeAdapter | null
        │       │
        │       └── return adapter | null | throw (ambiguous)
        │
        └── for each role × adapter
            └── syncRoleHooksIntoBrainRepl({ role, registry, adapter })
                │
                ├── compute author namespace
                │   └── "repo={registry.slug}/role={role.slug}"
                │
                ├── read declared hooks from Role.hooks.onBrain
                │   ├── onBoot: RoleHookOnBrain[]
                │   ├── onTool: RoleHookOnBrain[]
                │   └── onStop: RoleHookOnBrain[]
                │
                ├── get hooks found via adapter.dao.get.all({ by: { author } })
                │
                ├── compute diff
                │   ├── toAdd = declared - found
                │   ├── toRemove = found - declared
                │   └── toRetain = declared ∩ found
                │
                ├── apply upserts
                │   └── for each declared hook
                │       └── adapter.dao.set.upsert({ hook: BrainHook })
                │
                └── apply deletes
                    └── for each hook to remove
                        └── adapter.dao.del({ by: { unique } })
```

### adapter.dao operations: claudeCodeAdapter

```
claudeCodeAdapter.dao
│
├── get.one({ by: { unique } })
│   ├── config.dao.read({ from })
│   │   └── fs.readFile(.claude/settings.json) → parse JSON
│   ├── find hook in settings.hooks by [author, event, command]
│   └── return BrainHook | null
│
├── get.all({ by?: { author | event | command } })
│   ├── config.dao.read({ from })
│   ├── collect hooks from all event arrays (SessionStart, PreToolUse, etc)
│   ├── filter by criteria if provided
│   └── return BrainHook[]
│
├── set.findsert({ hook })
│   ├── get.one({ by: { unique: hook } })
│   ├── if found → return found (no change)
│   └── if not found
│       ├── translateHook({ hook }) → claude-code format
│       ├── config.dao.write({ settings, from })
│       └── return hook
│
├── set.upsert({ hook })
│   ├── get.one({ by: { unique: hook } })
│   ├── translateHook({ hook }) → claude-code format
│   ├── if found → replace in settings.hooks
│   ├── if not found → append to settings.hooks
│   ├── config.dao.write({ settings, from })
│   └── return hook
│
└── del({ by: { unique } })
    ├── config.dao.read({ from })
    ├── remove hook from settings.hooks by [author, event, command]
    ├── config.dao.write({ settings, from })
    └── return void
```

### translateHook: rhachet → claude-code

```
translateHook({ hook: BrainHook })
│
├── map event
│   ├── onBoot → "SessionStart"
│   ├── onTool + filter.when=before → "PreToolUse"
│   ├── onTool + filter.when=after → "PostToolUse"
│   └── onStop → "Stop"
│
├── map timeout
│   └── IsoDuration → seconds (e.g., "PT60S" → 60)
│
├── map filter (for onTool only)
│   └── filter.what → tool_name pattern
│
└── return claude-code hook shape
    {
      type: "command",
      command: hook.command,
      timeout: timeoutSeconds,
      tool_name?: filter.what  // for PreToolUse/PostToolUse
    }
```

### config.dao: read/write .claude/settings.json

```
config.dao.read({ from })
│
├── path = join(from, '.claude/settings.json')
├── if not exists → return { hooks: {} }
├── fs.readFile(path) → content
├── JSON.parse(content) → settings
└── return settings

config.dao.write({ settings, from })
│
├── path = join(from, '.claude/settings.json')
├── ensure .claude/ directory exists
├── JSON.stringify(settings, null, 2) → content
├── fs.writeFile(path, content)
└── return void
```

### translateHook: rhachet → opencode

```
translateHook({ hook: BrainHook })
│
├── map event → TypeScript handler code
│   ├── onBoot → session.created + session.compacted handlers
│   ├── onTool + filter.when=before → tool.execute.before handler
│   ├── onTool + filter.when=after → tool.execute.after handler
│   └── onStop → session.idle handler
│
├── map timeout
│   └── IsoDuration → milliseconds (e.g., "PT60S" → 60000)
│
├── map filter (for onTool only)
│   └── filter.what → tool name pattern check in handler
│
├── generate author metadata comment
│   └── // rhachet-hook: author={author}, event={event}, command={command}
│
└── return TypeScript code string for plugin file
```

### plugin.dao: read/write .opencode/plugin/rhachet-hooks.ts

```
plugin.dao.read({ from })
│
├── path = join(from, '.opencode/plugin/rhachet-hooks.ts')
├── if not exists → return { hooks: [] }
├── fs.readFile(path) → content
├── parse hooks from metadata comments
│   └── extract // rhachet-hook: ... lines → BrainHook[]
└── return hooks

plugin.dao.write({ hooks, from })
│
├── path = join(from, '.opencode/plugin/rhachet-hooks.ts')
├── ensure .opencode/plugin/ directory exists
├── generate plugin file content
│   ├── import statements
│   ├── for each hook: translateHook → handler code
│   └── export plugin object
├── fs.writeFile(path, content)
└── return void
```

### declarative sync: diff algorithm

```
syncRoleHooksIntoBrainRepl({ role, registry, adapter })
│
├── declared = flatMap role.hooks.onBrain events to BrainHook[]
│   └── for each event in [onBoot, onTool, onStop]
│       └── map RoleHookOnBrain → BrainHook (add author, event)
│
├── found = adapter.dao.get.all({ by: { author } })
│
├── compute unique keys
│   ├── declaredKeys = declared.map(h => serialize([h.author, h.event, h.command]))
│   └── foundKeys = found.map(h => serialize([h.author, h.event, h.command]))
│
├── diff
│   ├── toUpsert = declared (all declared get upserted for idempotency)
│   └── toDelete = found.filter(h => !declaredKeys.has(key(h)))
│
├── apply upserts
│   └── Promise.all(toUpsert.map(h => adapter.dao.set.upsert({ hook: h })))
│
└── apply deletes
    └── Promise.all(toDelete.map(h => adapter.dao.del({ by: { unique: h } })))
```

---

## phase 1: domain.objects

### step 1.1: create BrainHookEvent type

**location:** `src/domain.objects/BrainHookEvent.ts`

**purpose:** define event types that trigger brain hooks

**implementation:**
```ts
export type BrainHookEvent = 'onBoot' | 'onTool' | 'onStop';
```

**tests:** unit test validates type constraints

---

### step 1.2: create BrainHookFilter literal

**location:** `src/domain.objects/BrainHookFilter.ts`

**purpose:** filter criteria for onTool hooks — separates tool selection from execution time

**implementation:**
```ts
import { DomainLiteral } from 'domain-objects';

export interface BrainHookFilter {
  what: string;                      // tool pattern: "Bash", "Write|Edit", "*"
  when?: 'before' | 'after';         // time, defaults to "before"
}

export class BrainHookFilter
  extends DomainLiteral<BrainHookFilter>
  implements BrainHookFilter {}
```

**tests:** unit test for instantiation and default values

---

### step 1.3: create BrainHook entity

**location:** `src/domain.objects/BrainHook.ts`

**purpose:** brain hook with author namespace for ownership track

**implementation:**
```ts
import { DomainEntity } from 'domain-objects';

export interface BrainHook {
  author: string;                    // namespace: "repo=X/role=Y"
  event: BrainHookEvent;
  command: string;
  timeout: string;                   // IsoDuration: "PT60S", "PT5M"
  filter?: BrainHookFilter;          // for onTool only
}

export class BrainHook
  extends DomainEntity<BrainHook>
  implements BrainHook
{
  public static unique = ['author', 'event', 'command'] as const;
  public static updatable = ['filter', 'timeout'] as const;
}
```

**tests:**
- unit test for unique key computation
- unit test for updatable field validation

---

### step 1.4: create RoleHookOnBrain literal

**location:** `src/domain.objects/RoleHookOnBrain.ts`

**purpose:** a single hook declared by a role — author derived on application

**implementation:**
```ts
import { DomainLiteral } from 'domain-objects';

export interface RoleHookOnBrain {
  command: string;
  timeout: string;
  filter?: BrainHookFilter;
}

export class RoleHookOnBrain
  extends DomainLiteral<RoleHookOnBrain>
  implements RoleHookOnBrain {}
```

**tests:** unit test for instantiation

---

### step 1.5: create RoleHooksOnBrain literal

**location:** `src/domain.objects/RoleHooksOnBrain.ts`

**purpose:** container for hook declarations by event type

**implementation:**
```ts
import { DomainLiteral } from 'domain-objects';

export interface RoleHooksOnBrain {
  onBoot?: RoleHookOnBrain[];
  onTool?: RoleHookOnBrain[];
  onStop?: RoleHookOnBrain[];
}

export class RoleHooksOnBrain
  extends DomainLiteral<RoleHooksOnBrain>
  implements RoleHooksOnBrain
{
  public static nested = {
    onBoot: RoleHookOnBrain,
    onTool: RoleHookOnBrain,
    onStop: RoleHookOnBrain,
  };
}
```

**tests:** unit test for nested hydration

---

### step 1.6: rename InvokeHooks → RoleHooksOnDispatch

**location:** `src/domain.objects/RoleHooksOnDispatch.ts` (rename from `InvokeHooks.ts`)

**purpose:** align name with domain model (Role.hooks.onDispatch)

**steps:**
1. rename file from `InvokeHooks.ts` to `RoleHooksOnDispatch.ts`
2. rename interface and class from `InvokeHooks` to `RoleHooksOnDispatch`
3. update all imports and references via sedreplace

**tests:** verify all prior tests pass after rename

---

### step 1.7: create RoleHooks literal

**location:** `src/domain.objects/RoleHooks.ts`

**purpose:** separates dispatch hooks (rhachet middleware) from brain hooks (brain events)

**implementation:**
```ts
import { DomainLiteral } from 'domain-objects';

export interface RoleHooks {
  onDispatch?: RoleHooksOnDispatch;
  onBrain?: RoleHooksOnBrain;
}

export class RoleHooks
  extends DomainLiteral<RoleHooks>
  implements RoleHooks
{
  public static nested = {
    onDispatch: RoleHooksOnDispatch,
    onBrain: RoleHooksOnBrain,
  };
}
```

**tests:** unit test for nested hydration

---

### step 1.8: extend Role interface with hooks property

**location:** `src/domain.objects/Role.ts`

**purpose:** add optional `hooks` property to Role

**implementation:**
```ts
export interface Role {
  // ... prior properties
  hooks?: RoleHooks;  // NEW
}
```

**tests:** unit test validates Role instantiation with hooks

---

### step 1.9: create BrainHooksAdapterDao interface

**location:** `src/domain.objects/BrainHooksAdapterDao.ts`

**purpose:** DAO interface contract for brain hooks CRUD operations

**implementation:**
```ts
export interface BrainHooksAdapterDao {
  get: {
    one(input: { by: { unique: RefByUnique<typeof BrainHook> } }): Promise<BrainHook | null>;
    all(input?: { by?: PickOne<{ author: string; event: BrainHookEvent; command: string }> }): Promise<BrainHook[]>;
  };
  set: {
    findsert(input: { hook: BrainHook }): Promise<BrainHook>;
    upsert(input: { hook: BrainHook }): Promise<BrainHook>;
  };
  del(input: { by: { unique: RefByUnique<typeof BrainHook> } }): Promise<void>;
}
```

**tests:** type tests validate interface shape

---

### step 1.10: create BrainHooksAdapter interface

**location:** `src/domain.objects/BrainHooksAdapter.ts`

**purpose:** adapter contract that wraps DAO with slug identifier

**implementation:**
```ts
export interface BrainHooksAdapter {
  slug: string;
  dao: BrainHooksAdapterDao;
}
```

**tests:** type tests validate interface shape

---

### step 1.11: create BrainSpecifier type

**location:** `src/domain.objects/BrainSpecifier.ts`

**purpose:** typed identifier for brain selection

**implementation:**
```ts
export type BrainSpecifier = string;
```

**tests:** type tests validate usage

---

## phase 2: domain.operations

### step 2.1: create discoverBrainPackages

**location:** `src/domain.operations/brains/discoverBrainPackages.ts`

**purpose:** scans package.json for `rhachet-brains-*` packages

**implementation:** mirror `discoverRolePackages` pattern

**tests:**
- unit test: mock package.json with brain packages
- unit test: mock package.json without brain packages

---

### step 2.2: create getBrainHooksAdapterByConfigImplicit

**location:** `src/domain.operations/brains/getBrainHooksAdapterByConfigImplicit.ts`

**purpose:** discovers adapter for brain slug from installed packages

**algorithm:**
1. scan package.json for `rhachet-brains-*` packages
2. for each, import and call `getBrainHooks({ slug })`
3. return adapter if exactly one match found
4. return null if no match found
5. throw if multiple match found (ambiguous)

**tests:**
- unit test: single adapter match
- unit test: no adapter match
- unit test: multiple adapter match (throws)
- integration test: with mock brain package

---

### step 2.3: create detectBrainReplsInRepo

**location:** `src/domain.operations/brains/detectBrainReplsInRepo.ts`

**purpose:** detects brain repls by allowlisted config files

**allowlist:**
- `.claude/settings.json` → "claudecode"
- `.opencode/` directory → "opencode"

**tests:**
- unit test: claudecode detected
- unit test: opencode detected
- unit test: multiple detected
- unit test: none detected

---

### step 2.4: create syncRoleHooksIntoBrainRepl

**location:** `src/domain.operations/brains/syncRoleHooksIntoBrainRepl.ts`

**purpose:** declarative sync of role hooks into brain config

**algorithm:**
1. read Role.hooks.onBrain declarations
2. compute author namespace from registry + role
3. get hooks found for author via adapter.dao.get.all
4. compute diff: hooks to add, hooks to remove
5. apply set.upsert for declared hooks
6. apply del for hooks no longer declared

**tests:**
- unit test: diff computation logic
- integration test: full sync cycle
- integration test: declarative removal of stale hooks
- integration test: namespace isolation between roles

---

### step 2.5: create applyRoleHooksToDetectedBrains

**location:** `src/domain.operations/brains/applyRoleHooksToDetectedBrains.ts`

**purpose:** orchestrates hook sync for CLI command

**tests:**
- integration test: auto-detect + apply
- integration test: explicit brains + apply
- integration test: error handle for unknown slug

---

## phase 3: supplier packages

### step 3.1: create rhachet-brains-anthropic package structure

**location:** `src/_topublish/rhachet-brains-anthropic/`

**structure:**
```
src/
  index.ts
  hooks/
    getBrainHooks.ts
    claudeCodeAdapter.ts
    translateHook.ts
    config.dao.ts
```

---

### step 3.2: implement claudeCodeAdapter

**location:** `src/_topublish/rhachet-brains-anthropic/src/hooks/claudeCodeAdapter.ts`

**purpose:** implements BrainHooksAdapter for claude-code

**event map:**
- onBoot → SessionStart
- onTool (before) → PreToolUse
- onTool (after) → PostToolUse
- onStop → Stop

**tests:**
- unit test: each DAO method
- integration test: snapshot `.claude/settings.json` output
- integration test: preserve non-hook content

---

### step 3.3: implement translateHook

**location:** `src/_topublish/rhachet-brains-anthropic/src/hooks/translateHook.ts`

**purpose:** translates rhachet BrainHook → claude-code hook format

**tests:**
- unit test: onBoot translation
- unit test: onTool before translation
- unit test: onTool after translation
- unit test: onStop translation
- unit test: timeout conversion (ISO → seconds)

---

### step 3.4: implement config.dao

**location:** `src/_topublish/rhachet-brains-anthropic/src/hooks/config.dao.ts`

**purpose:** read/write `.claude/settings.json` with hook preservation

**tests:**
- integration test: read hooks from settings
- integration test: write hooks to settings
- integration test: preserve non-hook content
- integration test: create file if not found

---

### step 3.5: create rhachet-brains-opencode package structure

**location:** `src/_topublish/rhachet-brains-opencode/`

**structure:**
```
src/
  index.ts
  hooks/
    getBrainHooks.ts
    openCodeAdapter.ts
    plugin.dao.ts
```

---

### step 3.6: implement openCodeAdapter

**location:** `src/_topublish/rhachet-brains-opencode/src/hooks/openCodeAdapter.ts`

**purpose:** implements BrainHooksAdapter for opencode

**event map:**
- onBoot → session.created + session.compacted
- onTool (before) → tool.execute.before
- onTool (after) → tool.execute.after
- onStop → session.idle

**tests:**
- unit test: each DAO method
- integration test: snapshot `.opencode/plugin/rhachet-hooks.ts` output
- integration test: preserve other plugins

---

### step 3.7: implement translateHook (opencode)

**location:** `src/_topublish/rhachet-brains-opencode/src/hooks/translateHook.ts`

**purpose:** translates rhachet BrainHook → opencode TypeScript plugin code

**difference from anthropic:** generates TypeScript code strings instead of JSON objects

**tests:**
- unit test: onBoot translation to session.created handler
- unit test: onTool before translation to tool.execute.before handler
- unit test: onTool after translation to tool.execute.after handler
- unit test: onStop translation to session.idle handler
- unit test: timeout conversion (ISO → milliseconds)
- unit test: generated code includes author metadata comment

---

### step 3.8: implement plugin.dao (opencode)

**location:** `src/_topublish/rhachet-brains-opencode/src/hooks/plugin.dao.ts`

**purpose:** read/write `.opencode/plugin/rhachet-hooks.ts` with hook preservation

**tests:**
- integration test: read hooks from plugin file
- integration test: write hooks to plugin file
- integration test: preserve author metadata in comments
- integration test: create file if not found
- integration test: preserve other plugins in directory

---

## phase 4: cli integration

### step 4.1: extend invokeInit with --hooks option

**location:** `src/contract/cli/invokeInit.ts`

**purpose:** add `--hooks [slugs...]` option to init command

**behavior:**
- no `--hooks` → prior behavior (no hooks applied)
- `--hooks` (no args) → auto-detect brains + apply
- `--hooks <slugs...>` → apply to explicit brains only

**tests:** covered by acceptance tests

---

### step 4.2: update getLinkedRoles

**location:** `src/domain.operations/roles/getLinkedRoles.ts`

**purpose:** expose linked roles with hooks.onBrain declarations

**tests:** integration test validates hook declarations found

---

## phase 5: acceptance tests

### step 5.1: create init.hooks.acceptance.test.ts

**location:** `accept.blackbox/cli/init.hooks.acceptance.test.ts`

**tests:**
```ts
given('[case1] repo with role that declares hooks.onBrain', () => {
  when('[t0] init --roles <role> (no --hooks)', () => {
    then('exit code is 0');
    then('.claude/settings.json has no rhachet hooks');
  });

  when('[t1] init --roles <role> --hooks', () => {
    then('exit code is 0');
    then('.claude/settings.json has role hooks');
    then('hooks include author namespace');
  });

  when('[t2] init --roles <role> --hooks claudecode', () => {
    then('exit code is 0');
    then('.claude/settings.json has role hooks');
  });
});

given('[case2] repo with linked roles', () => {
  when('[t0] init --hooks', () => {
    then('exit code is 0');
    then('hooks applied for linked roles');
  });
});

given('[case3] unknown brain slug', () => {
  when('[t0] init --hooks unknown-slug', () => {
    then('exit code is non-zero');
    then('stderr contains available brain slugs');
  });
});
```

---

### step 5.2: create fixtures

**location:** `accept.blackbox/.test/assets/`

**fixtures to create:**
- `with-claude-config/` — minimal repo with `.claude/settings.json`
- `with-role-hooks/` — roles package with `hooks.onBrain` declarations
- `with-brains-package/` — mock `rhachet-brains-anthropic` package

---

### step 5.3: declarative sync acceptance tests

**location:** `accept.blackbox/cli/init.hooks.acceptance.test.ts` (continued)

**tests:**
```ts
given('[case4] role prior declared [hook1, hook2], now declares [hook2, hook3]', () => {
  when('[t0] init --hooks', () => {
    then('hook1 is removed (no longer declared)');
    then('hook2 is retained');
    then('hook3 is added');
  });
});

given('[case5] multiple roles with hooks', () => {
  when('[t0] init --roles roleA roleB --hooks', () => {
    then('roleA hooks are applied');
    then('roleB hooks are applied');
    then('roleA hooks are namespaced');
    then('roleB hooks are namespaced');
  });
});
```

---

### step 5.4: snapshot tests for config output

**location:** `accept.blackbox/cli/init.hooks.acceptance.test.ts` (continued)

**tests:**
```ts
given('[case6] complete hook application', () => {
  when('[t0] init --roles mechanic --hooks claudecode', () => {
    then('.claude/settings.json matches snapshot');
  });
});
```

---

## phase 6: integration tests

### step 6.1: adapter integration tests

**location:** `src/_topublish/rhachet-brains-anthropic/src/hooks/claudeCodeAdapter.integration.test.ts`

**tests:**
- get.one: found hook by unique ref
- get.one: null when not found
- get.all: all hooks
- get.all: filtered by author
- get.all: filtered by event
- set.findsert: add new hook
- set.findsert: idempotent on same hook
- set.upsert: add new hook
- set.upsert: update timeout
- del: remove hook
- del: idempotent on absent hook

---

### step 6.2: sync integration tests

**location:** `src/domain.operations/brains/syncRoleHooksIntoBrainRepl.integration.test.ts`

**tests:**
- sync adds declared hooks
- sync removes undeclared hooks
- sync retains unchanged hooks
- sync respects namespace isolation
- snapshot config after sync

---

## execution order

### priority 1: domain foundation
1. step 1.1 - 1.11 (domain.objects)

### priority 2: core operations
2. step 2.1 - 2.3 (discovery operations)
3. step 3.1 - 3.4 (claudecode adapter)
4. step 2.4 - 2.5 (sync operations)

### priority 3: integration
5. step 4.1 - 4.2 (cli integration)
6. step 5.1 - 5.4 (acceptance tests)

### priority 4: extension
7. step 3.5 - 3.6 (opencode adapter)
8. step 6.1 - 6.2 (integration tests)

---

## test coverage matrix

| component                            | unit | integration | acceptance |
| ------------------------------------ | ---- | ----------- | ---------- |
| BrainHook domain object              | ✓    |             |            |
| BrainHookFilter domain object        | ✓    |             |            |
| RoleHooksOnBrain domain object       | ✓    |             |            |
| discoverBrainPackages                | ✓    |             |            |
| getBrainHooksAdapterByConfigImplicit | ✓    | ✓           |            |
| detectBrainReplsInRepo               | ✓    |             |            |
| syncRoleHooksIntoBrainRepl           | ✓    | ✓           |            |
| applyRoleHooksToDetectedBrains       |      | ✓           |            |
| claudeCodeAdapter                    | ✓    | ✓           |            |
| translateHook (anthropic)            | ✓    |             |            |
| config.dao                           |      | ✓           |            |
| openCodeAdapter                      | ✓    | ✓           |            |
| translateHook (opencode)             | ✓    |             |            |
| plugin.dao                           |      | ✓           |            |
| init --roles (no hooks)              |      |             | ✓          |
| init --roles --hooks                 |      |             | ✓          |
| init --roles --hooks <slug>          |      |             | ✓          |
| init --hooks                         |      |             | ✓          |
| init --hooks <unknown>               |      |             | ✓          |
| declarative sync removal             |      | ✓           | ✓          |
| namespace isolation                  |      | ✓           | ✓          |
| config snapshot                      |      | ✓           | ✓          |

---

## citations

[1] `.behavior/v2026_01_09.hook-adapter/0.wish.md` — original wish

[2] `.behavior/v2026_01_09.hook-adapter/2.criteria.blackbox.md` — blackbox usecases

[3] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — blueprint contracts

[4] `.behavior/v2026_01_09.hook-adapter/3.1.research.patterns._.code.prod.v1.i1.md` — production code patterns

[5] `.behavior/v2026_01_09.hook-adapter/3.1.research.patterns._.code.test.v1.i1.md` — test code patterns

[6] `.behavior/v2026_01_09.hook-adapter/3.2.distill.domain._.v1.i1.md` — domain distillation

[7] `.agent/repo=ehmpathy/role=mechanic/briefs/practices/code.prod/readable.persistence/rule.prefer.declastruct.[demo].md` — declastruct pattern
