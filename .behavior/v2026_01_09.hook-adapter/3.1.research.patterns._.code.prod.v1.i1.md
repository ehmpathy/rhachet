# research.patterns.code.prod = production codepath patterns for hook-adapter

## summary

the hook-adapter feature will leverage these existing patterns:
- **package discovery** — scan package.json for `rhachet-*` packages
- **implicit config resolution** — resolve resources without explicit rhachet.use.ts
- **context composition** — lazy-loaded context with memoized getters
- **init workflow** — link + init phases with error collection
- **idempotent file operations** — findsert/upsert patterns
- **manifest-based discovery** — lightweight yaml manifests for bun binary compatibility

---

## pattern.1 = package discovery via discoverRolePackages [REUSE]

### location

`src/domain.operations/init/discoverRolePackages.ts`

### description

scans package.json dependencies for packages matching a naming convention.

### code

```typescript
export const discoverRolePackages = async (input: {
  from: string;
}): Promise<string[]> => {
  const root = await getGitRepoRoot({ from: input.from });
  const pkgPath = resolve(root, 'package.json');
  const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
  return Object.keys(allDeps).filter((name) =>
    name.startsWith('rhachet-roles-'),
  );
};
```
[1]

### relation to wish

we need an equivalent `discoverBrainPackages` that scans for `rhachet-brains-*` packages. the pattern is identical — only the prefix changes.

### classification

**[REUSE]** — clone the pattern for brain package discovery.

---

## pattern.2 = implicit config resolution via getRoleRegistriesByConfigImplicit [REUSE]

### location

`src/domain.operations/config/getRoleRegistriesByConfigImplicit.ts`

### description

discovers role registries from installed packages by:
1. scanning for `rhachet-roles-*` packages
2. resolving each package root via `createRequire`
3. loading manifest from `rhachet.repo.yml`
4. collecting errors for packages that lack manifests

### code

```typescript
export const getRoleRegistriesByConfigImplicit = async (input: {
  from: string;
}): Promise<{
  manifests: HasPackageRoot<RoleRegistryManifest>[];
  errors: { packageName: string; error: Error }[];
}> => {
  // find rhachet-roles-* packages
  const packageNames = await discoverRolePackages({ from: input.from });

  // create require from repo root for package resolution
  const repoRoot = await getGitRepoRoot({ from: input.from });
  const require = createRequire(`${repoRoot}/package.json`);

  // resolve each package and load manifest
  const manifests: HasPackageRoot<RoleRegistryManifest>[] = [];
  const errors: { packageName: string; error: Error }[] = [];

  for (const packageName of packageNames) {
    try {
      // resolve package root via package.json (main export depth is unpredictable)
      const packageJsonPath = require.resolve(`${packageName}/package.json`);
      const packageRoot = dirname(packageJsonPath);

      // load manifest directly (no cast to registry)
      const manifest = getRoleRegistryManifest({ packageRoot });
      manifests.push({ ...manifest, packageRoot });
    } catch (error) {
      // ... collect error for packages that lack manifest
    }
  }

  return { manifests, errors };
};
```
[2]

### relation to wish

we need an equivalent `getBrainHooksAdapterByConfigImplicit` that:
1. scans for `rhachet-brains-*` packages
2. imports each and calls `getBrainHooks({ slug })`
3. returns the first adapter that matches the slug

### classification

**[REUSE]** — clone the pattern, but call `getBrainHooks({ slug })` instead of loading yaml manifest.

---

## pattern.3 = context composition via ContextConfigOfUsage [EXTEND]

### location

`src/domain.operations/config/ContextConfigOfUsage.ts`

### description

defines context interface with lazy-loaded getters for config resources. separates explicit (rhachet.use.ts) from implicit (package discovery) sources.

### code

```typescript
export interface ContextConfigOfUsage {
  config: {
    usage: {
      isExplicit: () => boolean;
      getExplicitPath: () => string;
      get: {
        registries: {
          explicit: () => Promise<{ registries: RoleRegistry[] }>;
          implicit: () => Promise<{
            manifests: HasPackageRoot<RoleRegistryManifest>[];
            errors: { packageName: string; error: Error }[];
          }>;
        };
        brains: {
          explicit: () => Promise<BrainRepl[]>;
        };
        hooks: {
          explicit: () => Promise<InvokeHooks | null>;
        };
      };
    };
  };
}
```
[3]

### relation to wish

we need to extend this context to include:
- `brainHooksAdapters.implicit` — discover adapters from `rhachet-brains-*` packages
- `brainRepls.detected` — detect brain repls via allowlisted config files

### classification

**[EXTEND]** — add new getters for brain hooks adapters and detection.

---

## pattern.4 = context factory via genContextConfigOfUsage [EXTEND]

### location

`src/domain.operations/config/genContextConfigOfUsage.ts`

### description

creates context with memoized lazy getters. uses closure-based memoization for efficient just-in-time loading.

### code

```typescript
const memoize = <T>(fn: () => Promise<T>): (() => Promise<T>) => {
  let cached: Promise<T> | null = null;
  return () => {
    if (cached === null) cached = fn();
    return cached;
  };
};

export const genContextConfigOfUsage = async (input: {
  args: string[];
  cwd: string;
}): Promise<ContextConfigOfUsage> => {
  // ... resolve explicit config path

  // create memoized getters
  const getRegistriesExplicit = memoize(async () => { ... });
  const getRegistriesImplicit = memoize(async () => { ... });
  const getBrainsExplicit = memoize(async () => { ... });
  const getHooksExplicit = memoize(async () => { ... });

  return {
    config: {
      usage: {
        isExplicit: () => explicitConfigPath !== null,
        get: {
          registries: { explicit: getRegistriesExplicit, implicit: getRegistriesImplicit },
          brains: { explicit: getBrainsExplicit },
          hooks: { explicit: getHooksExplicit },
        },
      },
    },
  };
};
```
[4]

### relation to wish

we need to add memoized getters for:
- `getBrainHooksAdapterBySlug` — resolve adapter by slug from implicit packages
- `getDetectedBrainRepls` — detect brain repls via config file presence

### classification

**[EXTEND]** — add new memoized getters to the factory.

---

## pattern.5 = init workflow via initRolesFromPackages [EXTEND]

### location

`src/domain.operations/init/initRolesFromPackages.ts`

### description

batch init workflow that:
1. discovers manifests from packages
2. resolves specifiers to roles
3. executes link + init phases for each
4. collects errors without failing fast

### code

```typescript
export const initRolesFromPackages = async (input: {
  specifiers: RoleSpecifier[];
  from: string;
}): Promise<InitRolesResult> => {
  // discover manifests from packages
  const { manifests, errors: packageErrors } =
    await getRoleRegistriesByConfigImplicit({ from: input.from });

  // resolve all specifiers via getRolesFromManifests
  const roles = getRolesFromManifests({ specifiers: input.specifiers, manifests });

  // link and init each resolved role
  for (const resolved of roles) {
    // link phase
    execRoleLink({ role: resolved.role, repo: resolved.repo });

    // init phase
    execRoleInits({ role: resolved.role, repo: resolved.repo });
  }

  return result;
};
```
[5]

### relation to wish

we need to extend this to add a **hooks phase** after init:
1. detect brain repls in repo (or use explicit `--hooks` slugs)
2. for each detected brain, resolve adapter
3. call `syncRoleHooksIntoBrainRepl` for each role × brain

### classification

**[EXTEND]** — add hooks sync phase after link + init.

---

## pattern.6 = role linking via execRoleLink [REUSE]

### location

`src/domain.operations/invoke/link/execRoleLink.ts`

### description

creates `.agent/` directory structure and symlinks role resources (readme, briefs, skills, inits).

### code

```typescript
export const execRoleLink = (input: {
  role: RoleManifest;
  repo: RoleRegistryManifest;
}): { briefsCount: number; skillsCount: number; initsCount: number } => {
  // create .agent directory structure
  const agentDir = resolve(process.cwd(), '.agent');
  const repoDir = resolve(agentDir, `repo=${input.repo.slug}`);
  const repoRoleDir = resolve(repoDir, `role=${input.role.slug}`);

  mkdirSync(agentDir, { recursive: true });
  mkdirSync(repoDir, { recursive: true });
  mkdirSync(repoRoleDir, { recursive: true });

  // symlink resources
  symlinkResourceDirectories({ sourceDirs: input.role.briefs.dirs, ... });
  symlinkResourceDirectories({ sourceDirs: input.role.skills.dirs, ... });
  // ...
};
```
[6]

### relation to wish

no changes needed to execRoleLink. the hooks sync happens as a separate phase after linking.

### classification

**[REUSE]** — use as-is, hooks sync is a separate concern.

---

## pattern.7 = init execution via execRoleInits [REUSE]

### location

`src/domain.operations/invoke/init/execRoleInits.ts`

### description

executes role.inits.exec commands sequentially via shell.

### code

```typescript
export const execRoleInits = (input: {
  role: RoleManifest;
  repo: RoleRegistryManifest;
}): { commandsExecuted: number; commandsTotal: number } => {
  const execCmds = input.role.inits?.exec ?? [];

  for (const [idx, { cmd }] of execCmds.entries()) {
    const result = spawnSync(cmd, [], {
      cwd: process.cwd(),
      stdio: [process.stdin, process.stdout, process.stderr],
      shell: '/bin/bash',
    });

    if (result.status !== 0) {
      throw new Error(`init command failed: ${cmd} (exit code ${result.status})`);
    }
  }
};
```
[7]

### relation to wish

no changes needed. hook sync is a separate phase, not a shell command.

### classification

**[REUSE]** — use as-is.

---

## pattern.8 = role resolution via getRoleFromManifests [REUSE]

### location

`src/domain.operations/manifest/getRoleFromManifests.ts`

### description

resolves a role specifier (e.g., "mechanic" or "ehmpathy/mechanic") to a role + repo pair. handles ambiguity detection.

### code

```typescript
export const getRoleFromManifests = (input: {
  specifier: RoleSpecifier;
  manifests: RoleRegistryManifest[];
}): { repo: RoleRegistryManifest; role: RoleManifest } => {
  const parsed = parseRoleSpecifier({ specifier: input.specifier });

  // qualified specifier: find exact manifest match
  if (parsed.repo) {
    const found = input.manifests.find((m) => m.slug === parsed.repo);
    if (!found) throw new BadRequestError(`manifest "${parsed.repo}" not found`);
    return { repo: found, role: ... };
  }

  // unqualified specifier: find manifest that contains the role
  const candidates = input.manifests.filter((m) =>
    m.roles.some((r) => r.slug === parsed.role),
  );

  if (candidates.length === 0) throw new BadRequestError(`role not found`);
  if (candidates.length > 1) throw new BadRequestError(`role is ambiguous`);

  return { repo: candidates[0], role: ... };
};
```
[8]

### relation to wish

we may need a similar pattern for resolving brain hook adapters by slug, but simpler — just match on slug directly.

### classification

**[REUSE]** — reference pattern for adapter resolution.

---

## pattern.9 = idempotent file operations via findsertFile / upsertFile [REUSE]

### location

`src/infra/findsertFile.ts`, `src/infra/upsertFile.ts`

### description

idempotent file operations:
- `findsertFile` — find or insert (preserves existing)
- `upsertFile` — update or insert (overwrites existing)

### code

```typescript
// findsertFile: preserves existing content
export const findsertFile = (input: {
  cwd: string;
  path: string;
  content?: string;
}): { effect: 'FOUND' | 'CREATED' } => {
  if (existsSync(input.path)) {
    console.log(`  ○ [found] ${relative(input.cwd, input.path)}`);
    return { effect: 'FOUND' };
  }
  // create file or directory
  writeFileSync(input.path, input.content, 'utf8');
  console.log(`  + [created] ${relative(input.cwd, input.path)}`);
  return { effect: 'CREATED' };
};

// upsertFile: overwrites existing content
export const upsertFile = (input: {
  cwd: string;
  path: string;
  content?: string;
}): { effect: 'UPDATED' | 'CREATED' } => {
  const existed = existsSync(input.path);
  writeFileSync(input.path, input.content, 'utf8');
  return { effect: existed ? 'UPDATED' : 'CREATED' };
};
```
[9]

### relation to wish

the BrainHooksAdapter for claudecode will need to read/write `.claude/settings.json` while preserving non-hook content. this is similar to findsert but more nuanced — we need to merge JSON objects.

### classification

**[REUSE]** — reference pattern for file operations. adapter will implement JSON merge specifically.

---

## pattern.10 = dispatch hooks via InvokeHooks [EXTEND]

### location

`src/domain.objects/InvokeHooks.ts`

### description

defines hooks for customizing invoke behavior (dispatch middleware).

### code

```typescript
export interface InvokeHooks<TRole extends Role = Role> {
  onInvokeAskInput: Array<
    (input: InvokeOpts<{ ask: string; config: string }>) =>
      InvokeOpts<{ ask: string; config: string }>
  >;
  onInvokeActInput?: (input: AnySkillInput) => AnySkillInput;
}
```
[10]

### relation to wish

this represents `RoleHooksOnDispatch` in the new domain model. we need to:
1. rename `InvokeHooks` → `RoleHooksOnDispatch`
2. create new `RoleHooks` wrapper: `{ onDispatch?, onBrain? }`
3. create new `RoleHooksOnBrain`: `{ onBoot?, onTool?, onStop? }`

### classification

**[EXTEND]** — rename and wrap in new RoleHooks structure.

---

## pattern.11 = hooks config via getRoleHooksOnDispatchByConfigExplicit [REUSE]

### location

`src/domain.operations/config/getRoleHooksOnDispatchByConfigExplicit.ts`

### description

loads InvokeHooks from explicit config (rhachet.use.ts).

### code

```typescript
export const getRoleHooksOnDispatchByConfigExplicit = async (input: {
  opts: InvokeOpts<{ config: string }>;
}): Promise<InvokeHooks | null> => {
  const config = await import(input.opts.config);
  const hooksResult = await config.getInvokeHooks?.();
  if (!hooksResult) return null;

  const hooksList = Array.isArray(hooksResult) ? hooksResult : [hooksResult];
  return {
    onInvokeAskInput: hooksList.flatMap((h) => h?.onInvokeAskInput ?? []),
  };
};
```
[11]

### relation to wish

this pattern shows how to load hooks from config. we'll need similar loading for `Role.hooks.onBrain` from RoleRegistry, but that comes from role definition, not config.

### classification

**[REUSE]** — reference pattern for hooks loading.

---

## pattern.12 = CLI command via invokeInit [EXTEND]

### location

`src/contract/cli/invokeInit.ts`

### description

CLI command that routes based on options:
- `--roles` → `initRolesFromPackages`
- `--config` → generate rhachet.use.ts
- no flags → show usage

### code

```typescript
export const invokeInit = ({ program }: { program: Command }): void => {
  program
    .command('init')
    .option('--roles <roles...>', 'role specifiers to initialize')
    .option('--config', 'generate rhachet.use.ts config')
    .action(async (options) => {
      if (options.roles && options.roles.length > 0) {
        await initRolesFromPackages({ specifiers: options.roles, from: cwd });
        return;
      }
      if (options.config) {
        await generateRhachetUseTs({ cwd, root, mode: options.mode });
        return;
      }
      await showInitUsageInstructions({ from: cwd });
    });
};
```
[12]

### relation to wish

we need to add `--hooks <slugs...>` option to this command:
- `--roles mechanic --hooks claudecode` → link + init + sync hooks to specified brains
- `--roles mechanic` (no --hooks) → link + init + auto-detect brains + sync hooks
- `--hooks claudecode` (no --roles) → sync hooks for already-linked roles

### classification

**[EXTEND]** — add `--hooks` option and routing.

---

## pattern.13 = manifest domain objects [REUSE]

### location

`src/domain.objects/RoleManifest.ts`, `src/domain.objects/RoleRegistryManifest.ts`

### description

lightweight manifest types that Role/RoleRegistry satisfy. enables yaml-based discovery without full runtime objects.

### code

```typescript
// RoleManifest — minimal role shape for manifest-based operations
export interface RoleManifest {
  slug: string;
  readme: { uri: string };
  briefs: { dirs: { uri: string } | { uri: string }[] };
  skills: { dirs: { uri: string } | { uri: string }[] };
  inits?: { dirs?: ...; exec?: { cmd: string }[] };
}

// RoleRegistryManifest — minimal registry shape
export interface RoleRegistryManifest {
  slug: string;
  readme: { uri: string };
  roles: RoleManifest[];
}
```
[13]

### relation to wish

we don't need manifest equivalents for BrainHooksAdapter since adapters are loaded via dynamic import, not yaml manifests.

### classification

**[REUSE]** — reference pattern, but no direct equivalent needed.

---

## pattern.14 = Role domain object [EXTEND]

### location

`src/domain.objects/Role.ts`

### description

full Role entity with skills, briefs, traits, inits.

### code

```typescript
export interface Role<TSolid, TRigid> {
  slug: string;
  name: string;
  purpose: string;
  readme: { uri: string };
  traits: RoleTrait[];
  skills: { solid?: TSolid; rigid?: TRigid; dirs: ...; refs: ... };
  briefs: { dirs: ... };
  inits?: { dirs?: ...; exec?: { cmd: string }[] };
}
```
[14]

### relation to wish

we need to add `hooks?: RoleHooks` property:
```typescript
hooks?: {
  onDispatch?: RoleHooksOnDispatch;
  onBrain?: RoleHooksOnBrain;
}
```

### classification

**[EXTEND]** — add `hooks` property.

---

## citations

[1] `src/domain.operations/init/discoverRolePackages.ts:11-21` — "scans dependencies + devDependencies for packages matching `rhachet-roles-*`"

[2] `src/domain.operations/config/getRoleRegistriesByConfigImplicit.ts:19-60` — "discovers role registries from rhachet-roles-* packages via manifest"

[3] `src/domain.operations/config/ContextConfigOfUsage.ts:19-89` — "config portion of context for cli invocation... separates explicit (rhachet.use.ts) from implicit (rhachet.repo.yml) sources"

[4] `src/domain.operations/config/genContextConfigOfUsage.ts:68-164` — "creates context with config for the current invocation... uses closure-based memoization for lazy getters"

[5] `src/domain.operations/init/initRolesFromPackages.ts:27-136` — "initializes multiple roles from installed packages... enables `npx rhachet init --roles mechanic behaver` workflow"

[6] `src/domain.operations/invoke/link/execRoleLink.ts:20-110` — "links a role into the .agent directory structure... creates .agent/repo=$repo/role=$role structure with symlinks"

[7] `src/domain.operations/invoke/init/execRoleInits.ts:14-52` — "executes init commands for a role... executes role.inits.exec commands sequentially via /bin/bash"

[8] `src/domain.operations/manifest/getRoleFromManifests.ts:16-80` — "gets a single role from manifests by specifier... unified role lookup for link/init/ask operations"

[9] `src/infra/findsertFile.ts:8-25`, `src/infra/upsertFile.ts:8-27` — "findsert a file or directory (find or insert)... idempotent creation"

[10] `src/domain.objects/InvokeHooks.ts:32-58` — "hooks for customizing invoke behavior... enables input transformation before skill execution"

[11] `src/domain.operations/config/getRoleHooksOnDispatchByConfigExplicit.ts:12-32` — "get invoke hooks from explicit config (rhachet.use.ts)"

[12] `src/contract/cli/invokeInit.ts:95-134` — "adds the 'init' command to the CLI... enables initialization of roles from packages or config generation"

[13] `src/domain.objects/RoleManifest.ts:9-24`, `src/domain.objects/RoleRegistryManifest.ts:22-44` — "type for a single role within the manifest... enables type-safe role configuration that Role can satisfy"

[14] `src/domain.objects/Role.ts:33-124` — "defines a role that can have traits, know skills, and be instantiated across thread.context"
