# blueprint criteria = mechanism bounds for hook-adapter

## blackbox criteria satisfied

- usecase.1 = role declares hooks.onBrain ✓
- usecase.2 = discover BrainHooksAdapter via brain supplier ✓
- usecase.3 = apply Role.hooks.onBrain via BrainHooksAdapter ✓
- usecase.4 = adapter.set.findsert ✓
- usecase.5 = adapter.set.upsert ✓
- usecase.6 = adapter.set.delete ✓
- usecase.7 = adapter.get hooks ✓
- usecase.8 = declarative sync ✓
- usecase.9 = onTool hooks with filters ✓
- usecase.10 = error handle ✓
- boundary.1 = claudecode BrainHooksAdapter specifics ✓


## refactor.1 = rename InvokeHooks → RoleHooksOnDispatch

given('src/domain.objects/InvokeHooks.ts')
  then('rename to src/domain.objects/RoleHooksOnDispatch.ts')
  then('rename interface InvokeHooks → RoleHooksOnDispatch')
  then('update all imports and references')
    sothat('terminology aligns with domain model (Role.hooks.onDispatch)')


## domain.objects contracts

given('RoleHooks domain object')
  then('declares: onDispatch (RoleHooksOnDispatch, optional)')
  then('declares: onBrain (RoleHooksOnBrain, optional)')
  then('is declared on Role via Role.hooks property')

given('RoleHooksOnDispatch domain object')
  then('declares: onInvokeAskInput (transform ask input before execution)')
  then('declares: onInvokeActInput (transform act input before skill execution)')
  then('is middleware over rhachet dispatch actions')
// note: this is the renamed InvokeHooks.ts

given('RoleHookOnBrain domain object')
  then('declares: command (string, required)')
  then('declares: timeout (IsoDuration, required)')
  then('declares: filter (BrainHookFilter, optional, for onTool only)')
    // note: author derived on application; event implicit from container key

given('RoleHooksOnBrain domain object')
  then('declares: onBoot (RoleHookOnBrain[], optional)')
  then('declares: onTool (RoleHookOnBrain[], optional)')
  then('declares: onStop (RoleHookOnBrain[], optional)')
  then('is middleware over brain actions, applied via BrainHooksAdapter')

given('BrainHook domain object')
  then('declares: author (string, required) — namespace "repo=X/role=Y"')
  then('declares: event (onBoot | onTool | onStop, required)')
  then('declares: command (string, required)')
  then('declares: timeout (IsoDuration from iso-time, required)')
    // string: "PT60S", "PT5M" or object: { seconds: 60 }, { minutes: 5 }
  then('declares: filter (BrainHookFilter, optional, for onTool only)')
  then('unique key: [author, event, command]')
  then('updatable: [filter, timeout]')

given('BrainHookFilter domain object')
  then('declares: what (string, required) — tool pattern e.g. "Bash", "Write|Edit", "*"')
  then('declares: when ("before" | "after", optional, defaults to "before")')
    sothat('tool selection and time are separate concerns')

given('BrainHooksAdapter contract (BrainHooksAdapter.dao)')
  then('exposes: get.one({ by: { unique: RefByUnique<BrainHook> } }) => BrainHook | null')
  then('exposes: get.all({ by?: PickOne<{ command, author, event }> }) => BrainHook[]')
  then('exposes: set.findsert({ hook: BrainHook }) => BrainHook')
  then('exposes: set.upsert({ hook: BrainHook }) => BrainHook')
  then('exposes: del({ by: { unique: RefByUnique<BrainHook> } }) => void')


## domain.operations contracts

given('getBrainHooksAdapterByConfigImplicit contract')
  then('exposes: ({ slug: string, from: string }) => Promise<BrainHooksAdapter | null>')
  then('scans package.json for dependencies that start with `rhachet-brains-`')
  then('for each, attempts to import and call `getBrainHooks({ slug })`')
  then('returns adapter if exactly one matches slug, or null if none found')
  then('fails fast with error if multiple adapters match slug')
    sothat('ambiguous configurations are caught early')

given('syncRoleHooksIntoBrainRepl contract')
  then('exposes: ({ role: Role, adapter: BrainHooksAdapter }) => Promise<void>')
  then('reads Role.hooks.onBrain declaration')
  then('computes diff between declared hooks and hooks found for role author')
  then('applies set.upsert for hooks declared')
  then('applies set.delete for hooks no longer declared')
    sothat('declarative sync removes stale hooks')


## contract.cli contracts

given('`npx rhachet init --roles <role...>` command (no --hooks)')
  then('links and inits the specified roles (prior behavior)')
  then('does NOT apply hooks')
    sothat('users can init roles without brain repl enrollment')

given('`npx rhachet init --roles <role...> --hooks` command (no args)')
  then('links and inits the specified roles')
  then('auto-detects brains via detectBrainReplsInRepo()')
  then('for each detected brain, resolves adapter via getBrainHooksAdapterByConfigImplicit({ slug, from })')
  then('calls syncRoleHooksIntoBrainRepl for each linked role × each detected brain')
    sothat('--hooks with no args triggers auto-detection')

given('`npx rhachet init --roles <role...> --hooks <slug...>` command')
  then('links and inits the specified roles')
  then('skips auto-detection, uses only specified brains')
  then('for each slug, resolves adapter via getBrainHooksAdapterByConfigImplicit({ slug, from })')
  then('if any adapter not found, exits with error and lists available brain slugs')
  then('calls syncRoleHooksIntoBrainRepl for each linked role × each brain')
    sothat('user can override auto-detection')

given('`npx rhachet init --hooks` command (no args, no roles)')
  then('skips role linking and inits')
  then('auto-detects brains via detectBrainReplsInRepo()')
  then('applies hooks for already-linked roles to detected brains')
    sothat('hooks can be reapplied independently with auto-detection')

given('`npx rhachet init --hooks <slug...>` command (no roles)')
  then('skips role linking and inits')
  then('applies hooks for already-linked roles to specified brains')
    sothat('hooks can be reapplied independently to specific brains')


## domain.operations contracts (continued)

given('detectBrainReplsInRepo contract')
  then('exposes: ({ from: string }) => Promise<string[]>')
  then('checks for allowlisted brain config files')
  then('returns array of detected brain slugs')
  // e.g., .claude/settings.json → "claudecode"
  // e.g., .opencode/ directory → "opencode"


## rhachet-brains-* package contract

given('package named `rhachet-brains-*`')
  then('may export: getBrainHooks({ slug: string }) => BrainHooksAdapter | null')
  then('getBrainHooks returns adapter if package supports that slug')
  then('getBrainHooks returns null if package does not support that slug')
    sothat('multiple brain suppliers can be searched until one matches')


## composition boundaries

given('hook application flow')
  then('cli command discovers adapter via getBrainHooksAdapterByConfigImplicit')
  then('cli command invokes syncRoleHooksIntoBrainRepl with adapter and role')
  then('syncRoleHooksIntoBrainRepl uses BrainHooksAdapter.dao.{get,set,del} methods')
  then('adapter methods read/write brain-specific config file')

given('adapter implementation boundary')
  then('adapter encapsulates brain-specific config format')
  then('adapter encapsulates brain-specific file path')
  then('adapter exposes only generic BrainHooksAdapter contract')
    sothat('rhachet core is decoupled from brain-specific details')

given('namespace isolation boundary')
  then('all adapter operations scope by author')
  then('get operations can filter by author')
  then('set operations require author')
  then('delete operations only affect hooks with matched author')
    sothat('roles cannot interfere with each other')


## collocated brain suppliers (to eject later)

given('rhachet-brains-anthropic package')
  then('collocated at src/_topublish/rhachet-brains-anthropic/')
  then('exports getBrainHooks({ slug }) => BrainHooksAdapter | null')
  then('supports slug "claudecode" (and alias "anthropic/claude/code")')
  then('implements BrainHooksAdapter for claude code CLI')
    sothat('contracts can be established flexibly before ejection')

given('rhachet-brains-opencode package')
  then('collocated at src/_topublish/rhachet-brains-opencode/')
  then('exports getBrainHooks({ slug }) => BrainHooksAdapter | null')
  then('supports slug "opencode"')
  then('implements BrainHooksAdapter for opencode CLI')
    sothat('contracts can be established flexibly before ejection')

// note: these will be ejected to separate repos once contracts are stable


## adapter implementation specifics

given('claudecode adapter implementation (in rhachet-brains-anthropic)')
  then('reads/writes .claude/settings.json')
  then('manages hooks section as JSON array per event type')
  then('preserves non-hook content (permissions, etc)')
  then('maps: onBoot→SessionStart, onTool::before→PreToolUse, onTool::after→PostToolUse, onStop→Stop')

given('opencode adapter implementation (in rhachet-brains-opencode)')
  then('reads/writes .opencode/plugin/rhachet-hooks.ts')
  then('generates TypeScript plugin with lifecycle hooks')
  then('preserves other plugins in .opencode/plugin/')
  then('maps: onBoot→session.created+session.compacted, onTool::before→tool.execute.before, onTool::after→tool.execute.after, onStop→session.idle')


## test coverage criteria

given('BrainHooksAdapter implementation (claudecode, opencode)')
  then('has unit tests for each BrainHooksAdapter.dao.{get,set,del} method')
  then('has integration tests that snapshot resultant config file')
    sothat('config format changes are visible in review')

given('getBrainHooksAdapterByConfigImplicit')
  then('has unit tests for package discovery logic')
  then('has integration tests with mock rhachet-brains-* packages')

given('syncRoleHooksIntoBrainRepl')
  then('has unit tests for diff computation')
  then('has integration tests for full sync cycle')
  then('has integration tests proving declarative removal of stale hooks')
    sothat('the most critical behavior is verified')

given('cli command `init --hooks`')
  then('has acceptance tests invoking via subprocess')
  then('has acceptance tests for --hooks with no args (auto-detection)')
  then('has acceptance tests for --hooks with explicit slugs')
  then('has acceptance tests for error case (unknown slug)')
  then('has acceptance tests verifying --roles without --hooks does NOT bind hooks')
  then('has acceptance tests snapshotting resultant config')
