# blueprint criteria = mechanism bounds for hook-adapter

## blackbox criteria satisfied

- usecase.1 = role declares hooks.onBrain ✓
- usecase.2 = discover BrainHooksAdapter via brain supplier ✓
- usecase.3 = apply Role.hooks.onBrain via BrainHooksAdapter ✓
- usecase.4 = adapter.set.findsert ✓
- usecase.5 = adapter.set.upsert ✓
- usecase.6 = adapter.set.delete ✓
- usecase.7 = adapter.get hooks ✓
- usecase.8 = declarative sync ✓
- usecase.9 = onTool hooks with matchers ✓
- usecase.10 = error handle ✓
- boundary.1 = claude-code BrainHooksAdapter specifics ✓


## refactor.1 = rename InvokeHooks → RoleHooksOnDispatch

given('src/domain.objects/InvokeHooks.ts')
  then('rename to src/domain.objects/RoleHooksOnDispatch.ts')
  then('rename interface InvokeHooks → RoleHooksOnDispatch')
  then('update all imports and references')
    sothat('terminology aligns with domain model (Role.hooks.onDispatch)')


## domain.objects contracts

given('RoleHooks domain object')
  then('declares: onDispatch (RoleHooksOnDispatch, optional)')
  then('declares: onBrain (RoleHooksOnBrain, optional)')
  then('is declared on Role via Role.hooks property')

given('RoleHooksOnDispatch domain object')
  then('declares: onInvokeAskInput (transform ask input before execution)')
  then('declares: onInvokeActInput (transform act input before skill execution)')
  then('is middleware over rhachet dispatch actions')
// note: this is the renamed InvokeHooks.ts

given('RoleHooksOnBrain domain object')
  then('declares: onBoot (BrainHook[], optional)')
  then('declares: onTool (BrainHook[], optional)')
  then('declares: onStop (BrainHook[], optional)')
  then('is middleware over brain actions, applied via BrainHooksAdapter')

given('BrainHook domain object')
  then('declares: event (onBoot | onTool | onStop, required)')
  then('declares: command (string, required)')
  then('declares: timeout (number, required)')
  then('declares: matcher (string, optional, for onTool only)')

given('BrainHookApplied domain object')
  then('extends BrainHook with: author (string, required)')
    sothat('namespace ownership is tracked in applied state')

given('BrainHooksAdapter contract (BrainHooksAdapter.dao)')
  then('exposes: get.one({ by: { unique: RefByUnique<BrainHookApplied> } }) => BrainHookApplied | null')
  then('exposes: get.all({ by?: PickOne<{ command, author, event }> }) => BrainHookApplied[]')
  then('exposes: set.findsert({ hook: BrainHookApplied }) => BrainHookApplied')
  then('exposes: set.upsert({ hook: BrainHookApplied }) => BrainHookApplied')
  then('exposes: del({ by: { unique: RefByUnique<BrainHookApplied> } }) => void')


## domain.operations contracts

given('getBrainHooksAdapterByConfigImplicit contract')
  then('exposes: ({ slug: string }) => Promise<BrainHooksAdapter | null>')
  then('scans package.json for dependencies that start with `rhachet-brains-`')
  then('for each, attempts to import and call `getBrainHooks({ slug })`')
  then('returns adapter if exactly one matches slug, or null if none found')
  then('fails fast with error if multiple adapters match slug')
    sothat('ambiguous configurations are caught early')

given('syncRoleHooksIntoBrain contract')
  then('exposes: ({ role: Role, adapter: BrainHooksAdapter }) => Promise<void>')
  then('reads Role.hooks.onBrain declaration')
  then('computes diff between declared hooks and hooks found for role author')
  then('applies set.upsert for hooks declared')
  then('applies set.delete for hooks no longer declared')
    sothat('declarative sync removes stale hooks')


## contract.cli contracts

given('`npx rhachet init --hooks <slug...>` command')
  then('accepts one or more brain slugs')
  then('for each slug, resolves adapter via getBrainHooksAdapterByConfigImplicit({ slug })')
  then('if any adapter not found, exits with error and lists available brain slugs')
  then('if all adapters found, calls syncRoleHooksIntoBrain for each enrolled role × each brain')
    sothat('all Role.hooks.onBrain are applied to all specified brains')

given('`npx rhachet init --roles <role...> --hooks <slug...>` command')
  then('first links the specified roles')
  then('then applies hooks for each linked role to each brain')
    sothat('composite init is a single command')
  // example: `npx rhachet init --roles behaver mechanic --hooks claudecode opencode`


## rhachet-brains-* package contract

given('package named `rhachet-brains-*`')
  then('may export: getBrainHooks({ slug: string }) => BrainHooksAdapter | null')
  then('getBrainHooks returns adapter if package supports that slug')
  then('getBrainHooks returns null if package does not support that slug')
    sothat('multiple brain suppliers can be searched until one matches')


## composition boundaries

given('hook application flow')
  then('cli command discovers adapter via getBrainHooksAdapterByConfigImplicit')
  then('cli command invokes syncRoleHooksIntoBrain with adapter and role')
  then('syncRoleHooksIntoBrain uses BrainHooksAdapter.dao.{get,set,del} methods')
  then('adapter methods read/write brain-specific config file')

given('adapter implementation boundary')
  then('adapter encapsulates brain-specific config format')
  then('adapter encapsulates brain-specific file path')
  then('adapter exposes only generic BrainHooksAdapter contract')
    sothat('rhachet core is decoupled from brain-specific details')

given('namespace isolation boundary')
  then('all adapter operations scope by author')
  then('get operations can filter by author')
  then('set operations require author')
  then('delete operations only affect hooks with matched author')
    sothat('roles cannot interfere with each other')


## test coverage criteria

given('BrainHooksAdapter implementation (e.g., claude-code)')
  then('has unit tests for each BrainHooksAdapter.dao.{get,set,del} method')
  then('has integration tests that snapshot resultant config file')
    sothat('config format changes are visible in review')

given('getBrainHooksAdapterByConfigImplicit')
  then('has unit tests for package discovery logic')
  then('has integration tests with mock rhachet-brains-* packages')

given('syncRoleHooksIntoBrain')
  then('has unit tests for diff computation')
  then('has integration tests for full sync cycle')
  then('has integration tests proving declarative removal of stale hooks')
    sothat('the most critical behavior is verified')

given('cli command `init --hooks`')
  then('has acceptance tests invoking via subprocess')
  then('has acceptance tests for error case (unknown slug)')
  then('has acceptance tests snapshotting resultant config')
