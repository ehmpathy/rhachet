# blackbox criteria = experience bounds for hook-adapter

## usecase.1 = role declares hooks

given('a role with hooks declared')
  when('Role.hooks includes onBoot hooks')
    then('each onBoot hook specifies command, timeout')
      sothat('the role can declare what runs on session start')
    then('hooks are namespaced by role author (repo=X/role=Y)')
      sothat('multiple roles can declare hooks without collision')

  when('Role.hooks includes onTool hooks')
    then('each onTool hook specifies command, timeout, matcher')
      sothat('the role can declare what runs before specific tool use')
    then('matcher can target specific tools (Bash, Write, Edit, etc) or wildcard')
      sothat('hooks can be scoped to relevant tool events')


## usecase.2 = apply hooks to brain repl cli

given('a role with declared hooks')
  when('user runs `npx rhachet init --hooks <adapter-slug>`')
    then('rhachet finds the adapter registered for that slug')
      sothat('different brain repl clis can be supported')
    then('rhachet applies Role.hooks via the adapter')
      sothat('hooks are registered in the cli-specific format')
    then('hooks appear in repo-scoped config (e.g., .claude/settings.json)')
      sothat('hooks only affect the current repo')

given('no adapter registered for slug')
  when('user runs `npx rhachet init --hooks <unknown-slug>`')
    then('rhachet reports error with available adapters')
      sothat('user knows which adapters are valid')


## usecase.3 = set.findsert hooks (add if not present)

given('a hook not yet registered')
  when('adapter.register.onBoot.set.findsert is called')
    then('hook is added to the config')
    then('hook includes author namespace from role')
      sothat('hook ownership is tracked')

given('a hook already registered with same author')
  when('adapter.register.onBoot.set.findsert is called with same command')
    then('hook found is retained unchanged')
      sothat('findsert is idempotent')

given('a hook already registered with different author')
  when('adapter.register.onBoot.set.findsert is called with same command')
    then('both hooks coexist (different namespaces)')
      sothat('different roles can register same commands independently')


## usecase.4 = set.upsert hooks (add or update)

given('a hook not yet registered')
  when('adapter.register.onBoot.set.upsert is called')
    then('hook is added to the config')

given('a hook already registered with same author')
  when('adapter.register.onBoot.set.upsert is called with updated timeout')
    then('hook found is updated with new values')
      sothat('upsert enables modification of owned hooks')

given('a hook already registered with different author')
  when('adapter.register.onBoot.set.upsert is called')
    then('new hook is added (does not modify other namespace)')
      sothat('upsert respects namespace boundaries')


## usecase.5 = set.delete hooks (remove)

given('a hook registered by role A')
  when('adapter.register.onBoot.set.delete is called by role A')
    then('hook is removed from config')
      sothat('roles can clean up their own hooks')

given('a hook registered by role B')
  when('adapter.register.onBoot.set.delete is called by role A')
    then('hook remains in config (different namespace)')
      sothat('roles cannot delete other roles hooks')

given('a hook not registered')
  when('adapter.register.onBoot.set.delete is called')
    then('operation succeeds (no-op)')
      sothat('delete is idempotent')


## usecase.6 = get hooks

given('hooks registered by multiple roles')
  when('adapter.register.onBoot.get.all is called')
    then('returns all hooks for that event type')
      sothat('full hook state is visible')

  when('adapter.register.onBoot.get.all is called with author filter')
    then('returns only hooks for that author namespace')
      sothat('role can inspect its own hooks')

given('a specific hook registered')
  when('adapter.register.onBoot.get.one is called with command identifier')
    then('returns that specific hook or null')
      sothat('presence can be checked before operations')


## usecase.7 = declarative sync (Role.hooks applied holistically)

given('role A declares hooks [hook1, hook2]')
  when('hooks are applied via adapter')
    then('hook1 and hook2 are present in config')

given('role A prior declared [hook1, hook2], now declares [hook2, hook3]')
  when('hooks are applied via adapter')
    then('hook1 is removed (no longer declared)')
      sothat('removed declarations result in removed hooks')
    then('hook2 is retained')
    then('hook3 is added')
      sothat('config reflects current declaration state')

given('role A and role B both have hooks')
  when('role A hooks are reapplied')
    then('role B hooks are unaffected')
      sothat('declarative sync is namespace-scoped')


## usecase.8 = onTool hooks with matchers

given('role declares onTool hook with matcher "Bash"')
  when('hooks are applied')
    then('hook appears under PreToolUse matcher for "Bash"')
      sothat('hook only triggers for bash tool usage')

given('role declares onTool hook with matcher "*"')
  when('hooks are applied')
    then('hook appears under PreToolUse matcher for all tools')
      sothat('wildcard matcher triggers for any tool')

given('role declares onTool hooks with different matchers')
  when('hooks are applied')
    then('hooks are grouped by matcher')
      sothat('config structure matches cli expectations')


## usecase.9 = hook order

given('multiple hooks for same event and matcher')
  when('hooks are applied')
    then('hooks maintain declared order')
      sothat('execution sequence is predictable')

given('role declares hook with prepend option')
  when('hooks are applied')
    then('hook is positioned before hooks found prior')
      sothat('role can control hook priority')


## usecase.10 = error handle

given('invalid hook declaration (required field absent)')
  when('hooks are applied')
    then('operation fails with descriptive error')
      sothat('user knows what to fix')

given('config file is malformed')
  when('adapter attempts to read hooks')
    then('operation fails with descriptive error')
      sothat('user knows config needs repair')

given('config file does not exist')
  when('hooks are applied')
    then('config file is created with hooks')
      sothat('first-time setup works seamlessly')


## boundary.1 = claude-code adapter specifics

given('adapter slug is "anthropic/claude/code"')
  when('hooks are applied')
    then('config is written to .claude/settings.json')
    then('onBoot hooks map to SessionStart event')
    then('onTool hooks map to PreToolUse event')
    then('hook shape includes: type, command, timeout, author')
      sothat('format matches claude-code expectations')

given('.claude/settings.json found with non-hook content')
  when('hooks are applied')
    then('non-hook content (permissions, etc) is preserved')
      sothat('adapter only modifies hooks section')
