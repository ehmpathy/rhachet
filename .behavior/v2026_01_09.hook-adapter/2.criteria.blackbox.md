# blackbox criteria = experience bounds for hook-adapter

## usecase.1 = role declares hooks.onBrain

given('a role supplied via role supplier')
  when('Role.hooks.onBrain includes onBoot hooks')
    then('each onBoot hook specifies command, timeout')
      sothat('the role can declare what runs on brain session start')
    then('hooks are namespaced by role author (repo=X/role=Y)')
      sothat('multiple roles can declare hooks without collision')

  when('Role.hooks.onBrain includes onTool hooks')
    then('each onTool hook specifies command, timeout, filter')
      sothat('the role can declare what runs before or after specific tool use')
    then('filter is structured as { what, when }')
      sothat('tool selection and time are separate concerns')
    then('filter.what can target specific tools (bash, write, edit, etc) or wildcard')
      sothat('hooks can be scoped to relevant tool events')
    then('filter.when can be "before" or "after", defaults to "before"')
      sothat('hooks can run pre-tool or post-tool')

  when('Role.hooks.onBrain includes onStop hooks')
    then('each onStop hook specifies command, timeout')
      sothat('the role can declare what runs on brain session end')
    then('hooks are namespaced by role author (repo=X/role=Y)')
      sothat('multiple roles can declare hooks without collision')


## usecase.2 = discover BrainHooksAdapter via brain supplier

given('package.json has dependency `rhachet-brains-*`')
  when('rhachet searches for BrainHooksAdapter')
    then('rhachet scans dependencies for packages that start with `rhachet-brains-`')
    then('for each found, rhachet checks if package exports `getBrainHooks`')
    then('if exported, rhachet calls `getBrainHooks({ slug })` to resolve adapter')
      sothat('adapters are discovered via convention over configuration')

given('`getBrainHooks({ slug })` returns BrainHooksAdapter')
  when('adapter is resolved for slug')
    then('rhachet uses that adapter for hook operations')

given('`getBrainHooks({ slug })` returns null')
  when('adapter is resolved for slug')
    then('rhachet skips that package and continues search')
      sothat('brain suppliers can support multiple slugs selectively')

// note: this discovery pattern mirrors `src/domain.operations/config/getRoleRegistriesByConfigImplicit.ts`
// implementation would leverage something like `getBrainHooksByConfigImplicit.ts`
// future: `getBrainHooksByConfigExplicit.ts` (explicit usage config declaration) is not supported today but may be added later


## usecase.3 = apply Role.hooks.onBrain via BrainHooksAdapter

given('a role with Role.hooks.onBrain declared')
  when('user runs `npx rhachet init --roles <role...>`')
    then('rhachet links and inits the specified roles (existing behavior)')
    then('rhachet does NOT apply hooks (no --hooks flag)')
      sothat('users can init roles without enrolling brain repls immediately')

given('user wants to bind hooks with auto-detection')
  when('user runs `npx rhachet init --roles <role...> --hooks`')
    then('rhachet links and inits the specified roles')
    then('rhachet auto-detects brains via allowlisted config files')
      // e.g., if .claude/settings.json exists → claudecode detected
    then('rhachet applies Role.hooks.onBrain to each detected brain')
      sothat('--hooks with no args triggers auto-detection')
  // example: `npx rhachet init --roles behaver mechanic --hooks`

given('user wants to explicitly specify brains')
  when('user runs `npx rhachet init --roles <role...> --hooks <brain-slug...>`')
    then('rhachet links and inits the specified roles')
    then('rhachet skips auto-detection, uses only specified brains')
    then('rhachet applies Role.hooks.onBrain only to specified brains')
      sothat('user can override auto-detection')
  // example: `npx rhachet init --roles behaver mechanic --hooks claudecode`

given('user wants to apply hooks without linking roles (auto-detect)')
  when('user runs `npx rhachet init --hooks`')
    then('rhachet skips role linking and inits')
    then('rhachet auto-detects brains via allowlisted config files')
    then('rhachet applies Role.hooks.onBrain for already-linked roles to detected brains')
      sothat('hooks can be reapplied independently with auto-detection')
  // example: `npx rhachet init --hooks`

given('user wants to apply hooks without linking roles (explicit brains)')
  when('user runs `npx rhachet init --hooks <brain-slug...>`')
    then('rhachet skips role linking and inits')
    then('rhachet applies Role.hooks.onBrain for already-linked roles to specified brains')
      sothat('hooks can be reapplied independently to specific brains')
  // example: `npx rhachet init --hooks claudecode opencode`

given('--hooks specified but no brains detected')
  when('user runs `npx rhachet init --roles <role...> --hooks`')
    then('rhachet links and inits roles')
    then('rhachet logs warning that no brains were detected')
    then('rhachet suggests specifying brain slugs explicitly')
      sothat('user knows hooks were not applied and why')

given('no BrainHooksAdapter found for slug')
  when('user runs `npx rhachet init --hooks <unknown-slug>`')
    then('rhachet reports error with available brain slugs')
      sothat('user knows which brains have hook adapters')


## usecase.3b = auto-detect brains via allowlisted config files

// note: auto-detection only occurs when --hooks flag is present with no args
// e.g., `npx rhachet init --roles mechanic --hooks` or `npx rhachet init --hooks`

given('allowlisted brain config files')
  then('.claude/settings.json → claudecode')
  then('.opencode/plugin/ directory → opencode')
  // extend as more brains are supported

given('repo has .claude/settings.json')
  when('rhachet auto-detects brains (triggered by --hooks with no args)')
    then('claudecode is included in detected brains')

given('repo has .opencode/ directory')
  when('rhachet auto-detects brains (triggered by --hooks with no args)')
    then('opencode is included in detected brains')

given('repo has multiple brain configs')
  when('rhachet auto-detects brains (triggered by --hooks with no args)')
    then('all detected brains receive hooks')
      sothat('multi-brain repos work automatically')


## usecase.4 = BrainHooksAdapter.dao.set.findsert (add if not present)

given('a hook not yet in brain config')
  when('BrainHooksAdapter.dao.set.findsert is called with BrainHook')
    then('hook is added to the brain config')
    then('hook includes author namespace from role')
      sothat('hook ownership is tracked')

given('a hook already in brain config with same author + command + event')
  when('BrainHooksAdapter.dao.set.findsert is called')
    then('hook found is retained unchanged')
      sothat('findsert is idempotent')

given('a hook already in brain config with different author')
  when('BrainHooksAdapter.dao.set.findsert is called with same command + event')
    then('both hooks coexist (different namespaces)')
      sothat('different roles can register same commands independently')


## usecase.5 = BrainHooksAdapter.dao.set.upsert (add or update)

given('a hook not yet in brain config')
  when('BrainHooksAdapter.dao.set.upsert is called with BrainHook')
    then('hook is added to the brain config')

given('a hook already in brain config with same author + command + event')
  when('BrainHooksAdapter.dao.set.upsert is called with updated timeout')
    then('hook found is updated with new values')
      sothat('upsert enables modification of owned hooks')

given('a hook already in brain config with different author')
  when('BrainHooksAdapter.dao.set.upsert is called')
    then('new hook is added (does not modify other namespace)')
      sothat('upsert respects namespace boundaries')


## usecase.6 = BrainHooksAdapter.dao.del (remove)

given('a hook in brain config by role A')
  when('BrainHooksAdapter.dao.del is called by role A')
    then('hook is removed from brain config')
      sothat('roles can clean up their own hooks')

given('a hook in brain config by role B')
  when('BrainHooksAdapter.dao.del is called by role A')
    then('hook remains in brain config (different namespace)')
      sothat('roles cannot delete other roles hooks')

given('a hook not in brain config')
  when('BrainHooksAdapter.dao.del is called')
    then('operation succeeds (no-op)')
      sothat('delete is idempotent')


## usecase.7 = BrainHooksAdapter.dao.get

given('hooks in brain config from multiple roles')
  when('BrainHooksAdapter.dao.get.all is called')
    then('returns all hooks')
      sothat('full hook state is visible')

  when('BrainHooksAdapter.dao.get.all is called with author filter')
    then('returns only hooks for that author namespace')
      sothat('role can inspect its own hooks')

  when('BrainHooksAdapter.dao.get.all is called with event filter')
    then('returns only hooks for that event type')
      sothat('hooks can be queried by event')

given('a specific hook in brain config')
  when('BrainHooksAdapter.dao.get.one is called with unique ref')
    then('returns that specific hook or null')
      sothat('presence can be checked before operations')


## usecase.8 = declarative sync (Role.hooks.onBrain applied holistically)

given('role A declares hooks.onBrain with [hook1, hook2]')
  when('hooks are applied via adapter')
    then('hook1 and hook2 are present in brain config')

given('role A prior declared [hook1, hook2], now declares [hook2, hook3]')
  when('hooks are applied via adapter')
    then('hook1 is removed (no longer declared)')
      sothat('removed declarations result in removed hooks')
    then('hook2 is retained')
    then('hook3 is added')
      sothat('brain config reflects current Role.hooks.onBrain state')

given('role A and role B both have hooks.onBrain')
  when('role A hooks are reapplied')
    then('role B hooks are unaffected')
      sothat('declarative sync is namespace-scoped')


## usecase.9 = onTool hooks with filters

given('role declares onTool hook with filter { what: "Bash", when: "before" }')
  when('hooks are applied via adapter')
    then('hook appears under brain-specific PreToolUse event for "Bash"')
      sothat('hook runs before bash tool execution')

given('role declares onTool hook with filter { what: "Bash", when: "after" }')
  when('hooks are applied via adapter')
    then('hook appears under brain-specific PostToolUse event for "Bash"')
      sothat('hook runs after bash tool execution')

given('role declares onTool hook with filter { what: "*", when: "after" }')
  when('hooks are applied via adapter')
    then('hook appears under brain-specific PostToolUse event for all tools')
      sothat('wildcard after-hook triggers for any tool completion')

given('role declares onTool hook with filter { what: "Bash" } (no when)')
  when('hooks are applied via adapter')
    then('hook defaults to before time')
      sothat('backwards compatible with before-only semantics')

given('role declares onTool hooks with different filters')
  when('hooks are applied via adapter')
    then('hooks are grouped by filter.what and routed by filter.when')
      sothat('config structure matches brain expectations')


## usecase.10 = error handle

given('invalid Role.hooks.onBrain declaration (required field absent)')
  when('hooks are applied')
    then('operation fails with descriptive error')
      sothat('user knows what to fix')

given('brain config file is malformed')
  when('adapter attempts to read hooks')
    then('operation fails with descriptive error')
      sothat('user knows config needs repair')

given('brain config file does not exist')
  when('hooks are applied')
    then('config file is created with hooks')
      sothat('first-time setup works seamlessly')


## boundary.1 = claudecode BrainHooksAdapter specifics

given('brain slug is "claudecode"')
  when('Role.hooks.onBrain is applied via adapter')
    then('config is written to .claude/settings.json')
    then('onBoot hooks translate to SessionStart event')
    then('onTool hooks with filter.when="before" translate to PreToolUse event')
    then('onTool hooks with filter.when="after" translate to PostToolUse event')
    then('onStop hooks translate to Stop event')
    then('hook shape includes: type, command, timeout, author')
      sothat('format matches claudecode expectations')

given('.claude/settings.json found with non-hook content')
  when('hooks are applied via adapter')
    then('non-hook content (permissions, etc) is preserved')
      sothat('adapter only modifies hooks section')


## boundary.2 = opencode BrainHooksAdapter specifics

given('brain slug is "opencode"')
  when('Role.hooks.onBrain is applied via adapter')
    then('plugin file is written to .opencode/plugin/rhachet-hooks.ts')
    then('onBoot hooks translate to event listener for session.created + session.compacted')
    then('onTool hooks with filter.when="before" translate to tool.execute.before')
    then('onTool hooks with filter.when="after" translate to tool.execute.after')
    then('onStop hooks translate to event listener for session.idle')
    then('plugin exports author metadata for namespace tracking')
      sothat('format matches opencode plugin expectations')

given('.opencode/plugin/ has other plugins')
  when('hooks are applied via adapter')
    then('other plugins are preserved')
      sothat('adapter only manages rhachet-hooks.ts')
