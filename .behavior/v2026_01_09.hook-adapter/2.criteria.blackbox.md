# blackbox criteria = experience bounds for hook-adapter

## usecase.1 = role declares hooks.onBrain

given('a role supplied via role supplier')
  when('Role.hooks.onBrain includes onBoot hooks')
    then('each onBoot hook specifies command, timeout')
      sothat('the role can declare what runs on brain session start')
    then('hooks are namespaced by role author (repo=X/role=Y)')
      sothat('multiple roles can declare hooks without collision')

  when('Role.hooks.onBrain includes onTool hooks')
    then('each onTool hook specifies command, timeout, matcher')
      sothat('the role can declare what runs before specific tool use')
    then('matcher can target specific tools (bash, write, edit, etc) or wildcard')
      sothat('hooks can be scoped to relevant tool events')

  when('Role.hooks.onBrain includes onStop hooks')
    then('each onStop hook specifies command, timeout')
      sothat('the role can declare what runs on brain session end')
    then('hooks are namespaced by role author (repo=X/role=Y)')
      sothat('multiple roles can declare hooks without collision')


## usecase.2 = discover BrainHooksAdapter via brain supplier

given('package.json has dependency `rhachet-brains-*`')
  when('rhachet searches for BrainHooksAdapter')
    then('rhachet scans dependencies for packages that start with `rhachet-brains-`')
    then('for each found, rhachet checks if package exports `getBrainHooks`')
    then('if exported, rhachet calls `getBrainHooks({ slug })` to resolve adapter')
      sothat('adapters are discovered via convention over configuration')

given('`getBrainHooks({ slug })` returns BrainHooksAdapter')
  when('adapter is resolved for slug')
    then('rhachet uses that adapter for hook operations')

given('`getBrainHooks({ slug })` returns null')
  when('adapter is resolved for slug')
    then('rhachet skips that package and continues search')
      sothat('brain suppliers can support multiple slugs selectively')

// note: this discovery pattern mirrors `src/domain.operations/config/getRegistriesByConfigImplicit.ts`
// implementation would leverage something like `getBrainHooksByConfigImplicit.ts`
// future: `getBrainHooksByConfigExplicit.ts` (explicit usage config declaration) is not supported today but may be added later


## usecase.3 = apply Role.hooks.onBrain via BrainHooksAdapter

given('a role with Role.hooks.onBrain declared')
  when('user runs `npx rhachet init --hooks <brain-slug>`')
    then('rhachet discovers BrainHooksAdapter via brain supplier')
    then('rhachet applies Role.hooks.onBrain via the adapter')
      sothat('hooks are translated to brain-specific format')
    then('hooks appear in repo-scoped config (e.g., .claude/settings.json)')
      sothat('hooks only affect the current repo')

given('user wants to init roles and hooks together')
  when('user runs `npx rhachet init --roles <role...> --hooks <brain-slug...>`')
    then('rhachet first links the specified roles')
    then('rhachet then applies Role.hooks.onBrain for each linked role to each brain')
      sothat('composite init is a single command')
  // example: `npx rhachet init --roles behaver mechanic --hooks claudecode opencode`

given('user wants to apply hooks to multiple brains')
  when('user runs `npx rhachet init --hooks <brain-slug...>`')
    then('rhachet applies Role.hooks.onBrain to each specified brain')
      sothat('multi-brain setups are a single command')
  // example: `npx rhachet init --hooks claudecode opencode`

given('no BrainHooksAdapter found for slug')
  when('user runs `npx rhachet init --hooks <unknown-slug>`')
    then('rhachet reports error with available brain slugs')
      sothat('user knows which brains have hook adapters')


## usecase.4 = BrainHooksAdapter.dao.set.findsert (add if not present)

given('a hook not yet in brain config')
  when('BrainHooksAdapter.dao.set.findsert is called with BrainHookApplied')
    then('hook is added to the brain config')
    then('hook includes author namespace from role')
      sothat('hook ownership is tracked')

given('a hook already in brain config with same author + command + event')
  when('BrainHooksAdapter.dao.set.findsert is called')
    then('hook found is retained unchanged')
      sothat('findsert is idempotent')

given('a hook already in brain config with different author')
  when('BrainHooksAdapter.dao.set.findsert is called with same command + event')
    then('both hooks coexist (different namespaces)')
      sothat('different roles can register same commands independently')


## usecase.5 = BrainHooksAdapter.dao.set.upsert (add or update)

given('a hook not yet in brain config')
  when('BrainHooksAdapter.dao.set.upsert is called with BrainHookApplied')
    then('hook is added to the brain config')

given('a hook already in brain config with same author + command + event')
  when('BrainHooksAdapter.dao.set.upsert is called with updated timeout')
    then('hook found is updated with new values')
      sothat('upsert enables modification of owned hooks')

given('a hook already in brain config with different author')
  when('BrainHooksAdapter.dao.set.upsert is called')
    then('new hook is added (does not modify other namespace)')
      sothat('upsert respects namespace boundaries')


## usecase.6 = BrainHooksAdapter.dao.del (remove)

given('a hook in brain config by role A')
  when('BrainHooksAdapter.dao.del is called by role A')
    then('hook is removed from brain config')
      sothat('roles can clean up their own hooks')

given('a hook in brain config by role B')
  when('BrainHooksAdapter.dao.del is called by role A')
    then('hook remains in brain config (different namespace)')
      sothat('roles cannot delete other roles hooks')

given('a hook not in brain config')
  when('BrainHooksAdapter.dao.del is called')
    then('operation succeeds (no-op)')
      sothat('delete is idempotent')


## usecase.7 = BrainHooksAdapter.dao.get

given('hooks in brain config from multiple roles')
  when('BrainHooksAdapter.dao.get.all is called')
    then('returns all hooks')
      sothat('full hook state is visible')

  when('BrainHooksAdapter.dao.get.all is called with author filter')
    then('returns only hooks for that author namespace')
      sothat('role can inspect its own hooks')

  when('BrainHooksAdapter.dao.get.all is called with event filter')
    then('returns only hooks for that event type')
      sothat('hooks can be queried by event')

given('a specific hook in brain config')
  when('BrainHooksAdapter.dao.get.one is called with unique ref')
    then('returns that specific hook or null')
      sothat('presence can be checked before operations')


## usecase.8 = declarative sync (Role.hooks.onBrain applied holistically)

given('role A declares hooks.onBrain with [hook1, hook2]')
  when('hooks are applied via adapter')
    then('hook1 and hook2 are present in brain config')

given('role A prior declared [hook1, hook2], now declares [hook2, hook3]')
  when('hooks are applied via adapter')
    then('hook1 is removed (no longer declared)')
      sothat('removed declarations result in removed hooks')
    then('hook2 is retained')
    then('hook3 is added')
      sothat('brain config reflects current Role.hooks.onBrain state')

given('role A and role B both have hooks.onBrain')
  when('role A hooks are reapplied')
    then('role B hooks are unaffected')
      sothat('declarative sync is namespace-scoped')


## usecase.9 = onTool hooks with matchers

given('role declares onTool hook with matcher "Bash"')
  when('hooks are applied via adapter')
    then('hook appears under brain-specific matcher for "Bash"')
      sothat('hook only triggers for bash tool usage')

given('role declares onTool hook with matcher "*"')
  when('hooks are applied via adapter')
    then('hook appears under brain-specific matcher for all tools')
      sothat('wildcard matcher triggers for any tool')

given('role declares onTool hooks with different matchers')
  when('hooks are applied via adapter')
    then('hooks are grouped by matcher in brain config')
      sothat('config structure matches brain expectations')


## usecase.10 = error handle

given('invalid Role.hooks.onBrain declaration (required field absent)')
  when('hooks are applied')
    then('operation fails with descriptive error')
      sothat('user knows what to fix')

given('brain config file is malformed')
  when('adapter attempts to read hooks')
    then('operation fails with descriptive error')
      sothat('user knows config needs repair')

given('brain config file does not exist')
  when('hooks are applied')
    then('config file is created with hooks')
      sothat('first-time setup works seamlessly')


## boundary.1 = claude-code BrainHooksAdapter specifics

given('brain slug is "anthropic/claude/code"')
  when('Role.hooks.onBrain is applied via adapter')
    then('config is written to .claude/settings.json')
    then('onBoot hooks translate to SessionStart event')
    then('onTool hooks translate to PreToolUse event')
    then('onStop hooks translate to Stop event')
    then('hook shape includes: type, command, timeout, author')
      sothat('format matches claude-code expectations')

given('.claude/settings.json found with non-hook content')
  when('hooks are applied via adapter')
    then('non-hook content (permissions, etc) is preserved')
      sothat('adapter only modifies hooks section')
