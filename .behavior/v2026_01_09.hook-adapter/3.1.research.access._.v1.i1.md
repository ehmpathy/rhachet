# research.access = remote access requirements for hook-adapter

## summary

the hook-adapter feature requires access to:
1. **local filesystem** — brain-specific config files (e.g., `.claude/settings.json`)
2. **package.json** — to discover `rhachet-brains-*` packages
3. **node_modules** — to resolve and import brain supplier packages

no external APIs or databases are required. all access is local filesystem.

---

## lesson.1 = claude-code hooks filesystem access

### contract

claude-code stores hooks configuration in JSON files at three locations [1]:
- **project-level**: `.claude/settings.json` (repo-scoped, shareable)
- **user-level**: `~/.claude/settings.json` (global)
- **local**: `.claude/settings.local.json` (uncommitted)

project settings override user-level settings [1].

### hook events

claude-code supports eight hook events [2]:
1. `SessionStart` — fires when session begins or resumes
2. `PreToolUse` — before a tool executes
3. `PermissionRequest` — before permission dialogs appear
4. `PostToolUse` — after tools complete successfully
5. `PreCompact` — before context compaction occurs
6. `Stop` — when Claude finishes responding
7. `SubagentStop` — when subagents complete
8. `UserPromptSubmit` — when user submits a prompt

### JSON structure

```json
{
  "hooks": {
    "HookType": [
      {
        "matcher": "ToolName",
        "hooks": [
          {
            "type": "command",
            "command": "/path/to/script.sh",
            "timeout": 60
          }
        ]
      }
    ]
  }
}
```
[2]

### matcher syntax

- simple: `"Write"` — matches specific tool [2]
- pipe: `"Write|Edit"` — matches multiple tools [2]
- wildcard: `"*"` — matches all tools [2]
- argument pattern: `"Bash(npm test*)"` — matches commands [2]
- MCP tools: `"mcp__memory__.*"` pattern format [2]

matchers only apply to PreToolUse, PostToolUse, and PermissionRequest [1].
lifecycle hooks (Stop, SessionStart, Notification) ignore matchers [1].

### interface

- **read**: `JSON.parse(fs.readFileSync('.claude/settings.json', 'utf8'))`
- **write**: `fs.writeFileSync('.claude/settings.json', JSON.stringify(config, null, 2))`
- **merge**: must preserve non-hook content (permissions, etc)

### best practices

- use repo-scoped `.claude/settings.json` for shareable hooks [1]
- preserve non-hook sections when writing hooks [criteria: boundary.1]
- namespace hooks by author to avoid collision [criteria: usecase.1]
- default timeout is 60 seconds [2]

---

## lesson.2 = opencode hooks filesystem access

### contract

opencode uses a plugin-based hook system [3][4]:
- **project-level**: `opencode.json` in project root
- **plugins**: `.opencode/plugin/*.ts` (auto-discovered)
- **global**: `~/.config/opencode/opencode.json`

config precedence (lowest to highest) [3]:
1. remote config (`.well-known/opencode` endpoint)
2. global config (`~/.config/opencode/opencode.json`)
3. custom config (`OPENCODE_CONFIG` env var)
4. project config (`opencode.json` in project root)
5. `.opencode` directories
6. inline config (`OPENCODE_CONFIG_CONTENT` env var)

### hook types

opencode hooks are TypeScript plugins with lifecycle hooks [4]:

```typescript
export const MyPlugin: Plugin = async ({ client, $ }) => {
  return {
    tool: {
      execute: {
        before: async (input, output) => { /* runs before execution */ },
        after: async (input, output) => { /* runs after execution */ }
      }
    },
    event: async ({ event }) => { /* listen to system events */ }
  }
}
```
[4]

### interface

unlike claude-code (JSON config), opencode requires TypeScript plugin files:
- **location**: `.opencode/plugin/my-plugin.ts`
- **enable**: via `opencode.json` plugins section [4]

```json
{
  "plugins": {
    "my-plugin": { "enabled": true }
  }
}
```
[4]

### best practices

- place plugins in `.opencode/plugin/` for auto-discovery [4]
- use `tool.execute.before` for pre-tool hooks [4]
- use `tool.execute.after` for post-tool hooks [4]
- listen to `session.idle` for stop events [4]

---

## lesson.2b = opencode complete hook event list

opencode plugins can intercept 25+ events across the agent lifecycle [7][8].

### tool events

| event | description |
|-------|-------------|
| `tool.execute.before` | runs before a tool executes (can block) [7] |
| `tool.execute.after` | runs after a tool completes [7] |

note: MCP tool calls do NOT trigger tool.execute hooks [9]

### session events

| event | description |
|-------|-------------|
| `session.created` | new session started [7] |
| `session.updated` | session state changed [7] |
| `session.deleted` | session removed [7] |
| `session.error` | session encountered error [7] |
| `session.idle` | session finished responding (stop equivalent) [7] |
| `session.status` | session status changed [7] |
| `session.compacted` | context was compacted [7] |
| `session.diff` | session diff available [7] |
| `experimental.session.compacting` | before compaction summary (inject context) [7] |

### message events

| event | description |
|-------|-------------|
| `message.updated` | message content changed [7] |
| `message.removed` | message deleted [7] |
| `message.part.updated` | message part changed [7] |
| `message.part.removed` | message part deleted [7] |

### file events

| event | description |
|-------|-------------|
| `file.edited` | file was edited [7] |
| `file.watcher.updated` | file watcher state changed [7] |

### permission events

| event | description |
|-------|-------------|
| `permission.updated` | permission state changed [7] |
| `permission.replied` | user responded to permission prompt [7] |

### other events

| event | description |
|-------|-------------|
| `command.executed` | CLI command executed [7] |
| `installation.updated` | installation state changed [7] |
| `lsp.client.diagnostics` | LSP diagnostics received [7] |
| `lsp.updated` | LSP state changed [7] |
| `server.connected` | server connection established [7] |
| `todo.updated` | todo item changed [7] |
| `tui.prompt.append` | append to TUI prompt [7] |
| `tui.command.execute` | TUI command executed [7] |
| `tui.toast.show` | show toast notification [7] |

### rhachet mapping (refined)

| rhachet event | opencode event(s) | notes |
|---------------|-------------------|-------|
| onBoot | `session.created` + `session.compacted` | fires on session start AND compaction (fresh context) [7] |
| onTool::before | `tool.execute.before` | runs before tool execution [7] |
| onTool::after | `tool.execute.after` | runs after tool execution [7] |
| onStop | `session.idle` | fires when agent finishes responding [7] |

### hook execution model

- all hooks execute sequentially via async/await [8]
- each hook sees modifications from previous hooks [8]
- hooks can be disabled via `disabled_hooks` config array [8]
- oh-my-opencode provides 22 pre-built lifecycle hooks [8]

---

## lesson.3 = package.json scanning for brain suppliers

### contract

brain suppliers are discovered via package.json dependencies [criteria: usecase.2]:
- scan `dependencies` and `devDependencies`
- filter for packages that start with `rhachet-brains-`
- for each, check if package exports `getBrainHooks`

### existing pattern

this repo already implements implicit package discovery for role suppliers [5]:

```typescript
export const discoverRolePackages = async (input: {
  from: string;
}): Promise<string[]> => {
  const root = await getGitRepoRoot({ from: input.from });
  const pkgPath = resolve(root, 'package.json');
  const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
  return Object.keys(allDeps).filter((name) =>
    name.startsWith('rhachet-roles-'),
  );
};
```
[5]

### interface

brain supplier discovery follows same pattern:
1. read `package.json` from repo root
2. merge `dependencies` + `devDependencies`
3. filter for `rhachet-brains-*` packages
4. resolve each via `require.resolve()`
5. import and call `getBrainHooks({ slug })`

### best practices

- use `createRequire` from `node:module` for package resolution [6]
- resolve `package.json` path, then `dirname()` for package root [6]
- collect errors for packages that fail to load [6]
- fail fast if multiple adapters match same slug [criteria: blueprint]

---

## lesson.4 = mapping rhachet hooks to brain hooks

### claude-code mapping

| rhachet event | claude-code event(s) | notes |
|---------------|----------------------|-------|
| onBoot | SessionStart | fires on session start/resume/compaction [2] |
| onTool::before | PreToolUse | requires matcher [2] |
| onTool::after | PostToolUse | requires matcher [2] |
| onStop | Stop | fires when Claude finishes [2] |

note: claude-code SessionStart fires after compaction automatically [1]

### opencode mapping

| rhachet event | opencode event(s) | notes |
|---------------|-------------------|-------|
| onBoot | `session.created` + `session.compacted` | fires on session start AND compaction [7] |
| onTool::before | `tool.execute.before` | plugin hook [4] |
| onTool::after | `tool.execute.after` | plugin hook [4] |
| onStop | `session.idle` | plugin event listener [4] |

### adapter responsibility

each BrainHooksAdapter must:
1. translate rhachet hook shape → brain-specific format
2. encapsulate config file path
3. encapsulate config file format (JSON vs TypeScript)
4. preserve non-hook content when writing

---

## citations

[1] "Project-level hooks go in `.claude/settings.json` within your repository, making them shareable with your team. User-level hooks go in `~/.claude/settings.json`... Project-level settings take precedence over user-level settings."
— [Claude Code hooks guide](https://code.claude.com/docs/en/hooks-guide)

[2] "Claude Code supports eight hook events: SessionStart, PreToolUse, PermissionRequest, PostToolUse, PreCompact, Stop, SubagentStop, UserPromptSubmit... Matcher Syntax: Simple matching: 'Write', Pipe operator: 'Write|Edit', Wildcards: '*'... Timeout: Default 60 seconds per hook"
— [How to configure hooks](https://claude.com/blog/how-to-configure-hooks)

[3] "OpenCode supports JSON and JSONC formats. Configuration files are merged together rather than replaced... Config precedence order: Remote config, Global config, Custom config, Project config, .opencode directories, Inline config"
— [OpenCode Config docs](https://opencode.ai/docs/config/)

[4] "The plugin architecture intercepts tool execution with lifecycle hooks... tool: { execute: { before: async (input, output) => {}, after: async (input, output) => {} } }... Location: `.opencode/plugin/my-plugin.ts` (auto-discovered)"
— [OpenCode hooks guide](https://dev.to/einarcesar/does-opencode-support-hooks-a-complete-guide-to-extensibility-k3p)

[5] `src/domain.operations/init/discoverRolePackages.ts` — existing pattern for scanning package.json for `rhachet-roles-*` packages

[6] `src/domain.operations/config/getRoleRegistriesByConfigImplicit.ts` — existing pattern for resolving packages via `createRequire` and loading manifests

[7] "command.executed, file.edited, file.watcher.updated, installation.updated, lsp.client.diagnostics, lsp.updated, message.part.removed, message.part.updated, message.removed, message.updated, permission.replied, permission.updated, server.connected, session.created, session.compacted, session.deleted, session.diff, session.error, session.idle, session.status, session.updated, todo.updated, tool.execute.after, tool.execute.before, experimental.session.compacting"
— [OpenCode Plugins docs](https://opencode.ai/docs/plugins/)

[8] "There are 22 lifecycle hooks available in oh-my-opencode. Hooks intercept specific events during agent execution to modify behavior, inject context, manage resources, and implement recovery strategies... All hooks are enabled by default and can be individually disabled via the disabled_hooks configuration array... All hook events use async/await sequential execution. This ensures hooks execute in strict order, with each hook able to see modifications made by previous hooks."
— [OpenCode hooks search results](https://dev.to/einarcesar/does-opencode-support-hooks-a-complete-guide-to-extensibility-k3p)

[9] "When OpenCode calls an MCP tool, it doesn't trigger the tool.execute.before and tool.execute.after hooks in the plugin system, making it difficult to attach session-level metadata to an MCP tool call or inject arguments."
— [GitHub Issue #2319](https://github.com/sst/opencode/issues/2319)
