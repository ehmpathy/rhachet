# research.domain = domain model for hook-adapter

## summary

the hook-adapter feature requires these domain constructs:

1. **entities**: Role, RoleHooks, RoleHooksOnBrain, BrainHook, BrainHookApplied, BrainHooksAdapter
2. **literals**: BrainHookEvent, BrainHookMatcher
3. **operations**: discover adapters, sync hooks, get/set/del hooks
4. **relationships**: Role → RoleHooks → RoleHooksOnBrain → BrainHook[], adapted via BrainHooksAdapter

---

## domain.objects

### entities

#### Role (existing, extended)

```typescript
interface Role {
  slug: string;
  name: string;
  purpose: string;
  readme: { uri: string };
  traits: RoleTrait[];
  skills: { ... };
  briefs: { ... };
  inits?: { ... };
  hooks?: RoleHooks;  // NEW
}
```

the Role entity is extended with an optional `hooks` property [1].

#### RoleHooks (new)

```typescript
interface RoleHooks {
  onDispatch?: RoleHooksOnDispatch;
  onBrain?: RoleHooksOnBrain;
}
```

separates dispatch hooks (rhachet middleware) from brain hooks (brain event hooks) [2].

#### RoleHooksOnDispatch (renamed from InvokeHooks)

```typescript
interface RoleHooksOnDispatch {
  onInvokeAskInput: Array<(input: InvokeOpts) => InvokeOpts>;
  onInvokeActInput?: (input: SkillInput) => SkillInput;
}
```

middleware over rhachet dispatch actions. exists today as `InvokeHooks.ts` [3].

#### RoleHooksOnBrain (new)

```typescript
interface RoleHooksOnBrain {
  onBoot?: BrainHook[];
  onTool?: BrainHook[];
  onStop?: BrainHook[];
}
```

declares hooks to apply to brain repls via adapters [4].

#### BrainHook (new)

```typescript
import { IsoDuration } from 'iso-time';

interface BrainHook {
  event: BrainHookEvent;
  command: string;
  timeout: IsoDuration;
  matcher?: BrainHookMatcher;  // for onTool only
}

// IsoDuration accepts:
// - string: "PT60S", "PT5M", "PT1H"
// - object: { seconds: 60 }, { minutes: 5 }, { hours: 1 }
```

a single hook declaration. the `matcher` property only applies to onTool hooks [5]. timeout uses ISO 8601 duration format via `iso-time` package [20].

#### BrainHookApplied (new)

```typescript
interface BrainHookApplied extends BrainHook {
  author: string;  // namespace: "repo=X/role=Y"
}
```

a hook as stored in brain config, with author for namespace isolation [6].

#### BrainHooksAdapter (new)

```typescript
interface BrainHooksAdapter {
  slug: string;  // e.g., "claudecode", "opencode"
  dao: {
    get: {
      one: (input: { by: { unique: RefByUnique<BrainHookApplied> } }) => Promise<BrainHookApplied | null>;
      all: (input?: { by?: PickOne<{ command, author, event }> }) => Promise<BrainHookApplied[]>;
    };
    set: {
      findsert: (input: { hook: BrainHookApplied }) => Promise<BrainHookApplied>;
      upsert: (input: { hook: BrainHookApplied }) => Promise<BrainHookApplied>;
    };
    del: (input: { by: { unique: RefByUnique<BrainHookApplied> } }) => Promise<void>;
  };
}
```

adapts rhachet hook operations to brain-specific config format [7]. follows the DAO pattern where "the Repository's job is to expose domain semantics instead of raw database operations" [8].

### literals

#### BrainHookEvent (new)

```typescript
type BrainHookEvent = 'onBoot' | 'onTool' | 'onStop';
```

the event types that can trigger hooks [9].

#### BrainHookMatcher (new)

```typescript
interface BrainHookMatcher {
  what: string;                        // tool pattern: "Bash", "Write|Edit", "*"
  when?: 'before' | 'after';           // timing, defaults to "before"
}
```

structured matcher for onTool hooks, separating tool selection from timing [10].

---

## domain.operations

### discovery operations

#### discoverBrainPackages (new)

```typescript
discoverBrainPackages({ from: string }): Promise<string[]>
```

scans package.json for `rhachet-brains-*` packages. mirrors existing `discoverRolePackages` pattern [11].

#### getBrainHooksAdapterByConfigImplicit (new)

```typescript
getBrainHooksAdapterByConfigImplicit({ slug: string, from: string }): Promise<BrainHooksAdapter | null>
```

discovers adapter by scanning `rhachet-brains-*` packages and calling `getBrainHooks({ slug })` on each until one matches [12]. returns null if none found, throws if multiple match.

#### detectBrainReplsInRepo (new)

```typescript
detectBrainReplsInRepo({ from: string }): Promise<string[]>
```

detects brains via allowlisted config files [13]:
- `.claude/settings.json` → "claudecode"
- `.opencode/` directory → "opencode"

### sync operations

#### syncRoleHooksIntoBrainRepl (new)

```typescript
syncRoleHooksIntoBrainRepl({ role: Role, adapter: BrainHooksAdapter }): Promise<void>
```

declarative sync: computes diff between declared hooks and hooks found for role author, applies upsert for declared hooks, deletes hooks no longer declared [14].

this follows the reconciliation pattern where "the system runs a check→diff→execute loop, dealing with differences between actual state and desired state" [15].

### adapter DAO operations

per the DAO pattern, these operations are exposed via `BrainHooksAdapter.dao` [16]:

| operation    | signature                                                         | purpose                         |
| ------------ | ----------------------------------------------------------------- | ------------------------------- |
| get.one      | `({ by: { unique } }) => BrainHookApplied \| null`                | find specific hook              |
| get.all      | `({ by?: { author \| event \| command } }) => BrainHookApplied[]` | list hooks with optional filter |
| set.findsert | `({ hook }) => BrainHookApplied`                                  | add if not present (idempotent) |
| set.upsert   | `({ hook }) => BrainHookApplied`                                  | add or update                   |
| del          | `({ by: { unique } }) => void`                                    | remove hook (idempotent)        |

the unique reference for a hook is: `{ author, event, command, matcher? }`.

---

## relationships

### decoration tree

```
Role
└── hooks?: RoleHooks
    ├── onDispatch?: RoleHooksOnDispatch     # middleware over rhachet dispatch
    └── onBrain?: RoleHooksOnBrain           # hooks applied to brain repls
        ├── onBoot?: BrainHook[]
        ├── onTool?: BrainHook[]
        └── onStop?: BrainHook[]
```

RoleHooks decorates Role. RoleHooksOnBrain contains arrays of BrainHook declarations.

### subdomain tree

```
rhachet (core)
├── domain.objects
│   ├── Role (extended with hooks)
│   ├── RoleHooks
│   ├── RoleHooksOnDispatch (renamed from InvokeHooks)
│   ├── RoleHooksOnBrain
│   ├── BrainHook
│   └── BrainHookApplied
├── domain.operations
│   ├── config/
│   │   ├── getBrainHooksAdapterByConfigImplicit
│   │   └── detectBrainReplsInRepo
│   └── hooks/
│       └── syncRoleHooksIntoBrainRepl

rhachet-brains-* (suppliers)
├── BrainHooksAdapter (interface implementation)
└── getBrainHooks({ slug }) export
```

the adapter pattern enables "incompatible objects to collaborate by acting as a bridge between them" [17]. rhachet declares the contract, brain suppliers implement adapters.

### dependency graph

```
syncRoleHooksIntoBrainRepl
├── depends on: Role (reads Role.hooks.onBrain)
├── depends on: BrainHooksAdapter (calls dao methods)
└── uses: BrainHookApplied (domain object for storage)

getBrainHooksAdapterByConfigImplicit
├── depends on: discoverBrainPackages
├── depends on: package.json (reads dependencies)
└── returns: BrainHooksAdapter | null

CLI (init --roles --hooks)
├── depends on: getBrainHooksAdapterByConfigImplicit
├── depends on: detectBrainReplsInRepo (for auto-detection)
└── invokes: syncRoleHooksIntoBrainRepl
```

---

## composition

### how domain objects compose to support wish

the wish states: "it should be possible for different packages like `rhachet-brain-anthropic` to register how they support hook management" [18].

this is achieved via:

1. **Role.hooks.onBrain** — roles declare desired hooks
2. **BrainHooksAdapter** — brain suppliers implement adapters
3. **syncRoleHooksIntoBrainRepl** — rhachet reconciles declared state to actual state
4. **namespace isolation** — author field prevents role collision

### flow

```
┌─────────────────────────────────────────────────────────────────┐
│ npx rhachet init --roles mechanic --hooks claudecode            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 1. resolve adapter via getBrainHooksAdapterByConfigImplicit     │
│    - scan rhachet-brains-* packages                             │
│    - call getBrainHooks({ slug: "claudecode" })                 │
│    - return matching adapter                                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. syncRoleHooksIntoBrainRepl({ role: mechanic, adapter })          │
│    - read Role.hooks.onBrain declarations                       │
│    - get existing hooks for author "repo=ehmpathy/role=mechanic"│
│    - compute diff (add, update, remove)                         │
│    - apply via adapter.dao.set.upsert / adapter.dao.del         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. adapter translates to brain-specific config                  │
│    - claudecode: writes to .claude/settings.json                │
│    - maps: onBoot→SessionStart, onTool::before→PreToolUse, etc  │
│    - preserves non-hook content                                 │
└─────────────────────────────────────────────────────────────────┘
```

### declarative sync semantics

the sync operation follows the reconciliation pattern [19]:

```typescript
// pseudocode for syncRoleHooksIntoBrainRepl
const declared = role.hooks?.onBrain ?? {};
const author = `repo=${registry.slug}/role=${role.slug}`;
const existing = await adapter.dao.get.all({ by: { author } });

// upsert declared hooks
for (const hook of [...declared.onBoot, ...declared.onTool, ...declared.onStop]) {
  await adapter.dao.set.upsert({ hook: { ...hook, author } });
}

// delete hooks no longer declared
for (const hook of existing) {
  if (!isDeclared(hook, declared)) {
    await adapter.dao.del({ by: { unique: hook } });
  }
}
```

this ensures "if a hook is no longer specified by the role, it will no longer be present after hooks are applied" [18].

---

## citations

[1] `src/domain.objects/Role.ts` — existing Role interface, to be extended with `hooks` property

[2] `.agent/repo=.this/role=any/briefs/define.term.suppliers.md` — "each Role can declare `Role.hooks.{ onDispatch, onBrain }`"

[3] `src/domain.objects/InvokeHooks.ts` — existing dispatch hooks, to be renamed to RoleHooksOnDispatch

[4] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — "RoleHooksOnBrain domain object declares: onBoot, onTool, onStop"

[5] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — "BrainHook declares: event, command, timeout, matcher (for onTool only)"

[6] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — "BrainHookApplied extends BrainHook with: author"

[7] `.agent/repo=.this/role=any/briefs/define.term.adapters.md` — "an adapter transforms a payload from ShapeA to ShapeB, to adapt from ContractA to ContractB"

[8] "The Repository's job is to expose domain semantics - 'give me active users' - instead of 'execute this SQL'"
— [Khalil Stemmler, Repository Pattern](https://khalilstemmler.com/articles/typescript-domain-driven-design/repository-dto-mapper/)

[9] `.behavior/v2026_01_09.hook-adapter/2.criteria.blackbox.md` — usecase.1 defines onBoot, onTool, onStop hooks

[10] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — "BrainHookMatcher declares: what (string), when ('before' | 'after')"

[11] `src/domain.operations/init/discoverRolePackages.ts` — existing pattern for scanning package.json for `rhachet-roles-*`

[12] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — "getBrainHooksAdapterByConfigImplicit scans package.json for rhachet-brains-*"

[13] `.behavior/v2026_01_09.hook-adapter/2.criteria.blackbox.md` — usecase.3b defines allowlisted brain config files

[14] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — "syncRoleHooksIntoBrainRepl computes diff, applies upsert for declared, delete for removed"

[15] "The reconciliation process keeps running a 'check→diff→execute' loop, so that the system can always deal with the differences between the system's actual state and the desired state."
— [Alibaba Cloud, Declarative Application Management](https://www.alibabacloud.com/blog/fundamentals-of-declarative-application-management-in-kubernetes_596265)

[16] "DAO stands for Data Access Object. DAO Design Pattern is used to separate the data persistence logic in a separate layer."
— [DigitalOcean, DAO Design Pattern](https://www.digitalocean.com/community/tutorials/dao-design-pattern)

[17] "The Adapter Pattern is a structural design pattern that allows objects with incompatible interfaces to work together by acting as a bridge between them."
— [Refactoring Guru, Adapter Pattern](https://refactoring.guru/design-patterns/adapter/typescript/example)

[18] `.behavior/v2026_01_09.hook-adapter/0.wish.md` — original wish for hook-adapter feature

[19] "Desired state systems wrap imperative, mutable APIs with declarative interfaces. The abstraction works through a continuous cycle: observe the actual state, compare it to the desired state, and apply necessary changes."
— [Branislav Jenco, Desired State Systems](https://branislavjenco.github.io/desired-state-systems/)

[20] `iso-time` package — provides `IsoDuration` type supporting both ISO 8601 strings ("PT60S", "PT5M") and object format (`{ seconds: 60 }`, `{ minutes: 5 }`)
