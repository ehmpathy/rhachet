# distill.domain = declastruct design for hook-adapter

## summary

this document distills the domain.objects, domain.operations, and access patterns required to fulfill the hook-adapter feature via the declastruct pattern.

key principles:
- **declarative sync** — role declares desired hooks, rhachet reconciles to actual state
- **namespace isolation** — each role owns its hooks via author namespace
- **adapter pattern** — brain suppliers implement adapters that translate rhachet contract to brain-specific format
- **opt-in hooks** — `--hooks` flag required to bind hooks (no auto-bind by default)

---

## usecases and contracts

### usecase.1 = declare hooks on role

```ts
// role author declares hooks.onBrain
const mechanicRole: Role = {
  slug: 'mechanic',
  hooks: {
    onBrain: {
      onBoot: [
        { command: 'npx rhachet roles boot', timeout: 'PT60S' },
      ],
      onTool: [
        { command: 'npm run lint:fix', timeout: 'PT30S', filter: { what: 'Write|Edit', when: 'after' } },
      ],
    },
  },
};
// note: author derived from role; event implicit from container key
```

### usecase.2 = apply hooks via CLI

```sh
# init roles without hooks (prior behavior)
npx rhachet init --roles mechanic behaver

# init roles + auto-detect brains + bind hooks
npx rhachet init --roles mechanic behaver --hooks

# init roles + bind hooks to explicit brains only
npx rhachet init --roles mechanic behaver --hooks claudecode

# bind hooks for already-linked roles (auto-detect)
npx rhachet init --hooks

# bind hooks for already-linked roles (explicit)
npx rhachet init --hooks claudecode opencode
```

### usecase.3 = adapter resolves to brain-specific config

```ts
// rhachet calls adapter
const adapter = await getBrainHooksAdapterByConfigImplicit({ slug: 'claudecode', from: cwd });

// adapter provides DAO interface
await adapter.dao.set.upsert({
  hook: {
    event: 'onBoot',
    command: 'npx rhachet roles boot',
    timeout: 'PT60S',
    author: 'repo=ehmpathy/role=mechanic',
  },
});

// adapter writes brain-specific format (.claude/settings.json)
// {
//   "hooks": {
//     "SessionStart": [{
//       "type": "command",
//       "command": "npx rhachet roles boot",
//       "timeout": 60
//     }]
//   }
// }
```

### usecase.4 = declarative sync

```ts
// role declares: [hook1, hook2]
// brain config has: [hook1, hook3]
// after sync: [hook1, hook2] — hook3 removed, hook2 added
await syncRoleHooksIntoBrainRepl({ role, adapter });
```

---

## domain.objects

### BrainSpecifier (literal)

```ts
/**
 * .what = identifier for a brain repl
 * .why = typed specifier for brain selection in hooks operations
 * .note = aligns with RoleSpecifier pattern
 */
export type BrainSpecifier = string;
// examples: 'claudecode', 'anthropic/claude/code', 'opencode', 'anomaly/opencode'
```

### BrainHookEvent (literal)

```ts
/**
 * .what = event types that can trigger brain hooks
 */
export type BrainHookEvent = 'onBoot' | 'onTool' | 'onStop';
```

- `onBoot` — fires on session start, compaction, context refresh
- `onTool` — fires before/after tool execution
- `onStop` — fires when brain finishes response

### BrainHookFilter (literal)

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = filter criteria for onTool hooks — specifies tool selection and time
 * .why = separates tool selection from execution time
 */
export interface BrainHookFilter {
  what: string;                      // tool pattern: "Bash", "Write|Edit", "*"
  when?: 'before' | 'after';         // time, defaults to "before"
}

export class BrainHookFilter
  extends DomainLiteral<BrainHookFilter>
  implements BrainHookFilter {}
```

### BrainHook (entity)

```ts
import { DomainEntity } from 'domain-objects';
import { IsoDuration } from 'iso-time';

/**
 * .what = a brain hook with author namespace
 * .why = tracks ownership for namespace isolation in brain config
 */
export interface BrainHook {
  author: string;                    // namespace: "repo=X/role=Y"
  event: BrainHookEvent;
  command: string;
  timeout: IsoDuration;              // "PT60S" or { seconds: 60 }
  filter?: BrainHookFilter;          // for onTool only
}

export class BrainHook
  extends DomainEntity<BrainHook>
  implements BrainHook
{
  public static unique = ['author', 'event', 'command'] as const;
  public static updatable = ['filter', 'timeout'] as const;
}
```

### RoleHookOnBrain (literal)

```ts
import { DomainLiteral } from 'domain-objects';
import { IsoDuration } from 'iso-time';

/**
 * .what = a single hook declared by a role
 * .why = author derived on application; event implicit from container key
 */
export interface RoleHookOnBrain {
  command: string;
  timeout: IsoDuration;
  filter?: BrainHookFilter;          // for onTool only
}

export class RoleHookOnBrain
  extends DomainLiteral<RoleHookOnBrain>
  implements RoleHookOnBrain {}
```

### RoleHooksOnBrain (literal)

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = brain hooks declared by a role
 * .why = container for hook declarations by event type
 */
export interface RoleHooksOnBrain {
  onBoot?: RoleHookOnBrain[];
  onTool?: RoleHookOnBrain[];
  onStop?: RoleHookOnBrain[];
}

export class RoleHooksOnBrain
  extends DomainLiteral<RoleHooksOnBrain>
  implements RoleHooksOnBrain
{
  public static nested = {
    onBoot: RoleHookOnBrain,
    onTool: RoleHookOnBrain,
    onStop: RoleHookOnBrain,
  };
}
```

### RoleHooksOnDispatch (renamed from InvokeHooks)

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = dispatch hooks for rhachet middleware
 * .why = transforms inputs before skill execution
 * .note = renamed from InvokeHooks to align with domain model
 */
export interface RoleHooksOnDispatch {
  onInvokeAskInput?: Array<(input: InvokeOpts) => InvokeOpts>;
  onInvokeActInput?: (input: SkillInput) => SkillInput;
}

export class RoleHooksOnDispatch
  extends DomainLiteral<RoleHooksOnDispatch>
  implements RoleHooksOnDispatch {}
```

### RoleHooks (literal)

```ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = all hooks declared by a role
 * .why = separates dispatch hooks (rhachet middleware) from brain hooks (brain events)
 */
export interface RoleHooks {
  onDispatch?: RoleHooksOnDispatch;
  onBrain?: RoleHooksOnBrain;
}

export class RoleHooks
  extends DomainLiteral<RoleHooks>
  implements RoleHooks
{
  public static nested = {
    onDispatch: RoleHooksOnDispatch,
    onBrain: RoleHooksOnBrain,
  };
}
```

### Role (extended)

```ts
// role interface extended with hooks property
export interface Role {
  slug: string;
  name: string;
  purpose: string;
  // ... prior properties
  hooks?: RoleHooks;  // NEW
}
```

---

## access.daos

### BrainHooksAdapter.dao (contract)

```ts
import { RefByUnique, PickOne } from 'type-fns';

/**
 * .what = DAO interface for brain hooks CRUD operations
 * .why = adapts rhachet hook operations to brain-specific config format
 *
 * note: implements method syntax for bivariance (see define.bivariance-for-generics)
 */
export interface BrainHooksAdapterDao {
  get: {
    /**
     * .what = find specific hook by unique ref
     */
    one(input: {
      by: { unique: RefByUnique<typeof BrainHook> };
    }): Promise<BrainHook | null>;

    /**
     * .what = list hooks with optional filters
     */
    all(input?: {
      by?: PickOne<{ author: string; event: BrainHookEvent; command: string }>;
    }): Promise<BrainHook[]>;
  };

  set: {
    /**
     * .what = add hook if not present (idempotent)
     * .why = findsert enables safe repeated application
     */
    findsert(input: { hook: BrainHook }): Promise<BrainHook>;

    /**
     * .what = add or update hook
     * .why = upsert enables declarative sync
     */
    upsert(input: { hook: BrainHook }): Promise<BrainHook>;
  };

  /**
   * .what = remove hook by unique ref (idempotent)
   * .why = enables removal of hooks no longer declared
   */
  del(input: {
    by: { unique: RefByUnique<typeof BrainHook> };
  }): Promise<void>;
}
```

### BrainHooksAdapter (contract)

```ts
/**
 * .what = adapter that translates rhachet hook operations to brain-specific format
 * .why = enables rhachet to support multiple brain repls via supplier packages
 */
export interface BrainHooksAdapter {
  slug: string;
  dao: BrainHooksAdapterDao;
}
```

---

## domain.operations

### discoverBrainPackages

```ts
/**
 * .what = scans package.json for rhachet-brains-* packages
 * .why = enables implicit discovery of brain supplier packages
 */
export const discoverBrainPackages = async (input: {
  from: string;
}): Promise<string[]>
```

mirrors prior `discoverRolePackages` pattern.

### getBrainHooksAdapterByConfigImplicit

```ts
/**
 * .what = discovers adapter for a brain slug from installed packages
 * .why = enables adapter resolution without explicit config
 *
 * algorithm:
 * 1. scan package.json for rhachet-brains-* packages
 * 2. for each, import and call getBrainHooks({ slug })
 * 3. return adapter if exactly one matches
 * 4. return null if none match
 * 5. throw if multiple match (ambiguous)
 */
export const getBrainHooksAdapterByConfigImplicit = async (input: {
  slug: string;
  from: string;
}): Promise<BrainHooksAdapter | null>
```

### detectBrainReplsInRepo

```ts
/**
 * .what = detects brain repls by allowlisted config files
 * .why = enables auto-detection when --hooks flag has no args
 *
 * allowlist:
 * - .claude/settings.json → "claudecode"
 * - .opencode/ directory → "opencode"
 */
export const detectBrainReplsInRepo = async (input: {
  from: string;
}): Promise<string[]>
```

### syncRoleHooksIntoBrainRepl

```ts
/**
 * .what = declarative sync of role hooks into brain config
 * .why = reconciles declared hooks to actual state
 *
 * algorithm:
 * 1. read Role.hooks.onBrain declarations
 * 2. get hooks found for role author namespace
 * 3. compute diff (add, retain, remove)
 * 4. apply set.upsert for declared hooks
 * 5. apply del for hooks no longer declared
 */
export const syncRoleHooksIntoBrainRepl = async (input: {
  role: Role;
  registry: RoleRegistry;
  adapter: BrainHooksAdapter;
}): Promise<void>
```

### applyRoleHooksToDetectedBrains

```ts
/**
 * .what = applies role hooks to detected or specified brains
 * .why = orchestrates hook sync for CLI command
 */
export const applyRoleHooksToDetectedBrains = async (input: {
  roles: Array<{ role: RoleManifest; registry: RoleRegistryManifest }>;
  brains?: BrainSpecifier[];
  from: string;
}): Promise<{
  applied: Array<{ role: string; brain: string }>;
  errors: Array<{ role: string; brain: string; error: Error }>;
}> => {
  // resolve slugs: explicit or auto-detect
  const slugs = input.brains ?? await detectBrainReplsInRepo({ from: input.from });

  // resolve adapters for each slug
  const adapters: BrainHooksAdapter[] = [];
  for (const slug of slugs) {
    const adapter = await getBrainHooksAdapterByConfigImplicit({ slug, from: input.from });
    if (!adapter) throw new BadRequestError(`no adapter found for brain slug: ${slug}`);
    adapters.push(adapter);
  }

  // sync each role × adapter
  const applied: Array<{ role: string; brain: string }> = [];
  const errors: Array<{ role: string; brain: string; error: Error }> = [];

  for (const { role, registry } of input.roles) {
    for (const adapter of adapters) {
      try {
        await syncRoleHooksIntoBrainRepl({ role, registry, adapter });
        applied.push({ role: role.slug, brain: adapter.slug });
      } catch (error) {
        if (!(error instanceof Error)) throw error;
        errors.push({ role: role.slug, brain: adapter.slug, error });
      }
    }
  }

  return { applied, errors };
};
```

---

## supplier packages

### rhachet-brains-anthropic (collocated)

```
src/_topublish/rhachet-brains-anthropic/
  src/
    index.ts                 # re-exports from hooks/
    hooks/
      getBrainHooks.ts       # returns BrainHooksAdapter | null for slug
      claudeCodeAdapter.ts   # implements BrainHooksAdapter
      translateHook.ts       # rhachet hook → claude-code format
      config.dao.ts          # read/write .claude/settings.json (preserve non-hooks)
```

exports:

```ts
/**
 * .what = provides BrainHooksAdapter for claude-code
 * .why = brain supplier contract for rhachet implicit discovery
 */
export const getBrainHooks = (input: {
  slug: string;
}): BrainHooksAdapter | null => {
  if (input.slug === 'claudecode') return claudeCodeAdapter;
  if (input.slug === 'anthropic/claude/code') return claudeCodeAdapter; // alias
  return null;
};
```

### rhachet-brains-opencode (collocated)

```
src/_topublish/rhachet-brains-opencode/
  src/
    index.ts                 # re-exports from hooks/
    hooks/
      getBrainHooks.ts       # returns BrainHooksAdapter | null for slug
      openCodeAdapter.ts     # implements BrainHooksAdapter
      plugin.dao.ts          # read/write .opencode/plugin/rhachet-hooks.ts
```

exports:

```ts
/**
 * .what = provides BrainHooksAdapter for opencode
 * .why = brain supplier contract for rhachet implicit discovery
 */
export const getBrainHooks = (input: {
  slug: string;
}): BrainHooksAdapter | null => {
  if (input.slug === 'opencode') return openCodeAdapter;
  if (input.slug === 'anomaly/opencode') return openCodeAdapter; // alias
  return null;
};
```

---

## cli integration

### invokeInit (extended)

```ts
program
  .command('init')
  .option('--roles <roles...>', 'role specifiers to initialize')
  .option('--hooks [slugs...]', 'brain slugs to bind hooks (auto-detect if no args)')
  .action(async (options) => {
    // prior behavior: link + init roles
    if (options.roles?.length) {
      await initRolesFromPackages({ specifiers: options.roles, from: cwd });
    }

    // NEW: bind hooks if --hooks flag present
    if (options.hooks !== undefined) {
      const linkedRoles = await getLinkedRoles({ from: cwd });
      const brains = options.hooks?.length ? options.hooks : undefined;

      await applyRoleHooksToDetectedBrains({
        roles: linkedRoles,
        brains,
        from: cwd,
      });
    }
  });
```

---

## event map

### rhachet → claude-code

| rhachet event   | claude-code event | notes                             |
| --------------- | ----------------- | --------------------------------- |
| onBoot          | SessionStart      | fires on session start/compaction |
| onTool (before) | PreToolUse        | requires filter                   |
| onTool (after)  | PostToolUse       | requires filter                   |
| onStop          | Stop              | fires when claude finishes        |

### rhachet → opencode

| rhachet event   | opencode event(s)                   | notes                                 |
| --------------- | ----------------------------------- | ------------------------------------- |
| onBoot          | session.created + session.compacted | fires on session start AND compaction |
| onTool (before) | tool.execute.before                 | plugin hook                           |
| onTool (after)  | tool.execute.after                  | plugin hook                           |
| onStop          | session.idle                        | plugin event listener                 |

---

## unique references

### BrainHook.unique

```ts
// unique key for hook identity
{
  author: 'repo=ehmpathy/role=mechanic',
  event: 'onTool',
  command: 'npm run lint:fix',
}

// updatable properties (not part of identity)
{
  filter: { what: 'Write|Edit', when: 'after' },
  timeout: 'PT30S',
}
```

hooks are unique by: author × event × command

this enables:
- namespace isolation (different authors can have same command)
- idempotent operations (same hook declaration produces same identity)
- filter/timeout updates to same hook (no new hook created)
- declarative sync (can detect when hook removed from declaration)

---

## test coverage

### unit tests

| operation                            | test                    |
| ------------------------------------ | ----------------------- |
| discoverBrainPackages                | package.json scan       |
| getBrainHooksAdapterByConfigImplicit | adapter discovery logic |
| detectBrainReplsInRepo               | config file detection   |
| translateHook                        | rhachet → brain format  |

### integration tests

| operation                  | test                                  |
| -------------------------- | ------------------------------------- |
| BrainHooksAdapter.dao.*    | each DAO method on real config files  |
| syncRoleHooksIntoBrainRepl | full sync cycle with snapshots        |
| claudeCodeAdapter          | snapshot .claude/settings.json output |

### acceptance tests

| command                              | test                              |
| ------------------------------------ | --------------------------------- |
| `init --roles <role>`                | no hooks applied (prior behavior) |
| `init --roles <role> --hooks`        | auto-detect + apply               |
| `init --roles <role> --hooks <slug>` | explicit + apply                  |
| `init --hooks`                       | apply to linked roles             |
| `init --hooks <unknown>`             | error with available slugs        |

---

## citations

[1] `.behavior/v2026_01_09.hook-adapter/0.wish.md` — original wish

[2] `.behavior/v2026_01_09.hook-adapter/2.criteria.blackbox.md` — blackbox usecases

[3] `.behavior/v2026_01_09.hook-adapter/2.criteria.blueprint.md` — blueprint contracts

[4] `.behavior/v2026_01_09.hook-adapter/3.1.research.domain._.v1.i1.md` — domain model research

[5] `.behavior/v2026_01_09.hook-adapter/3.1.research.access._.v1.i1.md` — access patterns research

[6] `.behavior/v2026_01_09.hook-adapter/3.1.research.patterns._.code.prod.v1.i1.md` — production code patterns

[7] `.behavior/v2026_01_09.hook-adapter/3.1.research.patterns._.code.test.v1.i1.md` — test code patterns

[8] `.agent/repo=.this/role=any/briefs/define.term.adapters.md` — adapter concept definition

[9] `.agent/repo=.this/role=any/briefs/define.term.suppliers.md` — supplier concept definition

[10] `.agent/repo=ehmpathy/role=mechanic/briefs/practices/code.prod/readable.persistence/rule.prefer.declastruct.[demo].md` — declastruct pattern reference
