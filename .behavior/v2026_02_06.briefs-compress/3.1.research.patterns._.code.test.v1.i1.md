# research: test codepath patterns for briefs compression

## pattern 1: acceptance test structure — `roles.boot.acceptance.test.ts`

**path:** `accept.blackbox/cli/roles.boot.acceptance.test.ts`

[REUSE] test structure pattern (given/when/then + useBeforeAll)
[EXTEND] add cases for `.comp` preference and orphan failfast

### current pattern

```typescript
given('[case1] repo with briefs', () => {
  const repo = useBeforeAll(async () =>
    genTestTempRepo({ fixture: 'with-briefs' }),
  );

  when('[t0] roles boot --repo this --role any', () => {
    const result = useBeforeAll(async () =>
      invokeRhachetCliBinary({
        args: ['roles', 'boot', '--repo', 'this', '--role', 'any'],
        cwd: repo.path,
      }),
    );

    then('exits with status 0', () => {
      expect(result.status).toEqual(0);
    });

    then('outputs brief content', () => {
      expect(result.stdout).toContain('sample brief');
    });
  });
});
```

### blocklist test pattern (case 4)

```typescript
given('[case4] repo with .scratch and .archive directories', () => {
  const repo = useBeforeAll(async () =>
    genTestTempRepo({ fixture: 'with-scratch-archive' }),
  );

  when('[t0] roles boot --repo .this --role any', () => {
    then('includes the normal brief', () => {
      expect(result.stdout).toContain('included.brief.md');
    });

    then('excludes briefs in .scratch directory', () => {
      expect(result.stdout).not.toContain('excluded.scratch.md');
    });

    then('excludes briefs in .archive directory', () => {
      expect(result.stdout).not.toContain('excluded.archive.md');
    });

    then('reports correct brief count (1, not 3)', () => {
      expect(result.stdout).toContain('briefs = 1');
    });
  });
});
```

### key observations

- acceptance tests invoke the binary as a subprocess via `invokeRhachetCliBinary`
- assert on stdout content (brief tags, stats, content)
- assert on exit status
- one fixture per given block via `genTestTempRepo`

---

## pattern 2: test fixture factory — `genTestTempRepo.ts`

**path:** `accept.blackbox/.test/infra/genTestTempRepo.ts`

[EXTEND] add new fixture types for compression scenarios

### current signature

```typescript
export type TestRepoFixture =
  | 'minimal'
  | 'with-skills'
  | 'with-briefs'
  | 'with-registry'
  | 'with-inits'
  | 'with-scratch-archive'
  | ... // 20+ fixture types
  ;

export const genTestTempRepo = (input: {
  fixture: TestRepoFixture;
  suffix?: string;
  install?: boolean;
}): { path: string }
```

### implementation pattern

```typescript
// 1. create unique temp dir in os.tmpdir()
const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${suffix}`);

// 2. copy fixture assets
cpSync(fixturePath, repoPath, { recursive: true });

// 3. make .sh files executable
setSkillsExecutable({ dir: repoPath });

// 4. init git repo (required for rhachet)
execSync('git init', { cwd: repoPath, stdio: 'ignore' });

// 5. optional: run bun install
if (input.install) execSync('bun install', { cwd: repoPath });
```

### key observations

- fixtures are static file trees in `accept.blackbox/.test/assets/`
- copied to `os.tmpdir()` — isolated, OS handles cleanup
- git init is required (rhachet expects git repo)
- new fixtures for compression = new directories in `.test/assets/`

---

## pattern 3: cli binary invocation — `invokeRhachetCliBinary.ts`

**path:** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts`

[REUSE] as-is

### current signature

```typescript
export const invokeRhachetCliBinary = (input: {
  binary?: 'rhachet' | 'rhx';
  args: string[];
  cwd: string;
  stdin?: string;
  logOnError?: boolean;
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string>
```

### key observations

- uses `spawnSync` with `'utf-8'` encode
- returns `{ status, stdout, stderr }` — standard subprocess result
- auto-logs on failure unless `logOnError: false`
- resolves binary from `../../../bin/run`

---

## pattern 4: fixture — `with-scratch-archive/`

**path:** `accept.blackbox/.test/assets/with-scratch-archive/`

[REUSE] as reference pattern for new compression fixture
[EXTEND] create new fixtures for `.comp` scenarios

### current structure

```
with-scratch-archive/
  .agent/repo=.this/role=any/
    briefs/
      included.brief.md          ← loaded
      .scratch/excluded.scratch.md    ← excluded by blocklist
      .archive/excluded.archive.md    ← excluded by blocklist
    readme.md
  rhachet.use.ts
```

### key observations

- one "included" file + two "excluded" files in blocklisted dirs
- test asserts: included content present, excluded content absent, correct count
- same pattern applies to new compression fixtures

---

## pattern 5: fixture — `with-briefs/`

**path:** `accept.blackbox/.test/assets/with-briefs/`

[REUSE] as baseline comparison for compression tests

### current structure

```
with-briefs/
  .agent/repo=.this/role=any/
    briefs/sample.md
    readme.md
  rhachet.use.ts
```

### content of `sample.md`

```markdown
# sample brief

this is a sample brief for testing.

## .what
a test brief

## .why
validates brief discovery in acceptance tests
```

---

## pattern 6: unit tests — `getAllFilesFromDir.test.ts`

**path:** `src/infra/filesystem/getAllFilesFromDir.test.ts`

[REUSE] — no changes needed

### key test cases

```typescript
given('directory does not exist', () => {
  then('returns empty array', () => {
    const result = getAllFilesFromDir(resolve(testDir, 'nonexistent'));
    expect(result).toEqual([]);
  });
});

given('directory with nested subdirectories', () => {
  then('recursively finds all files', () => {
    const result = getAllFilesFromDir(resolve(testDir, 'nested'));
    expect(result).toHaveLength(3);
  });
});

given('directory with broken symlink', () => {
  then('skips broken symlink without error', () => {
    expect(() => getAllFilesFromDir(resolve(testDir, 'broken-symlink'))).not.toThrow();
  });
});
```

---

## pattern 7: integration test — `invokeRolesBoot.integration.test.ts`

**path:** `src/contract/cli/invokeRolesBoot.integration.test.ts`

[REUSE] test pattern
[EXTEND] add cases for `.comp` preference at integration level

### current pattern

```typescript
// direct Commander.js test with console.log spy
const rolesCommand = new Command('roles');
const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

invokeRolesBoot({ command: rolesCommand });

when('invoked with "boot --repo test --role mechanic"', () => {
  then('prints all briefs and skills with stats', async () => {
    await rolesCommand.parseAsync(
      ['boot', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );
    expect(logSpy).toHaveBeenCalledWith('<stats>');
    expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('briefs = 2'));
  });
});
```

---

## pattern 8: repo introspect acceptance test

**path:** `accept.blackbox/cli/repo.introspect.acceptance.test.ts`

[EXTEND] add orphan `.comp` validation test case

### key observations

- tests `rhachet repo introspect` command
- validates YAML output format
- validates error paths for broken packages
- uses `genTestTempRepo` with package-based fixtures

---

## pattern 9: performance test pattern

**path:** `accept.blackbox/cli/roles.boot.performance.collocated.acceptance.test.ts`

[REUSE] — useful to verify compression doesn't degrade boot speed

### current pattern

```typescript
given.runIf(RUN_PERF_TEST)('[case1] repo with collocated perf-role', () => {
  when('[t0] roles boot --repo .this --role perf-role', () => {
    let avgMs: number;
    beforeAll(() => {
      avgMs = measureAverageMs({
        runs: 30,
        fn: () => spawnSync(RHACHET_BIN, ['roles', 'boot', ...], { cwd: repo.path }),
      });
    });

    then('total execution time averages under 250ms across 30 runs', () => {
      expect(avgMs).toBeLessThan(250);
    });
  });
});
```

---

## summary

| pattern | path | action | rationale |
|---------|------|--------|-----------|
| acceptance test structure | `roles.boot.acceptance.test.ts` | [EXTEND] | add `.comp` preference + orphan failfast cases |
| fixture factory | `genTestTempRepo.ts` | [EXTEND] | add new fixture types for compression |
| cli binary invocation | `invokeRhachetCliBinary.ts` | [REUSE] | works as-is |
| fixture: with-scratch-archive | `.test/assets/with-scratch-archive/` | [REUSE] | reference pattern for new fixtures |
| fixture: with-briefs | `.test/assets/with-briefs/` | [REUSE] | baseline for comparison |
| unit test: getAllFilesFromDir | `getAllFilesFromDir.test.ts` | [REUSE] | no changes needed |
| integration test: boot | `invokeRolesBoot.integration.test.ts` | [EXTEND] | add `.comp` cases |
| acceptance test: introspect | `repo.introspect.acceptance.test.ts` | [EXTEND] | add orphan validation case |
| performance test | `roles.boot.performance...test.ts` | [REUSE] | verify no speed regression |

### new fixtures needed

| fixture name | purpose | structure |
|--------------|---------|-----------|
| `with-comp-briefs` | test `.comp` preference on boot | `briefs/sample.md` + `briefs/sample.md.comp` |
| `with-orphan-comp` | test orphan `.comp` failfast | `briefs/orphan.md.comp` (no `.md` source) |
| `with-mixed-comp` | test mixed: some briefs have `.comp`, some don't | `briefs/compressed.md` + `.md.comp` + `briefs/plain.md` |

### key architectural insight

all test infra is already in place. the work is:
1. create 2-3 new fixture directories in `.test/assets/`
2. add new `given` blocks to `roles.boot.acceptance.test.ts`
3. add new `given` block to `repo.introspect.acceptance.test.ts`
4. add unit tests for the new `.comp` preference logic (new file)
