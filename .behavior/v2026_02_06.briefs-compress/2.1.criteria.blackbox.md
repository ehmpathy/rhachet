# blackbox criteria: briefs compression

## usecase.1 = boot prefers compressed briefs

given('a role with briefs directory that contains both `.md` and `.md.min` files')
  when('`roles boot` is invoked for that role')
    then('briefs with a `.md.min` counterpart are loaded from the `.min` file')
      sothat('robots receive machine-optimized content with fewer tokens')
    then('briefs without a `.md.min` counterpart are loaded from the `.md` file')
      sothat('backwards compatibility is preserved for uncompressed briefs')
    then('boot output uses `<brief path="...">` tags with the `.md` path (not `.min`)')
      sothat('the brief identity is stable regardless of compression state')
    then('total token count in boot output is lower than all-`.md` boot')
      sothat('context window space is reclaimed for actual work')

given('a role with briefs directory that contains only `.md` files (no `.min` files)')
  when('`roles boot` is invoked for that role')
    then('all briefs are loaded from `.md` files as before')
      sothat('zero breakage for roles that have not adopted compression')

## usecase.2 = orphan `.min` failfast

given('a briefs directory that contains `foo.md.min` but no `foo.md`')
  when('`roles boot` is invoked')
    then('boot fails fast with an error that names the orphan `.min` file')
      sothat('derived artifacts without source are caught at boot time')

given('a briefs directory that contains `foo.md.min` but no `foo.md`')
  when('`rhachet repo introspect` is invoked')
    then('introspect fails fast with an error that names the orphan `.min` file')
      sothat('role authors catch orphan artifacts at build time before distribution')

## usecase.3 = compress briefs

given('a role with `.md` briefs')
  when('`rhachet briefs compress` is invoked for that role')
    then('a `.md.min` file is produced alongside each `.md` brief')
      sothat('compressed variants are co-located with their source')
    then('the `.md.min` content preserves all rules, enforcement levels, and code examples')
      sothat('robot comprehension is not degraded by compression')
    then('the `.md.min` content uses fewer tokens than the `.md` source')
      sothat('the compression provides measurable token reduction')
    then('the `.md` source files are not modified')
      sothat('human-readable source is preserved as-is')

given('a role with `.md` briefs where some already have `.md.min` counterparts')
  when('`rhachet briefs compress` is invoked')
    then('all `.md.min` files are regenerated from their `.md` source')
      sothat('stale compressed files are updated to match current source')

## usecase.4 = blocklist exclusion applies to `.min` files

given('a briefs directory with `.scratch/foo.md.min` and `.archive/bar.md.min`')
  when('`roles boot` is invoked')
    then('files in `.scratch/` and `.archive/` are excluded, both `.md` and `.min` variants')
      sothat('blocklist behavior is consistent across both file extensions')

## usecase.5 = stats reflect compressed load

given('a role where some briefs load from `.min` and some from `.md`')
  when('`roles boot` is invoked')
    then('the `<stats>` output reflects the actual tokens loaded (compressed where available)')
      sothat('the human can observe the token impact of compression')
