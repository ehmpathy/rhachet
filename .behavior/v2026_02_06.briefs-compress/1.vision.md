# vision: briefs compression

## the outcome world

### before

a robot boots with `npx rhachet roles boot --repo ehmpathy --role mechanic`. 92 briefs load at ~50k tokens. that's 25% of a 200k context window consumed before the first message. every session pays this tax. the briefs are written for humans — full prose, examples with verbose explanations, demos with full transcripts, package READMEs with install sections the robot will never use.

the human who authored those briefs optimized for human readability. the robot who consumes them pays the token cost of that readability every session, thousands of times.

### after

same boot command. same briefs directory. but now the loader sees `rule.require.input-context-pattern.md.min` alongside `rule.require.input-context-pattern.md` — and loads the `.min` variant. 92 briefs compress to ~25k tokens. the robot gets the same signal, same rules, same enforcement levels. the context window reclaims ~25k tokens for actual work.

the human still reads and edits `.md` files. the robot gets `.md.min` files — telegraphic, dense, machine-optimized. same knowledge, half the tokens.

### the "aha" moment

> "the briefs say the same rules... but in half the space. the robot follows them just as well. we just freed up 25k tokens for actual work every single session."

it clicks when you realize: LLMs don't need articles, prepositions, or verbose examples to understand a rule. they need the signal. compression strips the noise.

## user experience

### usecase 1: role author compresses briefs for distribution

a role author maintains `rhachet-roles-ehmpathy`. they write briefs in `.md` — full prose, examples, demos. then they run:

```sh
npx rhachet briefs compress --repo ehmpathy --role mechanic
```

for each brief `foo.md`, a `foo.md.min` is produced alongside it. the `.min` file is committed. both travel together.

**input:** `.md` briefs in `briefs/` directory
**output:** `.md.min` files alongside each `.md` source
**timeline:** one-time per brief edit, at author's discretion

### usecase 2: robot boots with compressed briefs

a robot starts a session. `roles boot` discovers briefs:

1. scan `briefs/` directory recursively
2. for each file, check: does a `.min` counterpart exist?
3. if yes → load the `.min`, skip the `.md`
4. if no → load the `.md` as-is (backwards compatible)

the robot never sees the difference. the loader handles it. the output is the same `<brief path="...">` xml tags, just with denser content.

**input:** `roles boot --repo X --role Y`
**output:** same boot format, fewer tokens
**timeline:** every session, automatic

### usecase 3: human inspects what the robot sees

a human wants to verify what the robot gets:

```sh
# see the compressed version
cat .agent/repo=ehmpathy/role=mechanic/briefs/practices/code.prod/rule.require.arrow-only.md.min

# see the source version
cat .agent/repo=ehmpathy/role=mechanic/briefs/practices/code.prod/rule.require.arrow-only.md
```

both live side-by-side. full transparency. the `.min` is still english-ish — telegraphic, not encrypted.

### usecase 4: human edits a brief, regenerates compression

the human edits `rule.require.arrow-only.md`. the `.min` is now stale. they regenerate:

```sh
npx rhachet briefs compress --repo ehmpathy --role mechanic
```

all `.min` files update. commit both.

## mental model

### how a human would describe it to a friend

> "you know how javascript has `.min.js` — the minified version that browsers load instead of the readable source? we do that for AI briefs. the human writes readable markdown, the robot loads a compressed version that has the same rules but fewer tokens."

### analogy: `.js` → `.min.js`

| concept | javascript | briefs |
|---------|-----------|--------|
| source | `app.js` | `rule.require.arrow-only.md` |
| compressed | `app.min.js` | `rule.require.arrow-only.md.min` |
| who reads source | developers | humans |
| who reads compressed | browsers | robots |
| what's removed | whitespace, comments, long names | articles, filler, verbose examples |
| what's preserved | behavior | rules, enforcement, signal |

### terms

| our term | what it means |
|----------|---------------|
| `.md` | human-readable brief source |
| `.md.min` | machine-optimized compressed brief |
| `briefs compress` | command to generate `.min` from `.md` |
| TSC | telegraphic semantic compression — the technique |

## evaluation

### how well does it solve the goals?

| goal | score | notes |
|------|-------|-------|
| reduce brief token overhead | strong | ~40-50% reduction on 50k+ baseline = ~25k tokens recovered |
| preserve robot comprehension | strong | TSC removes predictable words LLMs reconstruct from context |
| preserve human authorship | strong | humans edit `.md`, never touch `.min` |
| zero runtime cost | strong | compression at build/author time, not boot time |
| backwards compatible | strong | no `.min` = load `.md` as before |

### pros

- massive token saves compound across thousands of sessions
- no behavioral degradation — robots understand telegraphic english
- human workflow unchanged — edit `.md`, regenerate `.min`
- transparent — both files live side-by-side, auditable
- incremental adoption — compress one brief or all, loader handles both
- `.min` is still human-auditable (unlike binary compression)

### cons

- two files per brief to maintain (`.md` + `.md.min`)
- `.min` can go stale if human edits `.md` and forgets to regenerate
- compression quality depends on the compressor (deterministic transforms vs LLM)
- adds a build step to the brief authorship workflow

### edgecases and pit of success

| edgecase | how contracts keep users safe |
|----------|-------------------------------|
| `.min` exists but `.md` was deleted | failfast on both `roles boot` and `rhachet repo introspect` — orphan `.min` without source `.md` is a defect. `.min` is derived; source must exist. |
| `.md` exists but no `.min` | loader loads `.md` — full backwards compat, zero breakage |
| `.min` is stale (older than `.md`) | loader still loads `.min`. staleness is an author concern, not a runtime concern. lint or ci can warn. |
| brief has no compressible content (already terse) | `.min` ≈ `.md` in size — harmless, consistent treatment |
| nested `.md.min` in subdirectories | loader already recurses — extension check works at any depth |
| `.min` file in `.scratch/` or `.archive/` | blocklist still applies — `.scratch/foo.md.min` is excluded |

### what's awkward

1. **staleness detection** — no built-in way to know if `.min` is outdated relative to `.md`. a ci check or pre-commit hook could solve this, but it's an extra concern.

2. **compression fidelity** — who validates that the `.min` preserves the rule's intent? human review of diffs is the initial answer, but a quality gate (e.g., LLM comparison test) could automate this later.

3. **file extension choice** — `.md.min` vs `.comp.md` vs `.cmp`. `.md.min` reads as "this is a compressed .md" which feels right. but it's a new convention — not a standard extension.
