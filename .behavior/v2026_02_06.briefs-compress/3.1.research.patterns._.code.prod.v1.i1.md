# research: prod codepath patterns for briefs compression

## pattern 1: boot brief discovery — `bootRoleResources.ts`

**path:** `src/domain.operations/invoke/bootRoleResources.ts`

[REUSE] directory resolution, blocklist, tag output format
[EXTEND] brief file filter to prefer `.md.comp` over `.md`
[EXTEND] orphan `.comp` detection with failfast

### current logic

```typescript
// [1] resolve role directory
const roleDir = resolve(process.cwd(), '.agent', `repo=${slugRepo}`, `role=${slugRole}`);
const briefsDir = resolve(roleDir, 'briefs');
const skillsDir = resolve(roleDir, 'skills');
const readmePath = resolve(roleDir, 'readme.md');

// [2] discover all files recursively
const allFiles = getAllFilesFromDir(roleDir).sort();

// [3] filter by directory path + blocklist (NO extension filter)
const blocklist = ['.scratch', '.archive'];
const briefFiles = allFiles
  .filter((f) => f.startsWith(briefsDir))
  .filter((f) => !blocklist.some((dir) => f.includes(`/${dir}/`)));

// [4] read content directly
const content = readFileSync(filepath, 'utf-8');

// [5] format as xml tag with relative path
const relativePath = `.agent/repo=${slugRepo}/role=${slugRole}/${relative(roleDir, filepath)}`;
const tagName = isSkill ? 'skill' : isReadme ? 'readme' : 'brief';
console.log(`<${tagName} path="${relativePath}">`);
console.log(content);
console.log(`</${tagName}>`);
```

### key observations

- **no extension filter** — all files under `briefs/` are loaded, regardless of extension
- **blocklist is directory-based** — filters paths that contain `/.scratch/` or `/.archive/`
- **tag path uses relative path** — `.agent/repo=$repo/role=$role/briefs/...`
- **content is raw readFileSync** — no transform, no preference logic

### extension point for compression

between step [3] (filter) and step [4] (read), insert:
- for each brief file, check if a `.comp` counterpart exists
- if `.comp` exists and `.md` source exists → load `.comp`, use `.md` path for tag
- if `.comp` exists but `.md` source absent → failfast (orphan)
- if no `.comp` → load `.md` as-is

---

## pattern 2: file traversal — `getAllFilesFromDir.ts`

**path:** `src/infra/filesystem/getAllFilesFromDir.ts`

[REUSE] as-is — no changes needed

### current logic

```typescript
export const getAllFilesFromDir = (dir: string): string[] => {
  if (!existsSync(dir)) return [];
  const entries = readdirSync(dir);
  const files: string[] = [];
  for (const entry of entries) {
    const fullPath = resolve(dir, entry);
    let stats: ReturnType<typeof statSync>;
    try {
      stats = statSync(fullPath);
    } catch (error: unknown) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') continue; // broken symlink
      throw error;
    }
    if (stats.isDirectory()) files.push(...getAllFilesFromDir(fullPath));
    else if (stats.isFile()) files.push(fullPath);
  }
  return files;
};
```

### key observations

- returns ALL files — `.md`, `.md.comp`, `.src`, all of them
- the `.comp` files will already be discovered by this utility
- no changes needed here — the consumer handles the filter

---

## pattern 3: repo introspect — `invokeRepoIntrospect.ts`

**path:** `src/contract/cli/invokeRepoIntrospect.ts`

[EXTEND] add orphan `.comp` validation

### current logic

- loads `getRoleRegistry()` from the package entry point
- generates `rhachet.repo.yml` manifest with role metadata (slug, briefs dirs, skills dirs)
- does NOT read brief content — only enumerates paths

### extension point

after manifest generation, scan each role's briefs directory:
- for every `.md.comp` file, verify a matched `.md` source exists
- failfast with error if orphan `.comp` detected

---

## pattern 4: role file costs — `getRoleFileCosts.ts`

**path:** `src/domain.operations/role/getRoleFileCosts.ts`

[EXTEND] cost calculation should reflect compressed content when `.comp` is loaded

### current logic

```typescript
const fileCosts: FileCost[] = allFiles.map((filepath) => {
  const isSkill = filepath.startsWith(skillsDir);
  const isBrief = filepath.startsWith(briefsDir);
  const contentToCount = isSkill
    ? extractSkillDocumentation(filepath)
    : readFileSync(filepath, 'utf-8');
  const chars = contentToCount.length;
  const tokens = Math.ceil(chars / 4);
  const cost = (tokens / 1_000_000) * costPerMillionTokens;
  const type: FileCost['type'] = isSkill ? 'skill' : isBrief ? 'brief' : 'other';
```

### key observations

- same file discovery as boot — reuses `getAllFilesFromDir`
- same blocklist pattern
- cost reflects raw file content — should reflect what boot actually loads

---

## pattern 5: sdk brief access — `getRoleBriefs.ts`

**path:** `src/domain.operations/role/getRoleBriefs.ts`

[REUSE] — sdk consumers get raw briefs, compression is a boot/cli concern

### current logic

```typescript
export const getRoleBriefs = async (input: {
  by: {
    role: { name: string };
    repo?: { name: string };
    briefs: { name?: string[]; glob?: string };
  };
}): Promise<Artifact<typeof GitFile>[]>
```

- uses `fast-glob` for name/glob pattern match
- returns `Artifact<typeof GitFile>[]` — the actual file artifacts
- no extension filter

### key observation

sdk consumers import briefs programmatically for use in skills/weaves. they may want the full `.md` or the `.comp` — this is a separate concern from boot. for now, [REUSE] as-is. compression preference is a boot-path concern.

---

## pattern 6: cli command registration

**path:** `src/contract/cli/invokeRolesBoot.ts`

[REUSE] — no changes to cli interface

```typescript
command
  .command('boot')
  .description('boot context from role resources (briefs and skills)')
  .option('--repo <slug>', 'the repository slug for the role')
  .option('--role <slug>', 'the role to boot resources for')
  .option('--if-present', 'exit silently if role directory does not exist')
```

no new cli flags needed for compression — the preference is automatic.

---

## pattern 7: blocklist — hardcoded constant

**path:** `src/domain.operations/invoke/bootRoleResources.ts` line 48

[REUSE] — no changes

```typescript
const blocklist = ['.scratch', '.archive'];
```

applied via: `.filter((f) => !blocklist.some((dir) => f.includes(`/${dir}/`)))`

---

## pattern 8: token estimation

**path:** `src/domain.operations/invoke/bootRoleResources.ts` line 85

[REUSE] — no changes

```typescript
const approxTokens = Math.ceil(totalChars / 4);
const costPerMillionTokens = 3;
```

this already counts chars of loaded content — if we load `.comp` content, the stats will automatically reflect the compressed size.

---

## summary

| pattern | path | action | rationale |
|---------|------|--------|-----------|
| boot brief discovery | `bootRoleResources.ts` | [EXTEND] | add `.comp` preference + orphan failfast |
| file traversal | `getAllFilesFromDir.ts` | [REUSE] | already discovers all files |
| repo introspect | `invokeRepoIntrospect.ts` | [EXTEND] | add orphan `.comp` validation |
| role file costs | `getRoleFileCosts.ts` | [EXTEND] | cost should reflect compressed load |
| sdk brief access | `getRoleBriefs.ts` | [REUSE] | sdk is a separate concern |
| cli registration | `invokeRolesBoot.ts` | [REUSE] | no new flags needed |
| blocklist | `bootRoleResources.ts` | [REUSE] | works as-is for both extensions |
| token estimation | `bootRoleResources.ts` | [REUSE] | auto-reflects loaded content |

### key architectural insight

the compression preference logic touches ONE primary codepath: `bootRoleResources.ts`, between file discovery (step 3) and content read (step 4). the orphan validation touches TWO codepaths: boot + introspect. the rest (traversal, blocklist, stats, tags, cli) works as-is.
