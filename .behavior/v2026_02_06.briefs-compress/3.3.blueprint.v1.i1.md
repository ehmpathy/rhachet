# blueprint: briefs compression

## filediff treestruct

```
src/
  domain.operations/
    invoke/
      [~] bootRoleResources.ts                          # add .min preference + orphan failfast
      [+] bootRoleResources.test.ts                     # unit tests for preference + orphan logic
    role/
      [~] getRoleFileCosts.ts                           # apply .min preference to cost calc
      [+] getRoleFileCosts.test.ts                      # unit tests for cost with .min files
    briefs/
      [+] getRoleBriefRefs.ts                               # extract .min preference logic
      [+] getRoleBriefRefs.test.ts                          # unit tests for preference resolution
      [+] assertZeroOrphanMinifiedBriefs.ts                      # orphan .min detection
      [+] assertZeroOrphanMinifiedBriefs.test.ts                 # unit tests for orphan detection
  contract/
    cli/
      [~] invokeRepoIntrospect.ts                       # add orphan .min validation after manifest gen
      [+] invokeRepoIntrospect.integration.test.ts      # integration test for orphan failfast on introspect
  infra/
    filesystem/
      [○] getAllFilesFromDir.ts                          # no changes — already discovers all files

accept.blackbox/
  .test/
    assets/
      [+] with-min-briefs/                             # fixture: .md + .md.min (preference test)
      [+] with-orphan-min/                             # fixture: .md.min without .md (failfast test)
      [+] with-mixed-min/                              # fixture: some briefs have .min, some not
    infra/
      [~] genTestTempRepo.ts                            # add 3 new fixture type names
  cli/
    [~] roles.boot.acceptance.test.ts                   # add .min preference + orphan failfast cases
    [~] repo.introspect.acceptance.test.ts              # add orphan .min validation case
```

## codepath treestruct

```
bootRoleResources(input)
  [○] resolve roleDir, briefsDir, skillsDir, readmePath
  [○] getAllFilesFromDir(roleDir).sort()
  [○] filter briefFiles by briefsDir prefix
  [○] filter by blocklist (.scratch, .archive)
  [+] getRoleBriefRefs({ briefFiles, briefsDir })       ← NEW: .min preference
  │   [+] for each .md file: check if .md.min counterpart exists
  │   [+] if .min exists → ref = { pathToOriginal: .md, pathToMinified: .md.min }
  │   [+] if no .min   → ref = { pathToOriginal: .md, pathToMinified: null }
  │   [+] if .min exists but .md absent → collect as orphan
  │   [+] return { refs: RoleBriefRef[], orphans: Omit<RoleBriefRef, 'pathToOriginal'>[] }
  [+] assertZeroOrphanMinifiedBriefs({ orphans })                  ← NEW: failfast
  │   [+] if orphans.length > 0 → throw error that names orphan files
  [○] filter skillFiles by skillsDir prefix
  [○] build relevantFiles array
  [○] calculate stats (totalChars)
  │   [~] read content from ref.pathToMinified ?? ref.pathToOriginal (was: filepath)
  [○] print stats header
  [○] for each file: print <brief/skill/readme> tag
  │   [~] use ref.pathToOriginal for tag path (was: filepath)
  │   [~] use ref.pathToMinified ?? ref.pathToOriginal for readFileSync (was: filepath)
  [○] print stats footer

getRoleBriefRefs(input)                                  ← NEW PROCEDURE
  [+] separate .md files from .md.min files
  [+] for each .md file:
  │   [+] check if .md.min counterpart exists in the file list
  │   [+] if yes → ref = { pathToOriginal: .md, pathToMinified: .md.min }
  │   [+] if no  → ref = { pathToOriginal: .md, pathToMinified: null }
  [+] for each .md.min file:
  │   [+] check if .md source exists in the file list
  │   [+] if no → add { pathToMinified: .md.min } to orphans list
  [+] return { refs, orphans }

assertZeroOrphanMinifiedBriefs(input)                              ← NEW PROCEDURE
  [+] if input.orphans.length === 0 → return (no-op)
  [+] throw HelpfulError with message that names each orphan

getRoleFileCosts(input)
  [○] resolve briefsDir, skillsDir
  [○] getAllFiles(roleDir).sort()
  [+] getRoleBriefRefs({ briefFiles, briefsDir })       ← REUSE from above
  [+] assertZeroOrphanMinifiedBriefs({ orphans })                  ← REUSE from above
  [~] map refs to FileCost[]
  │   [~] use ref.pathToMinified ?? ref.pathToOriginal for content read
  │   [~] use ref.pathToOriginal for relativePath
  [○] return fileCosts

invokeRepoIntrospect(input)
  [○] load getRoleRegistry, generate manifest
  [○] serialize and write rhachet.repo.yml
  [+] for each role in registry:
  │   [+] scan briefs directory for .min files
  │   [+] assertZeroOrphanMinifiedBriefs({ orphans })              ← REUSE from above
  │   [+] failfast if orphans detected
```

## domain decomposition

### new procedures

#### `getRoleBriefRefs`

```
path: src/domain.operations/role/briefs/getRoleBriefRefs.ts
```

```ts
/**
 * .what = resolves brief files with .md.min preference
 * .why = when a .md.min counterpart exists, the minified variant
 *        is preferred for content load while the .md path is kept as identity
 */
export const getRoleBriefRefs = (input: {
  briefFiles: string[];
  briefsDir: string;
}): {
  refs: RoleBriefRef[];
  orphans: Array<Omit<RoleBriefRef, 'pathToOriginal'>>;
}
```

where `RoleBriefRef` is:
```ts
interface RoleBriefRef {
  pathToOriginal: string;
  pathToMinified: string | null;
}
```

contract:
- `input.briefFiles` = all files under `briefsDir` (post-blocklist)
- `refs[].pathToOriginal` = always the `.md` path (stable identity for `<brief path="...">` tag)
- `refs[].pathToMinified` = the `.md.min` path when it exists, `null` otherwise
- `orphans` = `.md.min` files with no `.md` source — `{ pathToMinified: string }`

logic:
1. partition `briefFiles` into `.md` files and `.md.min` files
2. for each `.md` file → check if `${file}.min` counterpart exists
3. for each `.md.min` file → check if the `.md` source exists
4. return both refs list and orphans list

#### `assertZeroOrphanMinifiedBriefs`

```
path: src/domain.operations/role/briefs/assertZeroOrphanMinifiedBriefs.ts
```

```ts
/**
 * .what = failfast if orphan .md.min files are detected
 * .why = .md.min is derived from .md source — orphan .md.min without
 *        source .md is a defect that must be caught early
 */
export const assertZeroOrphanMinifiedBriefs = (input: {
  orphans: Array<Omit<RoleBriefRef, 'pathToOriginal'>>;
}): void
```

contract:
- if `orphans.length === 0` → no-op
- if `orphans.length > 0` → throw with message that names each orphan's `pathToMinified`
- error type: standard `Error` with clear message for both cli and programmatic consumers

### modified procedures

#### `bootRoleResources` (update)

insertion point: between line 53 (blocklist filter) and line 55 (build relevantFiles).

changes:
1. call `getRoleBriefRefs({ briefFiles, briefsDir })` on the filtered brief files
2. call `assertZeroOrphanMinifiedBriefs({ orphans })` to failfast on orphans
3. replace `briefFiles` in `relevantFiles` with `refs` (as `RoleBriefRef[]`)
4. in stats calc loop: use `ref.pathToMinified ?? ref.pathToOriginal` for `readFileSync`
5. in print loop: use `ref.pathToOriginal` for `relativePath`, `ref.pathToMinified ?? ref.pathToOriginal` for content

the `.md.min` files must also be excluded from the raw `briefFiles` list — they are handled via the preference map, not as standalone files.

#### `getRoleFileCosts` (update)

changes:
1. filter brief files from allFiles (same blocklist as boot)
2. call `getRoleBriefRefs` to resolve .md.min preference → `RoleBriefRef[]`
3. call `assertZeroOrphanMinifiedBriefs` to failfast on orphans
4. map `refs` to `FileCost[]`: use `ref.pathToMinified ?? ref.pathToOriginal` for content read, `ref.pathToOriginal` for `relativePath`

#### `invokeRepoIntrospect` (update)

insertion point: after manifest generation (line 89), before output.

changes:
1. for each role in `registry.roles`:
   - resolve the briefs directory path from the role's source directory
   - scan with `getAllFilesFromDir`, filter to briefs
   - call `getRoleBriefRefs` to detect orphans
   - call `assertZeroOrphanMinifiedBriefs` to failfast

## test coverage

### unit tests

#### `getRoleBriefRefs.test.ts`

| case | input | expected |
|------|-------|----------|
| all `.md`, no `.md.min` | `[a.md, b.md]` | refs: both with `pathToMinified: null`, orphans: `[]` |
| all `.md` with `.md.min` counterparts | `[a.md, a.md.min, b.md, b.md.min]` | refs: `pathToOriginal` = `.md`, `pathToMinified` = `.md.min`, orphans: `[]` |
| mixed: some with `.md.min`, some without | `[a.md, a.md.min, b.md]` | a has `pathToMinified`, b has `pathToMinified: null` |
| orphan `.md.min` | `[a.md.min]` | refs: `[]`, orphans: `[{ pathToMinified: a.md.min }]` |
| mixed with orphan | `[a.md, b.md.min]` | a in refs with `pathToMinified: null`, b in orphans |
| empty input | `[]` | refs: `[]`, orphans: `[]` |

#### `assertZeroOrphanMinifiedBriefs.test.ts`

| case | input | expected |
|------|-------|----------|
| no orphans | `{ orphans: [] }` | no throw |
| one orphan | `{ orphans: ['foo.md.min'] }` | throws error with "foo.md.min" in message |
| two orphans | `{ orphans: ['a.md.min', 'b.md.min'] }` | throws error with both names |

#### `bootRoleResources.test.ts`

| case | scenario | expected |
|------|----------|----------|
| `.md.min` preference | brief with `.md.min` counterpart | content loaded from `pathToMinified`, tag path uses `pathToOriginal` |
| fallback to `.md` | brief without `.md.min` | content loaded from `pathToOriginal`, tag path uses `pathToOriginal` |
| orphan failfast | `.md.min` without `.md` | throws error |
| stats reflect compressed | mixed `.md.min` and `.md` | token count reflects actual loaded content |

#### `getRoleFileCosts.test.ts`

| case | scenario | expected |
|------|----------|----------|
| cost with `.md.min` | brief has `.md.min` | cost reflects `pathToMinified` content length |
| cost without `.md.min` | brief has only `.md` | cost reflects `pathToOriginal` content length |

### acceptance tests

#### `roles.boot.acceptance.test.ts` (extend)

```
given('[caseN] repo with compressed briefs')
  when('[t0] roles boot --repo .this --role any')
    then('loads content from .min file')
    then('uses .md path in <brief> tag, not .min path')
    then('brief count reflects only .md files (not .min)')
    then('token count reflects compressed content')

given('[caseN+1] repo with orphan .min')
  when('[t0] roles boot --repo .this --role any')
    then('exits with non-zero status')
    then('stderr names the orphan file')

given('[caseN+2] repo with mixed compression')
  when('[t0] roles boot --repo .this --role any')
    then('loads .min content for briefs that have .min')
    then('loads .md content for briefs that lack .min')
    then('total token count is less than all-.md load')
```

#### `repo.introspect.acceptance.test.ts` (extend)

```
given('[caseN] roles package with orphan .min')
  when('[t0] rhachet repo introspect')
    then('exits with non-zero status')
    then('stderr names the orphan file')
```

### new fixture assets

#### `with-min-briefs/`

```
with-min-briefs/
  .agent/repo=.this/role=any/
    briefs/
      sample.md                 ← human-readable source (longer)
      sample.md.min            ← compressed variant (shorter)
    readme.md
  rhachet.use.ts
```

`sample.md` content: ~200 chars (verbose prose)
`sample.md.min` content: ~100 chars (telegraphic, same rules)

#### `with-orphan-min/`

```
with-orphan-min/
  .agent/repo=.this/role=any/
    briefs/
      orphan.md.min            ← no .md source — triggers failfast
    readme.md
  rhachet.use.ts
```

#### `with-mixed-min/`

```
with-mixed-min/
  .agent/repo=.this/role=any/
    briefs/
      compressed.md             ← has .min counterpart
      compressed.md.min        ← compressed variant
      plain.md                  ← no .md.min, loaded as-is
    readme.md
  rhachet.use.ts
```

## composition boundaries

```
invokeRolesBoot (cli contract)
  └── bootRoleResources (domain operation)
        ├── getAllFilesFromDir (infra — reuse)
        ├── getRoleBriefRefs (domain — new)
        ├── assertZeroOrphanMinifiedBriefs (domain — new)
        └── extractSkillDocumentation (domain — reuse)

invokeRolesCost (cli contract)
  └── getRoleFileCosts (domain operation)
        ├── getAllFilesFromDir (infra — reuse)
        ├── getRoleBriefRefs (domain — new, shared)
        ├── assertZeroOrphanMinifiedBriefs (domain — new, shared)
        └── extractSkillDocumentation (domain — reuse)

invokeRepoIntrospect (cli contract)
  ├── getRoleRegistry (external — reuse)
  ├── castIntoRoleRegistryManifest (domain — reuse)
  ├── getAllFilesFromDir (infra — reuse)
  ├── getRoleBriefRefs (domain — new, shared)
  └── assertZeroOrphanMinifiedBriefs (domain — new, shared)
```

the two new procedures (`getRoleBriefRefs`, `assertZeroOrphanMinifiedBriefs`) are shared across all three surfaces. the preference logic lives in one place; the failfast lives in one place. all consumers reuse the same codepath.

## key decisions

1. **`.min` files excluded from raw brief list** — they are not standalone briefs. they participate via the preference map only. this prevents double-count in stats and double-load in output.

2. **`RoleBriefRef` as domain object** — `getRoleBriefRefs` returns `RoleBriefRef[]` with `pathToOriginal` (always `.md`) and `pathToMinified` (`.md.min` or `null`). consumers use `ref.pathToMinified ?? ref.pathToOriginal` for content, `ref.pathToOriginal` for identity. this keeps the `<brief path="...">` tag stable regardless of compression state.

3. **orphan detection is eager** — all three surfaces (boot, cost, introspect) detect orphans before any content read. failfast at scan time, not at load time.

4. **no new cli flags** — compression preference is automatic. no `--compress` or `--prefer-min` flag. the loader handles it transparently.

5. **no extension filter added to `getAllFilesFromDir`** — the infra layer remains generic. the domain layer handles the `.min` preference semantics.
