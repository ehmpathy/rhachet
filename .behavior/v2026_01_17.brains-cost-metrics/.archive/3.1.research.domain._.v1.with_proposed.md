# research: domain for brain cost metrics

this document enumerates the domain objects, operations, relationships, and composition required to fulfill the brain cost metrics feature.

---

## domain objects

### entities

entities are objects with unique identity tracked over time.

#### BrainAtom (extant)

```ts
interface BrainAtom {
  repo: string;   // e.g., "anthropic"
  slug: string;   // e.g., "claude/opus"
  description: string;
  ask: <TOutput>(...) => Promise<TOutput>;
}
```

> [1] "entities are objects defined by their unique identities rather than by their attributes" — [enterprisecraftsmanship](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)

the `BrainAtom` is an entity because it has identity (`repo` + `slug`) and its state (the base model) can change over time (e.g., model updates, price changes).

#### BrainRepl (extant)

```ts
interface BrainRepl {
  repo: string;
  slug: string;
  description: string;
  ask: <TOutput>(...) => Promise<TOutput>;
  act: <TOutput>(...) => Promise<TOutput>;
}
```

same rationale as BrainAtom — identity via `repo` + `slug`.

---

### literals (value objects)

literals are immutable objects identified by their attributes, not identity.

> [2] "there are two main characteristics for value objects: they have no identity. they are immutable." — [martinfowler](https://www.martinfowler.com/bliki/ValueObject.html)

#### BrainUsage

the static cost & gain profile of a brain. immutable snapshot of a brain's capabilities and rates.

```ts
interface BrainUsage {
  cost: {
    time: {
      speed: { tokens: number; per: IsoDuration };
      latency: IsoDuration;
    };
    cash: {
      per: 'token';
      cache: { get: Price; set: Price };
      input: Price;
      output: Price;
    };
  };
  gain: {
    size: { context: { tokens: number } };
    grades: { swe?: number; mmlu?: number; humaneval?: number };
    cutoff: IsoDateStamp;
    domain: 'ALL' | 'SOFTWARE';
    skills: { tooluse?: boolean; vision?: boolean };
  };
}
```

**why literal**: the usage profile is a descriptive aspect with no identity. two brains with identical usage profiles are interchangeable for comparison purposes.

> [3] "an object that represents a descriptive aspect of the domain with no conceptual identity is called a value object" — [dev.to](https://dev.to/ielgohary/domain-driven-design-entities-value-objects-and-services-chapter-51-22cm)

#### BrainOutput<TOutput>

the result of any brain invocation. wraps output with metrics.

```ts
interface BrainOutput<TOutput> {
  output: TOutput;
  metrics: BrainOutputMetrics;
}
```

**why literal**: the output is an immutable snapshot of an invocation result. no lifecycle, no identity.

#### BrainOutputMetrics

size and cost measurements from an invocation.

```ts
interface BrainOutputMetrics {
  size: {
    input: { chars: number; tokens: number };
    output: { chars: number; tokens: number };
    cache: { get: { tokens: number }; set: { tokens: number } };
  };
  cost: {
    time: IsoDuration;
    cash: {
      input: Price;
      output: Price;
      cache: { get: Price; set: Price };
      total: Price;
    };
  };
}
```

**why literal**: purely descriptive. identified by its values.

#### Price

a monetary amount. immutable value object per fowler's money pattern.

```ts
type Price = { dollars: number };
// or serialized: '$0.003'
```

> [4] "instances of money are immutable and each arithmetic operation will return a new instance of the object" — [ts-money](https://github.com/macor161/ts-money)

> [5] "money behaves differently from a simple number, and thus should be treated differently. the first and most important aspect is that it should always be composed of an amount and a currency." — [frontstuff](https://frontstuff.io/how-to-handle-monetary-values-in-javascript)

**why literal**: money is a classic value object. `$5` equals `$5` regardless of which instance.

#### TokenCount

token measurements for input/output/cache.

```ts
interface TokenCount {
  input: number;
  output: number;
  cache?: { get: number; set: number };
}
```

**why literal**: purely numerical, no identity.

#### IsoDuration

an iso8601 duration string (e.g., `'PT4.2S'`).

```ts
type IsoDuration = string; // branded
```

**why literal**: standardized time representation, immutable.

#### IsoDateStamp

an iso8601 date string (e.g., `'2024-01-15'`).

```ts
type IsoDateStamp = string; // branded
```

**why literal**: standardized date representation, immutable.

---

### events

no domain events are required for this feature. the system is query-oriented (read usage, calculate cost) rather than event-driven.

future consideration: `BrainInvocationCompleted` event could be emitted for observability pipelines.

---

## domain operations

### getBrainUsage

lookup the static usage profile of a brain.

```ts
const getBrainUsage = async (
  input: {
    by: { brain: { repo: string; slug: string } };
  },
  context: { brains: BrainRegistry },
): Promise<BrainUsage | null> => { ... };
```

| operation       | type   | description                                  |
| --------------- | ------ | -------------------------------------------- |
| `getBrainUsage` | getOne | retrieves usage profile for a specific brain |

### calcBrainOutputCost

calculate cash cost from token consumption and brain rates.

```ts
const calcBrainOutputCost = (
  input: {
    of: { brain: { repo: string; slug: string } };
    for: { tokens: TokenCount };
  },
  context: { brains: BrainRegistry },
): BrainOutputCost => { ... };
```

| operation             | type    | description                                   |
| --------------------- | ------- | --------------------------------------------- |
| `calcBrainOutputCost` | compute | deterministic calculation from tokens × rates |

note: this is a `compute*` operation (deterministic leaf), not a `get*` or `set*`.

### internal: wrapWithMetrics

wrap raw brain response with calculated metrics.

```ts
const wrapWithMetrics = <TOutput>(
  input: {
    output: TOutput;
    usage: { inputTokens: number; outputTokens: number; ... };
    brainUsage: BrainUsage;
    duration: IsoDuration;
  },
): BrainOutput<TOutput> => { ... };
```

| operation         | type    | description                                    |
| ----------------- | ------- | ---------------------------------------------- |
| `wrapWithMetrics` | compute | transforms raw output + usage into BrainOutput |

---

## relationships

### treestruct of decoration

```
BrainOutput<TOutput>
  ├── output: TOutput           // the actual result
  └── metrics: BrainOutputMetrics
        ├── size: TokenCount    // measurements
        └── cost: CashCost      // calculated prices
              ├── input: Price
              ├── output: Price
              ├── cache: { get: Price, set: Price }
              └── total: Price
```

`BrainOutput` **decorates** `TOutput` with metrics. the metrics **decorate** raw token counts with calculated prices.

### treestruct of subdomains

```
brain (subdomain)
  ├── identity
  │     ├── BrainAtom (entity)
  │     └── BrainRepl (entity)
  ├── profile
  │     └── BrainUsage (literal)
  │           ├── cost
  │           │     ├── time: speed, latency
  │           │     └── cash: rates per token
  │           └── gain
  │                 ├── size: context window
  │                 ├── grades: benchmarks
  │                 └── skills: capabilities
  └── invocation
        ├── BrainOutput<T> (literal)
        └── BrainOutputMetrics (literal)
              ├── size: token counts
              └── cost: calculated prices
```

### dependencies

```
BrainAtom ──owns──> BrainUsage
BrainRepl ──owns──> BrainUsage

BrainOutput<T> ──contains──> BrainOutputMetrics
BrainOutputMetrics ──contains──> Price (multiple)
BrainOutputMetrics ──contains──> TokenCount

calcBrainOutputCost ──reads──> BrainUsage
calcBrainOutputCost ──produces──> BrainOutputCost (subset of BrainOutputMetrics)

getBrainUsage ──reads──> BrainRegistry
```

---

## composition to fulfill wish

### usecase: know what you spent

```
1. caller invokes brain.ask() or brain.act()
2. plugin executes api call, receives raw usage from provider
3. plugin looks up BrainUsage for the brain
4. plugin invokes wrapWithMetrics({ output, usage, brainUsage, duration })
5. wrapWithMetrics computes cost via calcBrainOutputCost()
6. plugin returns BrainOutput<TOutput>
7. caller accesses result.output and result.metrics
```

### usecase: compare brains before choice

```
1. caller invokes getBrainUsage({ by: { brain: { repo, slug } } })
2. operation looks up brain in registry
3. operation returns BrainUsage (the static profile)
4. caller compares cost.cash, gain.grades, etc
5. caller decides which brain to use
```

### usecase: budget enforcement

```
1. caller declares budget: { cash: '$1.00' }
2. actor tracks accumulated spend across invocations
3. before each invocation, actor estimates cost via calcBrainOutputCost()
4. if estimate would exceed budget → stop
5. after invocation, actor updates accumulated spend from metrics.cost.cash.total
```

---

## summary of domain objects

| name                 | type    | description                          |
| -------------------- | ------- | ------------------------------------ |
| `BrainAtom`          | entity  | llm inference endpoint with identity |
| `BrainRepl`          | entity  | agentic repl with identity           |
| `BrainUsage`         | literal | static cost & gain profile           |
| `BrainOutput<T>`     | literal | invocation result with metrics       |
| `BrainOutputMetrics` | literal | size and cost measurements           |
| `Price`              | literal | monetary amount (immutable)          |
| `TokenCount`         | literal | token measurements                   |
| `IsoDuration`        | literal | iso8601 duration                     |
| `IsoDateStamp`       | literal | iso8601 date                         |

## summary of operations

| name                  | type    | description                               |
| --------------------- | ------- | ----------------------------------------- |
| `getBrainUsage`       | getOne  | lookup static profile by brain ref        |
| `calcBrainOutputCost` | compute | calculate cost from tokens × rates        |
| `wrapWithMetrics`     | compute | transform output + usage into BrainOutput |

---

## citations

1. enterprisecraftsmanship — entity identity definition
2. martinfowler — value object characteristics
3. dev.to — value object as descriptive aspect
4. ts-money — money immutability pattern
5. frontstuff — money as amount + currency

---

## sources

- [entity vs value object](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)
- [martinfowler value object](https://www.martinfowler.com/bliki/ValueObject.html)
- [ddd entities and value objects](https://dev.to/ielgohary/domain-driven-design-entities-value-objects-and-services-chapter-51-22cm)
- [ts-money](https://github.com/macor161/ts-money)
- [monetary values in javascript](https://frontstuff.io/how-to-handle-monetary-values-in-javascript)
