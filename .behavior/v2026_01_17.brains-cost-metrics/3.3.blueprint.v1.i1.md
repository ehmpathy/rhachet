# blueprint: brain cost metrics implementation

this document proposes an implementation blueprint for the brain cost metrics feature.

---

## filediffs treestruct

legend:
- `[+]` = create new file
- `[~]` = update file
- `[-]` = delete file

```
src/
  domain.objects/
    [+] BrainSpec.ts                    # new: supplier-guaranteed specification literal
    [+] BrainOutput.ts                  # new: output + metrics wrapper literal
    [+] BrainOutputMetrics.ts           # new: size and cost measurements literal
    [~] BrainAtom.ts                    # mod: add .spec property, change .ask() return type
    [~] BrainRepl.ts                    # mod: add .spec property, change .ask()/.act() return types
    [~] ContextBrain.ts                 # mod: update return types for brain operations
    [~] index.ts                        # mod: export new domain objects

  domain.operations/
    brainCost/
      [+] calcBrainOutputCost.ts        # new: pure function to calculate cost from tokens/chars
      [+] calcBrainOutputCost.test.ts   # new: unit tests for cost calculation
    brainAtom/
      [~] askViaBrainAtom.ts            # mod: return BrainOutput<TOutput> instead of TOutput
    brainRepl/
      [~] askViaBrainRepl.ts            # mod: return BrainOutput<TOutput> instead of TOutput
      [~] actViaBrainRepl.ts            # mod: return BrainOutput<TOutput> instead of TOutput
    context/
      [~] genContextBrain.ts            # mod: update delegates to handle new return types
      [~] genContextBrain.test.ts       # mod: update assertions for BrainOutput shape
      [~] genContextBrain.integration.test.ts  # mod: update assertions for BrainOutput shape

  .test.assets/
    [~] genMockedBrainAtom.ts           # mod: add spec property, return BrainOutput
    [~] genMockedBrainRepl.ts           # mod: add spec property, return BrainOutput
    [+] genSampleBrainSpec.ts           # new: helper to generate example BrainSpec for tests

  contract/
    sdk/
      [~] genActor.brain.caseAskable.integration.test.ts   # mod: update for BrainOutput return
      [~] genActor.brain.caseCollocated.integration.test.ts # mod: update for BrainOutput return
      [~] genActor.brain.casePublished.integration.test.ts  # mod: update for BrainOutput return
```

---

## codepaths treestruct

### new codepaths

```
calcBrainOutputCost
  ├── input validation
  │   ├── validate for.tokens XOR for.chars (PickOne)
  │   └── validate with.cost.cash structure
  ├── token resolution
  │   ├── if for.tokens → use directly
  │   └── if for.chars → estimate tokens (chars / 4 heuristic)
  ├── cost calculation (via iso-price arithmetic)
  │   ├── deets.input = priceMultiply(with.cost.cash.input, tokens.input)
  │   ├── deets.output = priceMultiply(with.cost.cash.output, tokens.output)
  │   ├── deets.cache.get = priceMultiply(with.cost.cash.cache.get, tokens.cache.get)
  │   ├── deets.cache.set = priceMultiply(with.cost.cash.cache.set, tokens.cache.set)
  │   └── total = priceSum(deets.input, deets.output, deets.cache.get, deets.cache.set)
  └── return { cash: { total, deets } }
```

### modified codepaths

```
BrainAtom.ask (supplier implementation)
  ├── [prior] invoke llm api
  ├── [prior] parse response via schema
  ├── [new] measure elapsed time
  ├── [new] extract usage from api response (input_tokens, output_tokens, cache_*)
  ├── [new] calculate chars from input/output strings
  ├── [new] construct BrainOutputMetrics via calcBrainOutputCost
  └── [changed] return BrainOutput<TOutput> { output, metrics }

BrainRepl.ask / BrainRepl.act (supplier implementation)
  ├── [prior] invoke llm api loop
  ├── [prior] parse final response via schema
  ├── [new] accumulate usage across turns
  ├── [new] measure total elapsed time
  ├── [new] construct BrainOutputMetrics via calcBrainOutputCost
  └── [changed] return BrainOutput<TOutput> { output, metrics }

askViaBrainAtom
  ├── [prior] delegate to atom.ask()
  └── [changed] return BrainOutput<TOutput> (passthrough)

askViaBrainRepl / actViaBrainRepl
  ├── [prior] delegate to repl.ask() / repl.act()
  └── [changed] return BrainOutput<TOutput> (passthrough)

genContextBrain
  ├── [prior] validate atoms/repls arrays
  ├── [prior] create lookup functions
  └── [changed] context.brain.*.ask/act return BrainOutput<TOutput>
```

---

## domain objects

### BrainSpec.ts

```ts
import { DomainLiteral } from 'domain-objects';
import type { IsoDuration, IsoDateStamp } from 'type-fns';
import type { IsoPrice } from 'iso-price';

/**
 * .what = static specification that the brain supplier publishes and guarantees
 * .why = enables callers to compare cost/gain before invocation
 */
export interface BrainSpec {
  cost: {
    time: {
      speed: { tokens: number; per: IsoDuration };
      latency: IsoDuration;
    };
    cash: {
      per: 'token';
      cache: { get: IsoPrice; set: IsoPrice };
      input: IsoPrice;
      output: IsoPrice;
    };
  };
  gain: {
    size: {
      context: { tokens: number };
    };
    grades: {
      swe?: number;
      mmlu?: number;
      humaneval?: number;
    };
    cutoff: IsoDateStamp;
    domain: 'ALL' | 'SOFTWARE';
    skills: {
      tooluse?: boolean;
      vision?: boolean;
    };
  };
}

export class BrainSpec extends DomainLiteral<BrainSpec> implements BrainSpec {}
```

### BrainOutput.ts

```ts
import { DomainLiteral } from 'domain-objects';
import type { BrainOutputMetrics } from './BrainOutputMetrics';

/**
 * .what = result of any brain invocation: output plus metrics
 * .why = pairs the caller's output with measurements from the invocation
 */
export interface BrainOutput<TOutput> {
  output: TOutput;
  metrics: BrainOutputMetrics;
}

export class BrainOutput<TOutput>
  extends DomainLiteral<BrainOutput<TOutput>>
  implements BrainOutput<TOutput>
{
  public static nested = { metrics: BrainOutputMetrics };
}
```

### BrainOutputMetrics.ts

```ts
import { DomainLiteral } from 'domain-objects';
import type { IsoDuration } from 'type-fns';
import type { IsoPrice } from 'iso-price';

/**
 * .what = size and cost measurements from a single brain invocation
 * .why = captures both size (tokens, chars) and cost (time, cash)
 */
export interface BrainOutputMetrics {
  size: {
    tokens: {
      input: number;
      output: number;
      cache: { get: number; set: number };
    };
    chars: {
      input: number;
      output: number;
      cache: { get: number; set: number };
    };
  };
  cost: {
    time: IsoDuration;
    cash: {
      total: IsoPrice;
      deets: {
        input: IsoPrice;
        output: IsoPrice;
        cache: { get: IsoPrice; set: IsoPrice };
      };
    };
  };
}

export class BrainOutputMetrics
  extends DomainLiteral<BrainOutputMetrics>
  implements BrainOutputMetrics {}
```

---

## domain operations

### calcBrainOutputCost.ts

```ts
import { priceMultiply, priceSum, priceDivide } from 'iso-price';
import type { IsoPrice } from 'iso-price';
import type { PickOne } from 'type-fns';
import type { BrainSpec } from '@src/domain.objects/BrainSpec';
import type { BrainOutputMetrics } from '@src/domain.objects/BrainOutputMetrics';

/**
 * .what = calculates the cash cost of a brain invocation
 * .why = enables cost estimation before invocation and cost calculation after
 */
export const calcBrainOutputCost = (
  input: {
    for: PickOne<{
      tokens: BrainOutputMetrics['size']['tokens'];
      chars: BrainOutputMetrics['size']['chars'];
    }>;
    with: {
      cost: {
        cash: BrainSpec['cost']['cash'];
      };
    };
  },
): {
  cash: {
    total: IsoPrice;
    deets: {
      input: IsoPrice;
      output: IsoPrice;
      cache: { get: IsoPrice; set: IsoPrice };
    };
  };
} => {
  // resolve tokens (use directly or estimate from chars)
  const tokens = input.for.tokens ?? {
    input: Math.ceil(input.for.chars!.input / 4),
    output: Math.ceil(input.for.chars!.output / 4),
    cache: {
      get: Math.ceil(input.for.chars!.cache.get / 4),
      set: Math.ceil(input.for.chars!.cache.set / 4),
    },
  };

  // calculate cost deets (rates are already per-token)
  const deets = {
    input: priceMultiply({ of: input.with.cost.cash.input, by: tokens.input }),
    output: priceMultiply({ of: input.with.cost.cash.output, by: tokens.output }),
    cache: {
      get: priceMultiply({ of: input.with.cost.cash.cache.get, by: tokens.cache.get }),
      set: priceMultiply({ of: input.with.cost.cash.cache.set, by: tokens.cache.set }),
    },
  };

  // calculate total
  const total = priceSum(deets.input, deets.output, deets.cache.get, deets.cache.set);

  return { cash: { total, deets } };
};
```

---

## test coverage

### unit tests

#### calcBrainOutputCost.test.ts

```ts
import { given, when, then } from 'test-fns';
import { calcBrainOutputCost } from './calcBrainOutputCost';

describe('calcBrainOutputCost', () => {
  const exampleRates = {
    per: 'token' as const,
    input: { amount: 3, currency: 'USD' }, // $3 per million = $0.000003 per token
    output: { amount: 15, currency: 'USD' }, // $15 per million
    cache: {
      get: { amount: 0.3, currency: 'USD' }, // $0.30 per million
      set: { amount: 3.75, currency: 'USD' }, // $3.75 per million
    },
  };

  given('[case1] token counts provided directly', () => {
    when('[t0] calculate cost for 1000 input, 500 output tokens', () => {
      then('total reflects sum of all components', () => {
        const result = calcBrainOutputCost({
          for: {
            tokens: {
              input: 1000,
              output: 500,
              cache: { get: 0, set: 0 },
            },
          },
          with: { cost: { cash: exampleRates } },
        });

        // input: 1000 * $3/1M = $0.003
        // output: 500 * $15/1M = $0.0075
        // total: $0.0105
        expect(result.cash.total.amount).toBeCloseTo(0.0105, 6);
      });

      then('deets breakdown is correct', () => {
        const result = calcBrainOutputCost({
          for: {
            tokens: {
              input: 1000,
              output: 500,
              cache: { get: 0, set: 0 },
            },
          },
          with: { cost: { cash: exampleRates } },
        });

        expect(result.cash.deets.input.amount).toBeCloseTo(0.003, 6);
        expect(result.cash.deets.output.amount).toBeCloseTo(0.0075, 6);
      });
    });

    when('[t1] calculate cost with cache tokens', () => {
      then('cache costs are included in total', () => {
        const result = calcBrainOutputCost({
          for: {
            tokens: {
              input: 1000,
              output: 500,
              cache: { get: 5000, set: 1000 },
            },
          },
          with: { cost: { cash: exampleRates } },
        });

        // cache.get: 5000 * $0.30/1M = $0.0015
        // cache.set: 1000 * $3.75/1M = $0.00375
        expect(result.cash.deets.cache.get.amount).toBeCloseTo(0.0015, 6);
        expect(result.cash.deets.cache.set.amount).toBeCloseTo(0.00375, 6);
      });
    });
  });

  given('[case2] char counts provided (token estimation)', () => {
    when('[t0] calculate cost from chars', () => {
      then('tokens are estimated at ~4 chars per token', () => {
        const result = calcBrainOutputCost({
          for: {
            chars: {
              input: 4000, // ~1000 tokens
              output: 2000, // ~500 tokens
              cache: { get: 0, set: 0 },
            },
          },
          with: { cost: { cash: exampleRates } },
        });

        // should approximate same cost as 1000/500 tokens
        expect(result.cash.total.amount).toBeCloseTo(0.0105, 5);
      });
    });
  });

  given('[case3] zero tokens', () => {
    when('[t0] all token counts are zero', () => {
      then('total cost is zero', () => {
        const result = calcBrainOutputCost({
          for: {
            tokens: {
              input: 0,
              output: 0,
              cache: { get: 0, set: 0 },
            },
          },
          with: { cost: { cash: exampleRates } },
        });

        expect(result.cash.total.amount).toEqual(0);
      });
    });
  });
});
```

#### BrainSpec domain object tests

```ts
// src/domain.objects/BrainSpec.test.ts
import { given, when, then } from 'test-fns';
import { BrainSpec } from './BrainSpec';

describe('BrainSpec', () => {
  given('[case1] valid spec properties', () => {
    when('[t0] instantiated with full spec', () => {
      then('creates BrainSpec instance', () => {
        const spec = new BrainSpec({
          cost: {
            time: {
              speed: { tokens: 100, per: 'PT1S' },
              latency: 'PT0.5S',
            },
            cash: {
              per: 'token',
              input: '$0.000003',
              output: '$0.000015',
              cache: { get: '$0.0000003', set: '$0.00000375' },
            },
          },
          gain: {
            size: { context: { tokens: 200000 } },
            grades: { swe: 72.5, mmlu: 88 },
            cutoff: '2025-04-01',
            domain: 'ALL',
            skills: { tooluse: true, vision: true },
          },
        });

        expect(spec.cost.cash.per).toEqual('token');
        expect(spec.gain.size.context.tokens).toEqual(200000);
      });
    });
  });
});
```

### integration tests

#### brain invocation with metrics

```ts
// src/domain.operations/context/genContextBrain.metrics.integration.test.ts
import { given, when, then, useBeforeAll } from 'test-fns';
import { z } from 'zod';

describe('genContextBrain with metrics', () => {
  given('[case1] brain atom with real api', () => {
    // requires actual brain provider integration
    // validates that BrainOutput { output, metrics } is returned

    when('[t0] atom.ask is invoked', () => {
      then('returns BrainOutput with output and metrics', async () => {
        // const result = await context.brain.atom.ask({ ... });
        // expect(result.output).toBeDefined();
        // expect(result.metrics.size.tokens.input).toBeGreaterThan(0);
        // expect(result.metrics.cost.cash.total.amount).toBeGreaterThan(0);
      });
    });
  });

  given('[case2] brain repl with real api', () => {
    when('[t0] repl.ask is invoked', () => {
      then('returns BrainOutput with accumulated metrics', async () => {
        // multi-turn metrics accumulation test
      });
    });

    when('[t1] repl.act is invoked', () => {
      then('returns BrainOutput with accumulated metrics', async () => {
        // agentic loop metrics accumulation test
      });
    });
  });
});
```

### acceptance tests

#### sdk contract: actor.ask returns BrainOutput

```ts
// src/contract/sdk/genActor.brain.metrics.acceptance.test.ts
import { given, when, then } from 'test-fns';

describe('genActor brain metrics contract', () => {
  given('[case1] actor with brain configured', () => {
    when('[t0] actor.ask is called', () => {
      then('returns { output, metrics } shape', async () => {
        // const result = await actor.ask({ prompt: '...', schema: {...} });
        // expect(result).toHaveProperty('output');
        // expect(result).toHaveProperty('metrics');
        // expect(result.metrics).toHaveProperty('size');
        // expect(result.metrics).toHaveProperty('cost');
      });

      then('metrics.cost.cash.total is IsoPrice', async () => {
        // expect(result.metrics.cost.cash.total).toHaveProperty('amount');
        // expect(result.metrics.cost.cash.total).toHaveProperty('currency');
      });
    });

    when('[t1] actor.act is called', () => {
      then('returns { output, metrics } shape', async () => {
        // same assertions as actor.ask
      });
    });
  });

  given('[case2] spec property access', () => {
    when('[t0] brain.spec is accessed', () => {
      then('returns BrainSpec with cost and gain', () => {
        // expect(brain.spec.cost.cash.input).toBeDefined();
        // expect(brain.spec.gain.size.context.tokens).toBeGreaterThan(0);
      });
    });
  });
});
```

---

## migration notes

### break assessment

| change | type | impact |
|--------|------|--------|
| `.ask()` returns `BrainOutput<T>` | hard break | all callers must access `.output` |
| `.act()` returns `BrainOutput<T>` | hard break | all callers must access `.output` |
| `.spec` property added | additive | no break — new property |

### caller migration pattern

before:
```ts
const result = await brain.ask({ prompt, schema });
console.log(result.content);
```

after:
```ts
const { output, metrics } = await brain.ask({ prompt, schema });
console.log(output.content);
console.log(metrics.cost.cash.total); // '$0.077'
```

---

## implementation phases

### phase 1: domain objects (no breaks yet)

1. create `BrainSpec.ts`, `BrainOutput.ts`, `BrainOutputMetrics.ts`
2. create `calcBrainOutputCost.ts` with unit tests
3. create `genSampleBrainSpec.ts` test helper

### phase 2: supplier contract (internal)

1. update `BrainAtom` interface to include `.spec` property
2. update `BrainRepl` interface to include `.spec` property
3. update supplier implementations to return `BrainOutput<T>`
4. update mock generators for tests

### phase 3: context layer (internal)

1. update `genContextBrain` return types
2. update `askViaBrainAtom`, `askViaBrainRepl`, `actViaBrainRepl`
3. update all affected tests

### phase 4: public api (hard break)

1. update `Actor.ask()` and `Actor.act()` return types
2. update all consumer tests and examples
3. document migration path in changelog

---

## dependencies

### new package dependency

```json
{
  "dependencies": {
    "iso-price": "^1.0.0"
  }
}
```

`iso-price` provides:
- `IsoPrice` type (flexible: `IsoPriceWords | IsoPriceShape | IsoPriceHuman`)
- `priceMultiply({ of, by })` — multiply price by scalar
- `priceSum(...prices)` — sum multiple prices
- `priceDivide({ of, by })` — divide price by scalar
- bigint precision internally — no `0.1 + 0.2 !== 0.3` headaches, no nano-dollar drift

---

## open questions

1. **removed: `getBrainSpec`** — since `.spec` is available on each brain instance, the standalone lookup function is unnecessary. callers access spec via `brain.spec` directly.

2. **tokenizer for char estimation** — the blueprint uses `chars / 4` as a simple heuristic. should we integrate a proper tokenizer (e.g., `tiktoken`) for more accurate estimation from chars?

3. **cache token treatment** — anthropic distinguishes `cache_creation_input_tokens` vs `cache_read_input_tokens`. openai uses `cached_tokens`. the spec normalizes to `cache.get` and `cache.set` — confirm this translation is correct.

---

## citations

1. domain distillation document — `3.2.distill.domain._.v1.i1.md`
2. research: claims — `3.1.research.claims._.v1.i1.md`
3. research: access layer — `3.1.research.access._.v1.i1.md`
4. research: domain terms — `3.1.research.domain.terms.v1.i1.md`
