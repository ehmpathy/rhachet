# distill: domain for brain cost metrics

this document distills the domain objects, operations, and relationships required to fulfill the brain cost metrics feature.

---

## usecases and contracts

### usecase 1: know what you spent

```ts
const result = await mechanic.act({
  skill: { review: { input: prUrl } },
});

// result.output: the actual output
// result.metrics: BrainOutputMetrics
console.log(result.metrics.cost.cash.total); // '$0.077'
```

### usecase 2: compare brains before you choose

```ts
const sonnetSpec = await getBrainSpec({
  by: { ref: { repo: 'anthropic', slug: 'claude/sonnet' } },
});

console.log(sonnetSpec.cost.cash.input);      // $3/mil tokens
console.log(sonnetSpec.gain.size.context);    // { tokens: 200000 }
console.log(sonnetSpec.gain.grades.swe);      // 62%
```

### usecase 3: calculate cost before or after

```ts
// get the spec first
const spec = await getBrainSpec({
  by: { ref: { repo: 'anthropic', slug: 'claude/opus' } },
}, context);

// estimate before invocation (from chars — will tokenize)
const estimate = calcBrainOutputCost({
  for: { chars: { input: 12000, output: 2400, cache: { get: 0, set: 0 } } },
  with: { cost: { cash: spec.cost.cash } },
});

// calculate after invocation (from metrics.size.tokens)
const realized = calcBrainOutputCost({
  for: { tokens: result.metrics.size.tokens },
  with: { cost: { cash: spec.cost.cash } },
});
```

---

## domain objects

### entities

entities have identity and change over time.

#### BrainAtom (extant, modified)

```ts
interface BrainAtom {
  // identity
  repo: string;   // e.g., "anthropic"
  slug: string;   // e.g., "claude/opus"
  description: string;

  // NEW: static specification
  spec: BrainSpec;

  // operations
  ask: <TOutput>(input: BrainAskInput<TOutput>) => Promise<BrainOutput<TOutput>>;
}
```

- `.unique` = `['repo', 'slug']`
- `.primary` = `['repo', 'slug']`
- **modification**: `.ask()` now returns `BrainOutput<TOutput>` instead of `TOutput`
- **addition**: `.spec` property exposes the brain's static specification

#### BrainRepl (extant, modified)

```ts
interface BrainRepl {
  // identity
  repo: string;
  slug: string;
  description: string;

  // NEW: static specification
  spec: BrainSpec;

  // operations
  ask: <TOutput>(input: BrainAskInput<TOutput>) => Promise<BrainOutput<TOutput>>;
  act: <TOutput>(input: BrainActInput<TOutput>) => Promise<BrainOutput<TOutput>>;
}
```

- `.unique` = `['repo', 'slug']`
- `.primary` = `['repo', 'slug']`
- **modification**: `.ask()` and `.act()` now return `BrainOutput<TOutput>` instead of `TOutput`
- **addition**: `.spec` property exposes the brain's static specification

---

### literals (value objects)

literals are immutable and identified by all their properties.

#### BrainSpec (new)

the static specification that the brain supplier publishes and guarantees.

```ts
interface BrainSpec {
  /**
   * what does it cost to use the brain
   */
  cost: {
    time: {
      speed: { tokens: number; per: IsoDuration };  // output token generation rate
      latency: IsoDuration;                          // time to first token
    };
    cash: {
      per: 'token';
      cache: { get: IsoPrice; set: IsoPrice };
      input: IsoPrice;
      output: IsoPrice;
    };
  };

  /**
   * what do you gain from the brain
   */
  gain: {
    size: {
      context: { tokens: number };  // context window capacity
    };
    grades: {
      swe?: number;       // swe-bench score (0-100)
      mmlu?: number;      // mmlu score (0-100)
      humaneval?: number; // humanrhachet completion --setupscore (0-100)
    };
    cutoff: IsoDateStamp;           // knowledge cutoff
    domain: 'ALL' | 'SOFTWARE';     // trained domain
    skills: {
      tooluse?: boolean;  // trained for tool use
      vision?: boolean;   // can process images
    };
  };
}
```

- `.unique` = all properties (it's a literal)
- **rationale**: specifications are what the supplier guarantees — context window, price rates, benchmark scores, knowledge cutoff. just as a motor is rated to 5000 RPM by its supplier, a brain is rated to 200k tokens by anthropic.

#### BrainOutput<TOutput> (new)

the result of any brain invocation. output plus metrics.

```ts
interface BrainOutput<TOutput> {
  output: TOutput;
  metrics: BrainOutputMetrics;
}
```

- `.unique` = all properties (it's a literal)
- **rationale**: pairs the caller's output with the measurements from the invocation. every `.ask()` and `.act()` returns this shape.

#### BrainOutputMetrics (new)

the size and cost measurements from a single invocation.

```ts
interface BrainOutputMetrics {
  size: {
    tokens: {
      input: number;
      output: number;
      cache: { get: number; set: number };
    };
    chars: {
      input: number;
      output: number;
      cache: { get: number; set: number };
    };
  };
  cost: {
    time: IsoDuration;
    cash: {
      total: IsoPrice;
      deets: {
        input: IsoPrice;
        output: IsoPrice;
        cache: { get: IsoPrice; set: IsoPrice };
      };
    };
  };
}
```

- `.unique` = all properties (it's a literal)
- **rationale**: captures both size (tokens, chars) and cost (time, cash). the metrics are calculated after each invocation via the brain's `BrainSpec` and the api's usage response.

#### IsoPrice (extant, from `iso-price`)

a monetary amount. flexible contract from the `iso-price` package.

```ts
// from iso-price
type IsoPrice = IsoPriceWords | IsoPriceShape | IsoPriceHuman;
// e.g., '$3', 'USD 25.00', { amount: 3, currency: 'USD' }

// convert any format via
asIsoPrice('$25') // → { amount: 25, currency: 'USD' }

// price arithmetic
priceDivide({ of: '$3', by: 1_000_000 })  // $3 per million tokens
priceMultiply({ of: cost.cash.input, by: size.tokens.input })
priceSum(a, b, c, d)
```

- **rationale**: flexible input formats (`'$3'`, `'USD 25.00'`, shape) with consistent arithmetic. `IsoPriceWords` allows `'USD 0.000_003'` for $3/mil, but `priceDivide({ of: '$3', by: 1_000_000 })` is simpler to read. `iso-price` handles bigint and decimal precision internally — no `0.1 + 0.2 !== 0.3` headaches, no nano-dollar drift at per-token scale.

---

### events

no new events are required for this feature.

---

## domain operations

### getBrainSpec (new)

lookup the static specification of a brain.

```ts
/**
 * .what = retrieves the static specification of a brain
 * .why = enables callers to compare cost/gain before invocation
 */
const getBrainSpec = async (
  input: {
    by: {
      ref: { repo: string; slug: string };
    };
  },
  context: ContextBrain,
): Promise<BrainSpec> => { ... };
```

- **contract**: `(input, context) => Promise<BrainSpec>`
- **access**: reads from static brain registry
- **idempotent**: yes (read-only)

### calcBrainOutputCost (new)

calculate the cost of a brain invocation from token counts. pure function — callers provide the rates.

```ts
/**
 * .what = calculates the cash cost of a brain invocation
 * .why = enables cost estimation before invocation and cost calculation after
 */
const calcBrainOutputCost = (
  input: {
    for: PickOne<{
      tokens: BrainOutputMetrics['size']['tokens'];
      chars: BrainOutputMetrics['size']['chars'];
    }>;
    with: {
      cost: {
        cash: BrainSpec['cost']['cash'];
      };
    };
  },
): {
  cash: {
    total: IsoPrice;
    deets: {
      input: IsoPrice;
      output: IsoPrice;
      cache: { get: IsoPrice; set: IsoPrice };
    };
  };
} => { ... };
```

- **contract**: `(input) => BrainOutputCost`
- **pure function**: no context, no lookup — callers provide `spec.cost.cash`
- **idempotent**: yes
- **behavior**:
  - if `for.tokens` is provided → use tokens directly
  - if `for.chars` is provided → use tokenizer to estimate tokens from chars
- **formula** (from tokens, via `iso-price`):
  - `cash.deets.input = priceMultiply({ of: with.cost.cash.input, by: tokens.input })`
  - `cash.deets.output = priceMultiply({ of: with.cost.cash.output, by: tokens.output })`
  - `cash.deets.cache.get = priceMultiply({ of: with.cost.cash.cache.get, by: tokens.cache.get })`
  - `cash.deets.cache.set = priceMultiply({ of: with.cost.cash.cache.set, by: tokens.cache.set })`
  - `cash.total = priceSum(cash.deets.input, cash.deets.output, cash.deets.cache.get, cash.deets.cache.set)`
- **note**: `with.cost.cash.*` rates are already per-token (e.g., `priceDivide({ of: '$3', by: 1_000_000 })` done at spec declaration)

**usage**:
```ts
const spec = await getBrainSpec({ by: { ref: { repo: 'anthropic', slug: 'claude/opus' } } }, context);

// from tokens (direct from api)
const cost = calcBrainOutputCost({
  for: { tokens: { input: 5000, output: 1000, cache: { get: 0, set: 0 } } },
  with: { cost: { cash: spec.cost.cash } },
});

// from chars (will tokenize internally)
const costFromChars = calcBrainOutputCost({
  for: { chars: { input: 12000, output: 2400, cache: { get: 0, set: 0 } } },
  with: { cost: { cash: spec.cost.cash } },
});

// from metrics.size.tokens directly
const costFromMetrics = calcBrainOutputCost({
  for: { tokens: result.metrics.size.tokens },
  with: { cost: { cash: spec.cost.cash } },
});
```

### castToBrainOutputMetrics (supplier responsibility)

each brain supplier (anthropic, openai, etc.) implements their own cast from their api response format to `BrainOutputMetrics`.

```ts
// example: anthropic supplier implements
const castToBrainOutputMetrics = (
  input: {
    raw: AnthropicUsageResponse;
    spec: BrainSpec;
    time: IsoDuration;
    chars: { input: number; output: number };
  },
): BrainOutputMetrics => { ... };

// example: openai supplier implements
const castToBrainOutputMetrics = (
  input: {
    raw: OpenAICompletionUsage;
    spec: BrainSpec;
    time: IsoDuration;
    chars: { input: number; output: number };
  },
): BrainOutputMetrics => { ... };
```

- **not prescribed by rhachet**: each supplier adapts their format
- **contract target**: produces `BrainOutputMetrics`
- **rhachet provides**: the `BrainOutputMetrics` shape and `calcBrainOutputCost` utility

---

## relationships

### composition hierarchy

```
BrainAtom ──has──> BrainSpec (1:1 composition)
BrainRepl ──has──> BrainSpec (1:1 composition)

BrainOutput<T>
  ├── output: T
  └── metrics: BrainOutputMetrics
        ├── size: { tokens, chars }
        └── cost: { time, cash }
              └── cash: { total: IsoPrice, deets: { input, output, cache } }
```

### data flow

```
[1] invoke BrainAtom.ask() or BrainRepl.ask()/act()
      │
      ▼
[2] call llm api (anthropic, openai)
      │
      ▼
[3] receive api response with usage: { input_tokens, output_tokens, cache_* }
      │
      ▼
[4] lookup BrainSpec from registry (by repo + slug)
      │
      ▼
[5] castToBrainOutputMetrics({ raw: usage, spec, time, chars })
      │
      ▼
[6] return BrainOutput<T> { output, metrics }
```

### dependency graph

```
BrainOutput<T>
  └── depends on ──> BrainOutputMetrics
                       └── depends on ──> IsoPrice

BrainAtom
  └── depends on ──> BrainSpec
                       └── depends on ──> IsoPrice

BrainRepl
  └── depends on ──> BrainSpec
                       └── depends on ──> IsoPrice

calcBrainOutputCost
  └── pure function
  └── input ──> PickOne<{ tokens, chars }> + BrainSpec['cost']['cash']
  └── if chars ──> tokenizer estimates tokens
  └── produces ──> { cash: { total, deets: { input, output, cache } } } (all IsoPrice)

getBrainSpec
  └── depends on ──> ContextBrain
  └── produces ──> BrainSpec
```

---

## access layer

### ContextBrain (extant)

the brain context that provides unified access to brain atoms and repls.

```ts
interface ContextBrain {
  brain: {
    atom: {
      ask: <TOutput>(input: { brain: RefByUnique<typeof BrainAtom>; ... }) => Promise<TOutput>;
    };
    repl: {
      ask: <TOutput>(input: { brain: RefByUnique<typeof BrainRepl>; ... }) => Promise<TOutput>;
      act: <TOutput>(input: { brain: RefByUnique<typeof BrainRepl>; ... }) => Promise<TOutput>;
    };
  };
}
```

- **source**: `src/domain.objects/ContextBrain.ts`
- **handles**: lookup, role embed, and delegation transparently
- **note**: the brain registry is internal to context creation; callers use refs to identify brains

---

## summary

### new domain objects

| object | type | purpose |
|--------|------|---------|
| `BrainSpec` | literal | static cost/gain specification of a brain |
| `BrainOutput<T>` | literal | wrapper for output + metrics |
| `BrainOutputMetrics` | literal | size and cost measurements |
| `IsoPrice` | literal (extant) | monetary amount (from `iso-price`) |

### modified domain objects

| object | modification |
|--------|--------------|
| `BrainAtom` | added `.spec: BrainSpec`; `.ask()` returns `BrainOutput<T>` |
| `BrainRepl` | added `.spec: BrainSpec`; `.ask()` and `.act()` return `BrainOutput<T>` |

### new domain operations

| operation | contract | purpose |
|-----------|----------|---------|
| `getBrainSpec` | `(input, context) => BrainSpec` | lookup brain specification |
| `calcBrainOutputCost` | `(input) => cash costs` | calculate invocation cost (pure function, callers provide rates) |

### supplier responsibility

| operation | contract | purpose |
|-----------|----------|---------|
| `castToBrainOutputMetrics` | `(input) => BrainOutputMetrics` | transform api usage to metrics (each supplier implements) |

### break assessment

| change | break type | impact |
|--------|------------|--------|
| `.ask()` returns `BrainOutput<T>` | hard break | all callers must access `.output` |
| `.act()` returns `BrainOutput<T>` | hard break | all callers must access `.output` |
| `.spec` property added | additive | no break — new property |

the return type change is an intentional hard break. metrics are always available, not an afterthought.

---

## citations

references from research documents:

1. anthropic api documentation — usage object in responses
2. openai api reference — CompletionUsage shape
3. claude agent sdk documentation — ModelUsage.costUSD
4. anthropic price page (january 2026) — token rates
5. domain terms research — BrainSpec as supplier-guaranteed specifications
6. extant domain research — current BrainAtom and BrainRepl shapes
