wish =

we need to know the cost of our brain actions

specifically, whenever we .act() and .ask() against a BrainRepl and BrainAtom, we need a way to get the cost as well as the output

---

lets hardcut the .ask() and .act() brain interfaces

to rather than just having output of `TOutput`

now have a standard output of something like

```
{
  output: TOutput,
  metrics: BrainOutputMetrics
}
```

where BrainOutputMetrics is something like

```ts
interface BrainOutputMetrics {
  size: {
    input: {
      chars,
      tokens,
    },
    output: {
      chars,
      tokens,
    }
  },
  cost: {
    time: IsoDurationWords,
    cash: {
      cache: { get: Price, set: Price },
      input: Price,
      output: Price,
    },
  }
}
```

which is dependent on
1. ability to access token consumption metrics from the api responses
2. static declaration of cost per brain slug, within each repo

dependent on something like

```ts
whats the best name & shape for the price and speed stats of a brain?

e.g., what is X in the below? (also, if Usage is not the right term, feel free to propose alterantives there too)

BrainUsageX ? {
  /**
   * what does it cost to use the brain
   */
  cost: {
    time: { // should we breakdown time into time-to-first-byte vs tokens speed? (what are the common metrics avalable?
      /**
       * how fast does it generate output tokens
       */
      speed: {
        tokens: number,
        per: IsoDuration,
      },

      /**
       * how long does it take till first token
       */
      latency: IsoDuration,
    },
    cash: {
      per: 'token',
      cache: { get: Price, set: Price },
      input: Price,
      output: Price,
    }
  },

  /**
   * what do you gain to use the brain
   */
  gain: {
    size: {
      /**
       * the context capacity of the brain (a.k.a., context window)
       */
      context: { tokens: number }
    },

    /**
     * how well did it do at key benchmarks
     */
    grades: {

    },

    /**
     * when its internalized knowledge was cutoff
     */
    cutoff: IsoDateStamp,

    /**
     * what domain was it trained on
     */
    domain: 'ALL' | 'SOFTWARE',

    /**
     * what skills was it trained into
     */
    skills: {
      /**
       * was it explicitly trained to have tooluse?
       */
      tooluse?: boolean,
    }
  },
}

BrainUsageEfficiency?
BrainUsageMetrics?
BrainUsageStats?
BrainUsageRates?
BrainUsageCosts?
BrainUsageMenu?
???

BrainMetricsOfUsage
&&
BrainMetricsOfOutput
```


the goal here is to capture all of the cost & gain required to use a brain

so that agents can decide which brain is best suited for the task, based on gain -vs- cost tradeoffs

e.g., if it tried the cheapest from a provider and that didn't work well, try another, within some constraints

consider the cutoff time of its knowledge

consider the domain it was focused on

etc

---

the brains should report their own background & capacity & costs & etc


i dont think that the terms above are great (e.g., Usage may not even be right)

but we need to support the access of this X for any brain

and the distillation of the most intuitive yet precice term is going to be critical

---

once we distill that,

rhachet will need to

1. expose the "BrainUsageX" shape (whatever we end up calling it)
2. expose the "BrainOutputX" shape (whatever we end up calling it)
3. expose the ability to
  - `calcBrainOutputCost({ of: { brain: RefByUnique<typeof BrainAtom> | RefByUnique<typeof BrainRepl>, }, for: { tokens: { input, cache: { get, set }, output } } }, ContextBrain)`
    - which folks can use to calc the expected vs realized costs in both time and cash
    - this operation should use the ContextBrain to lookup the specified brain, access its `BrainUsageX`, and cast into a `BrainOutputCost`

4. expose the ability to
  - `getBrainUsageX({ by: { brain:  RefByUnique<typeof BrainAtom> | RefByUnique<typeof BrainRepl> }})`
  - this will allow downstream consumers to compare the cost & gain and make the dynamic decisions on what brains to leverage
