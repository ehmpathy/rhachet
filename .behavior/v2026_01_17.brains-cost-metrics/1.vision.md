# vision: brain cost metrics

brains report their cost and gain. callers compare and choose. invocations return metrics alongside output.

---

## the experience

### usecase 1: know what you spent

after every `.act()` and `.ask()`, callers know exactly what it cost — in time, tokens, and cash.

```ts
const result = await mechanic.act({
  skill: { review: { input: prUrl } },
});

console.log(result.metrics);
// {
//   size: { input: { chars: 12000, tokens: 3200 }, output: { chars: 800, tokens: 210 } },
//   cost: {
//     time: 'PT4.2S',
//     cash: { input: '$0.012', output: '$0.063', cache: { get: '$0.002', set: '$0.00' } },
//   },
// }

console.log(result.output); // the actual review output
```

no more guesses. no more surprise bills. every invocation is observable.

### usecase 2: compare brains before you choose

before invocation, callers can inspect what they'd gain and what it'd cost — per brain.

```ts
import { getBrainUsage } from 'rhachet';

const sonnet = await getBrainUsage({
  by: { brain: { repo: 'anthropic', slug: 'claude/sonnet' } },
});
const opus = await getBrainUsage({
  by: { brain: { repo: 'anthropic', slug: 'claude/opus' } },
});

console.log(sonnet.cost.cash.input);  // $3/mil tokens
console.log(opus.cost.cash.input);    // $15/mil tokens

console.log(sonnet.gain.size.context); // { tokens: 200000 }
console.log(opus.gain.size.context);   // { tokens: 200000 }

console.log(sonnet.gain.grades.swe);   // 62%
console.log(opus.gain.grades.swe);     // 72%
```

the data exists. callers decide the tradeoff.

### usecase 3: dynamic brain selection

agents escalate when the cheap brain fails. actors try the default, then step up.

```ts
const result = await mechanic.act({
  skill: { review: { input: prUrl } },
  brains: {
    strategy: 'escalate',
    budget: { cash: '$0.50', time: 'PT30S' },
  },
});

// internally:
// 1. tries claude/haiku (cheapest in allowlist)
// 2. if quality gate fails → tries claude/sonnet
// 3. if quality gate fails → tries claude/opus
// 4. stops when budget is exhausted or quality is met
```

the actor knows the cost profile of each brain. it makes informed escalation decisions.

### usecase 4: budget enforcement

workflows declare budgets. actors respect them.

```ts
const result = await architect.act({
  skill: { plan: { issue: issueUrl } },
  budget: { cash: '$2.00' },
});

if (result.metrics.cost.cash.total > result.budget.cash) {
  // this never happens — actor stops before it exceeds
}
```

predictable spend. no runaway loops.

---

## the contracts

### BrainUsage

the cost & gain profile of a brain. static. declared by the brain provider.

```ts
interface BrainUsage {
  cost: {
    time: {
      speed: { tokens: number; per: IsoDuration };  // output token generation rate
      latency: IsoDuration;                          // time to first token
    };
    cash: {
      per: 'token';
      cache: { get: Price; set: Price };
      input: Price;
      output: Price;
    };
  };
  gain: {
    size: {
      context: { tokens: number };  // context window capacity
    };
    grades: {
      swe?: number;      // swe-bench score
      mmlu?: number;     // mmlu score
      humaneval?: number; // humaneval score
    };
    cutoff: IsoDateStamp;           // knowledge cutoff
    domain: 'ALL' | 'SOFTWARE';     // trained domain
    skills: {
      tooluse?: boolean;  // trained for tool use
      vision?: boolean;   // can process images
    };
  };
}
```

### BrainOutput<TOutput>

the result of any brain invocation. output plus metrics.

```ts
interface BrainOutput<TOutput> {
  output: TOutput;
  metrics: BrainOutputMetrics;
}

interface BrainOutputMetrics {
  size: {
    input: { chars: number; tokens: number };
    output: { chars: number; tokens: number };
    cache: { get: { tokens: number }; set: { tokens: number } };
  };
  cost: {
    time: IsoDuration;
    cash: {
      input: Price;
      output: Price;
      cache: { get: Price; set: Price };
      total: Price;
    };
  };
}
```

### sdk operations

```ts
// lookup the usage profile of any brain
const usage = await getBrainUsage({
  by: { brain: { repo: 'anthropic', slug: 'claude/opus' } },
}, context);

// calculate expected cost before invocation
const estimate = calcBrainOutputCost({
  of: { brain: { repo: 'anthropic', slug: 'claude/opus' } },
  for: { tokens: { input: 5000, output: 1000 } },
}, context);

// calculate realized cost after invocation
const realized = calcBrainOutputCost({
  of: { brain: { repo: 'anthropic', slug: 'claude/opus' } },
  for: { tokens: { input: 5200, cache: { get: 1000, set: 200 }, output: 950 } },
}, context);
```

---

## the terms

| term | definition |
|------|------------|
| `BrainUsage` | the static cost & gain profile of a brain |
| `BrainOutput` | the result of an invocation, with metrics |
| `BrainOutputMetrics` | size and cost measurements from an invocation |
| `cost.cash` | monetary cost in dollars |
| `cost.time` | duration of the invocation |
| `gain.size.context` | context window capacity in tokens |
| `gain.grades` | benchmark scores (swe-bench, mmlu, etc) |
| `gain.cutoff` | knowledge cutoff date |
| `Price` | a monetary amount (e.g., `'$0.003'` or `{ dollars: 0.003 }`) |
| `IsoDuration` | an iso8601 duration (e.g., `'PT4.2S'`) |

---

## the timelines

### timeline 1: developer who builds an agent

1. **discovers brains** — browses available brains via `getBrainUsage`, compares cost/gain
2. **configures actor** — adds brains to allowlist based on requirements
3. **invokes with metrics** — calls `.act()`, receives `BrainOutput` with metrics
4. **observes spend** — logs metrics, tracks cost per workflow
5. **optimizes** — adjusts brain selection based on observed cost vs quality

### timeline 2: agent at runtime

1. **receives task** — skill is invoked via `.act()`
2. **selects brain** — uses default or escalates based on strategy
3. **invokes brain** — calls brain.ask() or brain.act()
4. **receives response** — brain returns output + raw usage from api
5. **calculates metrics** — looks up brain's usage profile, computes cash cost
6. **returns result** — wraps output with metrics in `BrainOutput`

### timeline 3: budget-constrained workflow

1. **declares budget** — caller specifies `{ budget: { cash: '$1.00' } }`
2. **tracks spend** — actor accumulates metrics.cost.cash across attempts
3. **enforces limit** — stops before it exceeds budget
4. **reports final** — returns total metrics with all attempts

---

## how well does it solve the goals?

| goal | solved? | how |
|------|---------|-----|
| know cost after invocation | ✅ | every `.act()` and `.ask()` returns `BrainOutput<T>` with metrics |
| compare brains before choice | ✅ | `getBrainUsage()` exposes cost/gain for any brain |
| dynamic brain selection | ✅ | actors can read usage profiles and escalate with intelligence |
| budget enforcement | ✅ | `calcBrainOutputCost()` enables spend vs limit |
| surprise bill prevention | ✅ | metrics are observable; budgets are enforceable |
| quality-cost tradeoff | ✅ | gain.grades + cost.cash enables informed selection |

---

## the hardcut

the current `.ask()` and `.act()` return `Promise<TOutput>`.

after this change, they return `Promise<BrainOutput<TOutput>>`:

```ts
// before
const review = await mechanic.act({ skill: { review: { input: pr } } });
// review: ReviewOutput

// after
const result = await mechanic.act({ skill: { review: { input: pr } } });
// result: BrainOutput<ReviewOutput>
// result.output: ReviewOutput
// result.metrics: BrainOutputMetrics
```

this change breaks compatibility. all callers must update to access `.output`.

the tradeoff is worth it — metrics are always available, not an afterthought.
