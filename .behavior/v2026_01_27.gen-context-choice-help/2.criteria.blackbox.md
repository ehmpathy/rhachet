# usecase.1 = brain choice not found yields helpful error message

given('genContextBrain called with choice that does not match any brain')
  when('no atoms or repls match the choice string')
    then('error message includes the requested brain name')
      sothat('user knows what they asked for')
    then('error message includes list of available brains')
      sothat('user can see valid options without external lookup')
    then('available brains are limited to max 21 entries')
      sothat('error message stays readable for large brain registries')
  when('choice is { repl: string } and repl not found')
    then('error message includes list of available repls')
      sothat('user sees only relevant brain type options')
  when('choice is { atom: string } and atom not found')
    then('error message includes list of available atoms')
      sothat('user sees only relevant brain type options')

# usecase.2 = available brains sorted by similarity to requested name

given('genContextBrain called with choice that does not match any brain')
  when('multiple brains are available')
    then('available brains are sorted by string similarity to the requested choice')
      sothat('most likely intended brain appears first')
    then('most similar brain appears at top of list')
      sothat('user can quickly spot typos or close matches')

# usecase.3 = error message format uses treestruct log pattern

given('brain choice not found error is thrown')
  when('user reads the error message')
    then('available brains header starts with ðŸ”­ emoji')
      sothat('visual consistency with other rhachet stdout')
    then('available brains are formatted as treestruct with â”œâ”€â”€ and â””â”€â”€ connectors')
      sothat('visual consistency with rhachet list and cost commands')
    then('each brain entry shows the full slug (repo/slug)')
      sothat('user knows exactly what to type')
    then('atom entries are prefixed with â—‹ symbol')
      sothat('user can distinguish single-inference brains')
    then('repl entries are prefixed with â†» symbol')
      sothat('user can distinguish multi-turn brains')
    then('last entry uses â””â”€â”€ connector')
      sothat('treestruct pattern is complete')
    then('non-last entries use â”œâ”€â”€ connector')
      sothat('treestruct pattern is complete')

# usecase.4 = prior error metadata preserved

given('brain choice not found error is thrown')
  when('consumer catches the BadRequestError')
    then('error.metadata still contains structured available brains data')
      sothat('programmatic access to brain lists remains possible')
    then('error is still instanceof BadRequestError')
      sothat('error type detection continues to work')

# edge.1 = empty brain registry

given('genContextBrain called with no atoms and no repls')
  when('choice is provided')
    then('error message indicates no brains are available')
      sothat('user understands the registry is empty')

# edge.2 = single brain available

given('genContextBrain called with exactly one brain available')
  when('choice does not match')
    then('error message shows the single available option')
      sothat('user sees the only valid choice')

# edge.3 = more than 21 brains available

given('genContextBrain called with more than 21 brains available')
  when('choice does not match')
    then('only 21 brains are listed in the error message')
      sothat('message stays bounded')
    then('message indicates more brains are available but truncated')
      sothat('user knows the list is incomplete')
