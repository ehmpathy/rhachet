# research: production codepath patterns

## pattern.1 = genContextBrain error throw [EXTEND]

the current implementation throws `BadRequestError` with available brains in metadata, but not formatted in the message itself.

### citation.1
`src/domain.operations/context/genContextBrain.ts:108-116`
```ts
    // not found
    if (allMatched.length === 0)
      throw new BadRequestError(`brain not found: ${input.choice}`, {
        choice: input.choice,
        available: {
          atoms: atoms.map(getBrainSlugFull),
          repls: repls.map(getBrainSlugFull),
        },
      });
```

### citation.2
`src/domain.operations/context/genContextBrain.ts:79-83`
```ts
      if (!replMatched)
        throw new BadRequestError(`repl brain not found: ${choiceSlug}`, {
          choice: input.choice,
          available: { repls: repls.map(getBrainSlugFull) },
        });
```

### citation.3
`src/domain.operations/context/genContextBrain.ts:91-95`
```ts
      if (!atomMatched)
        throw new BadRequestError(`atom brain not found: ${choiceSlug}`, {
          choice: input.choice,
          available: { atoms: atoms.map(getBrainSlugFull) },
        });
```

### relation to wish
- currently emits available brains only in metadata
- wish requires available brains formatted in the error message itself
- will EXTEND to format available brains into the message string

---

## pattern.2 = getBrainSlugFull helper [REUSE]

computes the full `repo/slug` string from a brain object.

### citation.4
`src/domain.operations/context/genContextBrain.ts:14-19`
```ts
/**
 * .what = computes full slug from brain repo and slug
 * .why = enables match against user-friendly choice strings like 'xai/grok-3-fast'
 */
const getBrainSlugFull = (brain: { repo: string; slug: string }): string =>
  `${brain.repo}/${brain.slug}`;
```

### relation to wish
- already used to format brain slugs for the available list
- will REUSE directly in the formatter

---

## pattern.3 = treestruct inline format in invokeList [REUSE]

simple inline treestruct format with `├──` and `└──` connectors.

### citation.5
`src/contract/cli/invokeList.ts:35-39`
```ts
        for (let i = 0; i < skills.length; i++) {
          const isLast = i === skills.length - 1;
          const prefix = isLast ? '└── ' : '├── ';
          console.log(`${prefix}${skills[i]!.slug}`);
        }
```

### citation.6
`src/contract/cli/invokeList.ts:52-55`
```ts
        for (let i = 0; i < roles.length; i++) {
          const isLast = i === roles.length - 1;
          const prefix = isLast ? '└── ' : '├── ';
          console.log(`${prefix}${roles[i]!.slug}: ${roles[i]!.purpose}`);
        }
```

### relation to wish
- establishes the treestruct pattern used throughout rhachet cli
- will REUSE this exact pattern for format of available brains list

---

## pattern.4 = treestruct in bootRoleResources stats [REUSE]

treestruct format for stats output with emoji header.

### citation.7
`src/domain.operations/invoke/bootRoleResources.ts:94-104`
```ts
  const printStats = (): void => {
    console.log('<stats>');
    console.log('quant');
    console.log(`  ├── files = ${relevantFiles.length}`);
    console.log(`  │   ├── briefs = ${briefFiles.length}`);
    console.log(`  │   └── skills = ${skillFiles.length}`);
    console.log(`  ├── chars = ${totalChars}`);
    console.log(`  └── tokens ≈ ${approxTokens} (${costFormatted} at $3/mil)`);
    console.log('</stats>');
    console.log('');
  };
```

### relation to wish
- demonstrates indented treestruct with prefix spaces
- vision shows `   ├──` pattern (3-space indent under header)
- will REUSE this indented treestruct pattern

---

## pattern.5 = error metadata with available options [REUSE]

pattern of available options in error metadata for programmatic access.

### citation.8
`src/domain.operations/actor/findActorRoleSkillBySlug.ts:74-84`
```ts
  // skill not found
  throw new BadRequestError(`skill not found: ${input.slug}`, {
    slugSkill: input.slug,
    slugRole: input.role.slug,
    route: input.route,
    availableSolidSkills: input.role.skills.solid
      ? Object.keys(input.role.skills.solid)
      : [],
    availableRigidSkills: input.role.skills.rigid
      ? Object.keys(input.role.skills.rigid)
      : [],
  });
```

### relation to wish
- establishes pattern of available options in metadata
- will REUSE to preserve metadata for programmatic access (usecase.4)

---

## pattern.6 = BrainAtom domain object structure [REUSE]

brain atom has `repo` and `slug` fields that compose the full identifier.

### citation.9
`src/domain.objects/BrainAtom.ts:18-29`
```ts
export interface BrainAtom {
  /**
   * .what = identifier for the plugin package that provides this atom
   * .example = "anthropic", "openai", "ollama"
   */
  repo: string;

  /**
   * .what = unique identifier for this specific atom within the repo
   * .example = "claude-opus-4.5", "gpt-4o", "llama-3-70b"
   */
  slug: string;
```

### relation to wish
- defines the shape we iterate over to build the available list
- will REUSE to access repo/slug for format

---

## pattern.7 = BrainRepl domain object structure [REUSE]

brain repl has identical `repo` and `slug` fields.

### citation.10
`src/domain.objects/BrainRepl.ts:21-30`
```ts
export interface BrainRepl {
  /**
   * .what = identifier for the plugin package that provides this repl
   * .example = "anthropic", "openai"
   */
  repo: string;

  /**
   * .what = unique identifier for this specific repl within the repo
   * .example = "claude-code", "codex"
   */
  slug: string;
```

### relation to wish
- defines the shape we iterate over to build the available list
- will REUSE to access repo/slug for format

---

## pattern.8 = no string similarity library [NEW]

the codebase has no string similarity dependency.

### citation.11
`package.json` dependencies (no matches for similarity libraries):
```
"dependencies": {
  "as-procedure": "1.1.11",
  "bottleneck": "2.19.5",
  "chalk": "4.1.2",
  ...
}
```

### relation to wish
- wish requests string similarity sort (bonus)
- will need to either:
  - add a lightweight dependency (e.g., `fastest-levenshtein`)
  - implement simple levenshtein inline
- recommend: add `fastest-levenshtein` (~1kb, zero deps, fast)

---

## pattern.9 = formatCostTree complex tree render [REFERENCE]

more complex tree render with recursive node structure.

### citation.12
`src/domain.operations/role/formatCostTree.ts:84-86`
```ts
  // determine connector character
  const connector = isRoot ? '' : isLast ? '└── ' : '├── ';
  const childPrefix = isRoot ? '' : prefix + (isLast ? '    ' : '│   ');
```

### relation to wish
- demonstrates the full treestruct character set
- our use case is flat list (not nested), so simpler pattern.3 suffices
- REFERENCE only, not directly reused

---

## summary

| pattern | action | why |
|---------|--------|-----|
| genContextBrain error throw | EXTEND | add formatted message with treestruct |
| getBrainSlugFull helper | REUSE | already computes `repo/slug` |
| treestruct inline format | REUSE | `├──`/`└──` pattern from invokeList |
| treestruct indented stats | REUSE | 3-space indent pattern from bootRoleResources |
| error metadata pattern | REUSE | preserve available in metadata |
| BrainAtom structure | REUSE | access repo/slug fields |
| BrainRepl structure | REUSE | access repo/slug fields |
| string similarity | NEW | add `fastest-levenshtein` or implement inline |
| formatCostTree | REFERENCE | complex tree pattern for reference only |
