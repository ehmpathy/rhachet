# research: test codepath patterns

## pattern.1 = genMockedBrainAtom fixture [REUSE]

test fixture that generates a mocked BrainAtom with configurable repo/slug.

### citation.1
`src/.test.assets/genMockedBrainAtom.ts:11-29`
```ts
export const genMockedBrainAtom = (input?: {
  repo?: string;
  slug?: string;
  description?: string;
  content?: string;
}): BrainAtom =>
  new BrainAtom({
    repo: input?.repo ?? '__mock_repo__',
    slug: input?.slug ?? '__mock_atom__',
    description: input?.description ?? 'mocked brain atom for tests',
    spec: genSampleBrainSpec(),
    ask: async (askInput) =>
      new BrainOutput({
        output: askInput.schema.output.parse({
          content: input?.content ?? '__mock_response__',
        }),
        metrics: genMockedBrainOutputMetrics(),
      }),
  });
```

### relation to wish
- can generate atoms with specific repo/slug combinations for test
- will REUSE to create multiple atoms for error message tests

---

## pattern.2 = genMockedBrainRepl fixture [REUSE]

test fixture that generates a mocked BrainRepl with configurable repo/slug.

### citation.2
`src/.test.assets/genMockedBrainRepl.ts:11-36`
```ts
export const genMockedBrainRepl = (input?: {
  repo?: string;
  slug?: string;
  description?: string;
  content?: string;
}): BrainRepl =>
  new BrainRepl({
    repo: input?.repo ?? '__mock_repo__',
    slug: input?.slug ?? '__mock_repl__',
    description: input?.description ?? 'mocked brain repl for tests',
    spec: genSampleBrainSpec(),
    ask: async (askInput) =>
      new BrainOutput({ ... }),
    act: async (actInput) =>
      new BrainOutput({ ... }),
  });
```

### relation to wish
- can generate repls with specific repo/slug combinations for test
- will REUSE to create multiple repls for error message tests

---

## pattern.3 = given/when/then from test-fns [REUSE]

bdd-style test structure for readable, organized tests.

### citation.3
`src/domain.operations/context/genContextBrain.test.ts:1-2`
```ts
import { BadRequestError } from 'helpful-errors';
import { given, then, when } from 'test-fns';
```

### citation.4
`src/domain.operations/context/genContextBrain.test.ts:398-426`
```ts
given('[case12] choice is string with no match', () => {
  const mockAtom = genMockedBrainAtom({ repo: 'xai', slug: 'grok-3' });
  const mockRepl = genMockedBrainRepl({
    repo: 'anthropic',
    slug: 'claude-code',
  });

  when('[t0] genContextBrain is called with unknown slug', () => {
    then('it throws BadRequestError with "brain not found"', () => {
      expect(() =>
        genContextBrain({
          atoms: [mockAtom],
          repls: [mockRepl],
          choice: 'notfound/brain',
        }),
      ).toThrow(BadRequestError);

      try {
        genContextBrain({ ... });
      } catch (error) {
        expect((error as Error).message).toContain('brain not found');
      }
    });
  });
});
```

### relation to wish
- establishes test structure pattern for new error message tests
- will REUSE this exact pattern for available brains tests

---

## pattern.4 = getError from test-fns [REUSE]

utility to capture errors for detailed assertion without try/catch boilerplate.

### citation.5
`src/domain.operations/actor/findActorRoleSkillBySlug.test.ts:1`
```ts
import { getError, given, then, when } from 'test-fns';
```

### citation.6
`src/domain.operations/actor/findActorRoleSkillBySlug.test.ts:99-111`
```ts
then('throws BadRequestError with helpful hint', async () => {
  const error = await getError(() =>
    findActorRoleSkillBySlug({
      slug: 'wordcount',
      role: testRole,
      route: 'solid',
    }),
  );
  expect(error).toBeDefined();
  expect(error.message).toContain('declared in role.skills.solid');
  expect(error.message).toContain('no executable found');
});
```

### relation to wish
- cleaner pattern for error message assertions than try/catch
- will REUSE for test of error message content

---

## pattern.5 = toMatchSnapshot for observability [EXTEND]

snapshot tests for visual verification of output format.

### citation.7
`src/domain.operations/invoke/init/execRoleInits.integration.test.ts:69-73`
```ts
const output = logs.join('\n');
expect(output).toMatchSnapshot();
```

### citation.8
`src/domain.operations/init/genRhachetUseConfig.test.ts:14-15`
```ts
// Snapshot for observability
expect(result).toMatchSnapshot();
```

### relation to wish
- snapshot tests capture exact error message format
- will EXTEND to snapshot the formatted available brains list

---

## pattern.6 = error message content assertions [EXTEND]

assert specific content within error messages.

### citation.9
`src/domain.operations/context/genContextBrain.test.ts:103-107`
```ts
try {
  genContextBrain({ atoms: [atom1, atom2] });
} catch (error) {
  expect((error as Error).message).toContain('duplicate atom');
}
```

### citation.10
`src/domain.operations/context/genContextBrain.test.ts:415-423`
```ts
try {
  genContextBrain({
    atoms: [mockAtom],
    repls: [mockRepl],
    choice: 'notfound/brain',
  });
} catch (error) {
  expect((error as Error).message).toContain('brain not found');
}
```

### relation to wish
- establishes pattern for assert message contains specific text
- will EXTEND to assert available brains list appears in message
- will EXTEND to assert treestruct format appears in message (â”œâ”€â”€ and â””â”€â”€)
- will EXTEND to assert symbols appear (â—‹ for atoms, â†» for repls)

---

## pattern.7 = multiple brains with distinct repo/slug [NEW]

tests currently use single atoms or repls; need multiple for available list test.

### citation.11
`src/domain.operations/context/genContextBrain.test.ts:289-303`
```ts
given('[case8] choice is undefined', () => {
  const mockAtom = genMockedBrainAtom({ repo: 'xai', slug: 'grok-3' });
  const mockRepl = genMockedBrainRepl({
    repo: 'anthropic',
    slug: 'claude-code',
  });

  when('[t0] genContextBrain is called without choice', () => {
    then('brain.choice is null', () => {
      const context = genContextBrain({
        atoms: [mockAtom],
        repls: [mockRepl],
      });
      expect(context.brain.choice).toBeNull();
    });
  });
});
```

### relation to wish
- current tests use 1-2 brains
- need to test with >21 brains for truncation edge case
- will add NEW test case with array of many brains

---

## pattern.8 = error metadata assertions [NEW]

need to verify metadata is preserved in error for programmatic access.

### citation.12
`src/domain.operations/context/genContextBrain.ts:110-116` (production code reference)
```ts
throw new BadRequestError(`brain not found: ${input.choice}`, {
  choice: input.choice,
  available: {
    atoms: atoms.map(getBrainSlugFull),
    repls: repls.map(getBrainSlugFull),
  },
});
```

### relation to wish
- need to verify error.metadata still contains structured data
- will add NEW test assertions for metadata preservation

---

## summary

| pattern | action | why |
|---------|--------|-----|
| genMockedBrainAtom fixture | REUSE | generates atoms with configurable repo/slug |
| genMockedBrainRepl fixture | REUSE | generates repls with configurable repo/slug |
| given/when/then structure | REUSE | bdd-style test organization |
| getError from test-fns | REUSE | clean error capture for assertions |
| toMatchSnapshot | EXTEND | verify exact error message format |
| error message assertions | EXTEND | assert treestruct, symbols in message |
| multiple distinct brains | NEW | test >21 brains for truncation |
| error metadata assertions | NEW | verify programmatic access preserved |

## proposed test cases

based on the criteria, these test cases are needed:

1. **[case.new.1] error message includes available brains list**
   - given: multiple atoms and repls
   - when: choice does not match any brain
   - then: error.message contains formatted list

2. **[case.new.2] available brains use treestruct format**
   - given: multiple brains available
   - when: choice not found
   - then: error.message contains `â”œâ”€â”€` and `â””â”€â”€` connectors
   - then: error.message contains `ðŸ”­ available brains` header

3. **[case.new.3] atoms prefixed with â—‹, repls prefixed with â†»**
   - given: atoms and repls available
   - when: choice not found
   - then: atoms have `â—‹` prefix in message
   - then: repls have `â†»` prefix in message

4. **[case.new.4] available brains sorted by similarity**
   - given: brains available with similar names to typo
   - when: typo choice provided (e.g., "antrhopic/cloude-code")
   - then: most similar brain appears first

5. **[case.new.5] truncation at 21 brains**
   - given: >21 brains available
   - when: choice not found
   - then: only 21 brains listed
   - then: message indicates more are available

6. **[case.new.6] error metadata preserved**
   - given: brains available
   - when: choice not found
   - then: error.metadata.available contains structured data
   - then: error instanceof BadRequestError

7. **[case.new.7] empty registry shows appropriate message**
   - given: no atoms and no repls
   - when: choice provided
   - then: error message indicates no brains available
