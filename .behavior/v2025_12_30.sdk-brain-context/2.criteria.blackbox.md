# usecase.1 = define a brain.atom plugin

given a developer wants to create a brain.atom plugin package
  when they define RhachetBrainAtom instances
    then each atom must have { repo, slug } identifiers
    then each atom must have a human-readable description
    then each atom must have an `.imagine(input, context)` method implementation
      sothat the atom can perform LLM inference when invoked
    then each atom is typed as RhachetBrainAtom
      sothat typescript provides autocomplete and type safety
  when they export a `getBrainAtoms()` function
    then it returns an array of RhachetBrainAtom instances
      sothat consumers can forward atoms to genContextRhachetBrain

given a developer provides an invalid RhachetBrainAtom definition
  when repo or slug is missing
    then a clear error message indicates which identifier is missing
  when .imagine method is missing
    then a clear error message indicates the method is required


# usecase.2 = define a brain.repl plugin

given a developer wants to create a brain.repl plugin package
  when they define RhachetBrainRepl instances
    then each repl must have { repo, slug } identifiers
    then each repl must have a human-readable description
    then each repl must have an `.imagine(input, context)` method implementation
      sothat the repl can execute agentic loops when invoked
    then each repl is typed as RhachetBrainRepl
      sothat typescript provides autocomplete and type safety
  when they export a `getBrainRepls()` function
    then it returns an array of RhachetBrainRepl instances
      sothat consumers can forward repls to genContextRhachetBrain

given a developer provides an invalid RhachetBrainRepl definition
  when repo or slug is missing
    then a clear error message indicates which identifier is missing
  when .imagine method is missing
    then a clear error message indicates the method is required


# usecase.3 = create a brain context via factory

given a developer has imported brain plugin packages
  when they call `genContextRhachetBrain({ atoms, repls })`
    then `atoms` accepts arrays from plugin `getBrainAtoms()` calls
    then `repls` accepts arrays from plugin `getBrainRepls()` calls
    then arrays from multiple plugins can be spread together
    then the factory returns a ContextRhachetBrain
    then the context exposes `context.brain.atom.imagine()` method
    then the context exposes `context.brain.repl.imagine()` method
      sothat callers have a unified interface to invoke brains

given a developer passes duplicate brain identifiers to the factory
  when two atoms or two repls share the same { repo, slug }
    then a clear error indicates the duplicate
      sothat accidental conflicts are caught at context creation

given a developer passes an empty atoms array
  when they call `genContextRhachetBrain({ atoms: [], repls })`
    then the context is created successfully
    then atom.imagine calls fail with "no atoms available" guidance
      sothat partial configurations are allowed

given a developer passes an empty repls array
  when they call `genContextRhachetBrain({ atoms, repls: [] })`
    then the context is created successfully
    then repl.imagine calls fail with "no repls available" guidance
      sothat partial configurations are allowed


# usecase.4 = imagine via brain.atom

given a developer has a ContextRhachetBrain with atoms
  when they call `context.brain.atom.imagine({ brain, role, prompt, schema })`
    then `brain: { repo, slug }` identifies which atom to use
    then `role: { briefs }` content is prepended to the system prompt
      sothat the atom is primed with domain knowledge
    then `prompt` is the user message to send
    then `schema: { input, output }` defines expected types (optional)
    then the response is returned to the caller
      sothat developers receive the atom's imagination output

given the brain reference does not exist in context
  when calling `context.brain.atom.imagine()`
    then a clear error indicates the brain was not found
    then the error includes the { repo, slug } that was requested
      sothat developers can debug configuration issues

given role.briefs is provided
  when the imagine call executes
    then briefs content is embedded in the system prompt
      sothat the atom has role-specific context

given role.briefs is empty or undefined
  when the imagine call executes
    then the call proceeds without role embedding
      sothat briefs are optional


# usecase.5 = imagine via brain.repl

given a developer has a ContextRhachetBrain with repls
  when they call `context.brain.repl.imagine({ brain, role, prompt, schema })`
    then `brain: { repo, slug }` identifies which repl to use
    then `role: { briefs }` content is prepended to the system prompt
      sothat the repl is primed with domain knowledge
    then `prompt` is the task/instruction to execute
    then `schema: { input, output }` defines expected types (optional)
    then the response is returned to the caller
      sothat developers receive the repl's imagination output

given the brain reference does not exist in context
  when calling `context.brain.repl.imagine()`
    then a clear error indicates the brain was not found
    then the error includes the { repo, slug } that was requested
      sothat developers can debug configuration issues

given role.briefs is provided
  when the imagine call executes
    then briefs content is embedded in the system prompt
      sothat the repl has role-specific context

given role.briefs is empty or undefined
  when the imagine call executes
    then the call proceeds without role embedding
      sothat briefs are optional


# usecase.6 = type safety for imagine inputs and outputs

given schema.output is provided as a Zod schema
  when the imagine call returns
    then the return type is inferred from the Zod schema
      sothat typescript knows the exact output shape

given schema.output is not provided
  when the imagine call returns
    then the return type is a generic imagination response
      sothat the call is still usable without strict typing


# usecase.7 = plugin examples for ecosystem (to be published as separate packages)

given this release includes _topublish/* examples
  when rhachet-brain-anthropic is in _topublish
    then it demonstrates RhachetBrainAtom instances for claude models
    then it demonstrates RhachetBrainRepl instances for claude-code
    then it exports `getBrainAtoms()` and `getBrainRepls()` functions
      sothat developers see the plugin contract in action
  when rhachet-brain-openai is in _topublish
    then it demonstrates RhachetBrainAtom instances for gpt models
    then it demonstrates RhachetBrainRepl instances for codex
    then it exports `getBrainAtoms()` and `getBrainRepls()` functions
      sothat developers see the plugin contract in action

given these _topublish examples are ready
  when this feature is released
    then rhachet-brain-anthropic will be extracted and published as its own npm package
    then rhachet-brain-openai will be extracted and published as its own npm package
      sothat consumers can `npm install rhachet-brain-anthropic` or `npm install rhachet-brain-openai`

given a developer wants to create their own brain plugin package
  when they reference the published rhachet-brain-anthropic or rhachet-brain-openai packages
    then they see the full pattern for defining atoms and repls
    then they see the export convention (`getBrainAtoms`, `getBrainRepls`)
      sothat they can bootstrap their own plugin package


# boundary.1 = brain identification

given a brain reference
  when { repo, slug } is provided
    then the brain is uniquely identified
  when repo is missing
    then the lookup fails with clear error
  when slug is missing
    then the lookup fails with clear error


# boundary.2 = role embedding

given role content
  when briefs is Artifact<typeof GitFile>[]
    then each artifact's content is extracted and concatenated
    then the combined content is prepended to system prompt
      sothat the brain has role-specific context from the brief files
  when briefs is an empty array
    then system prompt is unmodified
  when briefs is undefined
    then system prompt is unmodified


# boundary.3 = context creation inputs

given genContextRhachetBrain input
  when atoms is undefined
    then atoms defaults to empty array
  when repls is undefined
    then repls defaults to empty array
  when both atoms and repls are undefined or empty
    then context is created but all imagine calls fail with guidance
