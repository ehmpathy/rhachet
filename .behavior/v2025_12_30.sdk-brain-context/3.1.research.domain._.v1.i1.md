# domain research: sdk brain context

## summary

this document researches the domain objects, operations, and relationships needed to fulfill the wish for a pluggable brain context framework in rhachet.


---


## 1. domain objects

### 1.1 entities

#### RhachetBrainAtom

**definition**: an LLM inference endpoint capable of creative language imagination (single-turn or multi-turn without agentic loop)

**unique key**: `{ repo, slug }`
- `repo`: identifier for the plugin package (e.g., "anthropic", "openai")
- `slug`: identifier for the specific model (e.g., "claude-opus-4.5", "gpt-4o")

**attributes**:
- `description`: human-readable explanation of the atom's capabilities
- `imagine(input, context)`: the core operation contract

**real-world examples**:
- anthropic claude models via `@anthropic-ai/sdk` [1]
- openai gpt models via `openai` sdk [2]

**reference implementation pattern** (from anthropic sdk) [1]:
```typescript
const message = await client.messages.create({
  max_tokens: 1024,
  messages: [{ role: 'user', content: 'Hello, Claude' }],
  model: 'claude-sonnet-4-5-20250929',
  system: 'You are a helpful assistant.',
});
```

---

#### RhachetBrainRepl

**definition**: a brain.atom operating behind a REPL (read-execute-print-loop), enabling agentic behavior through iterative tool use

**unique key**: `{ repo, slug }`
- `repo`: identifier for the plugin package (e.g., "anthropic", "openai")
- `slug`: identifier for the specific repl (e.g., "claude-code", "codex")

**attributes**:
- `description`: human-readable explanation of the repl's capabilities
- `imagine(input, context)`: the core operation contract (executes agentic loop)

**real-world examples**:
- claude code via `@anthropic-ai/claude-code` [3]
- openai codex via `@openai/codex` [4]

**agentic loop pattern** (from claude agent sdk) [5]:
> "the SDK implements a four-stage feedback cycle: 1. Gather Context, 2. Take Action, 3. Verify Work, 4. Repeat"

---

#### ContextRhachetBrain

**definition**: the runtime context object that provides unified access to registered brain atoms and repls

**attributes**:
- `brain.atom.imagine({ brain, role, prompt, schema })`: lookup and invoke an atom
- `brain.repl.imagine({ brain, role, prompt, schema })`: lookup and invoke a repl

**pattern**: follows existing `RoleContext` pattern in rhachet codebase


---

### 1.2 literals (value objects)

#### RhachetBrainImagineInput

**definition**: the input shape for the `.imagine()` operation

**attributes**:
- `role: { briefs?: Artifact<typeof GitFile>[] }`: domain knowledge to prepend
- `prompt: string`: the user message/instruction
- `schema?: { input?: ZodSchema, output?: ZodSchema }`: optional type constraints

---

#### RhachetBrainImagineOutput

**definition**: the output shape from the `.imagine()` operation

**attributes**:
- typed according to `schema.output` when provided
- generic response shape when no schema


---


## 2. domain operations

### 2.1 factory operations

#### genContextRhachetBrain

**signature**: `({ atoms, repls }) => ContextRhachetBrain`

**behavior**:
- accepts arrays of RhachetBrainAtom and RhachetBrainRepl instances
- validates no duplicate `{ repo, slug }` within atoms or repls
- returns a ContextRhachetBrain instance

**pattern**: similar to how `RoleRegistry` collects `Role[]` in current codebase


### 2.2 plugin export operations

#### getBrainAtoms (plugin contract)

**signature**: `() => RhachetBrainAtom[]`

**behavior**: returns all brain atoms provided by a plugin package

#### getBrainRepls (plugin contract)

**signature**: `() => RhachetBrainRepl[]`

**behavior**: returns all brain repls provided by a plugin package


### 2.3 imagine operations

#### context.brain.atom.imagine

**signature**: `({ brain, role, prompt, schema }) => Promise<Output>`

**behavior**:
1. lookup atom by `{ repo, slug }` from registered atoms
2. extract and concatenate briefs content from `role.briefs`
3. prepend briefs to system prompt
4. delegate to `atom.imagine(input, context)`
5. return typed response

#### context.brain.repl.imagine

**signature**: `({ brain, role, prompt, schema }) => Promise<Output>`

**behavior**:
1. lookup repl by `{ repo, slug }` from registered repls
2. extract and concatenate briefs content from `role.briefs`
3. prepend briefs to system prompt
4. delegate to `repl.imagine(input, context)`
5. return typed response


---


## 3. relationships

### 3.1 treestruct of decoration

```
ContextRhachetBrain
├── brain
│   ├── atom
│   │   └── imagine() → delegates to RhachetBrainAtom.imagine()
│   └── repl
│       └── imagine() → delegates to RhachetBrainRepl.imagine()
└── (internal: atoms[], repls[] for lookup)
```

### 3.2 treestruct of common subdomains

```
rhachet (sdk)
├── domain.objects
│   ├── RhachetBrainAtom (new)
│   ├── RhachetBrainRepl (new)
│   └── ContextRhachetBrain (new, or in domain.operations/context/)
└── domain.operations
    └── context
        └── genContextRhachetBrain (new)

rhachet-brain-anthropic (plugin, _topublish)
├── atoms
│   └── claudeOpus45Atom
├── repls
│   └── claudeCodeRepl
└── exports
    ├── getBrainAtoms()
    └── getBrainRepls()

rhachet-brain-openai (plugin, _topublish)
├── atoms
│   └── gpt4oAtom
├── repls
│   └── codexRepl
└── exports
    ├── getBrainAtoms()
    └── getBrainRepls()
```

### 3.3 dependencies

```
ContextRhachetBrain
  └── depends on → RhachetBrainAtom[] (from plugins)
  └── depends on → RhachetBrainRepl[] (from plugins)

genContextRhachetBrain
  └── depends on → RhachetBrainAtom (type)
  └── depends on → RhachetBrainRepl (type)
  └── produces → ContextRhachetBrain

RhachetBrainAtom (plugin impl)
  └── depends on → @anthropic-ai/sdk (for anthropic plugin)
  └── depends on → openai (for openai plugin)

RhachetBrainRepl (plugin impl)
  └── depends on → @anthropic-ai/claude-code (for anthropic plugin)
  └── depends on → @openai/codex (for openai plugin)
```


---


## 4. composition to support wish

### 4.1 developer workflow

```typescript
// 1. import plugins
import { getBrainAtoms, getBrainRepls } from 'rhachet-brain-anthropic';
import { getBrainAtoms as getOpenAIAtoms, getBrainRepls as getOpenAIRepls } from 'rhachet-brain-openai';

// 2. create context
const context = genContextRhachetBrain({
  atoms: [...getBrainAtoms(), ...getOpenAIAtoms()],
  repls: [...getBrainRepls(), ...getOpenAIRepls()],
});

// 3. use context to imagine
const result = await context.brain.atom.imagine({
  brain: { repo: 'anthropic', slug: 'claude-opus-4.5' },
  role: { briefs },
  prompt: 'analyze this code',
});
```

### 4.2 plugin author workflow

```typescript
// rhachet-brain-anthropic/src/atoms/claudeOpus45.ts
import Anthropic from '@anthropic-ai/sdk';
import type { RhachetBrainAtom } from 'rhachet';

const client = new Anthropic();

export const claudeOpus45Atom: RhachetBrainAtom = {
  repo: 'anthropic',
  slug: 'claude-opus-4.5',
  description: 'Claude Opus 4.5 - Anthropic flagship model',
  imagine: async (input, context) => {
    const message = await client.messages.create({
      model: 'claude-opus-4.5-20250929',
      max_tokens: 4096,
      system: input.systemPrompt, // briefs already embedded by context
      messages: [{ role: 'user', content: input.prompt }],
    });
    return { content: message.content };
  },
};

// rhachet-brain-anthropic/src/index.ts
export const getBrainAtoms = () => [claudeOpus45Atom];
export const getBrainRepls = () => [claudeCodeRepl];
```


---


## 5. sdk patterns referenced

### 5.1 anthropic sdk pattern [1]

```typescript
import Anthropic from '@anthropic-ai/sdk';

const client = new Anthropic();

const message = await client.messages.create({
  max_tokens: 1024,
  messages: [{ role: 'user', content: 'Hello, Claude' }],
  model: 'claude-sonnet-4-5-20250929',
  system: 'You are a helpful assistant.',
});
```

key properties:
- `model`: string identifier
- `messages`: array with `{ role, content }`
- `system`: top-level system prompt (separate from messages)
- `max_tokens`: required
- `tools`: optional array for function calling

### 5.2 openai sdk pattern [2]

```typescript
import OpenAI from 'openai';

const client = new OpenAI();

const completion = await client.chat.completions.create({
  model: 'gpt-4o',
  messages: [
    { role: 'developer', content: 'Talk like a pirate.' },
    { role: 'user', content: 'Are semicolons optional in JavaScript?' },
  ],
});
```

key properties:
- `model`: string identifier
- `messages`: array with `{ role, content }`
  - roles: `system`, `developer`, `user`, `assistant`
  - `developer` role introduced january 2025 for o-series models [6]

### 5.3 claude code pattern [3]

> "Claude Code is an agentic coding tool that lives in your terminal, understands your codebase, and helps you code faster by executing routine tasks, explaining complex code, and handling git workflows"

design philosophy:
> "Claude Code is intentionally low-level and unopinionated, providing close to raw model access without forcing specific workflows"

### 5.4 openai codex pattern [4]

> "Codex CLI is OpenAI's coding agent that you can run locally from your terminal. It can read, change, and run code on your machine in the selected directory."

MCP integration:
> "You can run Codex as an MCP server and connect it from other MCP clients"


---


## citations

[1] [Anthropic TypeScript SDK](https://github.com/anthropics/anthropic-sdk-typescript)
> "This library provides convenient access to the Anthropic REST API from server-side TypeScript or JavaScript."

[2] [OpenAI Node SDK](https://github.com/openai/openai-node)
> "The official OpenAI library provides convenient access to the OpenAI REST API from TypeScript or JavaScript."

[3] [Claude Code Overview](https://github.com/anthropics/claude-code)
> "Claude Code is an agentic coding tool that lives in your terminal, understands your codebase, and helps you code faster"

[4] [OpenAI Codex CLI](https://github.com/openai/codex)
> "Codex CLI is a coding agent from OpenAI that runs locally on your computer"

[5] [Building Agents with Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)
> "give your agents a computer, allowing them to work like humans do"
> "the SDK implements a four-stage feedback cycle: 1. Gather Context, 2. Take Action, 3. Verify Work, 4. Repeat"

[6] [OpenAI Developer Role](https://community.openai.com/t/what-goes-in-the-system-vs-developer-role/1347594)
> "You could think about developer and user messages like a function and its arguments in a programming language. Developer messages provide the system's rules and business logic"

[7] [Claude Client SDKs](https://platform.claude.com/docs/en/api/client-sdks)
> "The Claude Code SDK evolved into the broader Claude Agent SDK to support general-purpose agents beyond coding"

[8] [Codex with Agents SDK](https://developers.openai.com/codex/guides/agents-sdk/)
> "By exposing the CLI as a Model Context Protocol (MCP) server and orchestrating it with the OpenAI Agents SDK, you can create deterministic, auditable workflows"
