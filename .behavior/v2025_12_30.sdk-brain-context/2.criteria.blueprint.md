## blackbox criteria satisfied

- usecase.1 = define a brain.atom plugin ✓
- usecase.2 = define a brain.repl plugin ✓
- usecase.3 = create a brain context via factory ✓
- usecase.4 = imagine via brain.atom ✓
- usecase.5 = imagine via brain.repl ✓
- usecase.6 = type safety for imagine inputs and outputs ✓
- usecase.7 = plugin examples for ecosystem ✓
- boundary.1 = brain identification ✓
- boundary.2 = role embedding ✓
- boundary.3 = context creation inputs ✓


## subcomponent contracts

given RhachetBrainAtom interface
  then exposes: repo: string (identifier for the plugin package)
  then exposes: slug: string (identifier for this specific atom)
  then exposes: description: string (human-readable description)
  then exposes: imagine(input, context) => Promise<{ content: string }>
  then input is inline: { role: { briefs? }, prompt, schema? }
  then plugin handles briefs directly (maximizes context, caches, finetuned behaviors)

given RhachetBrainRepl interface
  then exposes: repo: string (identifier for the plugin package)
  then exposes: slug: string (identifier for this specific repl)
  then exposes: description: string (human-readable description)
  then exposes: imagine(input, context) => Promise<{ content: string }>
  then input is inline: { role: { briefs? }, prompt, schema? }
  then plugin handles briefs directly (maximizes context, caches, finetuned behaviors)

given ContextRhachetBrain interface
  then exposes: brain.atom.imagine({ brain, role, prompt, schema }) => Promise<Output>
  then exposes: brain.repl.imagine({ brain, role, prompt, schema }) => Promise<Output>
  then brain parameter is { repo: string, slug: string }

given genContextRhachetBrain factory
  then exposes: genContextRhachetBrain({ atoms, repls }) => ContextRhachetBrain
  then atoms parameter is RhachetBrainAtom[]
  then repls parameter is RhachetBrainRepl[]
  then throws on duplicate { repo, slug } within atoms
  then throws on duplicate { repo, slug } within repls


## composition boundaries

given ContextRhachetBrain implementation
  then composes atoms array and repls array from factory input
  then brain.atom.imagine looks up atom by { repo, slug } and delegates to atom.imagine
  then brain.repl.imagine looks up repl by { repo, slug } and delegates to repl.imagine
  then briefs are passed directly to plugin (plugin decides how to handle)

given castBriefsToPrompt utility
  then exported from SDK for plugin authors to use
  then converts Artifact<typeof GitFile>[] to concatenated prompt string
  then generalized from bootRoleResources logic
  then bootRoleResources refactored to use this shared utility

given plugin package structure (rhachet-brain-*)
  then exports getBrainAtomsBy{Provider}(): RhachetBrainAtom[]
  then exports getBrainReplsBy{Provider}(): RhachetBrainRepl[]
  then each exported atom/repl implements the respective interface


## integration boundaries

given rhachet SDK exports
  then exports RhachetBrainAtom type
  then exports RhachetBrainRepl type
  then exports ContextRhachetBrain type
  then exports genContextRhachetBrain function
  then exports castBriefsToPrompt function

given _topublish/rhachet-brain-anthropic package
  then implements RhachetBrainAtom for claude models (e.g., claude-opus-4.5)
  then implements RhachetBrainRepl for claude-code
  then exports getBrainAtomsByAnthropic() and getBrainReplsByAnthropic()
  then ready for extraction to standalone npm package post-release

given _topublish/rhachet-brain-openai package
  then implements RhachetBrainAtom for gpt models (e.g., gpt-4o)
  then implements RhachetBrainRepl for codex
  then exports getBrainAtomsByOpenAI() and getBrainReplsByOpenAI()
  then ready for extraction to standalone npm package post-release


## test coverage criteria

given RhachetBrainAtom and RhachetBrainRepl types
  then has unit tests for type validation (repo, slug, description, imagine required)

given genContextRhachetBrain factory
  then has unit tests for successful context creation
  then has unit tests for duplicate detection errors
  then has unit tests for empty array handling

given ContextRhachetBrain.brain.atom.imagine
  then has unit tests for successful lookup and delegation
  then has unit tests for brain-not-found error
  then has unit tests for briefs embedding into prompt
  then has unit tests for optional briefs (empty/undefined)

given ContextRhachetBrain.brain.repl.imagine
  then has unit tests for successful lookup and delegation
  then has unit tests for brain-not-found error
  then has unit tests for briefs embedding into prompt
  then has unit tests for optional briefs (empty/undefined)

given schema type inference
  then has unit tests for Zod schema output type inference
  then has unit tests for generic response when no schema

given _topublish plugin packages
  then has integration tests demonstrating full flow:
    import plugin -> genContextRhachetBrain -> context.brain.*.imagine
