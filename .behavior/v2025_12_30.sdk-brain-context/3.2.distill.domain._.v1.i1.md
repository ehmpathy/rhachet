# domain distillation: sdk brain context

## 1. usecases and envisioned contracts

### usecase.1: define a brain.atom plugin

```typescript
// plugin author defines an atom
import { RhachetBrainAtom } from 'rhachet';

export const brainAtomClaudeOpus = new RhachetBrainAtom({
  repo: 'anthropic',
  slug: 'claude-opus-4.5',
  description: 'Claude Opus 4.5 - Anthropic flagship model',
  imagine: async (input, context) => {
    // ... provider-specific implementation
  },
});

// plugin exports via convention
export const getBrainAtomsByAnthropic = (): RhachetBrainAtom[] => [brainAtomClaudeOpus];
```

### usecase.2: define a brain.repl plugin

```typescript
// plugin author defines a repl
import { RhachetBrainRepl } from 'rhachet';

export const brainReplClaudeCode = new RhachetBrainRepl({
  repo: 'anthropic',
  slug: 'claude-code',
  description: 'Claude Code - agentic coding assistant',
  imagine: async (input, context) => {
    // ... provider-specific agentic implementation
  },
});

// plugin exports via convention
export const getBrainReplsByAnthropic = (): RhachetBrainRepl[] => [brainReplClaudeCode];
```

### usecase.3: create a brain context via factory

```typescript
import { genContextRhachetBrain } from 'rhachet';
import { getBrainAtomsByAnthropic, getBrainReplsByAnthropic } from 'rhachet-brain-anthropic';
import { getBrainAtomsByOpenAI, getBrainReplsByOpenAI } from 'rhachet-brain-openai';

const context = genContextRhachetBrain({
  atoms: [...getBrainAtomsByAnthropic(), ...getBrainAtomsByOpenAI()],
  repls: [...getBrainReplsByAnthropic(), ...getBrainReplsByOpenAI()],
});
```

### usecase.4: imagine via brain.atom

```typescript
const result = await context.brain.atom.imagine({
  brain: { repo: 'anthropic', slug: 'claude-opus-4.5' },
  role: { briefs: await getRoleBriefs({ glob: 'practices/*' }) },
  prompt: 'analyze this code for quality issues',
  schema: { output: z.object({ issues: z.array(z.string()) }) },
});
// result is typed as { issues: string[] }
```

### usecase.5: imagine via brain.repl

```typescript
const result = await context.brain.repl.imagine({
  brain: { repo: 'anthropic', slug: 'claude-code' },
  role: { briefs: await getRoleBriefs({ glob: 'refactor/*' }) },
  prompt: 'refactor this function to use async/await',
  schema: { output: z.object({ refactoredCode: z.string() }) },
});
// result is typed as { refactoredCode: string }
```


---


## 2. domain.objects

### 2.1 RhachetBrainAtom

```typescript
// src/domain.objects/RhachetBrainAtom.ts

import { DomainEntity } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';

/**
 * .what = an LLM inference endpoint capable of creative language imagination
 * .why =
 *   - enables registration of pluggable LLM atoms (e.g., claude, gpt, llama)
 *   - provides a standardized contract for single-turn or multi-turn inference
 *   - enables dynamic swapping of models at runtime
 */
export interface RhachetBrainAtom {
  /**
   * .what = identifier for the plugin package that provides this atom
   * .example = "anthropic", "openai", "ollama"
   */
  repo: string;

  /**
   * .what = unique identifier for this specific atom within the repo
   * .example = "claude-opus-4.5", "gpt-4o", "llama-3-70b"
   */
  slug: string;

  /**
   * .what = human-readable description of this atom's capabilities
   * .why = helps developers understand what this atom is best suited for
   */
  description: string;

  /**
   * .what = the imagination operation contract
   * .why = standardizes how all atoms are invoked, regardless of provider
   *
   * .note = plugin is responsible for handling role.briefs appropriately.
   *   this design maximizes leverage of each brain's unique capabilities:
   *   - context window optimization (e.g., claude's 200k vs gpt's 128k)
   *   - provider-specific caching (e.g., anthropic prompt caching)
   *   - finetuned behaviors (e.g., system prompt placement, formatting)
   */
  imagine: (
    input: {
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema?: { output?: unknown };
    },
    context: { [key: string]: unknown },
  ) => Promise<{ content: string }>;
}
export class RhachetBrainAtom
  extends DomainEntity<RhachetBrainAtom>
  implements RhachetBrainAtom
{
  public static unique = ['repo', 'slug'] as const;
}
```


### 2.2 RhachetBrainRepl

```typescript
// src/domain.objects/RhachetBrainRepl.ts

import { DomainEntity } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';

/**
 * .what = a brain.atom operating behind a REPL (read-execute-print-loop)
 * .why =
 *   - enables registration of pluggable agentic repls (e.g., claude-code, codex)
 *   - provides a standardized contract for agentic tool-using inference
 *   - enables dynamic swapping of agentic systems at runtime
 *
 * .note = repls differ from atoms in that they execute iterative agentic loops
 *   with tool use, rather than single-turn inference
 */
export interface RhachetBrainRepl {
  /**
   * .what = identifier for the plugin package that provides this repl
   * .example = "anthropic", "openai"
   */
  repo: string;

  /**
   * .what = unique identifier for this specific repl within the repo
   * .example = "claude-code", "codex"
   */
  slug: string;

  /**
   * .what = human-readable description of this repl's capabilities
   * .why = helps developers understand what this repl is best suited for
   */
  description: string;

  /**
   * .what = the imagination operation contract
   * .why = standardizes how all repls are invoked, regardless of provider
   *
   * .note = plugin is responsible for handling role.briefs appropriately.
   *   this design maximizes leverage of each brain's unique capabilities:
   *   - context window optimization (e.g., claude-code's extended context)
   *   - provider-specific caching (e.g., session persistence, tool caching)
   *   - finetuned behaviors (e.g., agentic loop tuning, tool configurations)
   */
  imagine: (
    input: {
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema?: { output?: unknown };
    },
    context: { [key: string]: unknown },
  ) => Promise<{ content: string }>;
}
export class RhachetBrainRepl
  extends DomainEntity<RhachetBrainRepl>
  implements RhachetBrainRepl
{
  public static unique = ['repo', 'slug'] as const;
}
```


### 2.3 ContextRhachetBrain

```typescript
// src/domain.objects/ContextRhachetBrain.ts

import { DomainLiteral, RefByUnique } from 'domain-objects';

import type { RhachetBrainAtom } from './RhachetBrainAtom';
import type { RhachetBrainRepl } from './RhachetBrainRepl';

/**
 * .what = runtime context providing unified access to brain atoms and repls
 * .why =
 *   - provides a clean interface for invoking brains by reference
 *   - handles lookup, role embedding, and delegation transparently
 *   - enables dynamic brain swapping without caller changes
 */
export interface ContextRhachetBrain {
  /**
   * .what = interface for invoking brain atoms
   */
  brain: {
    atom: {
      /**
       * .what = lookup and invoke a brain atom by reference
       * .why = provides ergonomic access to atoms with automatic role embedding
       */
      imagine: <TOutput = RhachetBrainAtomImagineOutput>(input: {
        brain: RefByUnique<typeof RhachetBrainAtom>;
        role: { briefs?: Artifact<typeof GitFile>[] };
        prompt: string;
        schema?: { input?: ZodSchema; output?: ZodSchema<TOutput> };
      }) => Promise<TOutput>;
    };

    repl: {
      /**
       * .what = lookup and invoke a brain repl by reference
       * .why = provides ergonomic access to repls with automatic role embedding
       */
      imagine: <TOutput = RhachetBrainReplImagineOutput>(input: {
        brain: RefByUnique<typeof RhachetBrainRepl>;
        role: { briefs?: Artifact<typeof GitFile>[] };
        prompt: string;
        schema?: { input?: ZodSchema; output?: ZodSchema<TOutput> };
      }) => Promise<TOutput>;
    };
  };
}
export class ContextRhachetBrain
  extends DomainLiteral<ContextRhachetBrain>
  implements ContextRhachetBrain {}
```


---


## 3. domain.operations

### 3.1 genContextRhachetBrain

```typescript
// src/domain.operations/context/genContextRhachetBrain.ts

import { BadRequestError } from 'helpful-errors';

import type { RhachetBrainAtom } from '../../domain.objects/RhachetBrainAtom';
import type { RhachetBrainRepl } from '../../domain.objects/RhachetBrainRepl';
import type { ContextRhachetBrain } from '../../domain.objects/ContextRhachetBrain';

/**
 * .what = factory to create a brain context from plugin-provided atoms and repls
 * .why =
 *   - provides a clean entry point for context creation
 *   - validates no duplicate { repo, slug } identifiers
 *   - composes the context with lookup and delegation logic
 */
export const genContextRhachetBrain = (input: {
  atoms?: RhachetBrainAtom[];
  repls?: RhachetBrainRepl[];
}): ContextRhachetBrain => {
  // default to empty arrays
  const atoms = input.atoms ?? [];
  const repls = input.repls ?? [];

  // validate no duplicate atoms
  const atomKeys = atoms.map((a) => `${a.repo}:${a.slug}`);
  const duplicateAtom = atomKeys.find((k, i) => atomKeys.indexOf(k) !== i);
  if (duplicateAtom)
    throw new BadRequestError('duplicate atom identifier', { duplicateAtom });

  // validate no duplicate repls
  const replKeys = repls.map((r) => `${r.repo}:${r.slug}`);
  const duplicateRepl = replKeys.find((k, i) => replKeys.indexOf(k) !== i);
  if (duplicateRepl)
    throw new BadRequestError('duplicate repl identifier', { duplicateRepl });

  // return context with lookup and delegation
  return {
    brain: {
      atom: {
        imagine: async (imagineInput) => {
          const atom = findBrainAtomByRef({ atoms, ref: imagineInput.brain });
          return atom.imagine(imagineInput, {});
        },
      },
      repl: {
        imagine: async (imagineInput) => {
          const repl = findBrainReplByRef({ repls, ref: imagineInput.brain });
          return repl.imagine(imagineInput, {});
        },
      },
    },
  };
};
```


### 3.2 findBrainAtomByRef

```typescript
// src/domain.operations/context/findBrainAtomByRef.ts

import { BadRequestError } from 'helpful-errors';
import type { RefByUnique } from 'domain-objects';

import type { RhachetBrainAtom } from '../../domain.objects/RhachetBrainAtom';

/**
 * .what = finds a brain atom by its unique reference
 * .why = enables lookup of registered atoms by { repo, slug }
 */
export const findBrainAtomByRef = (input: {
  atoms: RhachetBrainAtom[];
  ref: RefByUnique<typeof RhachetBrainAtom>;
}): RhachetBrainAtom => {
  // fail fast if no atoms available
  if (input.atoms.length === 0)
    throw new BadRequestError('no atoms available in context', {
      ref: input.ref,
    });

  // lookup atom by ref
  const atomFound = input.atoms.find(
    (a) => a.repo === input.ref.repo && a.slug === input.ref.slug,
  );

  // fail if not found
  if (!atomFound)
    throw new BadRequestError('brain atom not found', { ref: input.ref });

  return atomFound;
};
```


### 3.3 findBrainReplByRef

```typescript
// src/domain.operations/context/findBrainReplByRef.ts

import { BadRequestError } from 'helpful-errors';
import type { RefByUnique } from 'domain-objects';

import type { RhachetBrainRepl } from '../../domain.objects/RhachetBrainRepl';

/**
 * .what = finds a brain repl by its unique reference
 * .why = enables lookup of registered repls by { repo, slug }
 */
export const findBrainReplByRef = (input: {
  repls: RhachetBrainRepl[];
  ref: RefByUnique<typeof RhachetBrainRepl>;
}): RhachetBrainRepl => {
  // fail fast if no repls available
  if (input.repls.length === 0)
    throw new BadRequestError('no repls available in context', {
      ref: input.ref,
    });

  // lookup repl by ref
  const replFound = input.repls.find(
    (r) => r.repo === input.ref.repo && r.slug === input.ref.slug,
  );

  // fail if not found
  if (!replFound)
    throw new BadRequestError('brain repl not found', { ref: input.ref });

  return replFound;
};
```


### 3.4 castBriefsToPrompt

```typescript
// src/domain.operations/briefs/castBriefsToPrompt.ts

import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';

/**
 * .what = converts briefs artifacts to concatenated prompt text
 * .why = utility for plugin authors to easily compose briefs into system prompts
 *
 * .note = generalized from bootRoleResources logic;
 *   bootRoleResources should be refactored to use this shared utility,
 *   ensuring consistent briefs handling across boot and brain.imagine
 */
export const castBriefsToPrompt = (input: {
  briefs: Artifact<typeof GitFile>[];
}): string => {
  return input.briefs
    .map((brief) => brief.content)
    .filter(Boolean)
    .join('\n\n');
};
```


---


## 4. access.daos

no daos required for this feature - all state is in-memory and transient.

the brain context is created at runtime from plugin-provided instances and does not persist.


---


## 5. file structure

```
src/
├── domain.objects/
│   ├── RhachetBrainAtom.ts
│   ├── RhachetBrainRepl.ts
│   └── ContextRhachetBrain.ts
├── domain.operations/
│   ├── briefs/
│   │   ├── castBriefsToPrompt.ts
│   │   └── castBriefsToPrompt.test.ts
│   └── context/
│       ├── genContextRhachetBrain.ts
│       ├── genContextRhachetBrain.test.ts
│       ├── findBrainAtomByRef.ts
│       ├── findBrainAtomByRef.test.ts
│       ├── findBrainReplByRef.ts
│       └── findBrainReplByRef.test.ts
└── _topublish/
    ├── rhachet-brain-anthropic/
    │   ├── readme.md
    │   └── src/
    │       ├── atoms/
    │       │   └── brainAtomClaudeOpus.ts
    │       ├── repls/
    │       │   └── brainReplClaudeCode.ts
    │       └── index.ts
    └── rhachet-brain-openai/
        ├── readme.md
        └── src/
            ├── atoms/
            │   └── brainAtomGpt4o.ts
            ├── repls/
            │   └── brainReplCodex.ts
            └── index.ts
```


---


## 6. sdk exports

```typescript
// src/contract/sdk.ts (additions)

// domain objects
export { RhachetBrainAtom } from '../domain.objects/RhachetBrainAtom';
export { RhachetBrainRepl } from '../domain.objects/RhachetBrainRepl';
export { ContextRhachetBrain } from '../domain.objects/ContextRhachetBrain';

// domain operations
export { genContextRhachetBrain } from '../domain.operations/context/genContextRhachetBrain';
export { castBriefsToPrompt } from '../domain.operations/briefs/castBriefsToPrompt';
```
