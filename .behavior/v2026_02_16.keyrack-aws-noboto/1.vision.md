# vision: keyrack aws sso with portal flow (not programmatic flow)

## domain terms

### portal flow (human flow)
- browser prompt: standard "Sign in" / "Allow"
- no oauth client registration
- same experience as direct visit to `d-xxxxxxxxxx.awsapps.com/start`
- what humans see when they manually signin to aws

### programmatic flow (boto flow)
- browser prompt: "Allow access to botocore-client-{name}?"
- registers oauth client via `register_client` api
- client name = `botocore-client-{session-name}`
- what programmatic tools use for automated token refresh

## the goal

keyrack must use **portal flow** for unlock. first-time setup triggers one-time OAuth registration (unavoidable), but all subsequent unlocks use portal flow.

## pit of success: roundtrip validation at set

### the insight

the "botocore-client" OAuth prompt is a **one-time registration** per sso-session. once approved, all subsequent unlocks use portal flow.

### the pit of success

`keyrack set` validates the full roundtrip before success:

```
keyrack set
├── 1. vault.set(slug, value)     → store the key
├── 2. vault.unlock({ slug })     → triggers one-time OAuth registration
├── 3. vault.get({ slug })        → prove retrirhachet completion --setupworks
└── 4. vault.relock({ slug })     → clear session, leave locked
```

this guarantees:
- OAuth registration happens at setup (user expects prompts at setup)
- any misconfiguration fails fast at setup, not at unlock time
- future `keyrack unlock` uses portal flow (no botocore mention)

### this applies to ALL vaults

the roundtrip validation is NOT specific to aws.iam.sso — keyrack set does this for EVERY vault adapter. if `keyrack set` succeeds, the key is guaranteed to work.

## ground truth

### fact 1: config format does NOT determine flow

declastruct-aws uses sso-session config format:
```ini
[sso-session ehmpathy.demo.admin]
sso_start_url = https://d-xxxxxxxx.awsapps.com/start
sso_region = us-east-1
sso_registration_scopes = sso:account:access

[profile ehmpathy.demo.admin]
sso_session = ehmpathy.demo.admin
sso_account_id = xxxxxxxxx
sso_role_name = AdministratorAccess
region = us-east-1
```

yet `aws sso login --profile ehmpathy.demo.admin` uses **portal flow** by default.

**conclusion**: the sso-session config format does NOT trigger programmatic flow.

### fact 2: default cli behavior uses portal flow

`aws sso login --profile $name` → portal flow (regardless of config format)

### fact 3: explicit `--sso-session` flag triggers programmatic flow (hypothesis)

`aws sso login --sso-session $name` → programmatic flow (botocore-client-*)

this is the suspected culprit for the broken behavior.

### what keyrack must do

always use `aws sso login --profile $name`, never `aws sso login --sso-session $name`

## the outcome world

### before/after contrast

**before (no roundtrip validation):**
```
$ rhx keyrack set --key AWS_PROFILE --env test --vault aws.iam.sso
  → stores key, no validation
  → user: "cool, done"

$ rhx keyrack unlock --env test
  → browser: "Allow access to botocore-client-{name}?"
  → user: "wtf is botocore-client? i didn't expect this!"
  → user: "is this sketchy? who registered an oauth client?"
```

**after (roundtrip validation at set):**
```
$ rhx keyrack set --key AWS_PROFILE --env test --vault aws.iam.sso
  → browser: "Allow access to botocore-client-{name}?" (one-time, at setup)
  → user: "ok, setup prompts make sense"
  → roundtrip validated, key stored

$ rhx keyrack unlock --env test
  → browser: standard "Sign in" / "Allow" (portal flow)
  → user: "cool, just regular sso signin"
```

### the "aha" moment

"prompts at setup make sense. prompts at unlock should be simple. keyrack delivers exactly that."

## user experience

### setup flow (`rhx keyrack set`)

1. user runs `rhx keyrack set --key AWS_PROFILE --env test --vault aws.iam.sso`
2. keyrack prompts for sso start url (or picks from known urls)
3. keyrack creates temp profile for auth
4. keyrack runs `aws sso login --profile keyrack-temp` (portal flow)
5. browser opens → standard aws sso signin
6. user clicks "allow" → no botocore mention
7. keyrack lists accounts/roles
8. user picks account + role
9. keyrack writes permanent profile to `~/.aws/config` (sso-session format)
10. keyrack stores profile name in vault

### unlock flow (`rhx keyrack unlock`)

1. user runs `rhx keyrack unlock`
2. keyrack checks each aws.iam.sso profile
3. for each expired session:
   - keyrack runs `aws sso login --profile $profileName`
   - browser opens → standard aws sso signin
   - user clicks "allow"
4. all profiles refreshed

### both flows use same auth experience

the user sees identical browser prompts whether they're:
- first time setup (new profile)
- re-auth (expired session)

just normal aws sso signin. zero boto clients.

## mental model

### how users would describe it

"keyrack lets me store which aws profile to use, and when i need to signin it just opens aws sso like normal."

### analogies

- like a keychain that remembers which key goes to which door
- when you need to unlock a door, it just opens the normal lock
- no weird oauth apps, no api clients, just... the lock

## evaluation

### pros

- familiar user experience
- no oauth client confusion
- no "botocore-client-xyz" in browser
- works exactly like manual aws sso signin

### cons

- tokens expire naturally (no automatic background refresh)

### why this is acceptable

keyrack's design:
- `unlock` command handles explicit refresh
- user triggers auth when needed
- no surprise browser popups
- expiration is a feature, not a bug

## sources

- [aws cli sso configuration](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html)
- [aws cli sso login reference](https://docs.aws.amazon.com/cli/latest/reference/sso/login.html)
- [aws cli pkce authorization announcement](https://aws.amazon.com/blogs/developer/aws-cli-adds-pkce-based-authorization-for-sso/)
