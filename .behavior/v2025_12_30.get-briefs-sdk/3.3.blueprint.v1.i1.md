# blueprint: `getRoleBriefs` SDK procedure

## summary

expose an SDK procedure `getRoleBriefs` that finds and returns briefs as `Artifact<typeof GitFile>[]` from linked role directories. enables role composition by allowing procedures to programmatically access briefs from other linked roles.

---

## blackbox criteria satisfied

- usecase.1 = get briefs by name for a linked role ✓
- usecase.2 = disambiguate roles with same name across registries ✓
- usecase.3 = handle missing or unlinked roles ✓
- usecase.4 = handle missing briefs ✓
- usecase.5 = compose roles using briefs from other roles ✓

---

## implementation plan

### 1. create domain operation: `getRoleBriefs.ts`

**path**: `src/domain.operations/role/getRoleBriefs.ts`

**contract**:
```ts
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';

/**
 * .what = finds and returns briefs from a linked role directory as lazy-loadable artifacts
 * .why = enables role composition by allowing procedures to programmatically access briefs
 *
 * .note = this procedure looks into `.agent/*` directories for linked roles.
 *         if you just wrote a brief in the repo the role is defined in,
 *         you must run `npm run build && npx rhachet role link` before it can be used.
 */
export const getRoleBriefs = async (input: {
  by: {
    role: { name: string };
    repo?: { name: string };
    briefs: { name?: string[]; glob?: string };
  };
}): Promise<Artifact<typeof GitFile>[]>
```

**behavior**:
1. scan `.agent/repo=*/role=*/` directories for matching role name
2. if `repo.name` provided, filter to only that repo
3. if multiple roles match and no repo filter → throw ambiguous role error
4. if zero roles match → throw role not found error
5. resolve briefs path: `.agent/repo=$repo/role=$role/briefs/`
6. if briefs dir doesn't exist → throw unlinked error with hint about `npm run build && npx rhachet role link`
7. match briefs:
   - if `briefs.name[]` provided: find exact matches, throw if any not found
   - if `briefs.glob` provided: find all matches via glob pattern
8. return `Artifact<typeof GitFile>[]` via `genArtifactGitFile({ uri })`

**pattern reference**: follows `bootRoleResources.ts` for directory traversal, `genArtifactGitFile` from `rhachet-artifact-git` for artifact creation

---

### 2. implementation details

**directory scanning**:
```ts
import { existsSync, readdirSync } from 'node:fs';
import { resolve } from 'node:path';

// scan .agent/ for repo=*/role=* directories
const dirAgent = resolve(process.cwd(), '.agent');
if (!existsSync(dirAgent)) {
  throw new BadRequestError('no .agent directory found. run `npx rhachet roles link` first.');
}

const dirsRepo = readdirSync(dirAgent)
  .filter((d) => d.startsWith('repo='))
  .map((d) => ({ slug: d.replace('repo=', ''), path: resolve(dirAgent, d) }));
```

**role matching**:
```ts
interface RoleLinked {
  slugRepo: string;
  slugRole: string;
  pathRole: string;
  pathBriefs: string;
}

const rolesMatching: RoleLinked[] = [];

for (const dirRepo of dirsRepo) {
  // filter by repo if specified
  if (input.by.repo?.name && dirRepo.slug !== input.by.repo.name) continue;

  const dirsRole = readdirSync(dirRepo.path)
    .filter((d) => d.startsWith('role='))
    .filter((d) => d.replace('role=', '') === input.by.role.name);

  for (const dirRole of dirsRole) {
    const pathRole = resolve(dirRepo.path, dirRole);
    rolesMatching.push({
      slugRepo: dirRepo.slug,
      slugRole: input.by.role.name,
      pathRole,
      pathBriefs: resolve(pathRole, 'briefs'),
    });
  }
}
```

**ambiguity handling**:
```ts
if (rolesMatching.length === 0) {
  throw new BadRequestError(
    `role "${input.by.role.name}" not found in .agent/ directory. did you forget to \`npx rhachet roles link --role ${input.by.role.name}\`?`,
  );
}

if (rolesMatching.length > 1) {
  const locations = rolesMatching.map((r) => `  - repo=${r.slugRepo}`).join('\n');
  throw new BadRequestError(
    `multiple roles found with name "${input.by.role.name}":\n${locations}\n\nuse by.repo.name to disambiguate`,
  );
}

const roleLinked = rolesMatching[0]!;
```

**unlinked check**:
```ts
if (!existsSync(roleLinked.pathBriefs)) {
  throw new BadRequestError(
    `briefs directory not found for role "${roleLinked.slugRole}" in repo="${roleLinked.slugRepo}". ` +
    `did you forget to \`npx rhachet roles link --role ${roleLinked.slugRole}\`? ` +
    `(if you just wrote a brief, run: npm run build && npx rhachet roles link)`,
  );
}
```

**brief matching with glob**:
```ts
import { glob } from 'glob';
import { genArtifactGitFile } from 'rhachet-artifact-git';

const pathsBrief: string[] = [];

if (input.by.briefs.name?.length) {
  // exact name matching
  for (const name of input.by.briefs.name) {
    const pathsMatching = await glob(`**/${name}*`, { cwd: roleLinked.pathBriefs, absolute: true });
    if (pathsMatching.length === 0) {
      throw new BadRequestError(
        `brief "${name}" not found in role "${roleLinked.slugRole}" (repo="${roleLinked.slugRepo}")`,
      );
    }
    pathsBrief.push(...pathsMatching);
  }
} else if (input.by.briefs.glob) {
  // glob pattern matching
  const pathsMatching = await glob(input.by.briefs.glob, { cwd: roleLinked.pathBriefs, absolute: true });
  // empty array is valid for glob (no error)
  pathsBrief.push(...pathsMatching);
}

// dedupe and create artifacts
const pathsUnique = [...new Set(pathsBrief)];
return pathsUnique.map((uri) => genArtifactGitFile({ uri }));
```

---

### 3. export from SDK

**modify**: `src/contract/sdk.ts`

add export:
```ts
export { getRoleBriefs } from '@src/domain.operations/role/getRoleBriefs';
```

---

## file changes summary

| file | action |
|------|--------|
| `src/domain.operations/role/getRoleBriefs.ts` | create |
| `src/domain.operations/role/getRoleBriefs.test.ts` | create |
| `src/contract/sdk.ts` | modify (add export) |

---

## test scenarios

```ts
// src/domain.operations/role/getRoleBriefs.test.ts

given('[case1] role is linked with briefs', () => {
  when('[t0] getRoleBriefs with role name and brief names', () => {
    then('returns Artifact<typeof GitFile>[] for matching briefs')
  })
  when('[t1] getRoleBriefs with role name and glob pattern', () => {
    then('returns Artifact<typeof GitFile>[] for all matching briefs')
  })
  when('[t2] getRoleBriefs with glob pattern that matches nothing', () => {
    then('returns empty array')
  })
})

given('[case2] multiple roles with same name across repos', () => {
  when('[t0] getRoleBriefs with role name only', () => {
    then('throws error indicating ambiguous role match')
  })
  when('[t1] getRoleBriefs with role name and repo filter', () => {
    then('returns briefs from specified repo only')
  })
})

given('[case3] role not found', () => {
  when('[t0] getRoleBriefs with nonexistent role name', () => {
    then('throws error indicating role not found')
  })
})

given('[case4] role exists but briefs directory missing', () => {
  when('[t0] getRoleBriefs', () => {
    then('throws error with hint about npm run build && npx rhachet role link')
  })
})

given('[case5] brief name not found', () => {
  when('[t0] getRoleBriefs with nonexistent brief name', () => {
    then('throws error indicating brief not found for that role')
  })
})
```

---

## example usage

from the vision:

```ts
const imagineBehaviorMeasuredGain = async (input, context) => {
  // get the briefs for measurement from this role
  const briefs = await getRoleBriefs({
    by: {
      repo: { name: 'bhuild' },
      role: { name: 'behaver' },
      briefs: { glob: 'measure/*' },
    },
  });

  // and ask the brain.repl to measure based on those briefs
  const imagined = context.brain.repl.imagine(
    { prompt, role: { briefs } },
    context,
  );

  // ...
};
```

the `getRoleBriefs` call finds briefs from `.agent/repo=bhuild/role=behaver/briefs/` matching the glob and returns `Artifact<typeof GitFile>[]`.

---

## dependencies

- uses: `glob`, `rhachet-artifact-git`, `helpful-errors`, `node:fs`, `node:path`
- glob package already in dependencies (used elsewhere in codebase)

---

## compatibility

- fully backwards compatible (new SDK export, no changes to prior behavior)
- follows patterns from existing role operations
