wish =

we want to support multistep .ask() and .act() on BrainAtom and BrainRepl interfaces


specifically,

the ability to { continue: RefByUnique<typeof BrainSession> }

where BrainSession's unique key = { exid }

---

we should track down whether each of the main brain suppliers supports an idempotency key input to define a session (e.g., exid)

or whether some of them supply only readonly session identifiers (in which case, we'd need to pivot to RefByPrimary and have exid be the primary key)


---

ultimately, we want to be able to say something like


const { session, output } = brain.ask({ say: 'you are a reviewer. here are the rules you should review content with. reply with { understood: true } if you understood`})

and then say

brain.ask({ on: { session }, say: 'review the content below. report all the blockers and nitpicks, ${content}' })


---

note
- a session is part of a thread, but is different
  - threads are a history that we keep.
  - threads can span multiple sessions. (could ahve invoked independent sessions or resumed sessions, or mixed)
  - sessions are a history that the brain provider keeps.

e.g., each time you pause a repl or make an new disjoint request, its a new session

and you can do that to thread a thought route over and over
- independently as "what is a cat" ->  Artifact<Brief<'cat'>> from sessionA
- independently ask "what is a dog" -> Artifact<Brief<'dog'>> from sessionB
- then, independently give a session C both artifacts, and ask -> "what is a pet"

or, you can thread a thought route via one session
- start the session with "what is a cat"
- extend with "what is a dog"
- complete with "what is a pet"

both threads will lead to very different answers

from the navigators side, each thread is a one atomic chain of thought, spread across multiple brains or within one brain.

from the brains side, they're very different chains of thought.

---

we'll want to make brief on this to relate it to the current Thread entity we already have

eventually, these will connect explicitly via typedef boundaries

for now, just conceptually for consistency and broader perspective


---

e.g.,

BrainSession = brains perspective on thought events
Thread = navigators perspective on thought events


----

update: prefer the domain.terms distilled in .behavior/v2026_01_23.brain-continue/3.1.research.domain.terms.v1.i4.choice.md


---

update, per .agent/repo=.this/role=any/briefs/domain.thought/define.term.brain.episodes.md

it looks like BrainRepl's will need to support continuation on both PickOne<{ episode: BrainEpisode, series: BrainSeries }>

---

update: use `on:` instead of `in:` for continuation — episodes and series are timelines you build upon, not containers you enter


----

note: immutability is a firm contract requirement now

exchanges are immutable
episodes are immutable
sessions are immutable

outputs are always new instances

this enables safe composition and restoration (branches, revivals, persistance, etc)

---

for now, callers can design their own persistance mechanisms as desired (caches, serialization, etc)

if a generally useful pattern emerges, we can lift it into rhachet later


----

also, its possible that not every brain supplier will have the capcity to support continuation

in cases that they dont, thats no big deal, they can fail fast

given we require emission of episodes && series on response,
- callers can manually persist the emitted responses && replace the unsupported brain and resume with a supported brain
- contexts can, on behalf of callers, emit these responses into logs to persist by default to enable recovery by default

so, it still supports a pit of success even if some brains have limited capabilities

---

update: episodes and series are self-contained domain literals

key insight: no external state to look up or expire

- episodes and series carry their own data (exchanges, compaction summaries)
- they have content-derived hashes for identity (readonly, cannot be set)
- brain suppliers receive the full context as plaintext on continuation
- no need for supplier-side idempotency keys or session storage
- "invalid reference" or "expired" errors don't apply — the data is in the literal itself

this simplifies the model:
- callers hold the full state
- suppliers are stateless (just receive context and respond)
- cross-supplier continuation is trivial (same plaintext works everywhere)
