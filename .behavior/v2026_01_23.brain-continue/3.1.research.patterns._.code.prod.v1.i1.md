# production codepath patterns research: brain-continue

research into prod patterns relevant to brain-continue implementation (BrainExchange, BrainEpisode, BrainSeries)

---

## 1. domain literal patterns

### [REUSE] DomainLiteral base class

the codebase uses `DomainLiteral` from `domain-objects` for all immutable value types.

> "extends `DomainLiteral` for hash-based immutability" [1]

```typescript
// Thread.ts:28-30
export class Thread<TThreadContext>
  extends DomainLiteral<Thread<TThreadContext>>
  implements Thread<TThreadContext> {}
```

```typescript
// StitchSetEvent.ts:27-29
export class StitchSetEvent<TThreads extends Threads<any, 'single'>, TOutput>
  extends DomainLiteral<StitchSetEvent<TThreads, TOutput>>
  implements StitchSetEvent<TThreads, TOutput> {}
```

```typescript
// StitchTrailMarker.ts:8-10
export class StitchTrailMarker
  extends DomainLiteral<StitchTrailMarker>
  implements StitchTrailMarker {}
```

**application to brain-continue:**
- BrainExchange extends DomainLiteral
- BrainEpisode extends DomainLiteral
- BrainSeries extends DomainLiteral
- hash derived from content via DomainLiteral mechanics

---

### [REUSE] immutable state via .clone()

state transitions use `.clone({ field: newValue })` pattern, never mutation.

> "create new thread state immutably via `.clone({ stitches: [...before, new] })`" [2]

```typescript
// enstitch.ts:117-124
const stitcheeBefore = Thread.build(
  getStitchee(
    input.threads[stitcheeKey] ??
      UnexpectedCodePathError.throw(
        'could not find stitchee from input.threads',
      ),
  ),
);
const stitcheeAfter = stitcheeBefore.clone({
  stitches: [...stitcheeBefore.stitches, stitch], // append the latest stitch
});
```

**application to brain-continue:**
- BrainEpisode returns NEW instance via `.clone({ exchanges: [...prior, newExchange] })`
- BrainSeries returns NEW instance via `.clone({ episodes: [...prior, newEpisode] })`
- prior references remain valid and unchanged

---

### [REUSE] array spread for append

arrays are spread-appended, never mutated via push/splice.

```typescript
// withStitchTrail.ts:64
trail: [...(context.stitch.trail ?? []), stitchTrailMarker], // append the trail marker
```

```typescript
// enstitch.ts:121
stitches: [...stitcheeBefore.stitches, stitch], // append the latest stitch
```

**application to brain-continue:**
- BrainEpisode.exchanges: `[...prior.exchanges, newExchange]`
- BrainSeries.episodes: `[...prior.episodes, newEpisode]`

---

## 2. brain interface patterns

### [EXTEND] BrainAtom.ask() contract

current BrainAtom.ask() returns `Promise<BrainOutput<TOutput>>`.

```typescript
// BrainAtom.ts:44-55
ask: <TOutput>(
  input: {
    plugs?: BrainAtomPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
) => Promise<BrainOutput<TOutput>>;
```

**extension for brain-continue:**
- add `on?: { episode: BrainEpisode }` to input
- return `{ episode: BrainEpisode; output: TOutput }` instead of just `BrainOutput<TOutput>`
- episode contains the exchange(s) from this call plus any prior exchanges

---

### [EXTEND] BrainRepl.ask() and .act() contracts

current BrainRepl has ask() and act() with same signature pattern as BrainAtom.

```typescript
// BrainRepl.ts:45-56
ask: <TOutput>(
  input: {
    plugs?: BrainReplPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
) => Promise<BrainOutput<TOutput>>;

// BrainRepl.ts:66-77
act: <TOutput>(
  input: {
    plugs?: BrainReplPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
) => Promise<BrainOutput<TOutput>>;
```

**extension for brain-continue:**
- add `on?: PickOne<{ episode: BrainEpisode; series: BrainSeries }>` to input
- return `{ series: BrainSeries; episode: BrainEpisode; output: TOutput }`
- series tracks episodes across compaction boundaries
- episode tracks exchanges within current context window

---

## 3. composition patterns

### [REUSE] StitchSetEvent return pattern

all enweave operations return `StitchSetEvent` that contains both the output and updated state.

```typescript
// StitchSetEvent.ts:8-26
export interface StitchSetEvent<
  TThreads extends Threads<any, 'single'>,
  TOutput,
> {
  /**
   * .what = when the stitch was set
   */
  occurredAt: IsoTimeStamp;

  /**
   * .what = the stitch which was set
   */
  stitch: Stitch<TOutput>;

  /**
   * .what = the threads it was set with
   */
  threads: TThreads;
}
```

**application to brain-continue:**
- BrainAtom.ask() returns `{ episode, output }` (similar pattern)
- BrainRepl.ask() returns `{ series, episode, output }` (similar pattern)
- each call returns the current state alongside the output

---

### [REUSE] sequential composition via enweaveOneRoute

sequential execution threads state immutably through pipeline.

```typescript
// enweaveOneRoute.ts:22-46
export const enweaveOneRoute = withStitchTrail(
  async <TStitcher extends GStitcher>(
    input: {
      stitcher: StitchRoute<TStitcher>;
      threads: TStitcher['threads'];
    },
    context: TStitcher['context'],
  ): Promise<StitchSetEvent<TStitcher['threads'], TStitcher['output']>> => {
    // track the latest state of the threads
    let threadsNow: TStitcher['threads'] = input.threads;

    // track the last output
    let outputNow: any = null;

    // for each stitcher in the route.sequence, execute it one by one
    for (const stitcher of input.stitcher.sequence) {
      // execute the stitcher
      const { stitch, threads } = await enweaveOneStitcher(
        { stitcher, threads: threadsNow },
        context,
      );

      // update the latest states
      threadsNow = threads; // enables subsequent stitchers to leverage prior results
      outputNow = stitch;
    }

    // return the results
    return StitchSetEvent.build({
      occurredAt: asIsoTimeStamp(new Date()),
      stitch: outputNow,
      threads: threadsNow,
    });
  },
);
```

**application to brain-continue:**
- episode continuation chains exchanges sequentially
- series continuation chains episodes sequentially
- each step receives prior state and returns new state

---

### [REUSE] parallel composition via enweaveOneFanout

parallel execution with fanin for consensus patterns.

```typescript
// enweaveOneFanout.ts:28-42
// enweave parallel stitchers concurrently
const fanoutResults = await Promise.all(
  parallels.map((stitcher) =>
    enweaveOneStitcher({ stitcher, threads: input.threads }, context),
  ),
);

// merge fanout results into grouped threads by role
const threadsAfterFanout = fanoutResults.reduce(
  (acc, result) => {
    for (const role of Object.keys(
      result.threads,
    ) as (keyof TStitcher['threads'])[]) {
      const thread = result.threads[role]!;

      if (!acc[role]) acc[role] = { seed: input.threads[role]!, peers: [] };
      acc[role]!.peers.push(thread);
    }

    return acc;
  },
  // ...
);
```

**application to brain-continue:**
- fanout from saved episode: branch to multiple parallel paths
- each branch receives same episode as start point
- each branch returns independent episode reference
- enables consensus patterns across suppliers

---

## 4. thread/context patterns

### [REUSE] Thread with accumulated history

Thread accumulates stitches as exchanges occur.

```typescript
// Thread.ts:8-28
export interface Thread<TThreadContext> {
  /**
   * the context accumulated for this thread so far
   */
  context: TThreadContext;

  /**
   * .what = the stitches that were executed with this thread so far
   */
  stitches: Stitch<any>[];

  /**
   * .what = the history that produced the state of this thread
   * .note =
   *   - history should only be used for observability
   *   - should expect it to be optional, (e.g., only in prep environments, rarely in prod)
   */
  history?: StitchSetEvent<any, any>[];
}
```

**application to brain-continue:**
- BrainEpisode.exchanges parallels Thread.stitches (ordered list of accumulated items)
- BrainSeries.episodes parallels the concept of chained threads
- history is optional for observability (similar pattern)

---

### [REUSE] context spread for immutable updates

context is spread-updated, never mutated.

```typescript
// withStitchTrail.ts:70-72
return await logic(input, {
  ...context,
  ...stitchTrailContextNow,
});
```

**application to brain-continue:**
- context flows through brain invocations immutably
- each operation receives prior context and returns new context

---

### [REUSE] StitchTrail for continuation identity

StitchTrail provides audit trail to trace execution.

```typescript
// StitchTrail.ts:6-12
export interface StitchTrailMarker {
  stitchUuid: string;
  stitcherSlug: string;
}
export class StitchTrailMarker
  extends DomainLiteral<StitchTrailMarker>
  implements StitchTrailMarker {}
```

```typescript
// StitchTrail.ts:26-35
export const asStitchTrailDesc = (input: {
  trail: StitchTrail;
}): StitchTrailDesc => {
  return input.trail
    .map(
      (marker) => `@${marker.stitcherSlug}(${marker.stitchUuid.slice(0, 7)})`,
    )
    .join(' > ');
};
```

**application to brain-continue:**
- BrainExchange.hash provides identity for each exchange
- BrainEpisode.hash provides identity for episode checkpoints
- BrainSeries.hash provides identity for series checkpoints

---

## 5. unique/primary key patterns

### [REUSE] DomainEntity with unique keys

BrainAtom and BrainRepl use `unique = ['repo', 'slug']` pattern.

```typescript
// BrainAtom.ts:57-59
export class BrainAtom extends DomainEntity<BrainAtom> implements BrainAtom {
  public static unique = ['repo', 'slug'] as const;
}
```

```typescript
// BrainRepl.ts:79-81
export class BrainRepl extends DomainEntity<BrainRepl> implements BrainRepl {
  public static unique = ['repo', 'slug'] as const;
}
```

**application to brain-continue:**
- BrainExchange: hash is content-derived (readonly), exid is supplier-assigned (readonly, optional)
- BrainEpisode: hash is content-derived (readonly)
- BrainSeries: hash is content-derived (readonly)
- no external lookup by unique key — identity is in the content itself

---

## 6. error patterns

### [REUSE] UnexpectedCodePathError for invariant violations

```typescript
// enstitch.ts:85-89
// otherwise, unsupported and unexpected
throw new UnexpectedCodePathError(
  'why did we get an unsupported stitcher.form?',
  { stitcher: input.stitcher },
);
```

**application to brain-continue:**
- continuation not supported error: `UnexpectedCodePathError.throw('continuation not supported', { priorEpisode })`
- compacted episode error: `UnexpectedCodePathError.throw('episode has been compacted', { episode, suggestion: 'continue via series' })`

---

## 7. serialization patterns

### [REUSE] DomainLiteral serialization

DomainLiteral provides built-in serialization via `serialize()` from domain-objects.

**application to brain-continue:**
- episodes serialize exchanges to plaintext for cross-supplier transfer
- series serialize episodes + compaction summaries
- any supplier can deserialize and continue

---

## citations

[1] src/domain.objects/Thread.ts:28-30 — Thread extends DomainLiteral
[2] src/domain.operations/stitch/enstitch.ts:117-124 — immutable state via .clone()
[3] src/domain.operations/stitch/withStitchTrail.ts:64 — array spread pattern
[4] src/domain.objects/BrainAtom.ts:44-55 — BrainAtom.ask() signature
[5] src/domain.objects/BrainRepl.ts:45-56, 66-77 — BrainRepl.ask() and .act() signatures
[6] src/domain.objects/StitchSetEvent.ts:8-26 — StitchSetEvent structure
[7] src/domain.operations/weave/enweaveOneRoute.ts:22-46 — sequential composition
[8] src/domain.operations/weave/enweaveOneFanout.ts:28-42 — parallel composition
[9] src/domain.objects/Thread.ts:8-28 — Thread with accumulated history
[10] src/domain.operations/stitch/withStitchTrail.ts:70-72 — context spread pattern
[11] src/domain.objects/StitchTrail.ts:6-35 — StitchTrail for continuation identity
[12] src/domain.objects/BrainAtom.ts:57-59 — unique key pattern
[13] src/domain.operations/stitch/enstitch.ts:85-89 — UnexpectedCodePathError pattern

---

## summary

| pattern | marker | application |
|---------|--------|-------------|
| DomainLiteral base | [REUSE] | BrainExchange, BrainEpisode, BrainSeries all extend DomainLiteral |
| immutable .clone() | [REUSE] | state transitions create new instances via .clone() |
| array spread append | [REUSE] | exchanges/episodes appended via spread, never mutated |
| BrainAtom.ask() | [EXTEND] | add `on: { episode }` input, return `{ episode, output }` |
| BrainRepl.ask()/act() | [EXTEND] | add `on: PickOne<{ episode, series }>`, return `{ series, episode, output }` |
| StitchSetEvent return | [REUSE] | return pattern with state + output |
| sequential composition | [REUSE] | episode/series continuation chains state through |
| parallel composition | [REUSE] | fanout from saved episode for consensus patterns |
| Thread.stitches | [REUSE] | BrainEpisode.exchanges parallels accumulated list pattern |
| context spread | [REUSE] | context flows immutably through operations |
| StitchTrail identity | [REUSE] | hash provides content-based identity |
| unique key pattern | [REUSE] | hash is content-derived, readonly |
| UnexpectedCodePathError | [REUSE] | error contracts for invariant violations |
| DomainLiteral serialization | [REUSE] | cross-supplier transfer via plaintext serialization |
