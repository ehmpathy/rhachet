# brain-continue: implementation roadmap

## .overview

checklist-style roadmap for brain-continue feature per blueprint `3.3.blueprint.v1.i1.md`.

phases are ordered by dependency. each phase has:
- prerequisites (briefs to read)
- deliverables (files to create/modify)
- acceptance criteria (behavioral tests)
- verification (how to confirm done)

---

## phase 1: domain.objects (foundation)

### 1.1 prerequisites

read before start:
- [ ] `3.1.research.patterns._.code.prod.v1.i1.md` — DomainLiteral pattern, immutable .clone()
- [ ] `3.2.distill.domain._.v1.i1.md` — domain object contracts
- [ ] `2.criteria.blueprint.md` — subcomponent contracts for BrainExchange, BrainEpisode, BrainSeries

### 1.2 deliverables

- [ ] `src/domain.objects/BrainExchange.ts`
  ```ts
  interface BrainExchange {
    hash: string;           // content-derived identity
    input: string;          // user prompt
    output: string;         // brain response
    exid: string | null;    // supplier's exchange id (opaque)
  }
  class BrainExchange extends DomainLiteral<BrainExchange> {}
  ```

- [ ] `src/domain.objects/BrainEpisode.ts`
  ```ts
  interface BrainEpisode {
    hash: string;                    // content-derived identity
    exchanges: BrainExchange[];      // ordered exchanges in this episode
    epid: string | null;             // supplier's episode id (opaque)
  }
  class BrainEpisode extends DomainLiteral<BrainEpisode> {}
  ```

- [ ] `src/domain.objects/BrainSeries.ts`
  ```ts
  interface BrainSeries {
    hash: string;                    // content-derived identity
    episodes: BrainEpisode[];        // ordered episodes in this series
    srid: string | null;             // supplier's series id (opaque)
  }
  class BrainSeries extends DomainLiteral<BrainSeries> {}
  ```

- [ ] `src/domain.objects/BrainChoiceSlug.ts`
  ```ts
  type BrainChoiceSlug = 'atom' | 'repl';
  ```

- [ ] export all from `src/domain.objects/index.ts` (if barrel exists) or individual exports

### 1.3 acceptance criteria

| id | criterion | verification |
|----|-----------|--------------|
| obj.1 | BrainExchange is DomainLiteral with hash, input, output, exid | `new BrainExchange({...})` succeeds |
| obj.2 | BrainEpisode is DomainLiteral with hash, exchanges[], epid | `new BrainEpisode({...})` succeeds |
| obj.3 | BrainSeries is DomainLiteral with hash, episodes[], srid | `new BrainSeries({...})` succeeds |
| obj.4 | all objects are immutable (no .updatable fields) | `.clone()` returns new instance |
| obj.5 | BrainChoiceSlug discriminates atom vs repl | type-only assertion in tests |

### 1.4 verification

```sh
npm run test:types  # type definitions compile
npm run test:unit -- BrainExchange.test.ts
npm run test:unit -- BrainEpisode.test.ts
npm run test:unit -- BrainSeries.test.ts
```

- [ ] all tests pass
- [ ] no type errors

---

## phase 2: domain.operations (factories + hash)

### 2.1 prerequisites

read before start:
- [ ] `3.1.research.patterns._.code.prod.v1.i1.md` — factory patterns, hash computation
- [ ] `3.3.blueprint.v1.i1.md` section 2.2/2.3 — narrative codepaths for gen* operations
- [ ] phase 1 complete (domain.objects exist)

### 2.2 deliverables

- [ ] `src/domain.operations/brain/computeBrainExchangeHash.ts`
  ```ts
  export const computeBrainExchangeHash = (input: {
    input: string;
    output: string;
  }): string => { /* sha256 of canonical content */ }
  ```

- [ ] `src/domain.operations/brain/computeBrainEpisodeHash.ts`
  ```ts
  export const computeBrainEpisodeHash = (input: {
    exchanges: BrainExchange[];
  }): string => { /* sha256 of exchange hashes */ }
  ```

- [ ] `src/domain.operations/brain/computeBrainSeriesHash.ts`
  ```ts
  export const computeBrainSeriesHash = (input: {
    episodes: BrainEpisode[];
  }): string => { /* sha256 of episode hashes */ }
  ```

- [ ] `src/domain.operations/brain/genBrainExchange.ts`
  ```ts
  export const genBrainExchange = (input: {
    with: { input: string; output: string; exid: string | null };
  }): BrainExchange => {
    const hash = computeBrainExchangeHash({ input: input.with.input, output: input.with.output });
    return new BrainExchange({ hash, ...input.with });
  }
  ```

- [ ] `src/domain.operations/brain/genBrainEpisode.ts`
  ```ts
  export const genBrainEpisode = (input: {
    on?: { episode: BrainEpisode | null };
    with: { exchange: BrainExchange; epid?: string | null };
  }): BrainEpisode => {
    const exchangesPrior = input.on?.episode?.exchanges ?? [];
    const exchanges = [...exchangesPrior, input.with.exchange];
    const hash = computeBrainEpisodeHash({ exchanges });
    return new BrainEpisode({ hash, exchanges, epid: input.with.epid ?? null });
  }
  ```

- [ ] `src/domain.operations/brain/genBrainSeries.ts`
  ```ts
  export const genBrainSeries = (input: {
    on?: { series: BrainSeries | null };
    with: { episode: BrainEpisode; srid?: string | null };
  }): BrainSeries => {
    const episodesPrior = input.on?.series?.episodes ?? [];
    const episodes = [...episodesPrior, input.with.episode];
    const hash = computeBrainSeriesHash({ episodes });
    return new BrainSeries({ hash, episodes, srid: input.with.srid ?? null });
  }
  ```

### 2.3 acceptance criteria

| id | criterion | verification |
|----|-----------|--------------|
| op.1 | genBrainExchange produces BrainExchange with content-derived hash | unit test |
| op.2 | genBrainEpisode appends exchange to prior (or fresh if null) | unit test |
| op.3 | genBrainSeries appends episode to prior (or fresh if null) | unit test |
| op.4 | same content → same hash (deterministic) | unit test with identical inputs |
| op.5 | different content → different hash | unit test with varied inputs |
| op.6 | gen* always returns NEW instance (immutability) | `episode !== genBrainEpisode({ on: { episode }, with: {...} })` |

### 2.4 verification

```sh
npm run test:unit -- computeBrainExchangeHash.test.ts
npm run test:unit -- computeBrainEpisodeHash.test.ts
npm run test:unit -- computeBrainSeriesHash.test.ts
npm run test:unit -- genBrainExchange.test.ts
npm run test:unit -- genBrainEpisode.test.ts
npm run test:unit -- genBrainSeries.test.ts
```

- [ ] all tests pass
- [ ] hash determinism verified
- [ ] immutability verified

---

## phase 3: interface extensions (contracts)

### 3.1 prerequisites

read before start:
- [ ] `2.criteria.blackbox.md` — all usecases for continuation
- [ ] `3.2.distill.domain._.v1.i1.md` — extended contracts for BrainOutput, BrainAtom, BrainRepl
- [ ] phase 2 complete (domain.operations exist)

### 3.2 deliverables

- [ ] `src/domain.objects/BrainOutput.ts` — extend with episode and series fields
  ```ts
  interface BrainOutput<T> {
    output: T;
    metrics: BrainOutputMetrics;
    episode: BrainEpisode;                              // NEW: always present
    series: BrainSeries | null;                         // NEW: null for atom, present for repl
  }
  ```

- [ ] `src/domain.objects/BrainAtom.ts` — extend .ask() signature
  ```ts
  interface BrainAtom {
    ask: <T>(input: {
      on?: { episode: BrainEpisode };                   // NEW: optional continuation
      role: RoleForBrain;
      prompt: string;
      schema: { output: ZodSchema<T> };
    }) => Promise<BrainOutput<T>>;
  }
  ```

- [ ] `src/domain.objects/BrainRepl.ts` — extend .ask() and .act() signatures
  ```ts
  interface BrainRepl {
    ask: <T>(input: {
      on?: PickOne<{                                    // NEW: optional continuation
        episode: BrainEpisode;
        series: BrainSeries;
      }>;
      role: RoleForBrain;
      prompt: string;
      schema: { output: ZodSchema<T> };
    }) => Promise<BrainOutput<T>>;

    act: <T>(input: {
      on?: PickOne<{                                    // NEW: optional continuation
        episode: BrainEpisode;
        series: BrainSeries;
      }>;
      role: RoleForBrain;
      prompt: string;
      schema: { output: ZodSchema<T> };
      tools: Tool[];
    }) => Promise<BrainOutput<T>>;
  }
  ```

### 3.3 acceptance criteria

| id | criterion | verification |
|----|-----------|--------------|
| int.1 | BrainOutput includes episode field | type assertion |
| int.2 | BrainOutput includes series field (nullable) | type assertion |
| int.3 | BrainAtom.ask accepts on.episode | type assertion |
| int.4 | BrainRepl.ask accepts PickOne<episode, series> | type assertion |
| int.5 | BrainRepl.act accepts PickOne<episode, series> | type assertion |
| int.6 | PickOne enforces exactly one of episode or series | type error on `{ episode, series }` |

### 3.4 verification

```sh
npm run test:types  # extended interfaces compile
npm run test:unit -- BrainOutput.test.ts
npm run test:unit -- BrainAtom.test.ts
npm run test:unit -- BrainRepl.test.ts
```

- [ ] type assertions pass
- [ ] PickOne constraint verified via @ts-expect-error tests

---

## phase 4: test assets (mocks)

### 4.1 prerequisites

read before start:
- [ ] `3.1.research.patterns._.code.test.v1.i1.md` — mock factory patterns (genMocked*, genSample*)
- [ ] prior patterns in `src/.test.assets/` (genMockedBrainOutputMetrics, genSampleBrainSpec)
- [ ] phase 3 complete (interfaces extended)

### 4.2 deliverables

- [ ] `src/.test.assets/genMockedBrainExchange.ts`
  ```ts
  export const genMockedBrainExchange = (input?: {
    input?: string;
    output?: string;
    exid?: string | null;
  }): BrainExchange => genBrainExchange({
    with: {
      input: input?.input ?? '__mock_input__',
      output: input?.output ?? '__mock_output__',
      exid: input?.exid ?? '__mock_exid__',
    },
  });
  ```

- [ ] `src/.test.assets/genMockedBrainEpisode.ts`
  ```ts
  export const genMockedBrainEpisode = (input?: {
    exchanges?: BrainExchange[];
    epid?: string | null;
  }): BrainEpisode => {
    const exchanges = input?.exchanges ?? [genMockedBrainExchange()];
    return new BrainEpisode({
      hash: computeBrainEpisodeHash({ exchanges }),
      exchanges,
      epid: input?.epid ?? '__mock_epid__',
    });
  };
  ```

- [ ] `src/.test.assets/genMockedBrainSeries.ts`
  ```ts
  export const genMockedBrainSeries = (input?: {
    episodes?: BrainEpisode[];
    srid?: string | null;
  }): BrainSeries => {
    const episodes = input?.episodes ?? [genMockedBrainEpisode()];
    return new BrainSeries({
      hash: computeBrainSeriesHash({ episodes }),
      episodes,
      srid: input?.srid ?? '__mock_srid__',
    });
  };
  ```

- [ ] update `src/.test.assets/genMockedBrainOutput.ts` (if found) or create
  ```ts
  export const genMockedBrainOutput = <T>(input: {
    output: T;
    episode?: BrainEpisode;
    series?: BrainSeries | null;
  }): BrainOutput<T> => new BrainOutput({
    output: input.output,
    metrics: genMockedBrainOutputMetrics(),
    episode: input.episode ?? genMockedBrainEpisode(),
    series: input.series ?? null,
  });
  ```

### 4.3 acceptance criteria

| id | criterion | verification |
|----|-----------|--------------|
| mock.1 | genMockedBrainExchange returns valid BrainExchange | unit test |
| mock.2 | genMockedBrainEpisode returns valid BrainEpisode | unit test |
| mock.3 | genMockedBrainSeries returns valid BrainSeries | unit test |
| mock.4 | genMockedBrainOutput includes episode field | unit test |
| mock.5 | mocks are composable (exchange → episode → series) | unit test |

### 4.4 verification

```sh
npm run test:unit -- genMockedBrainExchange.test.ts
npm run test:unit -- genMockedBrainEpisode.test.ts
npm run test:unit -- genMockedBrainSeries.test.ts
```

- [ ] all mock factories produce valid instances
- [ ] prior tests still pass with updated BrainOutput

---

## phase 5: acceptance tests (validation)

### 5.1 prerequisites

read before start:
- [ ] `3.1.research.patterns._.code.test.v1.i1.md` — given/when/then, useBeforeAll
- [ ] `2.criteria.blackbox.md` — all usecases to cover
- [ ] prior test patterns in `actorAsk.test.ts`, `genActor.test.ts`
- [ ] phase 4 complete (test assets available)

### 5.2 deliverables

- [ ] `src/domain.operations/brain/brainAtom.continuation.test.ts`
  - [ ] usecase.1: fresh ask returns episode with one exchange
  - [ ] usecase.2: continuation ask appends exchange to episode
  - [ ] usecase.3: continuation ask returns NEW episode (immutability)
  - [ ] usecase.4: episode hash changes when exchanges differ
  - [ ] usecase.5: episode hash stable when content identical

- [ ] `src/domain.operations/brain/brainRepl.continuation.test.ts`
  - [ ] usecase.6: fresh ask returns episode and series
  - [ ] usecase.7: continuation via episode resumes within episode
  - [ ] usecase.8: continuation via series resumes series (may compact)
  - [ ] usecase.9: series hash changes when episodes differ
  - [ ] usecase.10: compaction creates new episode, same series
  - [ ] usecase.11: PickOne enforces exactly one (type test)

- [ ] integration tests (if applicable)
  - [ ] cross-supplier continuation via hash (if suppliers support)

### 5.3 acceptance criteria

mapped from `2.criteria.blackbox.md`:

| id | criterion | test file |
|----|-----------|-----------|
| usecase.1 | fresh atom.ask → episode with 1 exchange | brainAtom.continuation.test.ts |
| usecase.2 | atom.ask on.episode → appended exchange | brainAtom.continuation.test.ts |
| usecase.3 | atom.ask returns NEW episode | brainAtom.continuation.test.ts |
| usecase.4 | atom episode hash varies with content | brainAtom.continuation.test.ts |
| usecase.5 | atom episode hash stable for same content | brainAtom.continuation.test.ts |
| usecase.6 | fresh repl.ask → episode + series | brainRepl.continuation.test.ts |
| usecase.7 | repl.ask on.episode → resumed episode | brainRepl.continuation.test.ts |
| usecase.8 | repl.ask on.series → resumed series | brainRepl.continuation.test.ts |
| usecase.9 | repl series hash varies with episodes | brainRepl.continuation.test.ts |
| usecase.10 | compaction → new episode, same series | brainRepl.continuation.test.ts |
| boundary.1 | on.episode null-safe (treated as fresh) | brainAtom.continuation.test.ts |
| boundary.2 | PickOne rejects both episode+series | brainRepl.continuation.test.ts |
| contract.1 | episode.exchanges is readonly | type test |
| contract.2 | series.episodes is readonly | type test |
| contract.3 | all gen* return NEW instance | unit tests in phase 2 |

### 5.4 verification

```sh
npm run test:unit -- brainAtom.continuation.test.ts
npm run test:unit -- brainRepl.continuation.test.ts
npm run test:integration  # if integration tests added
```

- [ ] all usecases covered
- [ ] all boundary conditions tested
- [ ] all contracts verified
- [ ] prior tests still pass

---

## phase 6: documentation (optional)

### 6.1 deliverables

- [ ] update `define.term.brain.episodes.md` with implementation details
- [ ] update `define.pattern.brain.episode.fanout_and_revive.md` with examples
- [ ] add jsdoc to all new domain.objects and domain.operations

### 6.2 verification

- [ ] briefs accurately reflect implementation
- [ ] examples compile and run

---

## .summary checklist

### foundation
- [ ] phase 1: domain.objects (BrainExchange, BrainEpisode, BrainSeries, BrainChoiceSlug)
- [ ] phase 2: domain.operations (gen*, compute*Hash)

### contracts
- [ ] phase 3: interface extensions (BrainOutput, BrainAtom, BrainRepl)

### validation
- [ ] phase 4: test assets (genMocked*)
- [ ] phase 5: acceptance tests (continuation usecases)

### polish
- [ ] phase 6: documentation (optional)

---

## .execution order

```
phase 1 (domain.objects)
    │
    ▼
phase 2 (domain.operations)
    │
    ▼
phase 3 (interface extensions)
    │
    ├──▶ phase 4 (test assets)
    │
    └──▶ phase 5 (acceptance tests)
              │
              ▼
         phase 6 (documentation)
```

phases 4 and 5 can proceed in parallel after phase 3.
