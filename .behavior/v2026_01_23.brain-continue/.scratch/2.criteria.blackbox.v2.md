# blackbox criteria: brain-continue (v2)

experience bounds for multi-exchange episodes via `.ask()` and `.act()`

---

## terms

| term | what |
|------|------|
| BrainEpisode | one continuous conversation with a brain supplier |
| BrainExchange | one request-response round-trip within an episode |
| BrainFocus | the goal + curated context the brain operates on |

---

# usecase.1 = start a fresh episode

given('a brain instance (atom or repl)')
  when('user calls .ask() without episode reference')
    then('a fresh episode is created')
      sothat('users can start new conversations')
    then('response includes episode reference')
      sothat('users can continue the episode later')
    then('response includes the brain output')
      sothat('users receive the answer to their question')

  when('user calls .act() without episode reference')
    then('a fresh episode is created')
    then('response includes episode reference')
    then('response includes the skill execution result')

---

# usecase.2 = continue a prior episode

given('an episode reference from a prior .ask() or .act() call')
  when('user calls .ask() with { in: { episode } }')
    then('the request continues the prior episode')
      sothat('the brain has context from prior exchanges')
    then('the focus evolves naturally with the new exchange')
      sothat('conversation builds on prior context')
    then('response includes the same episode reference')
      sothat('users can continue to chain requests')
    then('response includes the brain output')

  when('user calls .act() with { in: { episode } }')
    then('the request continues the prior episode')
    then('response includes the same episode reference')
    then('response includes the skill execution result')

---

# usecase.3 = fresh vs prior episode choice

given('an operation that invokes brain calls')
  when('user wants independent context per call')
    then('omit episode reference to start fresh each time')
      sothat('each call has isolated focus')

  when('user wants shared context across calls')
    then('pass episode reference to continue prior')
      sothat('focus evolves across exchanges')

---

# usecase.4 = multistep workflow with evolved focus

given('a brain enrolled with a reviewer role')
  when('user starts an episode with role instructions')
    then('response confirms the brain understood the instructions')
    then('response includes episode reference')
    then('focus is established: review per these instructions')

  when('user continues with content to review')
    then('the brain reviews content per the evolved focus')
      sothat('users can separate role setup from content to process')
    then('focus evolves: reviewed X, found Y')
    then('response includes review output')

  when('user continues with follow-up questions')
    then('the brain answers with full context of prior exchanges')
      sothat('follow-ups build on established focus')

---

# usecase.5 = episode reference shape

given('any .ask() or .act() response')
  when('user inspects the episode reference')
    then('episode has an exid property')
      sothat('users can identify episodes by external id')
    then('episode reference can be passed to subsequent calls')
      sothat('continuation is ergonomic')

---

# boundary.1 = invalid episode reference

given('an invalid or expired episode reference')
  when('user attempts to continue with that episode')
    then('error clearly indicates episode not found or expired')
      sothat('users understand what went wrong')
    then('error suggests to start a fresh episode')
      sothat('users have a recovery path')

---

# boundary.2 = episode from different brain supplier

given('an episode reference from brain supplier A')
  when('user attempts to continue on brain supplier B')
    then('error clearly indicates episode mismatch')
      sothat('users understand episodes are supplier-scoped')

---

# boundary.3 = explicit continuation with nonexistent episode

given('no prior episode exists')
  when('user calls .ask() with { in: { episode: nonExistentRef } }')
    then('error indicates episode not found')
    then('error does not create a fresh episode implicitly')
      sothat('explicit continuation fails explicitly')

---

# edge.1 = single-exchange episode continuation

given('an episode with only one prior exchange')
  when('user continues with a follow-up')
    then('the brain receives the prior exchange as context')
      sothat('even single-exchange episodes can be continued')
    then('focus evolves from the single prior exchange')

---

# edge.2 = context window capacity

given('an episode with many prior exchanges')
  when('user continues the episode')
    then('the brain receives sufficient context to respond coherently')
      sothat('long conversations remain useful')

  when('context window capacity is exceeded')
    then('compaction preserves the evolved focus')
      sothat('conversation can continue in a fresh episode')
    then('fresh episode starts with "previously on..." summary')
      sothat('focus is not lost across episodes')

---

# edge.3 = focus inference via reflection

given('an episode with several exchanges')
  when('user wants to understand the current focus')
    then('focus.concept is inferrable from exchange history')
    then('focus.context is inferrable from accumulated state')
      sothat('operators can curate focus for subsequent work')
