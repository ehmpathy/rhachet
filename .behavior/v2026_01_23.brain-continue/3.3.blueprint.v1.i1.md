# blueprint: brain-continue

implementation plan for multistep `.ask()` and `.act()` via episode and series continuation.

---

## 0. references

| ref | path | what |
|-----|------|------|
| wish | `.behavior/v2026_01_23.brain-continue/0.wish.md` | original feature request |
| vision | `.behavior/v2026_01_23.brain-continue/1.vision.md` | usecases and timelines |
| criteria.blackbox | `.behavior/v2026_01_23.brain-continue/2.criteria.blackbox.md` | experience bounds |
| criteria.blueprint | `.behavior/v2026_01_23.brain-continue/2.criteria.blueprint.md` | mechanism bounds |
| research.access | `.behavior/v2026_01_23.brain-continue/3.1.research.access._.v1.i1.md` | api research |
| research.patterns.prod | `.behavior/v2026_01_23.brain-continue/3.1.research.patterns._.code.prod.v1.i1.md` | production code patterns |
| research.patterns.test | `.behavior/v2026_01_23.brain-continue/3.1.research.patterns._.code.test.v1.i1.md` | test patterns |
| distillation | `.behavior/v2026_01_23.brain-continue/3.2.distill.domain._.v1.i1.md` | domain objects and operations |

---

## 1. filediff treestruct

```
src/
├── domain.objects/
│   ├── [+] BrainExchange.ts              # new: atomic request-response pair
│   ├── [+] BrainEpisode.ts               # new: context window of exchanges
│   ├── [+] BrainSeries.ts                # new: chain of episodes
│   ├── [+] BrainChoiceSlug.ts            # new: 'atom' | 'repl' discriminant
│   ├── [~] BrainOutput.ts                # update: add episode, series, type param
│   ├── [~] BrainAtom.ts                  # update: add on.episode to ask()
│   └── [~] BrainRepl.ts                  # update: add on.{episode,series} to ask/act
│
├── domain.operations/
│   └── brainEpisode/
│       ├── [+] genBrainExchange.ts       # factory: create exchange
│       ├── [+] genBrainExchange.test.ts  # unit test
│       ├── [+] genBrainEpisode.ts        # factory: create/extend episode
│       ├── [+] genBrainEpisode.test.ts   # unit test
│       ├── [+] genBrainSeries.ts         # factory: create/extend series
│       ├── [+] genBrainSeries.test.ts    # unit test
│       ├── [+] computeBrainExchangeHash.ts
│       ├── [+] computeBrainExchangeHash.test.ts
│       ├── [+] computeBrainEpisodeHash.ts
│       ├── [+] computeBrainEpisodeHash.test.ts
│       ├── [+] computeBrainSeriesHash.ts
│       └── [+] computeBrainSeriesHash.test.ts
│
├── .test.assets/
│   ├── [+] genMockedBrainExchange.ts     # mock factory
│   ├── [+] genMockedBrainEpisode.ts      # mock factory
│   └── [+] genMockedBrainSeries.ts       # mock factory
│
└── .test/
    └── [~] (current infra)               # no changes needed

accept.blackbox/
├── sdk/
│   ├── [+] brainAtom.continuation.acceptance.test.ts   # usecase.3,7 tests
│   └── [+] brainRepl.continuation.acceptance.test.ts   # usecase.4,5,6 tests
```

**legend:**
- `[+]` = create new file
- `[~]` = update file
- `[-]` = delete file (none in this blueprint)

---

## 2. codepath treestruct

### 2.1. rhachet wrapper codepath (thin passthrough)

```
caller
  │
  ▼
askViaBrainAtom({ atom, on?: { episode }, prompt, schema })
  │
  ▼
atom.ask({ on, prompt, schema })   # delegate to supplier
  │
  ▼
return BrainOutput<T, 'atom'>      # supplier constructs episode
```

```
caller
  │
  ▼
askViaBrainRepl({ repl, on?: { episode | series }, prompt, schema })
  │
  ▼
repl.ask({ on, prompt, schema })   # delegate to supplier
  │
  ▼
return BrainOutput<T, 'repl'>      # supplier constructs episode + series
```

rhachet wrappers remain thin — they pass `on.episode` / `on.series` to supplier and return result.

### 2.2. supplier-internal codepath (BrainAtom)

suppliers implement this internally via rhachet's exported utilities:

```
supplier.ask({ on?: { episode }, prompt, schema })
  │
  ▼
episodePrior = on?.episode ?? null
  │
  ▼
serialize episodePrior.exchanges to supplier's message format
(empty array if episodePrior is null)
  │
  ▼
invoke supplier's native api with serialized context + new prompt
  │
  ▼
genBrainExchange({ with: { input, output, exid } })
  │
  ▼
genBrainEpisode({ on: { episode: episodePrior }, with: { exchange } })
  │
  ▼
return { episode: NEW, series: null, output, metrics }
```

**key insight:** fresh episode is just `episodePrior = null`; continuation is `episodePrior = on.episode`. the flow is identical — genBrainEpisode handles both.

### 2.3. supplier-internal codepath (BrainRepl)

```
supplier.ask({ on?: { episode | series }, prompt, schema })
  │
  ▼
resolve prior state:
  - if on.series → episodePrior = series.episodes[-1], seriesPrior = series
  - if on.episode → episodePrior = episode, seriesPrior = null  # branch/revive
  - else → episodePrior = null, seriesPrior = null              # fresh start
  │
  ▼
serialize episodePrior.exchanges to supplier's context format
(empty if episodePrior is null)
  │
  ▼
run agentic loop with serialized context + new prompt
  │
  ▼
genBrainExchange for each exchange in the loop
  │
  ▼
decide episode strategy based on context window:
  - if seriesPrior && context window full:
      generate recap exchange ("previously on...")
      episodeNew = genBrainEpisode({ on: { episode: null }, with: { exchanges: [recap, ...new] } })
  - else:
      episodeNew = genBrainEpisode({ on: { episode: episodePrior }, with: { exchanges: new } })
  │
  ▼
genBrainSeries({ on: { series: seriesPrior }, with: { episode: episodeNew } })
  │
  ▼
return { episode: NEW, series: NEW, output, metrics }
```

**key insight:** all paths flow through the same operations — resolve prior → serialize → invoke → genExchange → genEpisode → genSeries. the only variation is what `episodePrior` and `seriesPrior` resolve to, plus the compaction decision.

### 2.4. hash computation codepath (supplier utility)

```
genBrainExchange
  │
  ▼
computeBrainExchangeHash({ input, output })  # excludes exid
  │
  ▼
toHashSha256([input, output].join('\n'))
  │
  ▼
return hash

genBrainEpisode
  │
  ▼
computeBrainEpisodeHash({ exchanges })
  │
  ▼
toHashSha256(exchanges.map(e => e.hash).join('\n'))
  │
  ▼
return hash

genBrainSeries
  │
  ▼
computeBrainSeriesHash({ episodes })
  │
  ▼
toHashSha256(episodes.map(e => e.hash).join('\n'))
  │
  ▼
return hash
```

---

## 3. contracts

### 3.1. domain.objects contracts

#### BrainExchange

```ts
interface BrainExchange {
  hash: string;           // content-derived, computed from input + output
  input: string;          // the user's request
  output: string;         // the brain's response
  exid: string | null;    // supplier-assigned id, null if not provided
}
class BrainExchange extends DomainLiteral<BrainExchange> {}
```

**invariants:**
- immutable after creation
- hash is deterministic from input + output (excludes exid)
- exid is readonly, never set by caller

#### BrainEpisode

```ts
interface BrainEpisode {
  hash: string;                  // content-derived, computed from exchanges
  exchanges: BrainExchange[];    // ordered list of exchanges
}
class BrainEpisode extends DomainLiteral<BrainEpisode> {
  static nested = { exchanges: BrainExchange };
}
```

**invariants:**
- immutable after creation
- exchanges are ordered (append-only semantics)
- hash is deterministic from exchange hashes

#### BrainSeries

```ts
interface BrainSeries {
  hash: string;               // content-derived, computed from episodes
  episodes: BrainEpisode[];   // ordered list of episodes
}
class BrainSeries extends DomainLiteral<BrainSeries> {
  static nested = { episodes: BrainEpisode };
}
```

**invariants:**
- immutable after creation
- episodes are ordered (append-only semantics)
- compaction summaries embedded as first exchange of subsequent episodes
- hash is deterministic from episode hashes

#### BrainChoiceSlug

```ts
type BrainChoiceSlug = 'atom' | 'repl';
```

**purpose:** discriminant for conditional type on series in BrainOutput

#### BrainOutput (extended)

```ts
type AsBrainOutputSeriesFor<T extends BrainChoiceSlug> =
  T extends 'repl' ? BrainSeries :
  T extends 'atom' ? null :
  BrainSeries | null;

interface BrainOutput<TOutput, TBrainChoiceSlug extends BrainChoiceSlug = BrainChoiceSlug> {
  output: TOutput;
  metrics: BrainOutputMetrics;
  episode: BrainEpisode;
  series: AsBrainOutputSeriesFor<TBrainChoiceSlug>;
}
```

**type safety:**
- `BrainOutput<T, 'atom'>` → series is `null`
- `BrainOutput<T, 'repl'>` → series is `BrainSeries`
- `BrainOutput<T>` → series is `BrainSeries | null` (default)

### 3.2. domain.operations contracts

#### genBrainExchange

```ts
const genBrainExchange = async (input: {
  with: { input: string; output: string; exid: string | null };
}): Promise<BrainExchange>
```

**postconditions:**
- returns BrainExchange with computed hash
- hash excludes exid (content-addressed, not supplier-addressed)

#### genBrainEpisode

```ts
const genBrainEpisode = async (input: {
  on: { episode: BrainEpisode | null };
  with: { exchange: BrainExchange };
}): Promise<BrainEpisode>
```

**postconditions:**
- returns NEW BrainEpisode (never mutates input)
- if on.episode is null, fresh episode with single exchange
- if on.episode is defined, new episode with prior exchanges + new exchange

#### genBrainSeries

```ts
const genBrainSeries = async (input: {
  on: { series: BrainSeries | null };
  with: { episode: BrainEpisode };
}): Promise<BrainSeries>
```

**postconditions:**
- returns NEW BrainSeries (never mutates input)
- if on.series is null, fresh series with single episode
- if on.series is defined, new series with prior episodes + new episode

#### compute*Hash operations

```ts
const computeBrainExchangeHash = async (input: { input: string; output: string }): Promise<string>
const computeBrainEpisodeHash = async (input: { exchanges: BrainExchange[] }): Promise<string>
const computeBrainSeriesHash = async (input: { episodes: BrainEpisode[] }): Promise<string>
```

**postconditions:**
- deterministic: same input → same hash
- content-derived: hash changes if content changes

### 3.3. interface contracts

#### BrainAtom.ask()

```ts
ask: <TOutput>(input: {
  on?: { episode: BrainEpisode };
  plugs?: BrainAtomPlugs;
  role: { briefs?: Artifact<typeof GitFile>[] };
  prompt: string;
  schema: { output: z.Schema<TOutput> };
}) => Promise<BrainOutput<TOutput, 'atom'>>
```

**changes from current:**
- add `on?: { episode: BrainEpisode }` to input
- return type is `BrainOutput<TOutput, 'atom'>` (series guaranteed null)

#### BrainRepl.ask() / BrainRepl.act()

```ts
ask: <TOutput>(input: {
  on?: PickOne<{ episode: BrainEpisode; series: BrainSeries }>;
  plugs?: BrainReplPlugs;
  role: { briefs?: Artifact<typeof GitFile>[] };
  prompt: string;
  schema: { output: z.Schema<TOutput> };
}) => Promise<BrainOutput<TOutput, 'repl'>>

act: <TOutput>(input: {
  on?: PickOne<{ episode: BrainEpisode; series: BrainSeries }>;
  plugs?: BrainReplPlugs;
  role: { briefs?: Artifact<typeof GitFile>[] };
  prompt: string;
  schema: { output: z.Schema<TOutput> };
}) => Promise<BrainOutput<TOutput, 'repl'>>
```

**changes from current:**
- add `on?: PickOne<{ episode, series }>` to input
- return type is `BrainOutput<TOutput, 'repl'>` (series guaranteed BrainSeries)

---

## 4. test coverage strategy

### 4.1. unit tests

| file | coverage |
|------|----------|
| `computeBrainExchangeHash.test.ts` | determinism, content-address, exid exclusion |
| `computeBrainEpisodeHash.test.ts` | determinism, order sensitivity |
| `computeBrainSeriesHash.test.ts` | determinism, order sensitivity |
| `genBrainExchange.test.ts` | hash computation, exid handle |
| `genBrainEpisode.test.ts` | fresh creation, continuation, immutability |
| `genBrainSeries.test.ts` | fresh creation, continuation, immutability |

**unit test pattern:**
```ts
describe('genBrainEpisode', () => {
  given('[case1] no prior episode', () => {
    const exchange = useBeforeAll(async () =>
      genBrainExchange({ with: { input: 'hi', output: 'hello', exid: null } })
    );

    when('[t0] genBrainEpisode with null episode', () => {
      then('creates fresh episode with single exchange', async () => {
        const episode = await genBrainEpisode({
          on: { episode: null },
          with: { exchange },
        });
        expect(episode.exchanges).toHaveLength(1);
        expect(episode.exchanges[0]).toEqual(exchange);
      });

      then('hash is deterministic', async () => {
        const ep1 = await genBrainEpisode({ on: { episode: null }, with: { exchange } });
        const ep2 = await genBrainEpisode({ on: { episode: null }, with: { exchange } });
        expect(ep1.hash).toEqual(ep2.hash);
      });
    });
  });

  given('[case2] prior episode defined', () => {
    const scene = useBeforeAll(async () => {
      const exchange1 = await genBrainExchange({ with: { input: 'hi', output: 'hello', exid: null } });
      const episode1 = await genBrainEpisode({ on: { episode: null }, with: { exchange: exchange1 } });
      const exchange2 = await genBrainExchange({ with: { input: 'bye', output: 'goodbye', exid: null } });
      return { episode1, exchange2 };
    });

    when('[t0] genBrainEpisode with prior episode', () => {
      then('creates NEW episode with prior exchanges + new exchange', async () => {
        const episode2 = await genBrainEpisode({
          on: { episode: scene.episode1 },
          with: { exchange: scene.exchange2 },
        });
        expect(episode2.exchanges).toHaveLength(2);
        expect(episode2.hash).not.toEqual(scene.episode1.hash);
      });

      then('prior episode remains unchanged', async () => {
        await genBrainEpisode({
          on: { episode: scene.episode1 },
          with: { exchange: scene.exchange2 },
        });
        expect(scene.episode1.exchanges).toHaveLength(1);
      });
    });
  });
});
```

### 4.2. integration tests

**scope:** test interaction between domain operations and brain suppliers

| scenario | test |
|----------|------|
| BrainAtom continuation | supplier receives serialized prior exchanges |
| BrainRepl series continuation | repl maintains context across calls |
| BrainRepl episode branch | branch from saved checkpoint creates new series |
| cross-supplier continuation | episode from supplier A used with supplier B |

**integration test pattern:**
```ts
describe('askViaBrainAtom.continuation', () => {
  const atom = useBeforeAll(async () => genMockedBrainAtom());

  given('[case1] continuation from prior episode', () => {
    const scene = useBeforeAll(async () => {
      const { episode: ep1 } = await atom.ask({
        prompt: 'you are a reviewer',
        schema: { output: z.object({ understood: z.boolean() }) },
        role: {},
      });
      return { ep1 };
    });

    when('[t0] ask with on.episode', () => {
      then('brain receives prior context', async () => {
        const { episode: ep2 } = await atom.ask({
          on: { episode: scene.ep1 },
          prompt: 'what was your role?',
          schema: { output: z.object({ role: z.string() }) },
          role: {},
        });
        expect(ep2.exchanges).toHaveLength(2);
      });
    });
  });
});
```

### 4.3. acceptance tests

**scope:** blackbox validation via sdk contract layer

| usecase | test |
|---------|------|
| usecase.1 | start new episode (BrainAtom) |
| usecase.2 | start new series (BrainRepl) |
| usecase.3 | continue prior episode (BrainAtom) |
| usecase.4 | continue prior series (BrainRepl) |
| usecase.5 | continue prior episode (BrainRepl) |
| usecase.6 | act continues prior context (BrainRepl) |
| usecase.7 | multistep review workflow |
| usecase.9 | structured output via schema |
| pattern.1 | fanout via saved episodes |
| pattern.2 | revive via saved episodes |
| crosssupplier.1 | episode continuation across suppliers |
| boundary.1-6 | error scenarios |
| contract.1 | immutability (prior refs unchanged) |

**acceptance test pattern:**
```ts
describe('brainAtom.continuation', () => {
  given('[case1] multistep review workflow (usecase.7)', () => {
    const scene = useBeforeAll(async () => {
      const atom = await getTestBrainAtom();
      return { atom };
    });

    when('[t0] establish reviewer role', () => {
      const result = useBeforeAll(async () =>
        scene.atom.ask({
          prompt: 'you are a reviewer. reply { understood: true }',
          schema: { output: z.object({ understood: z.boolean() }) },
          role: {},
        })
      );

      then('returns episode reference', () => {
        expect(result.episode).toBeDefined();
        expect(result.episode.hash).toBeDefined();
      });

      then('series is null for atom', () => {
        expect(result.series).toBeNull();
      });
    });

    when('[t1] continue with review task', () => {
      const scene2 = useBeforeAll(async () => {
        const { episode: ep1 } = await scene.atom.ask({
          prompt: 'you are a reviewer',
          schema: { output: z.object({ understood: z.boolean() }) },
          role: {},
        });
        const { episode: ep2, output } = await scene.atom.ask({
          on: { episode: ep1 },
          prompt: 'review: const x = 1',
          schema: { output: z.object({ issues: z.array(z.string()) }) },
          role: {},
        });
        return { ep1, ep2, output };
      });

      then('new episode has 2 exchanges', () => {
        expect(scene2.ep2.exchanges).toHaveLength(2);
      });

      then('prior episode unchanged (immutability)', () => {
        expect(scene2.ep1.exchanges).toHaveLength(1);
      });

      then('brain has context from prior exchange', () => {
        expect(scene2.output.issues).toBeDefined();
      });
    });
  });
});
```

### 4.4. test asset factories

```ts
// genMockedBrainExchange.ts
export const genMockedBrainExchange = async (input?: {
  input?: string;
  output?: string;
  exid?: string | null;
}): Promise<BrainExchange> =>
  genBrainExchange({
    with: {
      input: input?.input ?? '__mock_input__',
      output: input?.output ?? '__mock_output__',
      exid: input?.exid ?? null,
    },
  });

// genMockedBrainEpisode.ts
export const genMockedBrainEpisode = async (input?: {
  exchanges?: BrainExchange[];
}): Promise<BrainEpisode> => {
  const exchange = input?.exchanges?.[0] ?? (await genMockedBrainExchange());
  let episode = await genBrainEpisode({ on: { episode: null }, with: { exchange } });
  for (const ex of (input?.exchanges ?? []).slice(1)) {
    episode = await genBrainEpisode({ on: { episode }, with: { exchange: ex } });
  }
  return episode;
};

// genMockedBrainSeries.ts
export const genMockedBrainSeries = async (input?: {
  episodes?: BrainEpisode[];
}): Promise<BrainSeries> => {
  const episode = input?.episodes?.[0] ?? (await genMockedBrainEpisode());
  let series = await genBrainSeries({ on: { series: null }, with: { episode } });
  for (const ep of (input?.episodes ?? []).slice(1)) {
    series = await genBrainSeries({ on: { series }, with: { episode: ep } });
  }
  return series;
};
```

---

## 5. implementation phases

### phase 1: domain.objects (foundation)

**files:**
1. `BrainExchange.ts` — domain literal
2. `BrainEpisode.ts` — domain literal with nested exchanges
3. `BrainSeries.ts` — domain literal with nested episodes
4. `BrainChoiceSlug.ts` — type alias

**deliverables:**
- domain objects with schema validation
- serialization/deserialization via domain-objects
- unit tests for immutability

### phase 2: domain.operations (factories + hash)

**files:**
1. `computeBrainExchangeHash.ts` + test
2. `computeBrainEpisodeHash.ts` + test
3. `computeBrainSeriesHash.ts` + test
4. `genBrainExchange.ts` + test
5. `genBrainEpisode.ts` + test
6. `genBrainSeries.ts` + test

**deliverables:**
- async factory operations
- content-derived hash computation
- unit tests for determinism and immutability

### phase 3: interface extensions (contracts)

**files:**
1. `BrainOutput.ts` — add episode, series, type param
2. `BrainAtom.ts` — add on.episode to ask()
3. `BrainRepl.ts` — add on.{episode,series} to ask/act

**deliverables:**
- updated interfaces with backward compatibility
- type safety via conditional types
- type tests for BrainOutput generic params

### phase 4: test assets (mocks)

**files:**
1. `genMockedBrainExchange.ts`
2. `genMockedBrainEpisode.ts`
3. `genMockedBrainSeries.ts`

**deliverables:**
- mock factories for test setup
- shared across unit, integration, acceptance tests

### phase 5: acceptance tests (validation)

**files:**
1. `brainAtom.continuation.acceptance.test.ts`
2. `brainRepl.continuation.acceptance.test.ts`

**deliverables:**
- blackbox tests against sdk contract
- coverage of all usecases from criteria

---

## 6. dependencies

### internal dependencies

| dependency | used by | purpose |
|------------|---------|---------|
| `domain-objects` | BrainExchange, BrainEpisode, BrainSeries | DomainLiteral base, serialize() |
| `hash-fns` | compute*Hash operations | toHashSha256 |
| `type-fns` | BrainRepl interface | PickOne constraint |
| `zod` | ask/act contracts | schema validation |

### no new external dependencies

all required packages are already in the repo's dependencies.

---

## 7. backward compatibility

### no changes that break current code

- callers that don't use `on:` continue to work
- return type adds fields but doesn't remove any
- `BrainOutput<TOutput>` (no second param) remains valid

### additive changes only

| change | compatibility |
|--------|---------------|
| `on?: { episode }` on BrainAtom.ask() | optional, current calls work |
| `on?: PickOne<...>` on BrainRepl.ask()/act() | optional, current calls work |
| `episode` field on BrainOutput | new field, additive |
| `series` field on BrainOutput | new field, additive (null for atom) |
| second type param on BrainOutput | defaults to union, current code compiles |

---

## 8. open questions

### resolved

1. **compaction storage** — resolved: recap embedded as first exchange of subsequent episode, not separate metadata array
2. **supplier exid** — resolved: nullable, readonly, excluded from hash computation
3. **PickOne enforcement** — resolved: use PickOne from type-fns for compile-time safety

### deferred

1. **compaction trigger** — when exactly does compaction happen? left to supplier implementation
2. **supplier capability discovery** — how do callers know if supplier supports continuation? left to supplier documentation
3. **persistence patterns** — caller-managed for now; lift common patterns later if needed

---

## 9. validation checklist

after implementation, validate against criteria:

- [ ] usecase.1: start new episode (BrainAtom) ✓
- [ ] usecase.2: start new series (BrainRepl) ✓
- [ ] usecase.3: continue prior episode (BrainAtom) ✓
- [ ] usecase.4: continue prior series (BrainRepl) ✓
- [ ] usecase.5: continue prior episode (BrainRepl) ✓
- [ ] usecase.6: act continues prior context (BrainRepl) ✓
- [ ] usecase.7: multistep review workflow ✓
- [ ] usecase.8: independent episodes on same operation ✓
- [ ] usecase.9: structured output via schema ✓
- [ ] crosssupplier.1: episode continuation across suppliers ✓
- [ ] crosssupplier.2: series continuation across suppliers ✓
- [ ] pattern.1: fanout via saved episodes ✓
- [ ] pattern.2: revive via saved episodes ✓
- [ ] contract.1: immutability ✓
- [ ] contract.2: recovery via emitted refs ✓
- [ ] boundary.1-6: error scenarios ✓

---

## 10. responsibility boundaries

### rhachet's responsibility

rhachet **exports** domain objects and utilities for suppliers to use:

```
rhachet exports:
├── domain.objects/
│   ├── BrainExchange
│   ├── BrainEpisode
│   ├── BrainSeries
│   └── BrainOutput (with episode/series fields)
│
├── domain.operations/brainEpisode/
│   ├── genBrainExchange
│   ├── genBrainEpisode
│   ├── genBrainSeries
│   └── compute*Hash functions
│
└── interfaces (BrainAtom, BrainRepl with on.episode/series signatures)
```

rhachet's wrappers (`askViaBrainAtom`, `askViaBrainRepl`) remain thin:
- pass through `on.episode` / `on.series` to supplier
- return whatever supplier returns
- no episode/series construction logic

### supplier's responsibility

suppliers **import** from rhachet and handle episode/series construction:

```ts
// inside supplier's ask() implementation
import { genBrainExchange, genBrainEpisode } from 'rhachet';

// supplier knows internal state:
// - every exchange in the tool use loop
// - when compaction occurred
// - what the recap summary contained
// - supplier-assigned exids

const exchange = await genBrainExchange({ with: { input, output, exid } });
const episode = await genBrainEpisode({ on: { episode: priorEpisode }, with: { exchange } });
return { output, metrics, episode, series: null };
```

### why suppliers must handle this

the repl is a black box to rhachet. only the supplier knows:
- every exchange that happened in the agentic loop
- when context window filled and compaction occurred
- what the "previously on..." recap summary contained
- supplier-assigned exids (e.g., openai's response_id)

rhachet cannot construct episodes without this information.

---

## 11. summary

this blueprint implements brain-continue via:

1. **3 new domain literals** — BrainExchange, BrainEpisode, BrainSeries
2. **6 new domain operations** — gen* factories and compute*Hash functions (exported for suppliers)
3. **3 updated interfaces** — BrainOutput, BrainAtom, BrainRepl
4. **3 new test asset factories** — genMockedBrain{Exchange,Episode,Series}
5. **2 new acceptance test suites** — blackbox validation

key principles:
- **immutability** — all domain literals are immutable; every call returns NEW instance
- **content-address** — identity via hash, not supplier ids
- **stateless callers** — callers hold full state; suppliers receive plaintext
- **supplier-implemented** — suppliers construct episodes/series via rhachet utilities
- **backward compatible** — additive changes only; current code continues to work
