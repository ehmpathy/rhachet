# blackbox criteria: brain-continue

experience bounds for multistep `.ask()` and `.act()` via episode and series continuation

---

# usecase.1 = start a new episode (BrainAtom)

given('a BrainAtom instance')
  when('user calls .ask() without continuation reference')
    then('a new episode is created')
      sothat('users can start fresh conversations')
    then('response includes episode reference')
      sothat('users can continue the episode later')
    then('response includes the brain output')
      sothat('users receive the answer to their question')

---

# usecase.2 = start a new series (BrainRepl)

given('a BrainRepl instance')
  when('user calls .ask() without continuation reference')
    then('a new series is created')
      sothat('users can start fresh repl sessions')
    then('a new episode is created within the series')
      sothat('exchanges are tracked within context bounds')
    then('response includes series reference')
      sothat('users can continue the series later')
    then('response includes episode reference')
      sothat('users can continue the specific episode later')
    then('response includes the brain output')
      sothat('users receive the answer to their question')

---

# usecase.3 = continue a prior episode (BrainAtom)

given('an episode reference from a prior BrainAtom .ask() call')
  when('user calls .ask() with { on: { episode } }')
    then('the request builds on the prior episode context')
      sothat('the brain has context from prior exchanges')
    then('response includes a NEW episode reference')
      sothat('users can save this checkpoint for later branch or revive')
    then('the prior episode reference remains valid and unchanged')
      sothat('users can branch from any saved checkpoint')
    then('response includes the brain output')
      sothat('users receive the answer informed by prior context')

---

# usecase.4 = continue a prior series (BrainRepl)

given('a series reference from a prior BrainRepl .ask() call')
  when('user calls .ask() with { on: { series } }')
    then('the request continues the prior series')
      sothat('the repl resumes where it left off')
    then('the request continues the current episode within the series')
      sothat('exchanges are appended to the active context')
    then('response includes a NEW series reference')
      sothat('users can save this checkpoint for later branch or revive')
    then('the prior series reference remains valid and unchanged')
      sothat('users can branch from any saved checkpoint')
    then('response includes a NEW episode reference')
      sothat('users can save this checkpoint for later branch or revive')
    then('response includes the brain output')
      sothat('users receive the answer informed by prior context')

---

# usecase.5 = continue a prior episode (BrainRepl)

given('an episode reference from a prior BrainRepl .ask() call')
  when('user calls .ask() with { on: { episode } }')
    then('the request builds on the prior episode context')
      sothat('the brain has context from prior exchanges')
    then('response includes a NEW episode reference')
      sothat('users can save this checkpoint for later branch or revive')
    then('the prior episode reference remains valid and unchanged')
      sothat('users can branch from any saved checkpoint')
    then('response includes the brain output')
      sothat('users receive the answer informed by prior context')

---

# usecase.6 = .act() continues prior context (BrainRepl)

given('a series reference from a prior BrainRepl .ask() call')
  when('user calls .act() with { on: { series } }')
    then('the repl acts with awareness of prior context')
      sothat('a plan from .ask() flows into execution via .act()')
    then('response includes a NEW series reference')
      sothat('users can continue after the action')
    then('response includes a NEW episode reference')
      sothat('users have a checkpoint after the action')

given('an episode reference from a prior BrainRepl .ask() call')
  when('user calls .act() with { on: { episode } }')
    then('the repl acts with awareness of prior episode context')
      sothat('analysis from .ask() flows into action via .act()')
    then('response includes a NEW episode reference')
      sothat('users have a checkpoint after the action')

---

# usecase.7 = multistep review workflow (BrainAtom)

given('a brain enrolled with a reviewer role')
  when('user starts an episode with role instructions')
    then('response confirms the brain understood the instructions')
    then('response includes episode reference')

  when('user continues with content to review')
    then('the brain reviews content per the prior instructions')
      sothat('users can separate role setup from content to process')
    then('response includes review output')

---

# usecase.8 = independent episodes on same operation

given('an operation that requires multiple independent brain calls')
  when('user makes .ask() calls without continuation')
    then('each call creates an independent episode')
      sothat('users can make disjoint requests without context bleed')
    then('each response has a distinct episode reference')

---

# usecase.9 = episode reference shape

given('any .ask() or .act() response')
  when('user inspects the episode reference')
    then('episode is a DomainLiteral')
      sothat('episodes are immutable and can be passed by value')
    then('episode reference can be passed to subsequent calls')
      sothat('continuation is ergonomic')

---

# usecase.10 = series reference shape

given('any BrainRepl .ask() or .act() response')
  when('user inspects the series reference')
    then('series is a DomainLiteral')
      sothat('series are immutable and can be passed by value')
    then('series reference can be passed to subsequent calls')
      sothat('continuation is ergonomic')

---

# usecase.11 = structured output via schema

given('a BrainAtom instance')
  when('user calls .ask() with { schema: { output: z.Schema } }')
    then('response.output conforms to the schema')
      sothat('users receive typed, validated output')
    then('response includes episode reference')
      sothat('users can continue with structured context')

given('a BrainRepl instance')
  when('user calls .ask() with { schema: { output: z.Schema } }')
    then('response.output conforms to the schema')
      sothat('users receive typed, validated output')
    then('response includes series and episode references')
      sothat('users can continue with structured context')

---

# usecase.12 = consensus fanout with structured output

given('multiple BrainAtom instances from different suppliers')
  when('user calls .ask() on each with the same episode and schema')
    then('each response.output conforms to the schema')
      sothat('outputs are comparable across suppliers')
    then('user can aggregate and compare outputs')
      sothat('consensus patterns are enabled')

---

# boundary.1 = invalid episode reference

given('an invalid or expired episode reference')
  when('user attempts to continue with that episode')
    then('error clearly indicates episode not found or expired')
      sothat('users understand what went wrong')
    then('error suggests to start a new episode')
      sothat('users have a recovery path')

---

# boundary.2 = invalid series reference

given('an invalid or expired series reference')
  when('user attempts to continue with that series')
    then('error clearly indicates series not found or expired')
      sothat('users understand what went wrong')
    then('error suggests to start a new series')
      sothat('users have a recovery path')

---

# crosssupplier.1 = episode continuation across suppliers

given('an episode reference from brain supplier A')
  when('user continues on brain supplier B via { on: { episode } }')
    then('brain B receives the episode exchanges as plaintext')
      sothat('context flows across suppliers without translation')
    then('brain B responds with awareness of prior context')
      sothat('cross-supplier continuation is seamless')
    then('response includes a NEW episode reference')
      sothat('the episode timeline continues on the new supplier')

---

# crosssupplier.2 = series continuation across suppliers

given('a series reference from brain supplier A')
  when('user continues on brain supplier B via { on: { series } }')
    then('brain B receives the series context as plaintext')
      sothat('context flows across suppliers without translation')
    then('brain B responds with awareness of prior context')
      sothat('cross-supplier continuation is seamless')
    then('response includes a NEW series reference')
      sothat('the series timeline continues on the new supplier')

---

# boundary.3 = brain supplier does not support continuation

given('a brain supplier that lacks continuation support')
  when('user calls .ask() with { on: { episode } }')
    then('error clearly indicates continuation not supported')
      sothat('users understand the limitation')
    then('the response still includes the episode reference from the prior call')
      sothat('users can recover by switch to a capable brain')

given('a brain supplier that lacks continuation support')
  when('user makes a fresh .ask() call without continuation')
    then('the call succeeds normally')
      sothat('limited brains are still useful for independent calls')
    then('response includes episode reference')
      sothat('users can continue on a different brain if needed')

---

# boundary.4 = continuation reference not found

given('no prior episode or series exists')
  when('user calls .ask() with { on: { episode: nonExistentRef } }')
    then('error indicates episode not found')
    then('error does not create a new episode implicitly')
      sothat('explicit continuation fails explicitly')

  when('user calls .ask() with { on: { series: nonExistentRef } }')
    then('error indicates series not found')
    then('error does not create a new series implicitly')
      sothat('explicit continuation fails explicitly')

---

# boundary.5 = continue compacted episode (BrainRepl)

given('an episode that has been compacted')
  when('user attempts to continue that episode via { on: { episode } }')
    then('error indicates episode has been compacted')
      sothat('users understand they cannot add to compacted episodes')
    then('error suggests to continue via series instead')
      sothat('users have a recovery path')

---

# boundary.6 = PickOne prevents both episode and series (BrainRepl)

given('a BrainRepl .ask() call')
  when('user attempts to specify both { on: { episode, series } }')
    then('type error at compile time via PickOne constraint')
      sothat('users cannot accidentally specify conflicted continuation')
    then('only one of episode or series is accepted')
      sothat('continuation intent is unambiguous')

---

# edge.1 = empty episode history

given('an episode that was just created')
  when('user immediately continues with a follow-up')
    then('the brain receives the prior message as context')
      sothat('even single-exchange episodes can be continued')

---

# edge.2 = long episode history

given('an episode with many prior exchanges')
  when('user continues the episode')
    then('the brain receives sufficient context to respond coherently')
      sothat('long conversations remain useful')
    then('if context window exceeded, error clearly indicates limit')
      sothat('users understand why continuation failed')

---

# edge.3 = series with compaction

given('a series that has compacted at least once')
  when('user continues the series via { on: { series } }')
    then('the brain receives the recap from compaction')
      sothat('context is preserved across episode boundaries')
    then('the series continues coherently')
      sothat('compaction is transparent to users')

---

# contract.1 = immutability

given('any episode reference')
  when('user inspects the episode')
    then('episode is immutable')
      sothat('users can trust saved references as stable checkpoints')
    then('episode captures context at the moment it was created')
      sothat('users can return to any saved point in the timeline')

given('any series reference')
  when('user inspects the series')
    then('series is immutable')
      sothat('users can trust saved references as stable checkpoints')
    then('series captures state at the moment it was created')
      sothat('users can return to any saved point in the timeline')

given('a prior episode or series reference after a subsequent .ask() call')
  when('user attempts to continue from that prior reference')
    then('the prior reference still works')
      sothat('users can branch from any checkpoint')
    then('the brain receives context as of that checkpoint')
      sothat('later exchanges are not visible to branches')

---

# contract.2 = recovery via emitted refs

given('any .ask() or .act() call on any brain')
  when('the call completes')
    then('response always includes episode reference')
      sothat('callers can persist and recover regardless of brain capabilities')
    then('response always includes series reference for BrainRepl')
      sothat('callers can persist and recover regardless of brain capabilities')

given('a brain that failed or lacks continuation support')
  when('user has the episode reference from a prior response')
    then('user can continue on a different brain via { on: { episode } }')
      sothat('recovery is possible across brain suppliers')
    then('the new brain receives prior context as plaintext')
      sothat('no context is lost in the recovery')

given('a context with automatic ref emission to logs')
  when('any .ask() or .act() call completes')
    then('the episode and series refs are emitted to context.log')
      sothat('recovery is possible even if caller did not persist refs')

---

# contract.3 = memory efficiency

given('a BrainRepl with many .ask() calls over time')
  when('exchanges accumulate across the series')
    then('the repl only retains the latest series and episode refs internally')
      sothat('memory does not grow with N copies of refs')
    then('each .ask() returns the latest ref to the caller')
      sothat('the caller decides whether to save or ignore it')
    then('ignored refs are eligible for garbage collection')
      sothat('memory is reclaimed when refs are not saved by the caller')

---

# pattern.1 = fanout via saved episodes

given('a saved episode reference from a prior .ask() call')
  when('user calls .ask() multiple times with the same episode ref')
    then('each call branches from the same checkpoint')
      sothat('users can explore alternative paths in parallel')
    then('each call returns a distinct NEW episode reference')
      sothat('each branch has its own timeline from that point')
    then('the original saved episode remains unchanged')
      sothat('users can continue to branch from it')

---

# pattern.2 = revive via saved episodes

given('a saved episode reference from earlier in a conversation')
  when('a later exchange goes wrong and user wants to retry')
    then('user can call .ask() with the saved episode ref')
      sothat('users can resume from before the problematic exchange')
    then('the brain receives context only up to that checkpoint')
      sothat('the problematic exchange is not in context')
    then('user receives a NEW episode reference for the retry path')
      sothat('users can save this new checkpoint')

---

# doc.1 = readme explains core constructs

given('the package readme')
  when('user reads the documentation')
    then('readme explains BrainExchange')
      sothat('users understand one request-response round-trip')
    then('readme explains BrainEpisode')
      sothat('users understand one context window of exchanges')
    then('readme explains BrainSeries')
      sothat('users understand a chain of episodes bridged by compaction')

---

# doc.2 = readme explains immutability

given('the package readme')
  when('user reads the documentation')
    then('readme clarifies that episode refs are immutable')
      sothat('users understand prior refs remain valid')
    then('readme clarifies that series refs are immutable')
      sothat('users understand prior refs remain valid')
    then('readme explains that each .ask() returns NEW refs')
      sothat('users understand checkpoints are created on each call')

---

# doc.3 = readme demonstrates continuation patterns

given('the package readme')
  when('user reads the documentation')
    then('readme shows how to continue an episode')
      sothat('users understand linear continuation')
    then('readme shows how to continue a series')
      sothat('users understand series continuation across compaction')
    then('readme demonstrates fanout pattern')
      sothat('users see how to branch from a saved checkpoint')
    then('readme demonstrates revive pattern')
      sothat('users see how to resume from a prior checkpoint')

---

# doc.4 = readme demonstrates cross-supplier continuation

given('the package readme')
  when('user reads the documentation')
    then('readme explains episodes and series are rhachet-prescribed')
      sothat('users understand constructs are not supplier-specific')
    then('readme demonstrates continuation across different suppliers')
      sothat('users see the same episode can be continued on any brain')
    then('readme shows consensus fanout across multiple cheap suppliers')
      sothat('users see cost-optimization patterns')
    then('readme shows escalation from atoms to repls')
      sothat('users see how to escalate from triage to action')
