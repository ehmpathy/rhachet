# blueprint criteria: brain-continue

mechanism bounds for multistep `.ask()` and `.act()` via episode and series continuation

---

## blackbox criteria satisfied

- usecase.1 = start a new episode (BrainAtom) ✓
- usecase.2 = start a new series (BrainRepl) ✓
- usecase.3 = continue a prior episode (BrainAtom) ✓
- usecase.4 = continue a prior series (BrainRepl) ✓
- usecase.5 = continue a prior episode (BrainRepl) ✓
- usecase.6 = .act() continues prior context (BrainRepl) ✓
- usecase.7 = multistep review workflow (BrainAtom) ✓
- usecase.8 = independent episodes on same operation ✓
- usecase.9 = episode reference shape ✓
- usecase.10 = series reference shape ✓
- usecase.11 = structured output via schema ✓
- usecase.12 = consensus fanout with structured output ✓
- boundary.1 = invalid episode reference ✓
- boundary.2 = invalid series reference ✓
- boundary.3 = brain supplier does not support continuation ✓
- boundary.4 = continuation reference not found ✓
- boundary.5 = continue compacted episode (BrainRepl) ✓
- boundary.6 = PickOne prevents both episode and series (BrainRepl) ✓
- edge.1 = empty episode history ✓
- edge.2 = long episode history ✓
- edge.3 = series with compaction ✓
- crosssupplier.1 = episode continuation across suppliers ✓
- crosssupplier.2 = series continuation across suppliers ✓
- contract.1 = immutability ✓
- contract.2 = recovery via emitted refs ✓
- contract.3 = memory efficiency ✓
- pattern.1 = fanout via saved episodes ✓
- pattern.2 = revive via saved episodes ✓
- doc.1 = readme explains core constructs ✓
- doc.2 = readme explains immutability ✓
- doc.3 = readme demonstrates continuation patterns ✓
- doc.4 = readme demonstrates cross-supplier continuation ✓

---

## subcomponent contracts

### BrainExchange domain literal

given('BrainExchange contract')
  then('is a DomainLiteral')
  then('captures one request-response round-trip')
  then('exposes: input (user request)')
  then('exposes: output (brain response)')
  then('exposes: exid (readonly, optional, if brain supplier identifies individual exchanges)')
  then('exposes: hash (readonly, content fingerprint, cannot be set)')
  then('is immutable after creation')
  then('is serializable to plaintext for cross-supplier transfer')

---

### BrainEpisode domain literal

given('BrainEpisode contract')
  then('is a DomainLiteral')
  then('exposes: exchanges (ordered list of BrainExchange)')
  then('exposes: hash (readonly, content fingerprint, cannot be set)')
  then('is immutable after creation')
  then('captures context window state at moment of creation')
  then('is serializable for persistence and cross-supplier transfer')

given('BrainEpisode creation')
  then('returns a NEW instance on every .ask() or .act() call')
  then('prior episode references remain valid and unchanged')

---

### BrainSeries domain literal

given('BrainSeries contract')
  then('is a DomainLiteral')
  then('exposes: episodes (ordered list of BrainEpisode)')
  then('exposes: compaction summaries between episodes')
  then('exposes: hash (readonly, content fingerprint, cannot be set)')
  then('is immutable after creation')
  then('captures series state at moment of creation')
  then('is serializable for persistence and cross-supplier transfer')

given('BrainSeries creation')
  then('returns a NEW instance on every .ask() or .act() call')
  then('prior series references remain valid and unchanged')

---

### BrainAtom.ask() contract

given('BrainAtom.ask() contract')
  then('accepts: say (string prompt)')
  then('accepts: on.episode (optional BrainEpisode for continuation)')
  then('accepts: schema.output (optional z.Schema for structured output)')
  then('returns: episode (NEW BrainEpisode)')
  then('returns: output (brain response, typed if schema provided)')

given('BrainAtom.ask() without continuation')
  then('creates a new episode')
  then('episode contains single exchange from this call')

given('BrainAtom.ask() with continuation')
  then('builds on prior episode context')
  then('returns NEW episode that contains prior exchanges plus this exchange')
  then('prior episode reference remains valid and unchanged')

given('BrainAtom.ask() on supplier without continuation support')
  then('throws error that clearly indicates continuation not supported')
  then('error includes the prior episode reference for recovery')

---

### BrainRepl.ask() contract

given('BrainRepl.ask() contract')
  then('accepts: say (string prompt)')
  then('accepts: on.episode (optional BrainEpisode for branch/revive)')
  then('accepts: on.series (optional BrainSeries for linear continuation)')
  then('accepts: schema.output (optional z.Schema for structured output)')
  then('rejects: both on.episode AND on.series (PickOne constraint)')
  then('returns: series (NEW BrainSeries)')
  then('returns: episode (NEW BrainEpisode)')
  then('returns: output (brain response, typed if schema provided)')

given('BrainRepl.ask() without continuation')
  then('creates a new series')
  then('creates a new episode within that series')

given('BrainRepl.ask() with on.series')
  then('continues the prior series')
  then('continues the current episode within that series')
  then('returns NEW series and episode references')
  then('prior references remain valid and unchanged')

given('BrainRepl.ask() with on.episode')
  then('builds on prior episode context (branch/revive)')
  then('starts a new series from that episode')
  then('returns NEW series and episode references')
  then('prior episode reference remains valid and unchanged')

given('BrainRepl.ask() when context window fills')
  then('compacts exchanges into summary (internally)')
  then('starts new episode with recap')
  then('series continues across the compaction')
  then('compaction is transparent to caller')

given('BrainRepl.ask() on compacted episode via on.episode')
  then('throws error that indicates episode has been compacted')
  then('error suggests to continue via on.series instead')

given('BrainRepl.ask() on supplier without continuation support')
  then('throws error that clearly indicates continuation not supported')
  then('error includes the prior episode/series reference for recovery')

---

### BrainRepl.act() contract

given('BrainRepl.act() contract')
  then('accepts: do (string directive)')
  then('accepts: on.episode (optional BrainEpisode for branch/revive)')
  then('accepts: on.series (optional BrainSeries for linear continuation)')
  then('rejects: both on.episode AND on.series (PickOne constraint)')
  then('returns: series (NEW BrainSeries)')
  then('returns: episode (NEW BrainEpisode)')
  then('returns: output (action result)')

given('BrainRepl.act() with on.series')
  then('continues the prior series with action context')
  then('brain has awareness of prior exchanges from .ask()')

given('BrainRepl.act() with on.episode')
  then('builds on prior episode context')
  then('brain has awareness of prior exchanges')

---

### PickOne type constraint (from type-fns)

given('PickOne<{ episode, series }> usage')
  then('uses PickOne from type-fns')
  then('enforces exactly one of episode or series')
  then('enforces unambiguous continuation intent')

---

### episode serialization for cross-supplier transfer

given('episode serialization contract')
  then('episodes serialize to plaintext exchanges')
  then('serialization includes all exchange content')
  then('serialization is supplier-agnostic')
  then('any supplier can deserialize and continue')

given('cross-supplier continuation')
  then('target brain receives prior exchanges as plaintext')
  then('target brain responds with awareness of context')
  then('target brain returns NEW episode reference')

---

### error contracts

given('continuation not supported error')
  then('error message clearly indicates continuation not supported')
  then('error includes the prior reference for recovery')

given('compacted episode error')
  then('error message clearly indicates episode has been compacted')
  then('error suggests to continue via series instead')

---

## composition boundaries

given('BrainAtom implementation')
  then('composes BrainExchange and BrainEpisode')
  then('BrainExchange captures each request-response')
  then('BrainEpisode captures ordered exchanges')
  then('immutability enforced at domain literal level')

given('BrainRepl implementation')
  then('composes BrainExchange, BrainEpisode, and BrainSeries')
  then('BrainExchange captures each request-response')
  then('BrainEpisode captures context window of exchanges')
  then('BrainSeries captures chain of episodes with compaction')
  then('compaction produces summary to bridge episodes')
  then('immutability enforced at domain literal level')

given('cross-supplier continuation')
  then('BrainEpisode serializes exchanges to plaintext')
  then('any brain supplier can deserialize and use exchanges')
  then('no translation layer needed between suppliers')

---

## integration boundaries

given('brain supplier integration')
  then('each supplier implements BrainAtom and/or BrainRepl contracts')
  then('suppliers may decline continuation support')
  then('suppliers that decline must fail fast with clear errors')
  then('suppliers receive episode/series as plaintext exchanges')

given('context integration')
  then('context may provide persistence for episode/series storage')
  then('episode/series are self-contained (no external dependencies)')

given('schema integration')
  then('schema.output accepts zod schema')
  then('output is validated and typed per schema')
  then('schema applies regardless of continuation state')

---

## test coverage criteria

given('BrainExchange')
  then('has unit tests for immutability')
  then('has unit tests for serialization')

given('BrainEpisode')
  then('has unit tests for immutability')
  then('has unit tests for exchange accumulation')
  then('has unit tests for serialization')
  then('has unit tests for unique identifier generation')

given('BrainSeries')
  then('has unit tests for immutability')
  then('has unit tests for episode accumulation')
  then('has unit tests for compaction summary storage')
  then('has unit tests for serialization')
  then('has unit tests for unique identifier generation')

given('BrainAtom.ask()')
  then('has integration tests for fresh episode creation')
  then('has integration tests for episode continuation')
  then('has integration tests for structured output')
  then('has integration tests for continuation not supported error')

given('BrainRepl.ask()')
  then('has integration tests for fresh series creation')
  then('has integration tests for series continuation')
  then('has integration tests for episode continuation (branch)')
  then('has integration tests for structured output')
  then('has integration tests for compaction')
  then('has integration tests for PickOne enforcement')
  then('has integration tests for compacted episode error')
  then('has integration tests for continuation not supported error')

given('BrainRepl.act()')
  then('has integration tests for series continuation')
  then('has integration tests for episode continuation')
  then('has integration tests for context awareness from prior .ask()')

given('cross-supplier continuation')
  then('has integration tests for episode transfer between suppliers')
  then('has integration tests for series transfer between suppliers')

given('immutability contract')
  then('has acceptance tests that prove prior refs remain valid after new calls')
  then('has acceptance tests that prove branches work from saved checkpoints')

given('error contracts')
  then('has acceptance tests for each error type')
  then('has acceptance tests that prove recovery paths work')

given('full workflows')
  then('has acceptance test for usecase.7 (multistep review workflow)')
  then('has acceptance test for pattern.1 (fanout)')
  then('has acceptance test for pattern.2 (revive)')
  then('has acceptance test for cross-supplier consensus fanout')
