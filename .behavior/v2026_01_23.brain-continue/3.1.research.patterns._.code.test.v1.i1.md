# test codepath patterns research: brain-continue

research into test patterns relevant to brain-continue implementation (BrainExchange, BrainEpisode, BrainSeries)

---

## 1. test file organization patterns

### [REUSE] unit tests (`.test.ts`)

fast, isolated tests with mocks; no side effects or external dependencies.

```typescript
// Actor.test.ts structure
describe('Actor', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  given('[case1] a role with typed skills', () => {
    when('[t0] .act() with valid rigid skill', () => {
      then('skill "review" compiles with correct input', () => { /* ... */ });
    });
  });
});
```

**application to brain-continue:**
- BrainExchange unit tests: validate immutability, hash derivation
- BrainEpisode unit tests: validate exchange accumulation, .clone() pattern
- BrainSeries unit tests: validate episode accumulation, compaction storage

---

### [REUSE] integration tests (`.integration.test.ts`)

test components with real dependencies (filesystem, process execution).

> "create real temporary directories with `.temp/` prefix" [1]

```typescript
// actorRun.integration.test.ts:12-50
const testDir = resolve(__dirname, './.temp/actorRun');
const originalCwd = process.cwd();

beforeAll(() => {
  mkdirSync(testDir, { recursive: true });
  process.chdir(testDir);
  // create .agent structure
});

afterAll(() => {
  process.chdir(originalCwd);
  rmSync(testDir, { recursive: true, force: true });
});
```

**application to brain-continue:**
- BrainAtom.ask() integration tests: real api calls with continuation
- BrainRepl.ask()/act() integration tests: real repl sessions with series continuation
- cross-supplier continuation tests: episode transfer between different brains

---

### [REUSE] acceptance tests (`.acceptance.test.ts`)

black-box tests against compiled CLI binary.

> "use compiled `/bin/run` CLI binary (not source)" [2]

```typescript
// invokeRhachetCliBinary.ts:14-42
export const invokeRhachetCliBinary = (input: {
  args: string[];
  cwd: string;
  stdin?: string;
  logOnError?: boolean;
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const result = spawnSync(RHACHET_BIN, input.args, {
    cwd: input.cwd,
    input: input.stdin,
    shell: '/bin/bash',
    env: input.env ? { ...process.env, ...input.env } : undefined,
  });
  // ...
};
```

**application to brain-continue:**
- end-to-end tests via CLI that verify episode/series continuation
- validate error messages for continuation not supported
- validate structured output with schema

---

## 2. test fixture patterns

### [REUSE] mock brain factory

create complete BrainRepl mocks with controllable output.

```typescript
// Actor.test.ts:49-66
const testBrain: BrainRepl = {
  repo: 'test',
  slug: 'test-brain',
  spec: genSampleBrainSpec(),
  ask: jest.fn().mockResolvedValue(
    new BrainOutput({
      output: { response: 'response' },
      metrics: genMockedBrainOutputMetrics(),
    }),
  ),
  act: jest.fn().mockResolvedValue(
    new BrainOutput({
      output: { result: 'done' },
      metrics: genMockedBrainOutputMetrics(),
    }),
  ),
};
```

**application to brain-continue:**
- extend mock to return `{ episode, output }` for BrainAtom
- extend mock to return `{ series, episode, output }` for BrainRepl
- mock continuation behavior with prior episode/series input

---

### [EXTEND] genMockedBrainRepl factory

parameterized entity constructor with schema-aware output.

```typescript
// genMockedBrainRepl.ts:11-36
export const genMockedBrainRepl = (input?: {
  repo?: string;
  slug?: string;
  description?: string;
  content?: string;
}): BrainRepl =>
  new BrainRepl({
    repo: input?.repo ?? '__mock_repo__',
    slug: input?.slug ?? '__mock_repl__',
    spec: genSampleBrainSpec(),
    ask: async (askInput) =>
      new BrainOutput({
        output: askInput.schema.output.parse({ content: input?.content ?? '__mock_response__' }),
        metrics: genMockedBrainOutputMetrics(),
      }),
  });
```

**extension for brain-continue:**
- add `episode?: BrainEpisode` param to seed continuation state
- add `series?: BrainSeries` param for repl continuation
- return `{ episode, output }` or `{ series, episode, output }` as appropriate

---

### [REUSE] genMockedBrainOutputMetrics factory

parameterized metrics generator with sensible defaults.

```typescript
// genMockedBrainOutputMetrics.ts:9-48
export const genMockedBrainOutputMetrics = (input?: {
  inputTokens?: number;
  outputTokens?: number;
}): BrainOutputMetrics =>
  new BrainOutputMetrics({
    size: { tokens: { input: input?.inputTokens ?? 1000, output: input?.outputTokens ?? 500 } },
    cost: { time: { milliseconds: 1500 }, cash: { total: asIsoPrice('$0.01') } },
  });
```

**application to brain-continue:**
- reuse as-is for all brain output mocks

---

### [EXTEND] genSampleBrainSpec factory

realistic BrainSpec with Claude Opus details.

```typescript
// genSampleBrainSpec.ts:9-40
// Creates realistic BrainSpec with Claude Opus price data
// Used by genMockedBrainRepl for consistent mocks
```

**extension for brain-continue:**
- add `supportsContinuation?: boolean` field for test of continuation support detection

---

### [REUSE] mock adapter factory pattern

factory that creates mock adapters with tracked calls for assertion.

```typescript
// syncAllRoleHooksIntoEachBrainRepl.test.ts:12-50
const createMockAdapter = (
  slug: BrainSpecifier,
  hooksFound: BrainHook[] = [],
): BrainHooksAdapter & { calls: { upsert: BrainHook[]; del: BrainHook[] } } => {
  const calls = { upsert: [] as BrainHook[], del: [] as BrainHook[] };
  return {
    slug,
    calls,
    dao: {
      get: { one: jest.fn().mockResolvedValue(null), all: jest.fn().mockResolvedValue(hooksFound) },
      set: { findsert: jest.fn().mockImplementation(async ({ hook }) => { calls.upsert.push(hook); return hook; }) },
      del: jest.fn().mockImplementation(async ({ by }) => { /* track */ }),
    },
  };
};
```

**application to brain-continue:**
- use pattern for brain supplier mocks that track continuation calls

---

## 3. bdd patterns - given/when/then

### [REUSE] given/when/then nested structure with test-fns

hierarchical test scenarios with case/test numbered labels.

```typescript
// discoverBrainPackages.test.ts:10-90
describe('discoverBrainPackages', () => {
  given('[case1] package.json with brain packages', () => {
    const scene = useBeforeAll(async () => { /* setup */ });

    when('[t0] discoverBrainPackages is called', () => {
      then('returns brain packages from both deps and devDeps', () => {
        expect(scene.result).toContain('rhachet-brains-anthropic');
      });
      then('does not include non-brain packages', () => {
        expect(scene.result).not.toContain('other-package');
      });
      then('returns exactly 2 packages', () => {
        expect(scene.result).toHaveLength(2);
      });
    });
  });

  given('[case2] package.json with no brain packages', () => {
    // ... another test case
  });
});
```

**application to brain-continue:**
- usecase tests: `given('[case1] a BrainAtom instance')`
- boundary tests: `given('[case3] brain supplier does not support continuation')`
- pattern tests: `given('[case7] saved episode reference from prior .ask() call')`

---

### [REUSE] cli command tests with given/when/then

test CLI argument parse and error handle.

```typescript
// invokeAct.test.ts:62-155
given('invokeAct is registered on a CLI program', () => {
  let program: Command;

  beforeEach(() => {
    program = new Command();
    program.exitOverride();
    const mockContext = genMockContextConfigOfUsage({ /* ... */ });
    invokeAct({ program }, mockContext);
  });

  when('act command is called with valid args', () => {
    then('executes the skill with brain', async () => {
      await program.parseAsync(['act', '--role', 'tester', '--skill', 'summarize', '--input', '{"content":"hello"}']);
      expect(mockBrain.act).toHaveBeenCalled();
    });
  });

  when('act command is called with invalid brain format', () => {
    then('throws error about format', async () => {
      const error = await getError(() => program.parseAsync(['act', /* ... */ ]));
      expect(error.message).toContain('invalid brain format');
    });
  });
});
```

**application to brain-continue:**
- test `--on-episode` and `--on-series` CLI argument parse
- test error messages for PickOne constraint violations

---

## 4. useBeforeAll/useBeforeEach patterns

### [REUSE] shared setup with useBeforeAll

setup async code once per given() block.

```typescript
// discoverBrainPackages.test.ts:12-32
given('[case1] package.json with brain packages', () => {
  const scene = useBeforeAll(async () => {
    const dir = path.join(os.tmpdir(), `test-brains-${Date.now()}`);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(
      path.join(dir, 'package.json'),
      JSON.stringify({
        name: 'test-project',
        dependencies: { 'rhachet-brains-anthropic': '^1.0.0' },
      }),
    );
    const context = new ContextCli({ cwd: dir, gitroot: dir });
    const result = await discoverBrainPackages(context);
    return { dir, result };  // returns object accessible in then()
  });

  when('[t0] discoverBrainPackages is called', () => {
    then('returns brain packages', () => {
      expect(scene.result).toContain('rhachet-brains-anthropic');
    });
  });
});
```

**application to brain-continue:**
- setup initial episode with exchanges
- setup initial series with episodes
- return scene with prior state for continuation tests

---

### [REUSE] beforeEach for mock clear

reset mock call counts between test cases.

```typescript
// syncAllRoleHooksIntoEachBrainRepl.test.ts:68-71
describe('syncAllRoleHooksIntoEachBrainRepl', () => {
  beforeEach(() => {
    jest.clearAllMocks();  // reset all mock call counts
  });

  given('[case1] single role with hooks', () => {
    // ... test case
  });
});
```

**application to brain-continue:**
- clear brain mock calls between continuation tests
- ensure each test starts fresh

---

## 5. domain object test patterns

### [REUSE] type tests via @ts-expect-error

use typescript compiler as test assertion.

```typescript
// BrainAtom.types.test.ts:18-91
async () => {
  const schema = z.object({ answer: z.string() });
  const result = await brainAtom.ask({
    role: {},
    prompt: 'hello',
    schema: { output: schema },
  });

  // positive: answer exists and is string
  const _answer: string = result.output.answer;

  // negative: nonexistent property
  // @ts-expect-error - 'wrong' property does not exist on { answer: string }
  const _wrong = result.output.wrong;
};

describe('BrainAtom types', () => {
  it('should compile type tests successfully', () => {
    expect(true).toBe(true);  // runtime validation that types compiled
  });
});
```

**application to brain-continue:**
- type tests for BrainExchange shape
- type tests for BrainEpisode.exchanges array type
- type tests for PickOne<{ episode, series }> constraint
- type tests for extended .ask()/.act() return types

---

### [REUSE] Role.typed() for literal type preservation

preserve skill names for type inference.

```typescript
// Actor.test.ts:23-46
const testRole = Role.typed({
  slug: 'tester',
  name: 'Tester',
  purpose: 'test role for actor tests',
  traits: [],
  skills: {
    solid: { greet: { input: z.object({ name: z.string() }), output: z.object({ salutation: z.string() }) } },
    rigid: { summarize: { input: z.object({ content: z.string() }), output: z.object({ summary: z.string() }) } },
  },
  briefs: { dirs: { uri: '.agent/repo=.this/role=tester/briefs' } },
});
```

**application to brain-continue:**
- test role definitions with continuation-aware skills

---

## 6. brain test patterns

### [EXTEND] BrainRepl in Actor context

use real or mocked brain instances for actor tests.

```typescript
// actorAsk.integration.test.ts:24-61
const brain = genBrainRepl({ slug: 'openai/codex' }) as unknown as BrainRepl;

given('[case1] a valid role and brain', () => {
  when('[t0] actorAsk is called with a prompt', () => {
    then('returns a response from the brain', async () => {
      const result = await actorAsk({
        role: testerRole,
        brain,  // actual brain instance
        prompt: 'say hello',
        schema: ACTOR_ASK_DEFAULT_SCHEMA,
      });

      expect(result).toBeDefined();
      expect(result.output.answer).toBeDefined();
      expect(typeof result.output.answer).toEqual('string');
    });
  });
});
```

**extension for brain-continue:**
- add continuation tests: `when('[t1] actorAsk is called with prior episode')`
- validate episode returned in result
- validate prior context is received by brain

---

### [REUSE] brain hook adapter mock

mock adapter with calls tracker for assertion.

```typescript
// syncAllRoleHooksIntoEachBrainRepl.test.ts:14-50
const createMockAdapter = (slug: BrainSpecifier, hooksFound: BrainHook[] = []) => {
  const calls = { upsert: [] as BrainHook[], del: [] as BrainHook[] };
  return {
    slug,
    calls,
    dao: {
      get: { all: jest.fn().mockResolvedValue(hooksFound) },
      set: { findsert: jest.fn().mockImplementation(async ({ hook }) => {
        calls.upsert.push(hook);
        return hook;
      }) },
    },
  };
};

jest.mock('./getBrainHooksAdapterByConfigImplicit');
const mockGetAdapter = getBrainHooksAdapterByConfigImplicit as jest.Mock;

given('[case1] single role with hooks, single brain', () => {
  const adapter = createMockAdapter('claude-code', []);

  const result = useBeforeAll(async () => {
    mockGetAdapter.mockResolvedValue(adapter);
    return await syncAllRoleHooksIntoEachBrainRepl({ /* ... */ });
  });

  when('[t0] sync is executed', () => {
    then('returns 1 applied result', () => {
      expect(result.applied).toHaveLength(1);
    });
    then('applied result shows 1 hook created', () => {
      expect(adapter.calls.upsert).toHaveLength(1);
    });
  });
});
```

**application to brain-continue:**
- mock brain supplier for continuation support tests
- track continuation calls and verify episode/series passed

---

## 7. composition test patterns

### [REUSE] generic type preservation tests

verify generic type inference via compile-time checks.

```typescript
// genStitchFanout.test.ts:14-110
given('a fanout with two compute steps and a numeric concluder', () => {
  const threadMain = new Thread({
    context: { role: 'main' as const },
    stitches: [],
  });

  const stitcherFanout = genStitchFanout({
    slug: 'test:fanout:sum',
    parallels: [parallelA, parallelB],
    concluder,
  });

  when('used in enweaveOneFanout', () => {
    then('produces stitch.output of type number', async () => {
      const { stitch, threads } = await enweaveOneFanout(
        { stitcher: stitcherFanout, threads: { main: threadMain } },
        context,
      );

      // Compile-time check: output is number
      const testOutput: number = stitch.output;

      // Runtime check: sum = 30
      expect(testOutput).toEqual(30);
    });

    then('fails if you assume wrong output type', async () => {
      const { stitch } = await enweaveOneFanout({ /* ... */ });

      // @ts-expect-error: stitch.output is number, not string
      const wrongType: string = stitch.output;
      expect(wrongType);
    });
  });
});
```

**application to brain-continue:**
- type tests for episode.exchanges generic
- type tests for series.episodes generic
- type tests for continuation input/output types

---

### [REUSE] sequential composition route tests

validate thread shape requirements via compile-time and runtime checks.

```typescript
// enweaveOneRoute.integration.test.ts:31-79
given('a route with compute stitchers; same threads required for each stitcher', () => {
  // ... stitcher setup

  when('the wrong thread is given as input', () => {
    const threadAuthor = new Thread({
      context: { role: 'author' as const },
      stitches: [],
    });

    then('there should be a compile-time error when threads dont have desired thread', async () => {
      // @ts-expect-error: threads must include 'main'
      const { stitch } = await enweaveOneRoute(
        { stitcher: route, threads: { author: threadAuthor } },
        context,
      );
    });
  });
});
```

**application to brain-continue:**
- validate PickOne<{ episode, series }> constraint at compile-time
- validate episode/series type requirements

---

## 8. snapshot patterns

### [REUSE] snapshots after assertions

use snapshots AFTER specific assertions for observability.

```typescript
// genRhachetUseConfig.test.ts:15, 30, 43
it('should generate config for single package with aliased imports', () => {
  const result = genRhachetUseConfig({
    packages: ['rhachet-roles-ehmpathy'],
  });

  // Verify specific assertions
  expect(result).toContain(
    "import { getRoleRegistry as getRoleRegistryEhmpathy, getInvokeHooks as getInvokeHooksEhmpathy } from 'rhachet-roles-ehmpathy'",
  );

  // Snapshot for observability
  expect(result).toMatchSnapshot();
});
```

**application to brain-continue:**
- snapshot serialized episode for cross-supplier transfer tests
- snapshot series with compaction summaries
- observability in code reviews

---

## 9. test infra helpers

### [REUSE] genTestTempDir

managed temp directory with cwd switch.

```typescript
// genTestTempDir.ts:8-43
export const genTestTempDir = (input: {
  base: string;  // typically __dirname
  name: string;  // subdirectory name under .temp
}): {
  path: string;
  setup: () => void;   // call in beforeAll
  teardown: () => void; // call in afterAll
  rm: (relativePath: string) => void;
} => {
  const testDir = resolve(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,
    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },
    teardown: () => {
      process.chdir(originalCwd);
    },
    rm: (relativePath: string) => {
      rmSync(resolve(testDir, relativePath), { force: true, recursive: true });
    },
  };
};
```

**application to brain-continue:**
- integration tests that need filesystem state

---

### [REUSE] setTestTempAsset

safe test asset writer with .temp guard.

```typescript
// setTestTempAsset.ts:8-40
export const setTestTempAsset = (input: {
  dir: string;        // must be under .temp
  name: string;       // filename
  content: string;    // file content
  executable?: boolean; // default: true for .sh files
}): { path: string } => {
  // guard: ensure we're to write to a temp directory
  if (!input.dir.includes('.temp'))
    throw new Error(`setTestTempAsset: dir must be under .temp for safety`);

  const assetPath = resolve(input.dir, input.name);
  mkdirSync(dirname(assetPath), { recursive: true });
  writeFileSync(assetPath, input.content);

  const shouldExecute = input.executable ?? input.name.endsWith('.sh');
  if (shouldExecute) chmodSync(assetPath, '755');

  return { path: assetPath };
};
```

**application to brain-continue:**
- create test fixtures for episode/series serialization tests

---

### [REUSE] genTestTempRepo for acceptance tests

fixture-based temp repo generator.

```typescript
// genTestTempRepo.ts:44-89
export const genTestTempRepo = (input: {
  fixture: TestRepoFixture;  // 'minimal' | 'with-registry' | 'with-skills' | ...
  suffix?: string;
  install?: boolean;  // run bun install
}): { path: string } => {
  const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${input.suffix ? `-${input.suffix}` : ''}`);

  // Copy fixture assets
  const fixturePath = join(ASSETS_DIR, input.fixture);
  cpSync(fixturePath, repoPath, { recursive: true });

  // Make .sh files executable
  setSkillsExecutable({ dir: repoPath });

  // Init git repo (required for rhachet)
  execSync('git init', { cwd: repoPath, stdio: 'ignore' });
  execSync('git config user.email "test@example.com"', { cwd: repoPath });
  execSync('git config user.name "Test User"', { cwd: repoPath });

  // Install if needed
  if (input.install && existsSync(join(repoPath, 'package.json'))) {
    execSync('bun install', { cwd: repoPath, timeout: 120000 });
  }

  return { path: repoPath };
};
```

**application to brain-continue:**
- acceptance tests for continuation via CLI

---

### [REUSE] context generators

compose context via spread operator.

```typescript
// genContextLogTrail.ts:4-9
export const genContextLogTrail = (): ContextLogTrail => ({
  log: {
    ...pick(console, ['debug', 'log', 'info', 'warn', 'error']),
    trail: [],
  },
});

// usage: genStitchFanout.test.ts:16
const context = { ...genContextStitchTrail(), ...genContextLogTrail() };
```

**application to brain-continue:**
- compose context for episode/series tests

---

### [REUSE] jest mock module pattern

mock filesystem dependencies to avoid .agent/ directory requirement.

```typescript
// actorAct.test.ts:11-13
jest.mock('@src/domain.operations/role/getRoleBriefs', () => ({
  getRoleBriefs: jest.fn().mockResolvedValue([]),
}));
```

```typescript
// syncAllRoleHooksIntoEachBrainRepl.test.ts:52-66
jest.mock('../config/getBrainHooksAdapterByConfigImplicit', () => ({
  getBrainHooksAdapterByConfigImplicit: jest.fn(),
}));

// AFTER mocks defined, import them
import { getBrainHooksAdapterByConfigImplicit } from '../config/getBrainHooksAdapterByConfigImplicit';

const mockGetAdapter = getBrainHooksAdapterByConfigImplicit as jest.Mock;
```

**application to brain-continue:**
- mock brain suppliers for continuation support tests
- mock episode/series persistence if needed

---

## 10. new patterns needed

### [NEW] genMockedBrainExchange factory

create mock BrainExchange instances for tests.

```typescript
// proposed: genMockedBrainExchange.ts
export const genMockedBrainExchange = (input?: {
  input?: string;
  output?: string;
  exid?: string;
}): BrainExchange =>
  new BrainExchange({
    input: input?.input ?? '__mock_input__',
    output: input?.output ?? '__mock_output__',
    exid: input?.exid ?? undefined,
    // hash is readonly, derived from content
  });
```

---

### [NEW] genMockedBrainEpisode factory

create mock BrainEpisode instances for tests.

```typescript
// proposed: genMockedBrainEpisode.ts
export const genMockedBrainEpisode = (input?: {
  exchanges?: BrainExchange[];
}): BrainEpisode =>
  new BrainEpisode({
    exchanges: input?.exchanges ?? [genMockedBrainExchange()],
    // hash is readonly, derived from content
  });
```

---

### [NEW] genMockedBrainSeries factory

create mock BrainSeries instances for tests.

```typescript
// proposed: genMockedBrainSeries.ts
export const genMockedBrainSeries = (input?: {
  episodes?: BrainEpisode[];
  compactionSummaries?: string[];
}): BrainSeries =>
  new BrainSeries({
    episodes: input?.episodes ?? [genMockedBrainEpisode()],
    compactionSummaries: input?.compactionSummaries ?? [],
    // hash is readonly, derived from content
  });
```

---

## citations

[1] src/domain.operations/actor/actorRun.integration.test.ts:12-50 — temp directory setup
[2] accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:14-42 — CLI binary invoker
[3] src/.test.assets/genMockedBrainOutputMetrics.ts:9-48 — metrics factory
[4] src/.test.assets/genMockedBrainRepl.ts:11-36 — brain repl factory
[5] src/domain.operations/actor/Actor.test.ts:49-66 — mock brain with jest
[6] src/contract/cli/invokeAct.test.ts:62-155 — CLI command tests
[7] src/domain.objects/BrainAtom.types.test.ts:18-91 — type tests
[8] src/domain.operations/actor/Actor.test.ts:23-46 — Role.typed() usage
[9] src/domain.operations/role/syncAllRoleHooksIntoEachBrainRepl.test.ts:12-50 — mock adapter factory
[10] src/domain.operations/actor/actorAsk.integration.test.ts:24-61 — brain in actor context
[11] src/domain.operations/weave/genStitchFanout.test.ts:14-110 — composition type tests
[12] src/domain.operations/weave/enweaveOneRoute.integration.test.ts:31-79 — sequential composition tests
[13] src/contract/cli/genRhachetUseConfig.test.ts:15-43 — snapshot patterns
[14] src/.test/infra/genTestTempDir.ts:8-43 — temp directory helper
[15] src/.test/infra/setTestTempAsset.ts:8-40 — safe asset writer
[16] accept.blackbox/.test/infra/genTestTempRepo.ts:44-89 — fixture repo generator
[17] src/.test/genContextLogTrail.ts:4-9 — context generator
[18] src/domain.operations/actor/actorAct.test.ts:11-13 — jest mock pattern
[19] src/domain.operations/role/syncAllRoleHooksIntoEachBrainRepl.test.ts:52-66 — import after mock pattern
[20] src/domain.operations/brains/discoverBrainPackages.test.ts:10-90 — given/when/then pattern

---

## summary

| pattern | marker | application |
|---------|--------|-------------|
| unit test organization | [REUSE] | BrainExchange/Episode/Series unit tests |
| integration test organization | [REUSE] | brain continuation integration tests |
| acceptance test organization | [REUSE] | CLI continuation end-to-end tests |
| mock brain factory | [REUSE] | mock brains with controllable output |
| genMockedBrainRepl | [EXTEND] | add episode/series continuation support |
| genMockedBrainOutputMetrics | [REUSE] | metrics for all brain tests |
| genSampleBrainSpec | [EXTEND] | add supportsContinuation field |
| mock adapter factory | [REUSE] | brain supplier continuation track |
| given/when/then nested | [REUSE] | all brain-continue tests |
| useBeforeAll | [REUSE] | shared episode/series setup |
| beforeEach mock clear | [REUSE] | isolate continuation tests |
| type tests via @ts-expect-error | [REUSE] | PickOne constraint, return types |
| Role.typed() | [REUSE] | continuation-aware skill definitions |
| brain in actor context | [EXTEND] | continuation tests with prior episode/series |
| composition type tests | [REUSE] | episode/series generic types |
| sequential composition tests | [REUSE] | PickOne constraint validation |
| snapshots after assertions | [REUSE] | serialization observability |
| genTestTempDir | [REUSE] | filesystem integration tests |
| setTestTempAsset | [REUSE] | test fixture creation |
| genTestTempRepo | [REUSE] | acceptance test repos |
| context generators | [REUSE] | compose test context |
| jest mock module | [REUSE] | mock brain suppliers |
| genMockedBrainExchange | [NEW] | mock exchange instances |
| genMockedBrainEpisode | [NEW] | mock episode instances |
| genMockedBrainSeries | [NEW] | mock series instances |
