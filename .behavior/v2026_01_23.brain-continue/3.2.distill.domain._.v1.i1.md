# domain distillation: brain-continue

distills the domain.objects, domain.operations, and access layer required for episode and series continuation.

---

## 1. usecases

### from vision and criteria

| usecase         | what                                    | who                          |
| --------------- | --------------------------------------- | ---------------------------- |
| usecase.1       | start a new episode (BrainAtom)         | skill author, actor consumer |
| usecase.2       | start a new series (BrainRepl)          | skill author, actor consumer |
| usecase.3       | continue a prior episode (BrainAtom)    | skill author, actor consumer |
| usecase.4       | continue a prior series (BrainRepl)     | skill author, actor consumer |
| usecase.5       | continue a prior episode (BrainRepl)    | skill author, actor consumer |
| usecase.6       | act continues prior context (BrainRepl) | skill author                 |
| usecase.7       | multistep review workflow (BrainAtom)   | skill author                 |
| usecase.8       | independent episodes on same operation  | skill author                 |
| usecase.9       | structured output via schema            | skill author, actor consumer |
| usecase.10      | consensus fanout with structured output | skill author                 |
| crosssupplier.1 | episode continuation across suppliers   | skill author                 |
| crosssupplier.2 | series continuation across suppliers    | skill author                 |
| pattern.1       | fanout via saved episodes               | skill author                 |
| pattern.2       | revive via saved episodes               | skill author                 |

---

## 2. contracts

### 2.1. BrainAtom.ask() contract

```ts
// input
brain.ask({
  on?: { episode: BrainEpisode },  // build on prior episode
  prompt: string,
  schema?: { output: z.Schema<TOutput> },
  role?: { briefs?: Artifact<typeof GitFile>[] },
  plugs?: BrainAtomPlugs,
});

// output
{
  episode: BrainEpisode,  // NEW episode reference (immutable checkpoint)
  output: TOutput,
  metrics: BrainOutputMetrics,
}
```

### 2.2. BrainRepl.ask() contract

```ts
// input
repl.ask({
  on?: PickOne<{
    episode: BrainEpisode,  // branch/revive from prior episode
    series: BrainSeries,    // linear continuation
  }>,
  prompt: string,
  schema?: { output: z.Schema<TOutput> },
  role?: { briefs?: Artifact<typeof GitFile>[] },
  plugs?: BrainReplPlugs,
});

// output
{
  series: BrainSeries,    // NEW series reference
  episode: BrainEpisode,  // NEW episode reference
  output: TOutput,
  metrics: BrainOutputMetrics,
}
```

### 2.3. BrainRepl.act() contract

```ts
// input
repl.act({
  on?: PickOne<{
    episode: BrainEpisode,
    series: BrainSeries,
  }>,
  prompt: string,
  schema?: { output: z.Schema<TOutput> },
  role?: { briefs?: Artifact<typeof GitFile>[] },
  plugs?: BrainReplPlugs,
});

// output
{
  series: BrainSeries,
  episode: BrainEpisode,
  output: TOutput,
  metrics: BrainOutputMetrics,
}
```

---

## 3. domain.objects

### 3.1. BrainExchange

one request-response round-trip. the atomic unit of brain interaction.

```ts
/**
 * .what = one request-response pair in a brain conversation
 * .why = captures the atomic unit of brain interaction for replay and serialization
 */
export interface BrainExchange {
  /**
   * .what = content-derived hash of this exchange
   * .why = provides identity for content-addressed lookup and deduplication
   */
  hash: string;

  /**
   * .what = the user's request to the brain
   */
  input: string;

  /**
   * .what = the brain's response
   */
  output: string;

  /**
   * .what = supplier-assigned identifier for this exchange (readonly)
   * .why = null when supplier does not assign ids to individual messages
   * .note = some suppliers (e.g., openai responses api) assign ids; others (e.g., anthropic) do not
   */
  exid: string | null;
}

export class BrainExchange
  extends DomainLiteral<BrainExchange>
  implements BrainExchange {}
```

**declastruct notes:**
- DomainLiteral: immutable, content-derived hash
- hash: required, computed from input + output (excludes exid)
- no primary key: identity is via hash
- no unique key: content-addressed
- exid is readonly, supplier-assigned, nullable (null when supplier does not assign ids)

### 3.2. BrainEpisode

one context window of exchanges. the unit of continuity within a single context capacity.

```ts
/**
 * .what = one context window of exchanges
 * .why = captures state at a moment in time for continuation, branch, or revive
 */
export interface BrainEpisode {
  /**
   * .what = content-derived hash of this episode
   * .why = provides identity for content-addressed lookup and deduplication
   */
  hash: string;

  /**
   * .what = the ordered list of exchanges in this episode
   */
  exchanges: BrainExchange[];
}

export class BrainEpisode
  extends DomainLiteral<BrainEpisode>
  implements BrainEpisode
{
  public static nested = { exchanges: BrainExchange };
}
```

**declastruct notes:**
- DomainLiteral: immutable, content-derived hash
- hash: required, computed from exchanges
- no primary or unique key: content-addressed
- serializable for cross-supplier transfer

### 3.3. BrainSeries

chain of episodes bridged by compaction. the unit of continuity across context window boundaries.

```ts
/**
 * .what = chain of episodes with compaction summaries
 * .why = enables continuation across context window boundaries
 * .note = compaction summaries are stored as the first exchange of each subsequent episode,
 *   not as a separate array. the "previously on..." recap becomes the first user message
 *   and the brain's acknowledgment becomes the first assistant message.
 */
export interface BrainSeries {
  /**
   * .what = content-derived hash of this series
   * .why = provides identity for content-addressed lookup and deduplication
   */
  hash: string;

  /**
   * .what = the ordered list of episodes in this series
   */
  episodes: BrainEpisode[];
}

export class BrainSeries
  extends DomainLiteral<BrainSeries>
  implements BrainSeries
{
  public static nested = { episodes: BrainEpisode };
}
```

**declastruct notes:**
- DomainLiteral: immutable, content-derived hash
- hash: required, computed from episodes
- no primary or unique key: content-addressed
- compaction summaries are embedded in episodes, not stored separately


### 3.4. BrainChoiceSlug type

discriminant for brain type, used to conditionally type series.

**file:** `src/domain.objects/ContextBrain.ts`

```ts
/**
 * .what = string discriminant for brain type
 * .why = enables conditional types on BrainOutput.series
 * .note = named BrainChoiceSlug to avoid collision with prior BrainChoice = BrainAtom | BrainRepl
 */
export type BrainChoiceSlug = 'atom' | 'repl';
```

### 3.5. BrainOutput (extended)

update BrainOutput to always include episode, and conditionally type series based on brain choice.

**file:** `src/domain.objects/BrainOutput.ts`

```ts
/**
 * .what = conditional type for series based on brain choice
 * .why = guarantees series is null for atom, BrainSeries for repl, union for unknown
 */
type AsBrainOutputSeriesFor<TBrainChoiceSlug extends BrainChoiceSlug> =
  TBrainChoiceSlug extends 'repl'
    ? BrainSeries
    : TBrainChoiceSlug extends 'atom'
      ? null
      : BrainSeries | null;

/**
 * .what = result of any brain invocation: output plus metrics plus continuation refs
 * .why = pairs the caller's output with measurements and continuation state
 *
 * .note = every `.ask()` and `.act()` returns this shape
 */
export interface BrainOutput<TOutput, TBrainChoiceSlug extends BrainChoiceSlug = BrainChoiceSlug> {
  /**
   * .what = the actual output from the brain
   */
  output: TOutput;

  /**
   * .what = size and cost measurements from the invocation
   */
  metrics: BrainOutputMetrics;

  /**
   * .what = NEW episode reference (immutable checkpoint)
   * .why = enables continuation, fanout, and revive patterns
   */
  episode: BrainEpisode;

  /**
   * .what = NEW series reference (immutable checkpoint)
   * .why = null for BrainAtom, BrainSeries for BrainRepl, union when unknown
   */
  series: AsBrainOutputSeriesFor<TBrainChoiceSlug>;
}

export class BrainOutput<TOutput, TBrainChoiceSlug extends BrainChoiceSlug = BrainChoiceSlug>
  extends DomainLiteral<BrainOutput<TOutput, TBrainChoiceSlug>>
  implements BrainOutput<TOutput, TBrainChoiceSlug>
{
  public static nested = {
    metrics: BrainOutputMetrics,
    episode: BrainEpisode,
    series: BrainSeries,
  };
}
```

**usage:**
- `BrainOutput<TOutput, 'atom'>` — series is `null`
- `BrainOutput<TOutput, 'repl'>` — series is `BrainSeries`
- `BrainOutput<TOutput>` — series is `BrainSeries | null` (default, for generic code)

**change from current:**
- add second type parameter `TBrainChoiceSlug extends BrainChoiceSlug = BrainChoiceSlug`
- add `episode: BrainEpisode` (always present)
- add `series: BrainOutputSeries<TBrainChoiceSlug>` (conditionally typed)

### 3.6. BrainAtom (extended)

extend the current BrainAtom interface.

**file:** `src/domain.objects/BrainAtom.ts`

```ts
export interface BrainAtom {
  // ... current properties ...

  /**
   * .what = the ask operation with episode continuation
   */
  ask: <TOutput>(
    input: {
      on?: { episode: BrainEpisode };
      plugs?: BrainAtomPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<BrainOutput<TOutput, 'atom'>>;
}
```

**change from current:**
- add `on?: { episode: BrainEpisode }` to input
- return type `BrainOutput<TOutput, 'atom'>` guarantees `series: null`

### 3.7. BrainRepl (extended)

extend the current BrainRepl interface.

**file:** `src/domain.objects/BrainRepl.ts`

```ts
export interface BrainRepl {
  // ... current properties ...

  /**
   * .what = readonly analysis with series/episode continuation
   */
  ask: <TOutput>(
    input: {
      on?: PickOne<{
        episode: BrainEpisode;
        series: BrainSeries;
      }>;
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<BrainOutput<TOutput, 'repl'>>;

  /**
   * .what = read+write action with series/episode continuation
   */
  act: <TOutput>(
    input: {
      on?: PickOne<{
        episode: BrainEpisode;
        series: BrainSeries;
      }>;
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<BrainOutput<TOutput, 'repl'>>;
}
```

**change from current:**
- add `on?: PickOne<{ episode, series }>` to input for both ask and act
- return type `BrainOutput<TOutput, 'repl'>` guarantees `series: BrainSeries`

---

## 4. domain.operations

### 4.1. genBrainExchange

construct a BrainExchange from request-response pair.

```ts
/**
 * .what = constructs a BrainExchange from request-response pair
 * .why = provides a factory for the atomic unit of brain interaction
 */
export const genBrainExchange = async (input: {
  with: {
    input: string;
    output: string;
    exid: string | null;
  };
}): Promise<BrainExchange> => {
  const hash = await computeBrainExchangeHash({
    input: input.with.input,
    output: input.with.output,
  });
  return new BrainExchange({
    hash,
    input: input.with.input,
    output: input.with.output,
    exid: input.with.exid,
  });
};
```

### 4.2. genBrainEpisode

create or extend an episode with an exchange.

```ts
/**
 * .what = creates a new episode or extends a prior one with an exchange
 * .why = returns NEW episode (fresh if on.episode is null, extended otherwise)
 */
export const genBrainEpisode = async (input: {
  on: { episode: BrainEpisode | null };
  with: { exchange: BrainExchange };
}): Promise<BrainEpisode> => {
  const exchanges = [
    ...(input.on.episode?.exchanges ?? []),
    input.with.exchange,
  ];
  const hash = await computeBrainEpisodeHash({ exchanges });
  return new BrainEpisode({ hash, exchanges });
};
```

### 4.3. genBrainSeries

create or extend a series with an episode.

```ts
/**
 * .what = creates a new series or extends a prior one with an episode
 * .why = returns NEW series (fresh if on.series is null, extended otherwise)
 * .note = if this is a compaction boundary, the episode's first exchange should contain the recap
 */
export const genBrainSeries = async (input: {
  on: { series: BrainSeries | null };
  with: { episode: BrainEpisode };
}): Promise<BrainSeries> => {
  const episodes = [
    ...(input.on.series?.episodes ?? []),
    input.with.episode,
  ];
  const hash = await computeBrainSeriesHash({ episodes });
  return new BrainSeries({ hash, episodes });
};
```

### 4.4. computeBrainExchangeHash

compute content-derived hash for an exchange.

```ts
/**
 * .what = computes content-derived hash for a BrainExchange
 * .why = provides identity for content-addressed lookup and deduplication
 * .note = excludes exid since that is supplier-assigned, not content-derived
 */
export const computeBrainExchangeHash = async (input: {
  input: string;
  output: string;
}): Promise<string> =>
  toHashSha256([input.input, input.output].join('\n'));
```

### 4.5. computeBrainEpisodeHash

compute content-derived hash for an episode.

```ts
/**
 * .what = computes content-derived hash for a BrainEpisode
 * .why = provides identity for content-addressed lookup and deduplication
 */
export const computeBrainEpisodeHash = async (input: {
  exchanges: BrainExchange[];
}): Promise<string> =>
  toHashSha256(input.exchanges.map((e) => e.hash).join('\n'));
```

### 4.6. computeBrainSeriesHash

compute content-derived hash for a series.

```ts
/**
 * .what = computes content-derived hash for a BrainSeries
 * .why = provides identity for content-addressed lookup and deduplication
 */
export const computeBrainSeriesHash = async (input: {
  episodes: BrainEpisode[];
}): Promise<string> =>
  toHashSha256(input.episodes.map((e) => e.hash).join('\n'));
```

---

## 5. access layer

### 5.1. no persistent storage required

episodes and series are **self-contained** domain literals:
- callers hold the full state
- suppliers are stateless (receive context as plaintext, respond)
- cross-supplier continuation is trivial (same plaintext works everywhere)

this means:
- no DAOs needed for episode/series storage
- no external lookup by id or reference
- no expiration or invalidation concerns
- identity is in the content itself (hash)

### 5.2. caller-managed persistence

if callers want to persist episodes/series, they can:
- serialize via `serialize()` from domain-objects
- store in their preferred mechanism (cache, file, database)
- deserialize via `.build()` or constructor

this is intentionally left to callers. if a common pattern emerges, rhachet can lift it later.

---

## 6. implementation notes

### 6.1. supplier-side implementation

each brain supplier implements the continuation contract:

**for stateless apis (anthropic messages, openai chat completions):**
1. serialize prior episode/series exchanges to messages array via `serialize()` from domain-objects
2. append new prompt as user message
3. call api with full messages array
4. construct new exchange from response via `genBrainExchange`
5. return NEW episode/series via `genBrainEpisode` / `genBrainSeries`

**for stateful apis (openai responses api, google interactions api):**
1. if prior episode has supplier exid, use `previous_response_id` or `previous_interaction_id`
2. else fall back to plaintext serialization
3. capture response id in exchange.exid
4. construct new exchange via `genBrainExchange`
5. return NEW episode/series via `genBrainEpisode` / `genBrainSeries`

### 6.2. compaction (BrainRepl only)

when context window fills within a repl loop:
1. current episode ends
2. generate compaction summary (recap of exchanges)
3. start new episode with recap as first exchange (user: "previously on...", assistant: acknowledgment)
4. append new episode to series

the compaction logic lives in the BrainRepl implementation, not in these domain operations.
the recap becomes a regular exchange, not separate metadata.

### 6.3. error scenarios

**continuation not supported:**
```ts
// supplier that lacks continuation support throws
throw new UnexpectedCodePathError('continuation not supported', {
  priorEpisode: input.on?.episode,
  suggestion: 'use a different brain supplier or start fresh',
});
```

**compacted episode error (BrainRepl):**
```ts
// when caller tries to continue a compacted episode
throw new UnexpectedCodePathError('episode has been compacted', {
  episode: input.on?.episode,
  suggestion: 'continue via series instead',
});
```

---

## 7. summary

### domain.objects

| object          | base class    | purpose                                                        |
| --------------- | ------------- | -------------------------------------------------------------- |
| BrainExchange   | DomainLiteral | one request-response pair                                      |
| BrainEpisode    | DomainLiteral | one context window of exchanges                                |
| BrainSeries     | DomainLiteral | chain of episodes with compaction                              |
| BrainChoiceSlug | type alias    | `'atom' \| 'repl'` discriminant for conditional type on series |
| BrainOutput     | DomainLiteral | output + episode + series (typed via `BrainChoiceSlug`)        |

### domain.operations

| operation                | purpose                                  |
| ------------------------ | ---------------------------------------- |
| genBrainExchange         | construct exchange from request-response |
| genBrainEpisode          | create or extend episode with exchange   |
| genBrainSeries           | create or extend series with episode     |
| computeBrainExchangeHash | content-derived hash for exchange        |
| computeBrainEpisodeHash  | content-derived hash for episode         |
| computeBrainSeriesHash   | content-derived hash for series          |

### access layer

| component      | decision                             |
| -------------- | ------------------------------------ |
| DAOs           | not needed (self-contained literals) |
| persistence    | caller-managed                       |
| cross-supplier | via plaintext serialization          |

### interface changes

| interface     | change                                                                                             |
| ------------- | -------------------------------------------------------------------------------------------------- |
| BrainOutput   | add second type param `TBrainChoiceSlug`, add `episode`, add `series` (typed via conditional type) |
| BrainAtom.ask | add `on?: { episode }`, return `BrainOutput<TOutput, 'atom'>` (series is `null`)                   |
| BrainRepl.ask | add `on?: PickOne<{ episode, series }>`, return `BrainOutput<TOutput, 'repl'>` (series is present) |
| BrainRepl.act | add `on?: PickOne<{ episode, series }>`, return `BrainOutput<TOutput, 'repl'>` (series is present) |
