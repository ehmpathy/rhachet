# research.patterns.code.test: boot.yml for role context curation

## pattern.1: cli acceptance test structure

**location:** `accept.blackbox/cli/roles.boot.acceptance.test.ts:1-30`

**citation [1]:**
```typescript
import { given, then, useBeforeAll, when } from 'test-fns';
import { genTestTempRepo } from '@/blackbox/.test/infra/genTestTempRepo';
import { invokeRhachetCliBinary } from '@/blackbox/.test/infra/invokeRhachetCliBinary';

describe('rhachet roles boot', () => {
  given('[case1] repo with briefs', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-briefs' }),
    );
    when('[t0] roles boot --repo this --role any', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['roles', 'boot', '--repo', 'this', '--role', 'any'],
          cwd: repo.path,
        }),
      );
      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });
```

**relation to wish:** boot.yml tests will follow same BDD structure with given/when/then.

**action:** [REUSE] — same pattern for boot.yml acceptance tests.

---

## pattern.2: test temp repo generation

**location:** `accept.blackbox/.test/infra/genTestTempRepo.ts:48-93`

**citation [2]:**
```typescript
export const genTestTempRepo = (input: {
  fixture: TestRepoFixture;
  suffix?: string;
  install?: boolean;
}): { path: string; } => {
  // gen unique temp directory path
  const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const suffix = input.suffix ? `-${input.suffix}` : '';
  const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${suffix}`);

  // copy fixture assets into temp repo
  const fixturePath = join(ASSETS_DIR, input.fixture);
  cpSync(fixturePath, repoPath, { recursive: true });

  // make shell skills executable
  setSkillsExecutable({ dir: repoPath });

  // init git repo (required for rhachet)
  execSync('git init', { cwd: repoPath, stdio: 'ignore' });
```

**relation to wish:** boot.yml tests need temp repos with boot.yml fixtures.

**action:** [REUSE] — use same genTestTempRepo with new fixture type.

---

## pattern.3: test fixture directory structure

**location:** `accept.blackbox/.test/assets/with-briefs/`

**citation [3]:**
```
with-briefs/
├── .agent/repo=.this/role=any/
│   ├── readme.md
│   └── briefs/
│       └── sample.md
└── rhachet.use.ts
```

**citation [4]:** `accept.blackbox/.test/assets/with-briefs/.agent/repo=.this/role=any/briefs/sample.md:1-11`
```markdown
# sample brief

this is a sample brief for test purposes.

## .what

a test fixture brief that validates boot functionality.
```

**relation to wish:** boot.yml tests need fixtures with boot.yml and varied brief/skill configs.

**action:** [EXTEND] — create `with-boot-yaml-simple` and `with-boot-yaml-subject` fixtures.

---

## pattern.4: cli invocation helper

**location:** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:15-46`

**citation [5]:**
```typescript
export const invokeRhachetCliBinary = (input: {
  binary?: 'rhachet' | 'rhx';
  args: string[];
  cwd: string;
  stdin?: string;
  logOnError?: boolean;
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const binPath = input.binary === 'rhx' ? RHX_BIN : RHACHET_BIN;
  const result = spawnSync(binPath, input.args, {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
    env: input.env ? { ...process.env, ...input.env } : undefined,
  });
```

**relation to wish:** boot.yml tests invoke `rhachet roles boot` with various flags.

**action:** [REUSE] — same helper for boot.yml CLI tests.

---

## pattern.5: integration test temp directory

**location:** `src/.test/infra/genTestTempDir.ts:1-30`

**citation [6]:**
```typescript
export const genTestTempDir = (input: {
  base: string;
  name: string;
}): {
  path: string;
  setup: () => void;
  teardown: () => void;
  rm: (relativePath: string) => void;
} => {
  const testDir = resolve(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,
    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },
    teardown: () => {
      process.chdir(originalCwd);
    },
```

**relation to wish:** integration tests for boot.yml parse logic need temp dirs.

**action:** [REUSE] — same helper for boot.yml integration tests.

---

## pattern.6: test asset writer

**location:** `src/.test/infra/setTestTempAsset.ts:8-40`

**citation [7]:**
```typescript
export const setTestTempAsset = (input: {
  dir: string;
  name: string;
  content: string;
  executable?: boolean;
}): { path: string; } => {
  if (!input.dir.includes('.temp'))
    throw new Error(`setTestTempAsset: dir must be under .temp`);

  const assetPath = resolve(input.dir, input.name);
  mkdirSync(dirname(assetPath), { recursive: true });
  writeFileSync(assetPath, input.content);

  const shouldExecute = input.executable ?? input.name.endsWith('.sh');
  if (shouldExecute) chmodSync(assetPath, '755');

  return { path: assetPath };
};
```

**relation to wish:** integration tests can create boot.yml files dynamically.

**action:** [REUSE] — use for dynamic boot.yml content in tests.

---

## pattern.7: bdd test helpers from test-fns

**location:** `package.json:144` (test-fns v1.12.1)

**citation [8]:**
```typescript
import { given, then, when, useBeforeAll } from 'test-fns';

given('[case1] description', () => {
  const scene = useBeforeAll(async () => {
    // async setup
    return { data };
  });

  when('[t0] action', () => {
    then('assertion', () => {
      expect(scene.data).toBeDefined();
    });
  });
});
```

**relation to wish:** all boot.yml tests use BDD structure per briefs.

**action:** [REUSE] — same pattern throughout.

---

## pattern.8: snapshot test for cli output

**location:** `accept.blackbox/cli/init.full.acceptance.test.ts:42-44`

**citation [9]:**
```typescript
then('full stdout matches snapshot', () => {
  expect(result.stdout).toMatchSnapshot();
});
```

**relation to wish:** boot.yml output format can be validated via snapshots.

**action:** [REUSE] — snapshot tests for boot output structure.

---

## pattern.9: integration test structure

**location:** `src/domain.operations/role/getRoleBriefs.integration.test.ts:1-50`

**citation [10]:**
```typescript
describe('getRoleBriefs', () => {
  const testDir = resolve(__dirname, './.temp/getRoleBriefs');

  beforeAll(() => {
    mkdirSync(testDir, { recursive: true });
    process.chdir(testDir);
  });

  given('[case1] role linked with briefs', () => {
    beforeEach(() => {
      const briefsDir = resolve(testDir, '.agent/repo=testorg/role=tester/briefs');
      mkdirSync(briefsDir, { recursive: true });

      writeFileSync(
        resolve(briefsDir, 'rule.require.tests.md'),
        '# always write tests',
      );
    });

    when('[t0] getRoleBriefs with role name', () => {
      then('returns artifacts for matched briefs', async () => {
        const result = await getRoleBriefs({
          by: { role: { name: 'tester' }, briefs: { name: ['rule.require.tests'] } },
        });
        expect(result).toHaveLength(1);
      });
    });
  });
});
```

**relation to wish:** boot.yml parse and apply logic needs integration tests.

**action:** [REUSE] — same structure for boot.yml integration tests.

---

## pattern.10: jest configuration

**location:** `jest.unit.config.ts:13-42`

**citation [11]:**
```typescript
const config: Config = {
  verbose: true,
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@src/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(t|j)sx?$': '@swc/jest',
  },
  testMatch: [
    '**/*.test.ts',
    '!**/*.acceptance.test.ts',
    '!**/*.integration.test.ts',
  ],
};
```

**citation [12]:** `package.json:77-82`
```json
"test:unit": "jest -c ./jest.unit.config.ts --forceExit --verbose --passWithNoTests",
"test:integration": "jest -c ./jest.integration.config.ts --forceExit --verbose --passWithNoTests",
"test:acceptance:locally": "npm run build && LOCALLY=true jest -c ./jest.acceptance.config.ts"
```

**relation to wish:** boot.yml tests run via current test commands.

**action:** [REUSE] — current jest configs handle all test types.

---

## summary

| pattern | location | action | rationale |
|---------|----------|--------|-----------|
| cli acceptance structure | roles.boot.acceptance.test.ts | [REUSE] | same BDD pattern |
| temp repo generation | genTestTempRepo.ts | [REUSE] | same infra |
| fixture directory | with-briefs/ | [EXTEND] | add boot.yml fixtures |
| cli invocation | invokeRhachetCliBinary.ts | [REUSE] | same helper |
| temp directory | genTestTempDir.ts | [REUSE] | same helper |
| asset writer | setTestTempAsset.ts | [REUSE] | dynamic boot.yml |
| bdd helpers | test-fns | [REUSE] | same library |
| snapshot tests | init.full.acceptance.test.ts | [REUSE] | output validation |
| integration structure | getRoleBriefs.integration.test.ts | [REUSE] | same pattern |
| jest config | jest.*.config.ts | [REUSE] | current setup |

---

## new fixtures required

| fixture name | purpose | contents |
|--------------|---------|----------|
| `with-boot-yaml-simple` | simple mode tests | boot.yml with briefs.say globs |
| `with-boot-yaml-subject` | subject mode tests | boot.yml with always + subject.* |
| `with-boot-yaml-mixed` | error case tests | boot.yml with mixed mode (invalid) |
