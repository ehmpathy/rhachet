# vision: boot.yml for role context curation

## the outcome world

### before

every brief in a role gets injected into context at boot time. a mechanic role with 102 briefs means ~60k tokens consumed on session start — whether or not those briefs are relevant to the current task.

the human asks: "fix this failed test"

the agent receives: 102 briefs about domain-driven design, terraform patterns, seaturtle philosophy, gerund rules, and 98 other topics. most are irrelevant. context is cluttered. tokens are burned.

### after

roles declare a `boot.yml` that curates what gets said vs what gets referenced.

**simple mode** — for most roles:

```yaml
# boot.yml (simple mode)
briefs:
  say:
    - practices/code.test/**/*.md
    - practices/code.prod/pitofsuccess.errors/**/*.md
```

**subject mode** — for roles with many briefs that need usecase-scoped boot:

```yaml
# boot.yml (subject mode)
always:
  briefs:
    say:
      - practices/lang.terms/rule.forbid.gerunds.md

subject.test:
  briefs:
    say:
      - practices/code.test/**/*.md
```

now when the human asks "fix this failed test":
- the agent receives ~15 briefs about test patterns (full content via say)
- the agent sees other briefs as refs (paths only, no content)
- tokens drop from 60k to ~12k
- context is focused on the task at hand

### the aha moment

the agent encounters an unfamiliar pattern. it sees in its refs:
```
ref: practices/code.prod/evolvable.domain.objects/rule.require.immutable-refs.md
```

one Read tool call later, it has the brief it needs — on demand, not preloaded.

**context as a library, not a lecture.**

---

## two modes: simple vs subject

boot.yml supports two mutually exclusive modes. pick one and stay in it.

### simple mode

for most roles. top-level `briefs:` and `skills:` keys.

```yaml
# boot.yml (simple mode)
briefs:
  say:
    - practices/code.test/**/*.md
    - practices/code.prod/pitofsuccess.errors/**/*.md

skills:
  say:
    - git.commit/**/*.sh
```

**defaults:**
- if `briefs:` key is absent → all briefs are said
- if `briefs:` key is present but `say:` is absent → all briefs are said
- if `briefs.say:` is present → only matched briefs are said; all unmatched briefs are ref
- same logic applies independently to `skills:`

**rules:**
- no `always:` or `subject.*:` keys allowed in this mode

### subject mode

for roles with many briefs that benefit from usecase-scoped boot.

```yaml
# boot.yml (subject mode)
always:
  briefs:
    say:
      - practices/lang.terms/rule.forbid.gerunds.md
      - practices/lang.tones/rule.im_an.ehmpathy_seaturtle.md
    ref:
      - practices/lang.terms/**/*.md
  skills:
    say:
      - git.commit/**/*.sh

# subject-specific collections
subject.test:
  briefs:
    say:
      - practices/code.test/**/*.md
      - practices/code.prod/pitofsuccess.errors/**/*.md
    ref:
      - practices/code.prod/readable.narrative/**/*.md

subject.terms:
  briefs:
    say:
      - practices/lang.terms/**/*.md
    ref:
      - practices/lang.tones/**/*.md
```

**defaults:**
- if `always:` is absent → no briefs/skills are always included
- if `always.briefs:` is absent → no briefs are always included
- if `always.briefs.say:` is absent → no briefs are always said
- if `always.briefs.ref:` is absent → no briefs are always ref'd
- same logic applies to `always.skills:` and each `subject.$slug:`
- briefs/skills not matched by any `say:` or `ref:` glob appear in the `also` section as refs (when all subjects booted)
- briefs/skills not matched by any glob are omitted entirely (when specific subjects booted via `--usecase`)

**rules:**
- if `always:` or any `subject.*:` key exists → subject mode is active
- no top-level `briefs:` or `skills:` keys allowed in this mode
- fail fast if modes are mixed

### mode detection

| keys present | mode | behavior |
|--------------|------|----------|
| `briefs:` and/or `skills:` only | simple | top-level curation |
| `always:` and/or `subject.*:` | subject | usecase-scoped curation |
| both patterns | error | fail fast: "mixed mode not allowed" |

---

## user experience

### usecase 1: simple mode with say list

most roles start here. declare what to say; rest becomes ref.

```yaml
# boot.yml
briefs:
  say:
    - practices/code.test/**/*.md
    - practices/lang.terms/**/*.md

skills:
  say:
    - git.commit/**/*.sh
```

boots with:
- matched briefs/skills → full content (say)
- unmatched briefs/skills → path only (ref)

### usecase 2: current behavior (say all)

if you want current behavior (say all), just omit the boot.yml file entirely — or omit the `briefs:` and `skills:` keys.

no boot.yml = say all briefs and skills.

### usecase 3: subject mode — boot all subjects

```sh
rhachet roles boot --repo ehmpathy --role mechanic
```

all subjects are booted:
- `always` briefs/skills are included first
- each subject's `say` briefs are injected
- each subject's `ref` briefs appear as paths
- briefs not in any subject appear in an `also` section as refs

### usecase 4: subject mode — boot specific subjects

```sh
rhachet roles boot --repo ehmpathy --role mechanic --usecase test
rhachet roles boot --repo ehmpathy --role mechanic --usecase test,refactor
```

only the specified subjects are booted:
- `always` briefs/skills are included first (these never change)
- selected subjects' `say` and `ref` briefs are included
- briefs from other subjects and the `also` section are omitted entirely

### usecase 5: subject mode — overlap across subjects

when multiple subjects are booted and a brief appears in multiple:

```yaml
subject.test:
  briefs:
    say:
      - practices/code.prod/pitofsuccess.errors/**/*.md  # said here

subject.refactor:
  briefs:
    say:
      - practices/code.prod/pitofsuccess.errors/**/*.md  # also said here
```

boot with `--usecase test,refactor`:
- first occurrence: full content injected
- subsequent occurrences: `(as mentioned earlier in subject.test)` + path only

this prevents duplication while preserved discoverability.

---

## mental model

### progressive complexity

```
no boot.yml          →  say all (current behavior)
     ↓
simple mode          →  say: [...] curates what's said
     ↓
subject mode         →  always: + subject.*: for usecase-scoped boot
```

start simple. graduate to subjects when you need usecase-scoped context.

### how users would describe it

> "boot.yml lets you pick what briefs to load upfront vs what to just list."

> "subject mode is like course modules — pick the modules you need for your task."

### analogies

| analogy | say | ref |
|---------|-----|-----|
| library | books on your desk | books on the shelf (catalog shows they exist) |
| browser | open tabs | bookmarks |
| code | imported modules | available modules (can import on demand) |

### terms

| user term | our term | definition |
|-----------|----------|------------|
| "load" | say | inject full content at boot |
| "list" or "index" | ref | inject path only, no content |
| "core" or "base" | always | briefs/skills included on every boot (subject mode) |
| "topic" or "area" | subject | a curated collection for a usecase (subject mode) |
| "task mode" | usecase | subset of subjects to boot (subject mode) |

### key principle: presence of say flips the default

**simple mode defaults (per resource type):**

| scenario | briefs behavior | skills behavior |
|----------|-----------------|-----------------|
| no boot.yml | all said | all said |
| `briefs:` absent, `skills:` absent | all said | all said |
| `briefs: {}` (no say key) | all said | all said |
| `briefs: { say: [...] }` | matched = said, unmatched = ref | all said (skills not specified) |
| both have `say:` lists | matched = said, unmatched = ref | matched = said, unmatched = ref |

**subject mode defaults:**

| scenario | behavior |
|----------|----------|
| brief in `always.briefs.say` | said on every boot |
| brief in `always.briefs.ref` | ref'd on every boot |
| brief in `subject.X.briefs.say` | said when subject.X is booted |
| brief in `subject.X.briefs.ref` | ref'd when subject.X is booted |
| brief not in any glob, all subjects booted | ref'd in `also` section |
| brief not in any glob, specific subjects booted | omitted entirely |

---

## evaluation

### how well does it solve the goals?

| goal | solved? | notes |
|------|---------|-------|
| reduce token cost | yes | only say-briefs consume tokens |
| maintain discoverability | yes | ref-briefs show paths |
| enable on-demand access | yes | agent can Read any ref path |
| progressive complexity | yes | simple mode → subject mode |
| backwards compatible | yes | no boot.yml = current behavior (say all) |
| portable across repos | yes | boot.yml lives in role, gets symlinked |

### pros

- **progressive complexity**: start simple, graduate to subjects when needed
- **token efficiency**: boot context can drop from 60k to <15k tokens
- **focused context**: agent sees what matters for the task
- **backwards compatible**: no boot.yml = say all (current behavior)
- **fail fast**: mixed modes rejected immediately
- **portable**: boot.yml symlinked like other role assets

### cons

- **two modes to learn**: simple vs subject
- **glob complexity**: authors must understand glob patterns

### edge cases and pit of success

| edge case | handler |
|-----------|---------|
| no boot.yml present | default to current behavior: say all briefs |
| boot.yml with empty `briefs: {}` | say all briefs (no say list = say all) |
| boot.yml with `briefs: { say: [] }` | say none; all briefs are ref |
| mixed mode (both patterns) | fail fast: "mixed mode not allowed" |
| brief in always and also in subject | always wins; subject gets "as mentioned earlier" + ref |
| brief matches say in multiple subjects | first says content; others say "as mentioned earlier" + ref |
| brief not in any subject | appears in 'also' section as ref |
| `--usecase` in simple mode | fail fast: "usecase requires subject mode" |
| `--usecase` specifies unknown subject | fail fast: "subject not found" |

---

## contract shape

### simple mode

```yaml
# boot.yml schema (simple mode)
briefs:
  say: string[]   # globs for briefs to say; if omitted, say all

skills:
  say: string[]   # globs for skills to say; if omitted, say all
```

### subject mode

```yaml
# boot.yml schema (subject mode)

# briefs/skills included on every boot
always:
  briefs:
    say: string[]
    ref: string[]
  skills:
    say: string[]
    ref: string[]

# usecase-scoped collections (one per subject)
subject.$slug:
  briefs:
    say: string[]
    ref: string[]
  skills:
    say: string[]
    ref: string[]
```

---

## boot output structure

### simple mode

```
<brief path="...">full content here</brief>     # matched by briefs.say
<brief path="...">full content here</brief>

<ref path="..."/>                                # not matched by briefs.say
<ref path="..."/>

<skill path="...">content</skill>               # matched by skills.say
<ref path="..."/>                                # not matched by skills.say
```

### subject mode

```
# always section first
<brief path="...">full content here</brief>     # from always.briefs.say
<ref path="..."/>                                # from always.briefs.ref
<skill path="...">content</skill>               # from always.skills.say

# then selected subjects
<brief path="...">full content here</brief>     # from subject.$slug.briefs.say
<ref path="..."/>                                # from subject.$slug.briefs.ref
<skill path="...">content</skill>               # from subject.$slug.skills.say

# finally, uncategorized briefs (when all subjects booted)
<also>                                           # briefs not in any subject
  <ref path="..."/>
</also>
```

---

## what gets awkward?

### mode detection ambiguity

what if someone writes `briefs:` AND `subject.test:`?

**resolution**: fail fast. detect both patterns, reject with clear error: "mixed mode not allowed — use either top-level briefs/skills OR always/subject, not both."

### subject granularity

how fine-grained should subjects be? too few = still too much context. too many = overhead to select.

**resolution**: start with 3-5 subjects per role. iterate based on usage patterns. document recommended subjects in role readme.

### skill refs vs skill execution

for skills, `ref` means "show the path exists" — the agent can still execute any skill regardless of say/ref status.

**resolution**: clarify in docs: ref/say affects boot context, not execution capability.

### 'also' section can grow large

if role has many briefs and few subjects, 'also' section dominates.

**resolution**: this is a signal to create more subjects. alternatively, add a `hide` glob to explicitly exclude briefs from boot entirely.
