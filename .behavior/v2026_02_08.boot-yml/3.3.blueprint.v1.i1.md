# blueprint: boot.yml for role context curation

## overview

implement `boot.yml` support for the `rhachet roles boot` command, enabling roles to curate which briefs and skills are "say" (full content) vs "ref" (path only) at boot time.

---

## filediffs treestruct

```
src/
  domain.objects/
    [+] RoleBootSpec.ts                      # discriminated union + both mode types
    [+] RoleBootSpec.test.ts                 # unit tests for schema validation
    [~] RoleManifest.ts                      # add optional boot field

  domain.operations/
    boot/
      [+] parseRoleBootYaml.ts                   # parse + validate boot.yml
      [+] parseRoleBootYaml.test.ts              # unit tests
      [+] computeBootMode.ts                  # detect simple vs subject mode
      [+] computeBootMode.test.ts             # unit tests
      [+] filterBootResourcesByGlob.ts      # glob match briefs/skills
      [+] filterBootResourcesByGlob.test.ts # unit tests
      [+] computeBootPlan.ts                 # compute say/ref per resource
      [+] computeBootPlan.test.ts            # unit tests

    invoke/
      [~] bootRoleResources.ts               # integrate boot.yml logic
      [+] bootRoleResources.integration.test.ts  # integration tests

  contract/
    cli/
      [~] invokeRolesBoot.ts                 # add --usecase option

accept.blackbox/
  .test/
    assets/
      [+] with-boot-yaml-simple/             # simple mode fixture
      [+] with-boot-yaml-subject/            # subject mode fixture (with always)
      [+] with-boot-yaml-subject-no-always/  # subject mode fixture (without always)
      [+] with-boot-yaml-mixed/              # mixed mode (error case) fixture

  cli/
    [+] roles.boot.bootyaml.acceptance.test.ts  # acceptance tests
```

---

## codepaths treestruct

```
invokeRolesBoot (cli entry)
├── [~] parse --usecase option
├── [○] findUniqueRoleDir
└── [~] bootRoleResources
    ├── [○] resolve role directory
    ├── [○] enumerate all files (getAllFilesFromDir)
    ├── [+] loadRoleBootSpec
    │   ├── [+] check if boot.yml present
    │   ├── [+] parseRoleBootYaml (yaml → raw object)
    │   └── [+] validate against zod schema
    ├── [+] computeBootMode
    │   ├── [+] detect simple mode (briefs/skills keys)
    │   ├── [+] detect subject mode (always/subject.* keys)
    │   └── [+] fail fast on mixed mode
    ├── [+] computeBootPlan
    │   ├── [+] filterBootResourcesByGlob (fast-glob)
    │   ├── [+] resolve say vs ref per resource
    │   ├── [+] handle subject overlap dedupe
    │   └── [+] compute "also" section (subject mode)
    ├── [~] output resources
    │   ├── [○] say resources → <brief>content</brief>
    │   ├── [+] ref resources → <ref path="..."/>
    │   └── [+] also section → <also><ref.../></also>
    └── [~] output stats
        ├── [○] total files/chars/tokens
        └── [+] say vs ref breakdown
```

---

## domain.objects

### RoleBootSpec

```ts
// src/domain.objects/RoleBootSpec.ts
import { DomainLiteral } from 'domain-objects';
import { z } from 'zod';

/**
 * .what = schema for resource curation (briefs or skills)
 */
const schemaResourceCuration = z.object({
  say: z.array(z.string()).optional(),
  ref: z.array(z.string()).optional(),
});

/**
 * .what = schema for simple mode boot.yml
 */
const schemaRoleBootSpecSimplified = z.object({
  briefs: schemaResourceCuration.optional(),
  skills: schemaResourceCuration.optional(),
});

/**
 * .what = schema for subject section
 */
const schemaSubjectSection = z.object({
  briefs: schemaResourceCuration.optional(),
  skills: schemaResourceCuration.optional(),
});

/**
 * .what = schema for subject mode boot.yml
 * .note = subject keys are dynamic (subject.$slug)
 */
const schemaRoleBootSpecSubjected = z
  .object({
    always: schemaSubjectSection.optional(),
  })
  .catchall(schemaSubjectSection);

/**
 * .what = simple mode boot.yml — top-level briefs/skills curation
 */
export interface RoleBootSpecSimplified {
  mode: 'simple';
  briefs: { say: string[]; ref: string[] } | null;
  skills: { say: string[]; ref: string[] } | null;
}

export class RoleBootSpecSimplified extends DomainLiteral<RoleBootSpecSimplified> implements RoleBootSpecSimplified {
  public static schema = schemaRoleBootSpecSimplified;
}

/**
 * .what = subject mode boot.yml — usecase-scoped curation with always + subjects
 */
export interface RoleBootSpecSubjected {
  mode: 'subject';
  always: { briefs: { say: string[]; ref: string[] } | null; skills: { say: string[]; ref: string[] } | null } | null;
  subjects: Record<string, { briefs: { say: string[]; ref: string[] } | null; skills: { say: string[]; ref: string[] } | null }>;
}

export class RoleBootSpecSubjected extends DomainLiteral<RoleBootSpecSubjected> implements RoleBootSpecSubjected {
  public static schema = schemaRoleBootSpecSubjected;
}

/**
 * .what = discriminated union of boot.yml modes
 */
export type RoleBootSpec = RoleBootSpecSimplified | RoleBootSpecSubjected;
```

### RoleManifest extension

```ts
// extend current RoleManifest.ts
interface RoleManifest {
  // ... current fields
  boot?: { uri: string };  // [+] optional path to boot.yml
}
```

---

## domain.operations

### parseRoleBootYaml

```ts
// src/domain.operations/boot/parseRoleBootYaml.ts
import { parse as parseYaml } from 'yaml';
import { BadRequestError } from 'helpful-errors';
import { RoleBootSpec } from '@src/domain.objects/RoleBootSpec';

/**
 * .what = parses boot.yml content into validated config
 * .why = centralizes yaml parse + zod validation
 */
export const parseRoleBootYaml = (input: {
  content: string;
  path: string;
}): RoleBootSpec => {
  // parse yaml
  let raw: unknown;
  try {
    raw = parseYaml(input.content);
  } catch (error) {
    throw new BadRequestError('boot.yml has invalid yaml', {
      path: input.path,
      error,
    });
  }

  // detect mode and validate
  const mode = computeBootMode({ raw });
  // ... validation logic

  return new RoleBootSpec({ mode, ... });
};
```

### computeBootMode

```ts
// src/domain.operations/boot/computeBootMode.ts
import { BadRequestError } from 'helpful-errors';

/**
 * .what = detects boot.yml mode from raw parsed object
 * .why = fail fast on mixed mode, route to correct schema
 */
export const computeBootMode = (input: {
  raw: Record<string, unknown>;
}): 'simple' | 'subject' | 'none' => {
  const keys = Object.keys(input.raw);

  const hasSimpleKeys = keys.some((k) => k === 'briefs' || k === 'skills');
  const hasSubjectKeys = keys.some((k) => k === 'always' || k.startsWith('subject.'));

  // fail fast on mixed mode
  if (hasSimpleKeys && hasSubjectKeys) {
    throw new BadRequestError(
      'mixed mode not allowed — use either top-level briefs/skills OR always/subject, not both',
      { keys },
    );
  }

  if (hasSubjectKeys) return 'subject';
  if (hasSimpleKeys) return 'simple';
  return 'none';
};
```

### filterBootResourcesByGlob

```ts
// src/domain.operations/boot/filterBootResourcesByGlob.ts
import glob from 'fast-glob';

/**
 * .what = matches file paths against glob patterns
 * .why = reuses fast-glob pattern from getRoleBriefs
 */
export const filterBootResourcesByGlob = (input: {
  paths: string[];
  globs: string[];
  cwd: string;
}): string[] => {
  const matched = new Set<string>();

  for (const pattern of input.globs) {
    const matches = glob.sync(pattern, {
      cwd: input.cwd,
      absolute: true,
      onlyFiles: true,
    });
    matches.forEach((m) => matched.add(m));
  }

  return input.paths.filter((p) => matched.has(p));
};
```

### computeBootPlan

```ts
// src/domain.operations/boot/computeBootPlan.ts

/**
 * .what = computes which resources to say vs ref
 * .why = centralizes the say/ref decision logic
 */
export const computeBootPlan = (input: {
  config: RoleBootSpec | null;
  briefPaths: string[];
  skillPaths: string[];
  cwd: string;
  usecase?: string[];  // subject mode only
}): {
  briefs: { say: string[]; ref: string[] };
  skills: { say: string[]; ref: string[] };
  also: string[];  // subject mode only
} => {
  // no config = say all (backwards compat)
  if (!input.config) {
    return {
      briefs: { say: input.briefPaths, ref: [] },
      skills: { say: input.skillPaths, ref: [] },
      also: [],
    };
  }

  if (input.config.mode === 'simple') {
    return computeSimpleModePlan(input);
  }

  return computeSubjectModePlan(input);
};
```

---

## contract.cli

### invokeRolesBoot extension

```ts
// extend current invokeRolesBoot.ts
command
  .option('--usecase <subjects>', 'boot specific subjects (comma-separated, subject mode only)')
  .action(async (opts) => {
    // ... current logic

    // parse usecase flag
    const usecases = opts.usecase?.split(',').map((s) => s.trim());

    // validate usecase only valid in subject mode
    if (usecases && config?.mode !== 'subject') {
      throw new BadRequestError('usecase requires subject mode');
    }

    // pass to bootRoleResources
    await bootRoleResources({
      slugRepo,
      slugRole,
      ifPresent,
      usecases,  // [+] new param
    });
  });
```

---

## test fixtures

### with-boot-yaml-simple

```
accept.blackbox/.test/assets/with-boot-yaml-simple/
├── rhachet.use.ts
└── .agent/
    └── repo=.this/
        └── role=any/
            ├── readme.md
            ├── boot.yml              # simple mode config
            ├── briefs/
            │   ├── always-say.md     # matched by say glob
            │   ├── not-matched.md    # becomes ref
            │   └── subdir/
            │       └── deep.md       # test recursive glob
            └── skills/
                ├── say-me.sh         # matched by say glob
                └── ref-me.sh         # becomes ref
```

**boot.yml:**
```yaml
briefs:
  say:
    - always-say.md
    - subdir/**/*.md
skills:
  say:
    - say-me.sh
```

### with-boot-yaml-subject

```
accept.blackbox/.test/assets/with-boot-yaml-subject/
├── rhachet.use.ts
└── .agent/
    └── repo=.this/
        └── role=any/
            ├── readme.md
            ├── boot.yml              # subject mode config
            ├── briefs/
            │   ├── core.md           # in always.briefs.say
            │   ├── glossary.md       # in always.briefs.ref
            │   ├── shared.md         # in both subject.test.say AND subject.prod.say (overlap dedupe)
            │   ├── precedence.md     # in always.briefs.ref AND subject.test.briefs.say (say wins)
            │   ├── test-rules.md     # in subject.test.briefs.say only
            │   ├── prod-rules.md     # in subject.prod.briefs.say only
            │   └── misc.md           # not in any glob (also section)
            └── skills/
                ├── commit.sh         # in always.skills.say
                ├── lint.sh           # in always.skills.ref
                ├── test-runner.sh    # in subject.test.skills.say only
                ├── deploy.sh         # in subject.prod.skills.say only
                ├── shared-tool.sh    # in both subject.test.skills.say AND subject.prod.skills.say (overlap dedupe)
                ├── skill-precedence.sh  # in always.skills.ref AND subject.test.skills.say (say wins)
                └── orphan-skill.sh   # not in any glob (also section)
```

**boot.yml:**
```yaml
always:
  briefs:
    say:
      - core.md
    ref:
      - glossary.md
      - precedence.md
  skills:
    say:
      - commit.sh
    ref:
      - lint.sh
      - skill-precedence.sh

subject.test:
  briefs:
    say:
      - test-rules.md
      - shared.md
      - precedence.md    # also in always.ref; say wins
  skills:
    say:
      - test-runner.sh
      - shared-tool.sh
      - skill-precedence.sh  # also in always.ref; say wins

subject.prod:
  briefs:
    say:
      - prod-rules.md
      - shared.md        # also in subject.test.say; dedupe
  skills:
    say:
      - deploy.sh
      - shared-tool.sh   # also in subject.test.say; dedupe
```

### with-boot-yaml-mixed

```
accept.blackbox/.test/assets/with-boot-yaml-mixed/
├── rhachet.use.ts
└── .agent/
    └── repo=.this/
        └── role=any/
            ├── readme.md
            ├── boot.yml              # invalid: mixed mode
            └── briefs/
                └── sample.md
```

**boot.yml (invalid):**
```yaml
briefs:
  say:
    - sample.md
always:
  briefs:
    say:
      - sample.md
```

### with-boot-yaml-subject-no-always

```
accept.blackbox/.test/assets/with-boot-yaml-subject-no-always/
├── rhachet.use.ts
└── .agent/
    └── repo=.this/
        └── role=any/
            ├── readme.md
            ├── boot.yml              # subject mode without always section
            ├── briefs/
            │   ├── test-only.md      # in subject.test.briefs.say
            │   └── orphan.md         # not in any glob (also section)
            └── skills/
                └── test-tool.sh      # in subject.test.skills.say
```

**boot.yml:**
```yaml
subject.test:
  briefs:
    say:
      - test-only.md
  skills:
    say:
      - test-tool.sh
```

---

## test coverage

### unit tests

| file | coverage |
|------|----------|
| `RoleBootSpec.test.ts` | schema validation for both RoleBootSpecSimplified and RoleBootSpecSubjected |
| `parseRoleBootYaml.test.ts` | yaml parse, validation errors |
| `computeBootMode.test.ts` | simple/subject/mixed detection |
| `filterBootResourcesByGlob.test.ts` | glob pattern match |
| `computeBootPlan.test.ts` | say/ref decision, overlap dedupe |

### integration tests

| file | coverage |
|------|----------|
| `bootRoleResources.integration.test.ts` | end-to-end boot with real files |

### acceptance tests

| file | coverage |
|------|----------|
| `roles.boot.bootyaml.acceptance.test.ts` | all blackbox criteria from 2.1 |

#### acceptance test cases: simple mode

| case | when | then |
|------|------|------|
| `[case1]` no boot.yml | boot | all briefs/skills say |
| `[case2]` briefs.say: [...] | boot | matched briefs say, unmatched ref |
| `[case3]` briefs.say: [] | boot | all briefs ref |
| `[case4]` skills.say: [...] | boot | matched skills say, unmatched ref |
| `[case5]` skills.say: [] | boot | all skills ref |
| `[case6]` briefs.say + skills absent | boot | briefs curated, skills say all |
| `[case7]` skills.say + briefs absent | boot | skills curated, briefs say all |

#### acceptance test cases: subject mode — briefs

| case | when | then |
|------|------|------|
| `[case8]` boot all subjects | boot (no --usecase) | always + all subjects + also |
| `[case9]` boot single subject | --usecase test | always + test only, no prod, no also |
| `[case10]` boot multiple subjects | --usecase test,prod | always + test + prod, no also |
| `[case11]` unknown subject | --usecase unknown | error "subject not found" |
| `[case12]` briefs overlap dedupe (subject-subject) | --usecase test,prod | shared.md say in test, ref "(as mentioned earlier)" in prod |
| `[case13]` briefs overlap dedupe (always-subject) | boot | core.md say in always, deduped if also in subject |
| `[case14]` briefs say wins over ref | --usecase test | precedence.md say (subject.test.say > always.ref) |
| `[case15]` always.briefs.ref | boot | glossary.md appears as ref |
| `[case16]` briefs also section | boot (no --usecase) | misc.md in `<also>` as ref |
| `[case17]` briefs also omitted | --usecase test | misc.md not in output |

#### acceptance test cases: subject mode — skills

| case | when | then |
|------|------|------|
| `[case18]` always.skills.say | boot | commit.sh say |
| `[case19]` always.skills.ref | boot | lint.sh appears as ref |
| `[case20]` subject.test.skills.say | --usecase test | test-runner.sh say |
| `[case21]` subject.prod.skills.say | --usecase prod | deploy.sh say |
| `[case22]` skills overlap dedupe (subject-subject) | --usecase test,prod | shared-tool.sh say in test, ref "(as mentioned earlier)" in prod |
| `[case23]` skills say wins over ref | --usecase test | skill-precedence.sh say (subject.test.say > always.ref) |
| `[case24]` skills also section | boot (no --usecase) | orphan-skill.sh in `<also>` as ref |
| `[case25]` skills also omitted | --usecase test | orphan-skill.sh not in output |

#### acceptance test cases: subject mode — always absent

| case | when | then |
|------|------|------|
| `[case26]` always section absent | boot (no --usecase) | no always briefs/skills, only subject-specific + also |
| `[case27]` always absent + single subject | --usecase test | only subject.test briefs/skills, no also |

#### acceptance test cases: output structure

| case | when | then |
|------|------|------|
| `[case28]` say brief format | boot | said briefs appear as `<brief path="...">content</brief>` |
| `[case29]` ref brief format | boot | ref briefs appear as `<ref path="..."/>` |
| `[case30]` say skill format | boot | said skills appear as `<skill path="...">content</skill>` |
| `[case31]` ref skill format | boot | ref skills appear as `<ref path="..."/>` |
| `[case32]` also section format | boot (no --usecase) | also section wrapped in `<also>...</also>` |
| `[case33]` stats say/ref breakdown | boot | stats show say vs ref counts for briefs and skills |

#### acceptance test cases: error modes

| case | when | then |
|------|------|------|
| `[case34]` mixed mode | boot | error "mixed mode not allowed" |
| `[case35]` --usecase in simple mode | --usecase test | error "usecase requires subject mode" |

---

## output format

### say resources

```
<brief path=".agent/repo=.this/role=any/briefs/core.md">
full content here
</brief>
```

### ref resources

```
<ref path=".agent/repo=.this/role=any/briefs/misc.md"/>
```

### also section (subject mode)

```
<also>
  <ref path=".agent/repo=.this/role=any/briefs/uncategorized.md"/>
</also>
```

### overlap dedupe (subject mode)

```
<brief path="...">
(as mentioned earlier in always)
</brief>
```

---

## stats output extension

```
<stats>
quant
  ├── files = 22
  │   ├── briefs = 16
  │   │   ├── say = 4
  │   │   └── ref = 12
  │   └── skills = 5
  │       ├── say = 2
  │       └── ref = 3
  ├── chars = 12345 (say only)
  └── tokens ≈ 3086 ($0.01 at $3/mil)
</stats>
```

---

## execution order

1. **domain.objects** — create `RoleBootSpecSimplified`, `RoleBootSpecSubjected`, and union type
2. **domain.operations/boot** — implement parse, mode detect, glob match, plan compute
3. **domain.operations/invoke** — integrate into `bootRoleResources`
4. **contract/cli** — add `--usecase` option
5. **test fixtures** — create all 3 fixture directories
6. **tests** — unit → integration → acceptance

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| glob performance on large role | fast-glob is already used; cache glob results per boot |
| boot.yml schema evolution | zod schema is versioned; add migration path if needed |
| backwards compat | no boot.yml = say all (current behavior preserved) |
| subject overlap complexity | clear precedence rules documented in vision |

---

## dependencies

| package | version | purpose |
|---------|---------|---------|
| `yaml` | current | parse boot.yml |
| `zod` | current | schema validation |
| `fast-glob` | current | glob pattern match |
| `helpful-errors` | current | fail-fast errors |
| `domain-objects` | current | RoleBootSpec base |
| `test-fns` | current | BDD test structure |
