# research: test codepath patterns

research of test codepath patterns relevant to fulfill:
- wish: `.behavior/v2026_01_09.init-roles-many/0.wish.md`
- criteria: `.behavior/v2026_01_09.init-roles-many/2.criteria.blackbox.md`

---

## pattern.1 = test infrastructure: genTestTempDir

[REUSE]

managed temp directory creation with setup/teardown and cwd switch.

### citation.1
```
src/.test/infra/genTestTempDir.ts:4-22
```
```ts
/**
 * .what = creates a managed temp test directory with cwd switch
 * .why = standardizes test directory setup/teardown across integration tests
 */
export const genTestTempDir = (input: {
  /** base directory (typically __dirname) */
  base: string;
  /** subdirectory name under .temp */
  name: string;
}): {
  /** absolute path to the test directory */
  path: string;
  /** call in beforeAll to setup directory and switch cwd */
  setup: () => void;
  /** call in afterAll to restore original cwd */
  teardown: () => void;
  /** call to remove a file or directory within the test dir */
  rm: (relativePath: string) => void;
}
```

### relevance
- will reuse for new `init --roles` integration tests
- provides isolated test environment for package.json + node_modules simulation

---

## pattern.2 = test infrastructure: invokeRhachetCli

[REUSE]

CLI invocation via subprocess for integration tests.

### citation.2
```
src/.test/infra/invokeRhachetCli.ts:14-39
```
```ts
/**
 * .what = invokes the rhachet CLI via npx tsx
 * .why = standardizes CLI invocation for integration tests
 */
export const invokeRhachetCli = (input: {
  /** CLI args after 'rhachet' (e.g., ['run', '--skill', 'foo']) */
  args: string[];
  /** work directory for the command */
  cwd: string;
  /** optional stdin data to pipe */
  stdin?: string;
  /** whether to log output on failure (default: true) */
  logOnError?: boolean;
}): SpawnSyncReturns<string> => {
  const result = spawnSync('npx', ['tsx', RHACHET_BIN, ...input.args], {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
  });
  ...
  return result;
};
```

### relevance
- will reuse for blackbox test of `npx rhachet init --roles`
- returns stdout/stderr/status for assertion

---

## pattern.3 = test infrastructure: setTestTempAsset

[REUSE]

safe asset creation in temp directories with safety guard.

### citation.3
```
src/.test/infra/setTestTempAsset.ts:7-40
```
```ts
/**
 * .what = writes a test asset file to a temp directory
 * .why = standardizes test asset creation with safety guard for temp paths
 */
export const setTestTempAsset = (input: {
  /** directory to create the asset in (must be under .temp) */
  dir: string;
  /** filename (e.g., 'test.sh', 'data.json') */
  name: string;
  /** file content */
  content: string;
  /** whether to make the file executable (default: true for .sh files) */
  executable?: boolean;
}): {
  /** absolute path to the created asset */
  path: string;
} => {
  // guard: ensure we're under a temp directory
  if (!input.dir.includes('.temp'))
    throw new Error(
      `setTestTempAsset: dir must be under .temp for safety, got: ${input.dir}`,
    );
  ...
};
```

### relevance
- will reuse to create mock package.json and rhachet.repo.yml files
- safety guard prevents accidental writes outside test directories

---

## pattern.4 = BDD structure via test-fns

[REUSE]

given/when/then structure from test-fns for readable integration tests.

### citation.4
```
src/contract/cli/invokeInit.integration.test.ts:3-4
```
```ts
import { given, then, when } from 'test-fns';
```

### citation.5
```
src/contract/cli/invokeRolesLink.integration.test.ts:2
```
```ts
import { getError, given, then, when } from 'test-fns';
```

### relevance
- will reuse BDD structure for all new integration tests
- `getError` helper useful for test of error conditions

---

## pattern.5 = mock Role and RoleRegistry creation

[EXTEND]

create mock domain objects directly for test scenarios.

### citation.6
```
src/contract/cli/invokeRolesLink.integration.test.ts:109-127
```
```ts
const mockRole = new Role({
  slug: 'mechanic',
  name: 'Mechanic',
  purpose: 'Test mechanic role',
  readme: { uri: '.test/readme.md' },
  traits: [],
  skills: {
    dirs: [{ uri: 'test-skills' }],
    refs: [],
  },
  briefs: { dirs: [{ uri: 'test-briefs' }] },
  inits: { dirs: [{ uri: 'test-inits' }] },
});

const mockRegistry = new RoleRegistry({
  slug: 'test',
  readme: { uri: '.test/readme.md' },
  roles: [mockRole],
});
```

### relevance
- will extend to test rhachet.repo.yml parse
- need to add tests for discovery from `rhachet-roles-*` packages

---

## pattern.6 = CLI command registration and invocation

[REUSE]

register command handlers and invoke via parseAsync.

### citation.7
```
src/contract/cli/invokeRolesInit.integration.test.ts:60-78
```
```ts
const rolesCommand = new Command('roles');
const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

beforeEach(() => {
  logSpy.mockClear();
  ...
});

invokeRolesInit({ command: rolesCommand, registries: [mockRegistry] });

when('invoked with "init --repo test --role mechanic"', () => {
  then('it should execute all init commands sequentially', async () => {
    await rolesCommand.parseAsync(
      ['init', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );
    ...
  });
});
```

### relevance
- will reuse pattern for `init --roles` command test
- spy on console.log for output verification

---

## pattern.7 = file system state verification

[REUSE]

verify file existence, content, and permissions after command execution.

### citation.8
```
src/contract/cli/invokeRolesLink.integration.test.ts:154-167
```
```ts
// Check that .agent directory structure was created
expect(existsSync(resolve(testDir, '.agent/readme.md'))).toBe(true);
expect(
  existsSync(resolve(testDir, '.agent/repo=.this/readme.md')),
).toBe(true);
expect(
  existsSync(resolve(testDir, '.agent/repo=test/readme.md')),
).toBe(true);
expect(
  existsSync(
    resolve(testDir, '.agent/repo=test/role=mechanic/readme.md'),
  ),
).toBe(true);
```

### citation.9
```
src/contract/cli/invokeRolesLink.integration.test.ts:259-276
```
```ts
// Check that linked files are set to readonly (0o444)
const brief1Path = resolve(
  testDir,
  '.agent/repo=test/role=mechanic/briefs/test-briefs/brief1.md',
);
const brief1Stats = statSync(brief1Path);
// eslint-disable-next-line no-bitwise
const brief1Mode = brief1Stats.mode & 0o777;
expect(brief1Mode).toBe(0o555);
```

### relevance
- will reuse to verify `.agent/` structure after `init --roles`
- permission checks ensure read-only link works

---

## pattern.8 = error condition test via getError

[REUSE]

test error messages via getError helper from test-fns.

### citation.10
```
src/contract/cli/invokeRolesLink.integration.test.ts:330-343
```
```ts
when('invoked with "link --role nonexistent"', () => {
  then(
    'it should throw an error about role not found in registries',
    async () => {
      const error = await getError(() =>
        rolesCommand.parseAsync(['link', '--role', 'nonexistent'], {
          from: 'user',
        }),
      );

      expect(error?.message).toContain('no role named "nonexistent"');
    },
  );
});
```

### relevance
- will reuse for test of:
  - role not found errors
  - ambiguous role errors
  - package not found errors

---

## pattern.9 = multi-registry ambiguity test

[REUSE]

test scenarios where same role exists in multiple registries.

### citation.11
```
src/contract/cli/invokeRolesInit.integration.test.ts:173-240
```
```ts
given('multiple registries have the same role', () => {
  ...
  const registry1 = new RoleRegistry({
    slug: 'repo1',
    readme: { uri: '.test/readme.md' },
    roles: [mockRole1],
  });

  const registry2 = new RoleRegistry({
    slug: 'repo2',
    readme: { uri: '.test/readme.md' },
    roles: [mockRole2],
  });

  ...

  when('invoked with "init --role mechanic" without --repo', () => {
    then('it should throw an error about ambiguous repos', async () => {
      const error = await getError(() =>
        rolesCommand.parseAsync(['init', '--role', 'mechanic'], {
          from: 'user',
        }),
      );

      expect(error?.message).toContain('multiple roles named "mechanic"');
    });
  });
});
```

### relevance
- will reuse for test of `repo/role` disambiguation in `init --roles`
- critical for usecase.2 in blackbox criteria

---

## pattern.10 = package.json rhachet-roles discovery test

[EXTEND]

test discovery of `rhachet-roles-*` packages from package.json.

### citation.12
```
src/contract/cli/invokeInit.integration.test.ts:52-91
```
```ts
when(
  'invoked with package.json that has rhachet-roles-* packages',
  () => {
    beforeEach(() => {
      // Create package.json with rhachet-roles packages
      writeFileSync(
        resolve(testDir, 'package.json'),
        JSON.stringify({
          name: 'test-project',
          dependencies: {
            'rhachet-roles-ehmpathy': '1.0.0',
          },
        }),
      );
    });

    then(
      'it should create rhachet.use.ts with discovered packages',
      async () => {
        await program.parseAsync(['init'], { from: 'user' });

        const configPath = resolve(testDir, 'rhachet.use.ts');
        expect(existsSync(configPath)).toBe(true);

        const content = readFileSync(configPath, 'utf8');
        expect(content).toContain('getRoleRegistryEhmpathy');
        ...
      },
    );
  },
);
```

### relevance
- will extend to test rhachet.repo.yml discovery from packages
- foundation for `init --roles` package discovery tests

---

## pattern.11 = no rhachet-roles packages warn

[EXTEND]

test behavior when no `rhachet-roles-*` packages are found.

### citation.13
```
src/contract/cli/invokeInit.integration.test.ts:123-146
```
```ts
when('invoked with no rhachet-roles-* packages', () => {
  beforeEach(() => {
    writeFileSync(
      resolve(testDir, 'package.json'),
      JSON.stringify({
        name: 'test-project',
        dependencies: {
          lodash: '4.0.0',
        },
      }),
    );
  });

  then('it should warn and not create config', async () => {
    await program.parseAsync(['init'], { from: 'user' });

    const configPath = resolve(testDir, 'rhachet.use.ts');
    expect(existsSync(configPath)).toBe(false);

    expect(logSpy).toHaveBeenCalledWith(
      expect.stringContaining('No rhachet-roles-* packages found'),
    );
  });
});
```

### relevance
- will extend for edge.3: no rhachet-roles packages error
- should fail fast with helpful message per criteria

---

## pattern.12 = findsert vs upsert mode test

[REUSE]

test idempotent behavior with findsert (preserve) and upsert (overwrite).

### citation.14
```
src/contract/cli/invokeInit.integration.test.ts:199-219
```
```ts
then(
  'it should not overwrite found agent directories or readme (findsert)',
  async () => {
    // Pre-create with custom content
    const roleAnyDir = resolve(testDir, '.agent/repo=.this/role=any');
    const briefsDir = resolve(roleAnyDir, 'briefs');
    const readmePath = resolve(roleAnyDir, 'readme.md');

    mkdirSync(briefsDir, { recursive: true });
    writeFileSync(readmePath, 'custom content');

    await program.parseAsync(['init'], { from: 'user' });

    // Should preserve custom content
    expect(readFileSync(readmePath, 'utf8')).toBe('custom content');
    expect(logSpy).toHaveBeenCalledWith(
      expect.stringContaining('â—‹ [found]'),
    );
  },
);
```

### relevance
- will reuse findsert semantics for `init --roles`
- preserves prior linked roles, only adds new ones

---

## pattern.13 = directory cleanup and readonly handle

[REUSE]

clean up test directories, with readonly files from prior runs.

### citation.15
```
src/contract/cli/invokeRolesLink.integration.test.ts:23-41
```
```ts
/**
 * .what = recursively makes all files and directories writable
 * .why = enables cleanup of readonly directories set by setDirectoryReadonly
 */
const makeDirectoryWritable = (dirPath: string): void => {
  if (!existsSync(dirPath)) return;
  const entries = readdirSync(dirPath);
  for (const entry of entries) {
    const fullPath = resolve(dirPath, entry);
    const lstats = lstatSync(fullPath);
    if (lstats.isSymbolicLink()) continue;
    if (lstats.isDirectory()) {
      chmodSync(fullPath, 0o755);
      makeDirectoryWritable(fullPath);
    } else if (lstats.isFile()) {
      chmodSync(fullPath, 0o644);
    }
  }
  chmodSync(dirPath, 0o755);
};
```

### relevance
- will reuse for test cleanup of `.agent/` directories with readonly permissions
- critical for repeated test runs

---

## pattern.14 = symlink verification

[REUSE]

verify symlinks are created correctly in .agent/ structure.

### citation.16
```
src/contract/cli/invokeRolesLink.integration.test.ts:449-456
```
```ts
// check that briefs is a direct symlink to test-briefs (not a dir that has test-briefs)
const briefsPath = resolve(
  testDir,
  '.agent/repo=single-test/role=single-dir/briefs',
);
expect(existsSync(briefsPath)).toBe(true);
expect(lstatSync(briefsPath).isSymbolicLink()).toBe(true);
```

### relevance
- will reuse to verify `init --roles` creates correct symlinks
- confirms link behavior matches the found `roles link` command

---

## summary

| pattern | status | relevance |
|---------|--------|-----------|
| genTestTempDir | REUSE | isolated test environments |
| invokeRhachetCli | REUSE | blackbox CLI test |
| setTestTempAsset | REUSE | mock file creation |
| BDD via test-fns | REUSE | readable test structure |
| mock Role/RoleRegistry | EXTEND | add rhachet.repo.yml tests |
| CLI command invocation | REUSE | command handler test |
| file system verification | REUSE | verify .agent/ structure |
| error test via getError | REUSE | error message assertions |
| multi-registry ambiguity | REUSE | disambiguation tests |
| package.json discovery | EXTEND | rhachet.repo.yml discovery |
| no packages warn | EXTEND | fail fast error tests |
| findsert/upsert modes | REUSE | idempotent behavior |
| readonly cleanup | REUSE | test cleanup |
| symlink verification | REUSE | link behavior verification |

---

## new test patterns needed

for `init --roles` feature, need to add:

1. **mock node_modules with rhachet.repo.yml** - simulate installed packages with manifest files
2. **partial success test** - some roles succeed, some fail (edge.2)
3. **usage instructions output** - test default behavior shows help (usecase.1)
4. **available roles list** - test that available roles are listed (usecase.1)
