# blueprint v2: init-roles-many (refinements)

changes to v1 blueprint to address three key refinements:

1. **explicit symmetry** for `RoleRegistry` vs `RoleRegistryManifest` operations
2. **eliminate cast** — operations use whichever type they need directly
3. **eliminate early escapes** — just-in-time load with cache removes special-case branches

---

## refinement.1 = explicit symmetry in names

### rationale

v1 blueprint uses:
- `getRegistriesByOpts` — loads from rhachet.use.ts (implicit: "by config")
- `discoverRegistriesFromPackages` — loads from rhachet.repo.yml (implicit: "by manifest")

this hides the distinction between the two sources. rename for clarity:

| v1 name                          | v2 name                         | source                         |
| -------------------------------- | ------------------------------- | ------------------------------ |
| `getRegistriesByOpts`            | `getRoleRegistriesByConfigExplicit` | rhachet.use.ts                 |
| `discoverRegistriesFromPackages` | `getRoleRegistriesByConfigImplicit` | rhachet.repo.yml from packages |

### new name pattern

```
get{Resource}ByConfig{Source}
```

where:
- `{Resource}` = what we load (Registries, Brains, Hooks)
- `{Source}` = how we find it (Explicit, Implicit)
  - `Explicit` = user-declared config file (rhachet.use.ts)
  - `Implicit` = auto-discovered from installed packages (rhachet.repo.yml)

### operations renamed

| domain     | explicit                        | implicit                        |
| ---------- | ------------------------------- | ------------------------------- |
| registries | `getRoleRegistriesByConfigExplicit` | `getRoleRegistriesByConfigImplicit` |
| brains     | `getBrainsByConfigExplicit`     | (not supported yet)             |
| hooks      | `getRoleHooksOnDispatchByConfigExplicit`      | (not supported yet)             |

### file changes

**rename**: `src/domain.operations/invoke/getRegistriesByOpts.ts`
→ `src/domain.operations/config/getRoleRegistriesByConfigExplicit.ts`

**rename**: `src/domain.operations/manifest/discoverRegistriesFromPackages.ts`
→ `src/domain.operations/config/getRoleRegistriesByConfigImplicit.ts`

**rename**: `src/domain.operations/invoke/getBrainReplsByOpts.ts`
→ `src/domain.operations/config/getBrainsByConfigExplicit.ts`

**rename**: `src/domain.operations/invoke/getInvokeHooksByOpts.ts`
→ `src/domain.operations/config/getRoleHooksOnDispatchByConfigExplicit.ts`

---

## refinement.2 = eliminate cast between Manifest and Registry

### rationale

v1 blueprint has `castManifestToRegistry` which transforms `RoleRegistryManifest` → `RoleRegistry`. this hides the fundamental difference:

| aspect       | RoleRegistry                            | RoleRegistryManifest               |
| ------------ | --------------------------------------- | ---------------------------------- |
| source       | rhachet.use.ts (runtime import)         | rhachet.repo.yml (static yaml)     |
| roles        | `Role[]` with full domain objects       | `RoleManifest[]` with path strings |
| capabilities | supports Role.inits.exec, dynamic logic | static paths only                  |
| use case     | full runtime operations                 | link + boot operations             |

rather than cast away these differences, operations should declare which type they accept.

### operation signatures updated

operations that work with either source should accept a union or the common subset:

```typescript
// operations that only need static paths (link, boot)
export const symlinkRoleResources = (input: {
  manifest: RoleManifest;  // .path resolves to package root
  targetRoot: string;
}): Promise<void>

// operations that need Role objects (init exec, ask, act)
export const executeRoleInits = (input: {
  role: Role;
  registry: RoleRegistry;
}): Promise<void>
```

### type hierarchy

```
RoleRegistryManifest           # yaml-sourced, static paths
  └── RoleManifest             # single role from manifest

RoleRegistry                   # import-sourced, full objects
  └── Role                     # single role with full capabilities
```

### operations by type requirement

| operation               | accepts                                      | why                   |
| ----------------------- | -------------------------------------------- | --------------------- |
| `symlinkRoleResources`  | `RoleManifest`                               | only needs paths      |
| `enumerateRoleBriefs`   | `RoleManifest` or `Role`                     | only needs paths      |
| `enumerateRoleSkills`   | `RoleManifest` or `Role`                     | only needs paths      |
| `executeRoleInits`      | `Role` + `RoleRegistry`                      | needs Role.inits.exec |
| `getRolesFromManifests` | `RoleRegistryManifest[]`                     | needs slug match      |

### new operation: getRolesFromManifests

v1 had `resolveRoleSpecifiers` which returned `{ registry: RoleRegistry; role: Role }[]`. this assumes we cast manifests to registries first.

v2 adds a manifest-aware variant:

```typescript
/**
 * .what = gets roles from manifests by specifier
 * .why = enables link/init operations without full RoleRegistry
 *
 * .note = fail-fast on first error (not found, ambiguous)
 */
export const getRolesFromManifests = (input: {
  specifiers: RoleSpecifier[];
  manifests: RoleRegistryManifest[];
}): { manifest: RoleRegistryManifest; role: RoleManifest }[]
// throws BadRequestError on not found or ambiguity
```

---

## refinement.3 = eliminate early escapes via just-in-time load

### rationale

v1 invoke.ts has multiple escape hatches:

```typescript
// escape 1: init command (no config needed)
if (input.args[0] === 'init') { ... return; }

// escape 2: repo introspect (loads own config)
if (input.args[0] === 'repo' && input.args[1] === 'introspect') { ... return; }

// escape 3: roles link/init (fallback to package discovery)
if (input.args[0] === 'roles' && (input.args[1] === 'link' || input.args[1] === 'init')) { ... return; }

// main path: load everything upfront
const registries = await getRegistriesByOpts({ ... });
const brains = await getBrainReplsByOpts({ ... });
const hooks = await getInvokeHooksByOpts({ ... });
```

this is fragile:
- each new command that needs different config behavior adds another escape
- config load logic is duplicated
- hard to reason about which commands use which config source

### solution: just-in-time load with cache

instead of upfront config load, each command loads what it needs when it needs it.

**new**: `src/domain.operations/config/genContextConfigOfUsage.ts`

```typescript
/**
 * .what = config portion of context
 * .why = enables just-in-time load; commands declare what they need
 *
 * .note = uses with-simple-cache for memoization across calls
 */
export interface ContextConfigOfUsage {
  config: {
    usage: {
      /**
       * .what = checks if explicit config file exists
       */
      isExplicit: () => boolean;

      /**
       * .what = lazy getters for config resources
       */
      get: {
        registries: {
          /**
           * .what = loads RoleRegistry[] from rhachet.use.ts
           * .note = throws if isExplicit() is false
           */
          explicit: () => Promise<RoleRegistry[]>;

          /**
           * .what = discovers RoleRegistryManifest[] from installed packages
           * .note = always available (does not require rhachet.use.ts)
           */
          implicit: () => Promise<RoleRegistryManifest[]>;
        };

        brains: {
          /**
           * .what = loads BrainRepl[] from rhachet.use.ts
           * .note = throws if isExplicit() is false
           */
          explicit: () => Promise<BrainRepl[]>;
        };

        hooks: {
          /**
           * .what = loads InvokeHooks from rhachet.use.ts
           * .note = throws if isExplicit() is false
           */
          explicit: () => Promise<InvokeHooks>;
        };
      };
    };
  };
}

/**
 * .what = creates context with config for the current invocation
 * .why = centralizes config resolution logic
 *
 * .note = extracts --config <path> from args if present
 */
export const genContextConfigOfUsage = (input: {
  args: string[];  // may contain --config <path>
  cwd: string;
}): ContextConfigOfUsage
```

**--config path support**: the `genContextConfigOfUsage` extracts `--config <path>` from args:

```typescript
/**
 * .what = extracts config path from cli args
 * .why = supports custom config location via --config flag
 *
 * .example
 *   npx rhachet ask --config ./custom/rhachet.use.ts
 *   npx rhachet roles link --config /abs/path/rhachet.use.ts
 */
const extractConfigPathFromArgs = (input: { args: string[] }): string | null => {
  const configIndex = input.args.indexOf('--config');
  if (configIndex === -1) return null;
  const configPath = input.args[configIndex + 1];
  if (!configPath || configPath.startsWith('-')) return null;
  return configPath;
};

/**
 * .what = resolves explicit config path
 * .why = checks --config arg first, falls back to cwd discovery
 */
const resolveExplicitConfigPath = (input: {
  args: string[];
  cwd: string;
}): string | null => {
  // prefer --config <path> if provided
  const configPathFromArgs = extractConfigPathFromArgs({ args: input.args });
  if (configPathFromArgs) return path.resolve(input.cwd, configPathFromArgs);

  // fall back to cwd discovery
  const configPathFromCwd = path.join(input.cwd, 'rhachet.use.ts');
  if (fs.existsSync(configPathFromCwd)) return configPathFromCwd;

  return null;
};
```

**cache**: use `with-simple-cache` and `simple-in-memory-cache` for memoization:

```typescript
import { createCache } from 'simple-in-memory-cache';
import { withSimpleCache } from 'with-simple-cache';

// wrap loaders with cache — keys auto-derived from input args
const getRoleRegistriesByConfigExplicitCached = withSimpleCache(
  getRoleRegistriesByConfigExplicit,
  { cache: createCache() },
);

const getRoleRegistriesByConfigImplicitCached = withSimpleCache(
  getRoleRegistriesByConfigImplicit,
  { cache: createCache() },
);
```

### invoke.ts simplified

```typescript
/**
 * .what = main entrypoint for CLI execution
 * .why = routes commands to handlers with lazy config load
 */
export const invoke = async (input: { args: string[] }): Promise<void> => {
  const cwd = process.cwd();
  const context = genContextConfigOfUsage({ args: input.args, cwd });

  const program = new Command();
  program.name('rhachet');

  // all commands registered unconditionally
  // each command uses context.config.usage.get.* just-in-time

  invokeInit({ program }, context);           // uses: context.config.usage.get.registries.implicit (or none for --config)
  invokeRepoIntrospect({ program });          // uses: dynamic import (self-contained)
  invokeRoles({ program }, context);          // uses: context.config.usage.get.registries.explicit or .registries.implicit
  invokeList({ program }, context);           // uses: context.config.usage.get.registries.explicit
  invokeRun({ program });                     // uses: filesystem directly
  invokeChoose({ program });                  // uses: none
  invokeReadme({ program }, context);         // uses: context.config.usage.get.registries.explicit
  invokeAsk({ program }, context);            // uses: context.config.usage.get.* (all)
  invokeAct({ program }, context);            // uses: context.config.usage.get.* (all)

  await program.parseAsync(input.args, { from: 'user' });
};
```

### command handler patterns

each command handler decides what it needs:

```typescript
// invokeInit.ts — uses implicit discovery for --roles, explicit for --config
export const invokeInit = (
  input: { program: Command },
  context: ContextConfigOfUsage,
): void => {
  input.program
    .command('init')
    .option('--roles <roles...>', 'roles to initialize from packages')
    .option('--config', 'generate rhachet.use.ts config file')
    .action(async (opts) => {
      if (opts.config) {
        await generateRhachetUseTs({ from: process.cwd() });
        return;
      }
      if (opts.roles) {
        // uses implicit discovery — no rhachet.use.ts needed
        const manifests = await context.config.usage.get.registries.implicit();
        await initRolesFromManifests({ specifiers: opts.roles, manifests });
        return;
      }
      await showInitUsageInstructions({}, context);
    });
};

// invokeAsk.ts — requires explicit config
export const invokeAsk = (
  input: { program: Command },
  context: ContextConfigOfUsage,
): void => {
  input.program
    .command('ask')
    .action(async (opts) => {
      if (!context.config.usage.isExplicit()) {
        throw new BadRequestError('ask command requires rhachet.use.ts config');
      }
      const registries = await context.config.usage.get.registries.explicit();
      const brains = await context.config.usage.get.brains.explicit();
      const hooks = await context.config.usage.get.hooks.explicit();
      // ...
    });
};

// invokeRoles.ts — fallback pattern (explicit → implicit)
export const invokeRolesLink = (
  input: {},
  context: ContextConfigOfUsage,
): void => {
  // try explicit first, fall back to implicit
  const registries = context.config.usage.isExplicit()
    ? await context.config.usage.get.registries.explicit()
    : [];
  const manifests = await context.config.usage.get.registries.implicit();
  // ... use both for resolution
};
```

---

## file summary (changes from v1)

### renamed files

| v1 path                                                            | v2 path                                                         |
| ------------------------------------------------------------------ | --------------------------------------------------------------- |
| `src/domain.operations/invoke/getRegistriesByOpts.ts`              | `src/domain.operations/config/getRoleRegistriesByConfigExplicit.ts` |
| `src/domain.operations/manifest/discoverRegistriesFromPackages.ts` | `src/domain.operations/config/getRoleRegistriesByConfigImplicit.ts` |
| `src/domain.operations/invoke/getBrainReplsByOpts.ts`              | `src/domain.operations/config/getBrainsByConfigExplicit.ts`     |
| `src/domain.operations/invoke/getInvokeHooksByOpts.ts`             | `src/domain.operations/config/getRoleHooksOnDispatchByConfigExplicit.ts`      |

### new files

| path                                                         | purpose                        |
| ------------------------------------------------------------ | ------------------------------ |
| `src/domain.operations/config/genContextConfigOfUsage.ts`    | lazy config context factory    |
| `src/domain.operations/config/ContextConfigOfUsage.ts`       | interface definition           |
| `src/domain.operations/manifest/getRolesFromManifests.ts` | manifest-aware role lookup |

### removed from v1

| v1 component                         | reason                                               |
| ------------------------------------ | ---------------------------------------------------- |
| `castManifestToRegistry.ts`          | replaced by operations that accept manifest directly |
| early escape branches in `invoke.ts` | replaced by just-in-time load                        |

---

## implementation order (changes from v1)

| phase | v1                             | v2 change                                     |
| ----- | ------------------------------ | --------------------------------------------- |
| 1.2   | castManifestToRegistry         | **removed** — use manifest directly           |
| 1.3   | discoverRegistriesFromPackages | **rename** to getRoleRegistriesByConfigImplicit   |
| new   | —                              | **add** genContextConfigOfUsage               |
| new   | —                              | **add** getRolesFromManifests                 |
| 3.2   | initRolesFromPackages          | **update** to use manifests directly          |
| 5.1   | extend invokeRolesLink         | **update** to use ContextConfigOfUsage        |
| 5.2   | extend invokeRolesInit         | **update** to use ContextConfigOfUsage        |
| —     | invoke.ts early escapes        | **remove** — use unified command registration |

---

## test coverage (additions)

| file                                    | coverage                          |
| --------------------------------------- | --------------------------------- |
| `genContextConfigOfUsage.test.ts`       | lazy load, cache, path resolution |
| `getRolesFromManifests.test.ts`         | manifest-based lookup             |
| `getRoleRegistriesByConfigExplicit.test.ts` | explicit config load              |
| `getRoleRegistriesByConfigImplicit.test.ts` | package discovery                 |

---

## risks and mitigations (additions)

| risk                                   | mitigation                                              |
| -------------------------------------- | ------------------------------------------------------- |
| cache stale during long processes      | TTL of 60s, cache scoped to single invocation           |
| ContextConfigOfUsage passed everywhere | interface is minimal; commands only use what they need  |
| manifest/registry confusion            | clear type names, operations accept only what they need |
