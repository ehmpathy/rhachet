# blueprint: init-roles-many

implementation plan to fulfill wish at `.behavior/v2026_01_09.init-roles-many/0.wish.md`

---

## overview

enable `npx rhachet init --roles mechanic behaver reviewer` to initialize multiple roles from installed `rhachet-roles-*` packages via their `rhachet.repo.yml` manifests.

### key outcomes

1. **consumers** can initialize multiple roles in one command
2. **producers** can generate `rhachet.repo.yml` via `npx rhachet repo introspect`
3. **rhachet.use.ts** is no longer required for `roles link` or `roles init`
4. **disambiguation** via `repo/role` pattern when multiple packages have same role name

---

## phase.0 = domain objects

### phase.0.1 = RoleSpecifier type alias

**new file**: `src/domain.objects/RoleSpecifier.ts`

```typescript
/**
 * .what = a string that identifies a role, optionally scoped to a repo
 * .why = enables disambiguation when multiple repos have same role name
 *
 * .format =
 *   - "mechanic"           => role "mechanic" from any repo (must be unique)
 *   - "ehmpathy/mechanic"  => role "mechanic" from repo "ehmpathy"
 *
 * .examples =
 *   - "mechanic"
 *   - "behaver"
 *   - "ehmpathy/mechanic"
 *   - "bhuild/behaver"
 */
export type RoleSpecifier = string;
```

**tests**:
- unit: type alias compiles correctly

---

### phase.0.2 = RoleRegistryManifest domain object

**new file**: `src/domain.objects/RoleRegistryManifest.ts`

```typescript
/**
 * .what = schema for rhachet.repo.yml manifest file
 * .why = enables package-based role discovery without rhachet.use.ts
 */
export interface RoleRegistryManifest {
  /**
   * .what = unique identifier for this repo (e.g., "ehmpathy", "bhuild")
   * .note = matches the suffix of rhachet-roles-{slug} package name
   */
  slug: string;

  /**
   * .what = path to readme file relative to package root
   */
  readme: string;

  /**
   * .what = role definitions for this repo
   */
  roles: {
    /**
     * .what = unique identifier for this role (e.g., "mechanic")
     */
    slug: string;

    /**
     * .what = path to role readme relative to package root
     */
    readme: string;

    /**
     * .what = paths to briefs directories
     */
    briefs: { dirs: string | string[] };

    /**
     * .what = paths to skills directories
     */
    skills: { dirs: string | string[] };

    /**
     * .what = initialization configuration
     */
    inits?: {
      dirs?: string | string[];
      exec?: string[];
    };
  }[];
}
```

**tests**:
- unit: schema validation via zod
- unit: cast from yml to RoleRegistryManifest

---

## phase.1 = domain operations: manifest read

### phase.1.1 = getRoleRegistryManifest

**new file**: `src/domain.operations/manifest/getRoleRegistryManifest.ts`

```typescript
/**
 * .what = loads and validates rhachet.repo.yml from a package root
 * .why = enables registry discovery from installed packages
 */
export const getRoleRegistryManifest = async (input: {
  packageRoot: string;
}): Promise<RoleRegistryManifest>
```

**logic**:
1. read `{packageRoot}/rhachet.repo.yml`
2. parse yaml
3. validate against schema
4. return typed manifest

**tests**:
- unit: valid yml parses correctly
- unit: absent yml throws helpful error
- unit: malformed yml throws with field path
- integration: read from real file system

---

### phase.1.2 = castManifestToRegistry

**new file**: `src/domain.operations/manifest/castManifestToRegistry.ts`

```typescript
/**
 * .what = transforms RoleRegistryManifest into RoleRegistry
 * .why = bridges manifest format to domain object format
 *
 * .note = manifest-based registries have limitations vs import-based:
 *   - only static path refs supported (strings in yaml)
 *   - no in-memory Role object refs (no runtime logic)
 *   - all resource refs resolved to .agent/ symlinks
 *   - no dynamic skill/brief generation
 *
 * .note = this tradeoff enables:
 *   - bun binaries to read without JIT import
 *   - faster startup (no typescript transpile)
 *   - simpler package distribution
 */
export const castManifestToRegistry = (input: {
  manifest: RoleRegistryManifest;
  packageRoot: string;
}): RoleRegistry
```

**logic**:
1. map manifest.roles to Role[] with resolved paths
2. construct RoleRegistry with manifest.slug
3. return typed registry

**tests**:
- unit: manifest with single role casts correctly
- unit: manifest with multiple roles casts correctly
- unit: paths are resolved relative to packageRoot

---

### phase.1.3 = discoverRegistriesFromPackages

**new file**: `src/domain.operations/manifest/discoverRegistriesFromPackages.ts`

```typescript
/**
 * .what = discovers RoleRegistry[] from installed rhachet-roles-* packages
 * .why = enables role discovery without rhachet.use.ts
 */
export const discoverRegistriesFromPackages = async (input: {
  from: string;
}): Promise<{
  registries: RoleRegistry[];
  errors: { package: string; error: Error }[];
}>
```

**logic**:
1. call `discoverRolePackages({ from })` (reuse pattern.1)
2. for each package, resolve path in node_modules
3. load rhachet.repo.yml via `getRoleRegistryManifest`
4. cast to registry via `castManifestToRegistry`
5. collect errors for packages that lack manifest
6. return registries and errors

**tests**:
- integration: discover from mock node_modules with rhachet.repo.yml
- integration: error collection for package that lacks manifest
- integration: empty result when no packages found

---

## phase.2 = domain operations: role resolution

### phase.2.1 = parseRoleSpecifier

**new file**: `src/domain.operations/invoke/parseRoleSpecifier.ts`

```typescript
/**
 * .what = parses role specifier into repo/role components
 * .why = supports disambiguation via repo/role pattern
 *
 * @example "mechanic" => { repo: null, role: "mechanic" }
 * @example "ehmpathy/mechanic" => { repo: "ehmpathy", role: "mechanic" }
 */
export const parseRoleSpecifier = (input: {
  specifier: RoleSpecifier;
}): { repo: string | null; role: string }
```

**tests**:
- unit: bare role name parses correctly
- unit: repo/role pattern parses correctly
- unit: invalid patterns throw helpful error

---

### phase.2.2 = resolveRoleSpecifiers

**new file**: `src/domain.operations/invoke/resolveRoleSpecifiers.ts`

```typescript
/**
 * .what = resolves multiple role specifiers to concrete roles
 * .why = validates all roles exist before any link/init
 */
export const resolveRoleSpecifiers = (input: {
  specifiers: RoleSpecifier[];
  registries: RoleRegistry[];
}): {
  resolved: { registry: RoleRegistry; role: Role }[];
  errors: { specifier: RoleSpecifier; error: Error }[];
}
```

**logic**:
1. parse each specifier via `parseRoleSpecifier`
2. if repo specified, find exact match
3. if no repo, use `inferRepoByRole` (reuse pattern.8)
4. collect all errors before fail
5. return resolved roles and errors

**tests**:
- unit: single role resolves correctly
- unit: multiple roles resolve correctly
- unit: repo/role disambiguation works
- unit: ambiguous role errors with helpful message
- unit: absent role errors with available roles list

---

## phase.3 = cli command: init --roles

### phase.3.1 = extend invokeInit with --roles flag

**modify file**: `src/contract/cli/invokeInit.ts`

```typescript
  command
    .option('--roles <roles...>', 'roles to initialize (e.g., mechanic behaver)')
    .option('--config', 'generate rhachet.use.ts config file')
    .option('--mode <mode>', 'findsert (default) or upsert', 'findsert')
    .action(async (opts: { roles?: string[]; config?: boolean; mode: string }) => {
      // explicit config generation path
      if (opts.config) {
        await generateRhachetUseTs({ from: cwd, mode: opts.mode });
        return;
      }

      // init specific roles from packages
      if (opts.roles) {
        await initRolesFromPackages({ roles: opts.roles, mode: opts.mode });
        return;
      }

      // no flags: show usage instructions
      await showInitUsageInstructions({ from: cwd });
    });
```

**tests**:
- integration: init --roles mechanic links and inits role
- integration: init --roles mechanic behaver links and inits both
- integration: init --config generates rhachet.use.ts
- integration: init with no flags shows usage and available roles
- integration: error when role not found
- integration: error when no rhachet-roles packages found

---

### phase.3.2 = initRolesFromPackages

**new file**: `src/domain.operations/init/initRolesFromPackages.ts`

```typescript
/**
 * .what = initializes multiple roles from installed packages
 * .why = fulfills the core wish: one command to link+init multiple roles
 */
export const initRolesFromPackages = async (input: {
  roles: string[];
  mode: 'findsert' | 'upsert';
  from?: string;
}): Promise<void>
```

**logic**:
1. discover registries from packages
2. validate all packages have rhachet.repo.yml
3. resolve all role specifiers (fail fast if any absent/ambiguous)
4. for each resolved role:
   a. link role resources (reuse symlinkResourceDirectories)
   b. execute init commands (reuse executeInit)
5. report success with summary

**tests**:
- integration: links and inits single role
- integration: links and inits multiple roles
- integration: partial success when one init fails (edge.2)
- integration: fail fast when role not found (edge.1)
- acceptance: blackbox test of full flow

---

### phase.3.3 = showInitUsageInstructions

**new file**: `src/domain.operations/init/showInitUsageInstructions.ts`

```typescript
/**
 * .what = shows usage instructions when init called without --roles
 * .why = guides users on how to use the command
 */
export const showInitUsageInstructions = async (input: {
  from: string;
}): Promise<void>
```

**logic**:
1. discover registries from packages
2. enumerate all available roles
3. output usage format and available roles

**output format**:
```
usage: npx rhachet init --roles <role...>

available roles:
  mechanic        (from rhachet-roles-ehmpathy)
  behaver         (from rhachet-roles-bhuild)
  reviewer        (from rhachet-roles-ehmpathy)

examples:
  npx rhachet init --roles mechanic
  npx rhachet init --roles mechanic behaver
  npx rhachet init --roles ehmpathy/mechanic bhuild/behaver
```

**tests**:
- integration: lists available roles from packages
- integration: shows helpful message when no packages

---

## phase.4 = cli command: repo introspect

### phase.4.1 = invokeRepoIntrospect

**new file**: `src/contract/cli/invokeRepoIntrospect.ts`

```typescript
/**
 * .what = adds the "repo introspect" subcommand to the CLI
 * .why = enables producers to generate rhachet.repo.yml manifest
 */
export const invokeRepoIntrospect = (input: {
  command: Command;
}): void
```

**logic**:
1. register `repo introspect` command
2. options: `--output <path>` (default: `rhachet.repo.yml`, or `stdout` for console output)
3. action:
   a. dynamically import registry from package
   b. transform registry to manifest yaml
   c. write to specified output (file path or stdout)

**tests**:
- integration: generates valid rhachet.repo.yml (default output)
- integration: --output stdout outputs to console
- integration: --output custom/path.yml writes to specified path
- integration: error when not a rhachet-roles package

---

### phase.4.2 = generateRoleRegistryManifest

**new file**: `src/domain.operations/manifest/generateRoleRegistryManifest.ts`

```typescript
/**
 * .what = generates rhachet.repo.yml content from RoleRegistry
 * .why = automates manifest creation for producers
 */
export const generateRoleRegistryManifest = (input: {
  registry: RoleRegistry;
  packageRoot: string;
}): string
```

**logic**:
1. transform registry to manifest structure
2. resolve paths relative to package root
3. serialize to yaml string

**tests**:
- unit: single role generates correct yaml
- unit: multiple roles generates correct yaml
- unit: paths are relative to package root

---

## phase.5 = extend roles link/init without rhachet.use.ts

### phase.5.1 = extend invokeRolesLink

**modify file**: `src/contract/cli/invokeRolesLink.ts`

add fallback to discover registries from packages when rhachet.use.ts absent:

```typescript
// check for explicit rhachet.use.ts first
const hasExplicitConfig = await hasConfigExplicit({ from: cwd });
if (hasExplicitConfig) {
  const registries = await getRegistriesByOpts({ opts });
  // ... proceed with explicit registries
  return;
}

// fallback: discover from packages
const discovered = await discoverRegistriesFromPackages({ from: cwd });
if (discovered.registries.length === 0)
  BadRequestError.throw('no registries found: install rhachet-roles-* packages or create rhachet.use.ts');

const registries = discovered.registries;
// ... proceed with discovered registries
```

**tests**:
- integration: link works with rhachet.use.ts (backward compat)
- integration: link works without rhachet.use.ts
- integration: disambiguation via repo/role pattern

---

### phase.5.2 = extend invokeRolesInit

**modify file**: `src/contract/cli/invokeRolesInit.ts`

same fallback pattern as phase.5.1.

**tests**:
- integration: init works with rhachet.use.ts (backward compat)
- integration: init works without rhachet.use.ts
- integration: --command flag still works

---

## phase.6 = test coverage

### phase.6.1 = unit tests

| file | coverage |
|------|----------|
| `RoleRegistryManifest.ts` | schema validation |
| `getRoleRegistryManifest.ts` | parse, validate, error cases |
| `castManifestToRegistry.ts` | transform logic |
| `parseRoleSpecifier.ts` | specifier parse variants |
| `resolveRoleSpecifiers.ts` | resolution logic, error collection |
| `generateRoleRegistryManifest.ts` | yaml generation |
| `showInitUsageInstructions.ts` | output format |

---

### phase.6.2 = integration tests

| file | coverage |
|------|----------|
| `discoverRegistriesFromPackages.integration.test.ts` | package discovery with mock node_modules |
| `initRolesFromPackages.integration.test.ts` | full link+init flow |
| `invokeInit.integration.test.ts` | --roles flag behavior, usage instructions, error cases |
| `invokeRepoIntrospect.integration.test.ts` | manifest generation |
| `invokeRolesLink.integration.test.ts` | package-based discovery (rhachet.use.ts no longer required) |
| `invokeRolesInit.integration.test.ts` | package-based discovery (rhachet.use.ts no longer required) |

**note**: prior integration tests that covered rhachet.use.ts generation behavior in `invokeInit` should be migrated to test the `--config` flag path instead of the default behavior.

---

### phase.6.3 = acceptance tests

| scenario | criteria reference |
|----------|-------------------|
| init multiple roles | usecase.1 |
| disambiguation via repo/role | usecase.2 |
| repo introspect command | usecase.3 |
| roles link without rhachet.use.ts | usecase.4 |
| roles init without rhachet.use.ts | usecase.5 |
| rhachet.repo.yml discovery | usecase.6 |
| role not found error | edge.1 |
| partial success on init failure | edge.2 |
| no packages error | edge.3 |
| mixed disambiguation | edge.4 |
| backward compatibility (roles boot, roles link, roles init via rhachet.use.ts) | boundary.3 |

**note**: backward compatibility (boundary.3) refers to prior workflows that use `rhachet.use.ts` for `roles boot`, `roles link`, `roles init` commands - these must continue to work. the `init` command itself no longer generates `rhachet.use.ts`.

---

## phase.7 = documentation

### phase.7.1 = README updates

- document `npx rhachet init --roles` command
- document `repo/role` disambiguation pattern
- document `npx rhachet repo introspect` command
- document `rhachet.repo.yml` schema

---

## implementation order

| phase | description | deps |
|-------|-------------|------|
| 0.1 | RoleRegistryManifest domain object | none |
| 1.1 | getRoleRegistryManifest | 0.1 |
| 1.2 | castManifestToRegistry | 0.1 |
| 1.3 | discoverRegistriesFromPackages | 1.1, 1.2 |
| 2.1 | parseRoleSpecifier | none |
| 2.2 | resolveRoleSpecifiers | 2.1 |
| 3.3 | showInitUsageInstructions | 1.3 |
| 3.2 | initRolesFromPackages | 1.3, 2.2 |
| 3.1 | extend invokeInit with --roles | 3.2, 3.3 |
| 4.2 | generateRoleRegistryManifest | 0.1 |
| 4.1 | invokeRepoIntrospect | 4.2 |
| 5.1 | extend invokeRolesLink | 1.3 |
| 5.2 | extend invokeRolesInit | 1.3 |
| 6.* | test coverage | per phase |
| 7.1 | documentation | all |

---

## file summary

### new files

| path | purpose |
|------|---------|
| `src/domain.objects/RoleSpecifier.ts` | type alias for role specifier string |
| `src/domain.objects/RoleRegistryManifest.ts` | manifest schema |
| `src/domain.operations/manifest/getRoleRegistryManifest.ts` | load and validate yml |
| `src/domain.operations/manifest/castManifestToRegistry.ts` | transform to registry |
| `src/domain.operations/manifest/discoverRegistriesFromPackages.ts` | discover from packages |
| `src/domain.operations/manifest/generateRoleRegistryManifest.ts` | generate yml |
| `src/domain.operations/invoke/parseRoleSpecifier.ts` | parse repo/role specifier |
| `src/domain.operations/invoke/resolveRoleSpecifiers.ts` | resolve specifiers to roles |
| `src/domain.operations/init/initRolesFromPackages.ts` | core init logic |
| `src/domain.operations/init/showInitUsageInstructions.ts` | usage output |
| `src/contract/cli/invokeRepoIntrospect.ts` | repo introspect command |

### modified files

| path | change |
|------|--------|
| `src/contract/cli/invokeInit.ts` | add --roles flag path |
| `src/contract/cli/invokeRolesLink.ts` | add fallback to package discovery |
| `src/contract/cli/invokeRolesInit.ts` | add fallback to package discovery |
| `src/contract/cli/invoke.ts` | register repo introspect command |
| `README.md` | document new commands |

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| rhachet.repo.yml schema drift | validate schema on load with zod |
| backward compat break | test legacy rhachet.use.ts path explicitly |
| partial init failure UX | clear error messages with context |
| node_modules path resolution | use require.resolve for robust path find |
