# research: production codepath patterns

patterns relevant to fulfillment of wish: init-roles-many

---

## pattern.1 = package discovery via package.json scan

**[REUSE]**

### .what
discovers rhachet-roles-* packages by scan of package.json dependencies

### .where
`src/domain.operations/init/discoverRolePackages.ts`

### .citations

[1] lines 7-9:
```typescript
/**
 * .what = discovers rhachet role packages from package.json
 * .why = enables auto-initialization of rhachet.use.ts config
 * .how = scans dependencies + devDependencies for packages that match `rhachet-roles-*`
 */
```

[2] lines 11-21:
```typescript
export const discoverRolePackages = async (input: {
  from: string;
}): Promise<string[]> => {
  const root = await getGitRepoRoot({ from: input.from });
  const pkgPath = resolve(root, 'package.json');
  const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
  return Object.keys(allDeps).filter((name) =>
    name.startsWith('rhachet-roles-'),
  );
};
```

### .relation to wish
- wish requires: "find all the rhachet-roles-${repo} packages currently listed in package-json"
- pattern provides: exact package discovery mechanism via `rhachet-roles-*` prefix filter
- reuse directly for the new `init --roles` command

---

## pattern.2 = rhachet.use.ts config generation

**[REPLACE]**

### .what
generates rhachet.use.ts file with imports from discovered packages

### .where
`src/domain.operations/init/generateRhachetConfig.ts`

### .citations

[3] lines 12-15:
```typescript
/**
 * .what = generates rhachet.use.ts config file content
 * .why = enables auto-initialization from discovered role packages
 * .how = creates aliased imports and exports for registries and hooks
 */
```

[4] lines 41-47:
```typescript
  return `import type { InvokeHooks, RoleRegistry } from 'rhachet';

${imports}

export const getRoleRegistries = (): RoleRegistry[] => [${registries}];
export const getInvokeHooks = (): InvokeHooks[] => [${hooks}];
`;
```

### .relation to wish
- wish requires: "deprecate the rhachet.use.ts requirement"
- pattern provides: config file generation that we want to make optional
- replace: new pattern reads from rhachet.repo.yml instead of rhachet.use.ts

---

## pattern.3 = init command special path

**[EXTEND]**

### .what
init command bypasses normal config load since config may not exist yet

### .where
`src/contract/cli/invoke.ts`

### .citations

[5] lines 30-38:
```typescript
  // treat init command specially - it's purpose is to run before configs exists
  // note: only the bare 'init' command, not 'roles init' which requires config
  if (input.args[0] === 'init') {
    const program = new Command();
    program.name('rhachet');
    invokeInit({ program });
    await program.parseAsync(input.args, { from: 'user' });
    return;
  }
```

### .relation to wish
- wish requires: `init --roles` to work without rhachet.use.ts
- pattern provides: bypass of normal config load for init command
- extend: add `--roles` flag to this special path

---

## pattern.4 = registry load from rhachet.use.ts

**[EXTEND]**

### .what
dynamically imports rhachet.use.ts to get role registries

### .where
`src/domain.operations/invoke/getRegistriesByOpts.ts`

### .citations

[6] lines 5-7:
```typescript
/**
 * .what = get registries from the invocation options declared
 * .why = loads RoleRegistry[] from rhachet.use.ts config file
 * .note = only used by JIT path (tsx); bun path reads from .agent/ directly
 */
```

[7] lines 9-15:
```typescript
export const getRegistriesByOpts = async (input: {
  opts: InvokeOpts<{ config: string }>;
}): Promise<RoleRegistry[]> => {
  const config: { getRoleRegistries: () => Promise<RoleRegistry[]> } =
    await import(input.opts.config);
  return await config.getRoleRegistries();
};
```

### .relation to wish
- wish requires: work without rhachet.use.ts for `roles link` and `roles init`
- pattern provides: current mechanism that requires rhachet.use.ts
- extend: add alternative path that reads from rhachet.repo.yml in node_modules

---

## pattern.5 = roles link command

**[EXTEND]**

### .what
creates .agent/ directory structure and symlinks role resources

### .where
`src/contract/cli/invokeRolesLink.ts`

### .citations

[8] lines 18-22:
```typescript
/**
 * .what = adds the "roles link" subcommand to the CLI
 * .why = creates .agent/ directory structure and links role resources
 * .how = findserts standard readmes and symlinks briefs and skills
 */
```

[9] lines 30-34:
```typescript
  command
    .command('link')
    .description('link role resources into .agent/ directory structure')
    .option('--repo <slug>', 'the repository slug for the role')
    .option('--role <slug>', 'the role to link resources for')
```

[10] lines 36-44:
```typescript
    .action((opts: { repo?: string; role?: string }) => {
      if (!opts.role)
        BadRequestError.throw('--role is required (e.g., --role mechanic)');

      const role = assureFindRole({ registries, slug: opts.role });
      const repo = opts.repo
        ? registries.find((r) => r.slug === opts.repo)
        : inferRepoByRole({ registries, slugRole: opts.role });
```

### .relation to wish
- wish requires: `roles link` to work without rhachet.use.ts
- pattern provides: core link logic that depends on registries parameter
- extend: allow registries to be discovered from rhachet.repo.yml when rhachet.use.ts absent

---

## pattern.6 = roles init command

**[EXTEND]**

### .what
executes role initialization commands after link

### .where
`src/contract/cli/invokeRolesInit.ts`

### .citations

[11] lines 11-16:
```typescript
/**
 * .what = adds the "roles init" subcommand to the CLI
 * .why = executes role initialization commands after link
 * .how = runs Role.inits.exec commands sequentially
 *
 * .note = for single init execution, use `run --init <slug>` instead
 */
```

[12] lines 25-29:
```typescript
  command
    .command('init')
    .description('execute role initialization commands (run-all mode)')
    .option('--repo <slug>', 'the repository slug for the role')
    .option('--role <slug>', 'the role to initialize')
```

[13] lines 54-70:
```typescript
      // execute each command sequentially with explicit stdin passthrough
      for (let i = 0; i < execCmds.length; i++) {
        const { cmd } = execCmds[i]!;
        const cmdRelative = path.relative(process.cwd(), cmd);
        const branch = i === execCmds.length - 1 ? '└─' : '├─';
        console.log(`   ${branch} ${cmdRelative}`);
        const result = spawnSync(cmd, [], {
          cwd: process.cwd(),
          stdio: [process.stdin, process.stdout, process.stderr],
          shell: '/bin/bash',
        });

        // propagate non-zero exit codes
        if (result.status !== 0) {
          process.exit(result.status ?? 1);
        }
      }
```

### .relation to wish
- wish requires: `roles init` to work without rhachet.use.ts
- pattern provides: sequential init command execution
- extend: allow init commands to be discovered from rhachet.repo.yml

---

## pattern.7 = role resolution with disambiguation

**[REUSE]**

### .what
finds role by slug, errors if ambiguous or absent

### .where
`src/domain.operations/invoke/assureFindRole.ts`

### .citations

[14] lines 6-9:
```typescript
/**
 * .what = finds the first role match across registries
 * .why = ensures there is exactly one role match; fails if ambiguous or absent
 */
```

[15] lines 17-29:
```typescript
  const matches = registries
    .flatMap((r) => r.roles)
    .filter((r) => r.slug === slug);
  if (matches.length === 0)
    BadRequestError.throw(`no role named "${slug}" found in any registry`, {
      slug,
    });
  if (matches.length > 1)
    BadRequestError.throw(
      `multiple roles named "${slug}" found across registries`,
      { slug },
    );
  return matches[0]!;
```

### .relation to wish
- wish requires: support for `$repo/$role` disambiguation pattern
- pattern provides: error on ambiguous role names
- reuse: core logic stays, just need new input parse for `repo/role` format

---

## pattern.8 = repo inference by role

**[REUSE]**

### .what
infers the repo when only one has the specified role

### .where
`src/domain.operations/invoke/inferRepoByRole.ts`

### .citations

[16] lines 6-9:
```typescript
/**
 * .what = infers the repo (registry) when only one has the specified role
 * .why = allows omission of --repo when there's no ambiguity
 * .how = searches registries for the one with the role
 */
```

[17] lines 23-28:
```typescript
  // ambiguous case
  if (matchingRepos.length > 1) {
    const repoList = matchingRepos.map((r) => `  - ${r.slug}`).join('\n');
    BadRequestError.throw(
      `Multiple repos have role "${input.slugRole}":\n${repoList}\nPlease specify --repo to disambiguate.`,
    );
  }
```

### .relation to wish
- wish requires: disambiguation when multiple repos have same role name
- pattern provides: exact disambiguation logic with helpful error messages
- reuse: directly applicable to `init --roles` command

---

## pattern.9 = symlink resource directories

**[REUSE]**

### .what
creates symlinks for role resources (briefs, skills, inits) to .agent/ directory

### .where
`src/domain.operations/invoke/link/symlinkResourceDirectories.ts`

### .citations

[18] lines 121-128:
```typescript
/**
 * .what = creates symlinks for resource directories to a target directory
 * .why = enables role resources (briefs, skills, etc.) to be linked from node_modules or other sources
 * .how =
 *   - single { uri: string }: symlinks the source dir directly as the target dir
 *   - array { uri: string }[]: removes deprecated symlinks, then symlinks each dir within target
 *   - returns count of leaf files
 */
```

[19] lines 113-118:
```typescript
  // create relative symlink
  const relativeSource = relative(targetParent, sourcePath);
  symlinkSync(relativeSource, targetPath, 'dir');
  setDirectoryReadonlyExecutable({ dirPath: sourcePath });
  return countFilesInDirectory({ dirPath: sourcePath });
```

### .relation to wish
- wish requires: link roles from installed packages
- pattern provides: complete symlink creation with readonly permissions
- reuse: core link logic unchanged, just new source of role metadata

---

## pattern.10 = Role domain object structure

**[REUSE]**

### .what
defines role structure with briefs, skills, inits

### .where
`src/domain.objects/Role.ts`

### .citations

[20] lines 23-31:
```typescript
/**
 * .what = defines a role that can have traits, know skills, and be instantiated across thread.context
 * .why =
 *   - enables registration of usable roles (e.g., 'mechanic', 'designer', 'architect', 'ecologist')
 *   - enables instantiation of thread.contexts
 *
 * .note = generic type parameters preserve literal skill names for type-safe invocation
 *   - TSolid: the solid skills record type (e.g., { 'wordcount': { input, output } })
 *   - TRigid: the rigid skills record type (e.g., { 'review': { input, output } })
 */
```

[21] lines 108-122:
```typescript
  briefs: { dirs: { uri: string } | { uri: string }[] };

  /**
   * .what = initialization resources and commands for this role
   * .why = declares setup actions that should run once when a role is instantiated
   * .how =
   *   - dirs: directory-based init scripts for link (same pattern as briefs/skills)
   *     - single { uri: string }: symlinks this dir as the full inits dir
   *     - array { uri: string }[]: symlinks each dir within the inits dir
   *   - exec: commands to execute when `npx rhachet roles init` is run
   */
  inits?: {
    dirs?: { uri: string } | { uri: string }[];
    exec?: { cmd: string }[];
  };
```

### .relation to wish
- wish requires: rhachet.repo.yml to declare dirs and inits for each role
- pattern provides: established structure for role metadata
- reuse: rhachet.repo.yml should mirror this structure

---

## pattern.11 = RoleRegistry domain object structure

**[REUSE]**

### .what
defines registry as a collection of roles with a slug identifier

### .where
`src/domain.objects/RoleRegistry.ts`

### .citations

[22] lines 6-14:
```typescript
/**
 * .what = a curated collection of roles, available for use
 * .why =
 *   - acts as a declaration of available roles
 *   - enables composition of registries
 *   - supports cli and documentation introspection
 *   - supports fluid composition of roles via delegation (e.g., one role can runtime delegate to another that it found via registry)
 *
 * .note = a RoleRegistry is synonymous with a "repo" in CLI commands;
 *   the registry slug is used as the repo slug (e.g., --repo ehmpathy)
 */
```

[23] lines 16-32:
```typescript
export interface RoleRegistry {
  /**
   * .what = unique identifier for this registry
   * .note = this is also used as the "repo" slug in CLI commands
   */
  slug: string;

  /**
   * .what = reference to markdown file with overview of what this registry contains
   * .why = provides documentation, context, and intended use
   */
  readme: { uri: string };

  /**
   * .what = the roles that this registry has collected
   */
  roles: Role[];
}
```

### .relation to wish
- wish requires: rhachet.repo.yml schema for publishers
- pattern provides: established registry structure
- reuse: rhachet.repo.yml mirrors RoleRegistry shape

---

## pattern.12 = bin/run dispatcher

**[EXTEND]**

### .what
shell dispatcher routes commands to bun (fast) or jit (flexible)

### .where
`bin/run`

### .citations

[24] lines 3-10:
```bash
######################################################################
# .what = shell entrypoint for rhachet CLI
# .why = routes to bun (fast) or jit (flexible) dispatcher
#
# architecture:
#   run, roles boot/cost → run.bun (bun compiled, reads .agent/)
#   *                    → run.jit (jit, imports from npm packages)
#
# .note = run.bun does finer-grained dispatch to .bc binaries
######################################################################
```

[25] lines 22-43:
```bash
case "$1" in
  run)
    # fast path: dispatch to bun, if allowlisted
    exec "$SCRIPT_DIR/run.bun" "$@"
    ;;
  roles)
    case "$2" in
      boot|cost)
        # fast path: dispatch to bun, if allowlisted
        exec "$SCRIPT_DIR/run.bun" "$@"
        ;;
      *)
        # else, use jit
        exec "$SCRIPT_DIR/run.jit" "$@"
        ;;
    esac
    ;;
  *)
    # else, use jit
    exec "$SCRIPT_DIR/run.jit" "$@"
    ;;
esac
```

### .relation to wish
- wish requires: `init --roles` command
- pattern provides: dispatch logic that special-cases `init`
- extend: `init` already routes to jit; add `--roles` in invokeInit

---

## pattern.13 = init script execution

**[REUSE]**

### .what
executes init scripts with full arg passthrough via spawnSync

### .where
`src/domain.operations/invoke/executeInit.ts`

### .citations

[26] lines 27-32:
```typescript
/**
 * .what = executes an init script with passthrough args
 * .why = runs the discovered init with full arg passthrough
 *
 * .note = uses spawnSync with explicit stdin passthrough to ensure input
 *         reaches the script (Commander.js may consume stdin before execSync)
 */
```

[27] lines 47-52:
```typescript
  // execute with explicit stdin passthrough to ensure data reaches script
  const result = spawnSync(command, [], {
    cwd: process.cwd(),
    stdio: [process.stdin, process.stdout, process.stderr],
    shell: '/bin/bash',
  });
```

### .relation to wish
- wish requires: execute init for each role
- pattern provides: init execution with proper stdio
- reuse: directly applicable for `init --roles` batch execution

---

## pattern.14 = invokeInit bootstrap command

**[EXTEND]**

### .what
initializes rhachet.use.ts config from discovered packages

### .where
`src/contract/cli/invokeInit.ts`

### .citations

[28] lines 12-16:
```typescript
/**
 * .what = adds the "init" command to the CLI
 * .why = enables auto-generation of rhachet.use.ts config from discovered role packages
 * .how = discovers rhachet-roles-* packages and generates config file
 */
```

[29] lines 35-49:
```typescript
      // discover role packages
      const packages = await discoverRolePackages({ from: cwd });

      if (packages.length === 0) {
        console.log(`  - [none found]`);
        console.log(``);
        console.log(
          `⚠️  No rhachet-roles-* packages found in package.json dependencies.`,
        );
        console.log(
          `   Install a role package first, e.g.: npm install rhachet-roles-ehmpathy`,
        );
        console.log(``);
        return;
      }
```

[30] lines 80-88:
```typescript
      // persist .agent/repo=.this/role=any directories and readme
      const roleAnyDir = resolve(root, '.agent', 'repo=.this', 'role=any');
      persistFile({ cwd, path: resolve(roleAnyDir, 'briefs') });
      persistFile({ cwd, path: resolve(roleAnyDir, 'skills') });
      persistFile({
        cwd,
        path: resolve(roleAnyDir, 'readme.md'),
        content: 'this role applies to any agent that works within this repo\n',
      });
```

### .relation to wish
- wish requires: `init --roles mechanic behaver reviewer` command
- pattern provides: current init that generates rhachet.use.ts
- extend: add `--roles` flag for direct role link+init without rhachet.use.ts generation

---

## summary

| pattern | action | rationale |
|---------|--------|-----------|
| package discovery | REUSE | exact mechanism needed for wish |
| rhachet.use.ts generation | REPLACE | wish deprecates this requirement |
| init special path | EXTEND | add --roles flag path |
| registry load | EXTEND | add rhachet.repo.yml alternative |
| roles link | EXTEND | allow registry from yml |
| roles init | EXTEND | allow registry from yml |
| role resolution | REUSE | disambiguation logic needed |
| repo inference | REUSE | ambiguity logic needed |
| symlink resources | REUSE | core link mechanism |
| Role structure | REUSE | yml mirrors this shape |
| RoleRegistry structure | REUSE | yml mirrors this shape |
| bin/run dispatcher | EXTEND | init already special-cased |
| init execution | REUSE | batch execution uses this |
| invokeInit | EXTEND | add --roles path |
