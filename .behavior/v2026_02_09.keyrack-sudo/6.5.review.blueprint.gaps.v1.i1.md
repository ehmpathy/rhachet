# 6.5 blueprint gap review — stanza mismatch: X25519 vs ssh-ed25519

## summary

`./bin/run keyrack init` fails with `BadRequestError: failed to decrypt host manifest` on vlad's machine because the encryption and decryption paths use incompatible age recipient stanza formats. the npm library encrypts to `X25519` stanzas; the `age` CLI with SSH key identity only matches `ssh-ed25519` stanzas.

---

## error observed

```
⛈️ BadRequestError: failed to decrypt host manifest
{
  "path": "/home/vlad/.rhachet/keyrack/keyrack.host.age",
  "owner": null,
  "error": "Command failed: age -d -i \"/home/vlad/.ssh/id_ed25519\" \"/tmp/keyrack-decrypt-1771005121824.age\"\nage: error: no identity matched any of the recipients\n..."
}
```

---

## root cause

### the two stanza formats in age

the age encryption format supports multiple recipient stanza types. the two relevant ones:

| stanza header | recipient format | identity format | who creates it |
|---|---|---|---|
| `-> X25519 <ephemeral_share>` | `age1...` (native x25519) | `AGE-SECRET-KEY-...` | `age-encryption` npm library |
| `-> ssh-ed25519 <fingerprint> <ephemeral_share>` | `ssh-ed25519 AAAA...` | SSH private key file | `age` Go CLI |

these two stanzas are **not interchangeable**. an identity can only match its own stanza type.

### the encryption path (creates X25519 stanza)

```
initKeyrack.ts
  └─ readSshPubkey() → "ssh-ed25519 AAAA... comment"
  └─ new KeyrackKeyRecipient({ mech: 'ssh', pubkey: 'ssh-ed25519...' })
  └─ daoKeyrackHostManifest.set()
       └─ encryptToRecipients()
            └─ sshPubkeyToAgeRecipient() → converts ed25519 → x25519 → bech32 → "age1..."
            └─ encrypter.addRecipient("age1...")  ← npm library
            └─ produces: -> X25519 <ephemeral>    ← X25519 stanza in file header
```

the `age-encryption` npm library only supports native `age1...` recipients. it always produces `X25519` stanzas.

### the decryption path for passphrase-protected keys (looks for ssh-ed25519 stanza)

```
daoKeyrackHostManifest.get()
  └─ sshPrikeyToAgeIdentity({ keyPath: '~/.ssh/id_ed25519' })
       └─ extractSshKeyCipher() → 'aes256-ctr' (passphrase-protected)
       └─ returns: "SSH_KEY_PATH:/home/vlad/.ssh/id_ed25519"
  └─ decryptWithIdentity()
       └─ detects SSH_KEY_PATH_MARKER
       └─ decryptWithAgeCLI()
            └─ execSync('age -d -i "/home/vlad/.ssh/id_ed25519" "/tmp/keyrack-decrypt-*.age"')
            └─ age CLI scans for: -> ssh-ed25519 stanzas  ← NOT FOUND
            └─ "no identity matched any of the recipients"
```

the `age` Go CLI with `-i <ssh_key>` only matches `ssh-ed25519` stanzas. the file has `X25519` stanzas.

### the decryption path for unencrypted keys (works correctly)

```
daoKeyrackHostManifest.get()
  └─ sshPrikeyToAgeIdentity({ keyPath })
       └─ extractSshKeyCipher() → 'none' (unencrypted)
       └─ extractEd25519Seed() → 32 bytes
       └─ ed25519SeedToAgeIdentity() → "AGE-SECRET-KEY-..."
  └─ decryptWithIdentity()
       └─ no SSH_KEY_PATH_MARKER prefix
       └─ decrypter.addIdentity("AGE-SECRET-KEY-...")  ← npm library
       └─ matches X25519 stanza → ✅ success
```

for unencrypted keys, the in-process conversion produces a native age identity that matches the X25519 stanza.

### the mismatch matrix

| ssh key type | encryption stanza | identity format | decryption match | result |
|---|---|---|---|---|
| unencrypted | `X25519` (npm library) | `AGE-SECRET-KEY-...` (npm library) | ✅ X25519 ↔ AGE-SECRET-KEY | works |
| passphrase-protected | `X25519` (npm library) | SSH key file (age CLI) | ❌ X25519 ↔ ssh identity | fails |

---

## impact

**severity: BLOCKER** — keyrack init and all manifest decrypt operations fail for any human with a passphrase-protected SSH key (the standard best practice setup).

**who is affected:**
- all humans with passphrase-protected ed25519 keys → fails
- robots and CI with passphrase-less keys (`-N ""`) → works fine

---

## potential fixes

### option A: use age CLI for encryption when SSH recipients are present

instead of convert of SSH pubkeys to age1 recipients via npm library, shell out to `age` CLI for encryption too:

```
age -e -R <(echo "ssh-ed25519 AAAA...") -o output.age input.json
```

this creates `ssh-ed25519` stanzas that `age -d -i ssh_key` can match.

**tradeoff:** requires age CLI for both encryption AND decryption when SSH keys are used. but age CLI is already required for the decryption path.

### option B: use age CLI for key conversion (seed extraction from passphrase-protected keys)

use the age CLI to extract the seed from the passphrase-protected key (via ssh-agent), then convert to `AGE-SECRET-KEY-...` in-process. this produces a native age identity that matches the X25519 stanza.

**tradeoff:** unclear if the age CLI has a subcommand that exposes this; may not be feasible without direct ssh-agent protocol interaction.

### option C: encrypt to BOTH stanza types (X25519 and ssh-ed25519)

encrypt once to the `age1...` recipient (npm library, X25519 stanza) AND once to the raw SSH pubkey (age CLI, ssh-ed25519 stanza). either identity can decrypt.

**tradeoff:** doubles the encrypted file header size; requires two encryption passes.

### option D: always use age CLI for SSH key operations (bypass npm library for SSH)

delegate ALL SSH-related encryption/decryption to the age CLI. reserve the npm library for native age keys only.

**tradeoff:** simplest mental model; consistent stanza format; age CLI required for all SSH key users.

---

## resolution: cipher-aware recipient format at init time (approach 1)

### why options A–D were rejected

| option | rejected because |
|--------|-----------------|
| A: age CLI for all SSH encryption | breaks hybrid mode — forces age CLI on CI machines with passwordless keys |
| B: seed extraction from passphrase keys | not feasible — age CLI has no subcommand to expose the seed via ssh-agent |
| C: encrypt to both stanza types | requires age CLI for the encrypt path even for passwordless keys — violates CI constraint |
| D: always use age CLI for SSH | same as A — forces age CLI on all SSH key users |

### the hard constraint

**CI machines with passwordless ssh keys must NEVER require the `age` CLI binary.** this is the constraint that eliminates all options except approach 1.

### the fix: cipher-aware recipient format

at `keyrack init` time, detect the ssh key's cipher field. store the recipient pubkey in the format that matches the decrypt path:

| ssh key cipher at init | stored recipient pubkey | stored mech | encrypt path | decrypt path | age CLI needed |
|---|---|---|---|---|---|
| `none` (passwordless) | `age1...` (converted from ssh pubkey) | `age` | npm library (X25519 stanza) | npm library (AGE-SECRET-KEY) | **no** |
| `aes256-ctr` (passphrase) | `ssh-ed25519 AAAA...` (raw ssh pubkey) | `ssh` | age CLI (ssh-ed25519 stanza) | age CLI (-i ssh_key via ssh-agent) | **yes** |

the key insight: **the stored recipient pubkey format IS the signal** for which encryption/decryption path to use. no separate flag or config needed.

### how it works

```
initKeyrack.ts (at init time):
  └─ find ssh private key
  └─ extractSshKeyCipher(keyPath) → cipher field
  │
  ├─ if cipher === 'none' (passwordless):
  │     └─ readSshPubkey() → "ssh-ed25519 AAAA..."
  │     └─ sshPubkeyToAgeRecipient() → "age1..."
  │     └─ new KeyrackKeyRecipient({ mech: 'age', pubkey: 'age1...' })
  │     └─ npm library encrypts → X25519 stanza
  │     └─ npm library decrypts via AGE-SECRET-KEY ✅
  │
  └─ if cipher !== 'none' (passphrase-protected):
        └─ readSshPubkey() → "ssh-ed25519 AAAA..."
        └─ new KeyrackKeyRecipient({ mech: 'ssh', pubkey: 'ssh-ed25519 AAAA...' })
        └─ age CLI encrypts → ssh-ed25519 stanza
        └─ age CLI decrypts via -i ssh_key (ssh-agent) ✅
```

```
encryptToRecipients() (at encrypt time):
  └─ for each recipient:
       ├─ if recipient.pubkey starts with 'age1': npm library encrypter.addRecipient()
       └─ if recipient.pubkey starts with 'ssh-': shell out to age CLI
            └─ age -e -R <(echo "ssh-ed25519 AAAA...") -o output.age input
```

### the `ssh-keygen -p` edge case

`ssh-keygen -p` re-encrypts the **same** ed25519 keypair with a passphrase. it does NOT produce a new key — the pubkey stays identical. this means:

- init with passwordless key → stores `age1...` → encrypts to X25519 stanza
- user runs `ssh-keygen -p` → key is now passphrase-protected
- next decrypt → `sshPrikeyToAgeIdentity` detects `aes256-ctr` → returns `SSH_KEY_PATH:...`
- `decryptWithIdentity` → `decryptWithAgeCLI` → age CLI scans for `ssh-ed25519` stanza → NOT FOUND
- **error: stanza mismatch**

### why `--stanza ssh` is needed

both `init` and `recipient set` are cipher-aware by default — they detect the ssh key's cipher field and choose the stanza format accordingly. if the key is passwordless (cipher: none), both commands convert the ssh pubkey to `age1...` and produce X25519 stanzas.

this means `recipient set --pubkey ~/.ssh/id_ed25519.pub` on a passwordless key would produce ANOTHER `age1...` recipient — useless for prevention. the `--stanza ssh` flag overrides cipher-aware conversion and forces the raw `ssh-ed25519 AAAA...` format, which produces ssh-ed25519 stanzas.

**prevention (recommended)**: add the ssh-ed25519 recipient BEFORE the passphrase change, while the old key still works:

```
before you run ssh-keygen -p, add your ssh pubkey as a second recipient:

  1. add ssh recipient:    rhx keyrack recipient set --pubkey ~/.ssh/id_ed25519.pub --stanza ssh
     (--stanza ssh forces ssh-ed25519 format despite passwordless key)
     (re-encrypts manifest to BOTH age1... AND ssh-ed25519 stanzas)
  2. add passphrase:       ssh-keygen -p -f ~/.ssh/id_ed25519
     (key is now passphrase-protected — age CLI matches ssh-ed25519 stanza)
  3. remove stale recipient: rhx keyrack recipient del --label "default"
     (re-encrypts manifest with only the ssh-ed25519 recipient)
```

the manifest is decryptable at every step. no re-init needed — `recipient set` and `recipient del` handle the transition.

**recovery (if they forgot to add the recipient first)**: remove the passphrase temporarily to regain access:

```
recipient stanza mismatch: manifest was encrypted to age1... but your key now requires ssh-ed25519 stanzas.
this typically happens after ssh-keygen -p (add passphrase to key).

to fix (preserves all manifest data):
  1. remove passphrase:    ssh-keygen -p -f ~/.ssh/id_ed25519
     (enter current passphrase, leave new passphrase empty)
  2. add ssh recipient:    rhx keyrack recipient set --pubkey ~/.ssh/id_ed25519.pub --stanza ssh
     (--stanza ssh forces ssh-ed25519 format; key is temporarily passwordless)
     (re-encrypts manifest to BOTH age1... AND ssh-ed25519 stanzas)
  3. restore passphrase:   ssh-keygen -p -f ~/.ssh/id_ed25519
     (leave old passphrase empty, enter new passphrase)
  4. remove stale recipient: rhx keyrack recipient del --label "default"
     (re-encrypts manifest with only the ssh-ed25519 recipient)
```

this is acceptable because `ssh-keygen -p` is a rare, deliberate action — not an accident. the error message should guide to the prevention flow first (with `--stanza ssh`), and fall back to the recovery flow if already locked out.

---

## verification

the encrypted file at `~/.rhachet/keyrack/keyrack.host.age` contains:

```
-> X25519 amkMzslPuD/jmnlyD1aysnl/xZ3IgcDiXMqZDuxhQ24
```

this confirms the X25519 stanza. vlad's key at `~/.ssh/id_ed25519` is passphrase-protected (cipher: aes256-ctr), so the age CLI path is invoked for decrypt, which does not match X25519 stanzas. the fix is to re-init: at init time the cipher is detected and the recipient is stored as `ssh-ed25519 AAAA...` instead of `age1...`, which produces `ssh-ed25519` stanzas that the age CLI can match.

---

## immediate workaround

delete the stale manifest and re-init after the fix is applied:

```bash
rm ~/.rhachet/keyrack/keyrack.host.age
# then fix the code and re-run: ./bin/run keyrack init
```
