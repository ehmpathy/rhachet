# blueprint gaps review: keyrack sudo credentials

## summary

the implementation achieves **~50-60% fidelity** to the blueprint. the skeleton is present (cli commands, domain objects, storage structure) but **multiple critical control flow paths are broken**. the data structures are correct, but the connections between components are incomplete.

| category | count | severity |
|----------|-------|----------|
| critical (broken flow) | 7 | p0 |
| high (broken ux) | 3 | p1 |
| medium (incomplete) | 4 | p2 |
| architectural divergences | 2 | acceptable |

---

## critical gaps (p0) — broken control flow

### 1. context builders don't accept owner parameter

**root cause**: both `genKeyrackHostContext` and `genKeyrackGrantContext` call `daoKeyrackHostManifest.get({})` with **NO owner parameter**. this breaks per-owner isolation entirely.

**genKeyrackHostContext.ts:29-32**:
```ts
export const genKeyrackHostContext = async (): Promise<KeyrackHostContext> => {
  // NO owner parameter in signature!
  const hostManifest =
    (await daoKeyrackHostManifest.get({})) ??  // ← always reads default manifest
```

**genKeyrackGrantContext.ts:35-40**:
```ts
export const genKeyrackGrantContext = async (input: {
  gitroot: string;
  // NO owner parameter in input!
}): Promise<KeyrackGrantContext> => {
  const hostManifest =
    (await daoKeyrackHostManifest.get({})) ??  // ← always reads default manifest
```

**impact**: even when `--for mechanic` is specified, the context builders read the default manifest, not mechanic's manifest. per-owner isolation is completely broken.

---

### 2. cli list command doesn't pass owner

**location**: `invokeKeyrack.ts:616-655`

```ts
.action(async (opts: { for?: string; json?: boolean }) => {
  // opts.for is parsed but NOT passed to genKeyrackHostContext()!
  const context = await genKeyrackHostContext();
```

**impact**: `rhx keyrack list --for mechanic` ignores the `--for` flag.

---

### 3. sudo key lookup path broken

**root cause**: `getKeyrackKeyGrant` and `unlockKeyrack` both look up keys in `repoManifest.keys[slug]` **first**. but sudo keys are ONLY in host manifest.

**getKeyrackKeyGrant.ts:71-79**:
```ts
const keySpec = context.repoManifest?.keys[slug];
if (!keySpec) {
  return {
    status: 'absent',  // ← sudo keys ALWAYS hit this
    slug,
    message: `key '${slug}' not found in repo manifest`,
  };
}
```

**unlockKeyrack.ts:87-88**:
```ts
const spec = repoManifest.keys[slug];
if (!spec) continue;  // ← sudo keys are silently skipped
```

**impact**:
- sudo keys always show "absent" even when configured
- sudo keys cannot be unlocked
- acceptance tests document this at lines 700-702, 745-746, 785-786, 827

---

### 4. set sudo fails without keyrack.yml

**location**: `invokeKeyrack.ts:397-409`

```ts
let resolvedOrg: string;
if (opts.org === '@all') {
  resolvedOrg = '@all';
} else {
  if (!grantContext.repoManifest) {
    throw new BadRequestError('no keyrack.yml found in repo');  // ← fails for sudo!
  }
  resolvedOrg = assertKeyrackOrgMatchesManifest({...});
}
```

**impact**: cannot set sudo credentials in a repo without keyrack.yml, even though sudo keys don't need to be in keyrack.yml.

---

### 5. keyrack.yml write logic absent

**location**: `setKeyrackKeyHost.ts:83-98`

**current state**: the function ONLY writes to host manifest. it has **NO logic** to:
- write regular credentials (env !== 'sudo') to keyrack.yml

**impact**: regular credentials are ALSO absent from keyrack.yml. only host manifest is updated.

---

### 6. maxDuration not enforced

**location**: `unlockKeyrack.ts:86-128`

**current state**:
- `KeyrackKeyHost.maxDuration` field exists and is stored
- `unlockKeyrack` retrieves `hostConfig` but **NEVER reads** `hostConfig.maxDuration`
- all keys unlock with requested duration

**impact**: security feature bypassed.

---

### 7. vaultRecipient not used

**location**: `vaultAdapterOsSecure.ts:69-174`

**current state**:
- cli accepts `--vault-recipient` flag
- `KeyrackKeyHost.vaultRecipient` field stored
- adapter **ONLY uses passphrase-based encryption**
- no age-recipient encryption path

**impact**: `--vault-recipient` flag has no effect.

---

## high gaps (p1) — broken ux

### 8. cross-org sudo unlock returns 0 keys

**location**: acceptance test line 993-996

**documented gap**:
```ts
// gap: unlock with cross-org sudo key by full slug returns 0 keys
```

**root cause**: slug lookup in repoManifest fails for @all.sudo.* keys.

---

### 9. daemon org extraction loses @all

**location**: `getKeyrackKeyGrant.ts:137, 146`

```ts
org: slug.split('.')[0] ?? 'unknown',  // ← extracts '@all' from slug
```

**issue**: when daemon returns a key, org is re-extracted from slug rather than from stored value. this works for @all but is fragile.

---

### 10. --org flag absent on get command

**location**: acceptance test line 903

**documented gap**:
```ts
// .note = --org flag is only on `set`, not on `get` (gap in CLI)
```

---

## medium gaps (p2) — incomplete

### 11. env values not validated

**location**: `schema.ts`

```ts
env: z.string().optional().default('all'),
```

no whitelist validation. accepts typos like `--env sudoo`.

---

### 12. org validation in daemon GET absent

**blueprint specifies**: validate org matches request or @all

**current state**: returns keys without validation.

---

### 13. env/org filter params not in daemonAccessGet

**blueprint specifies**: `env?: string` and `org?: string` filter params

**current state**: only `socketPath` and `slugs`.

---

### 14. ssh recipient support absent

**current state**: `ageRecipientCrypto` only supports `mech: 'age'`. throws error for ssh keys.

---

## architectural divergences (acceptable)

### age keys vs ssh key discovery

| aspect | blueprint | implementation |
|--------|-----------|----------------|
| recipient key | ssh key discovery | age key generation |

acceptable — age keys are purpose-built for encryption.

### socket path location

| aspect | blueprint | implementation |
|--------|-----------|----------------|
| path | `/tmp/keyrack.daemon.sock` | `$XDG_RUNTIME_DIR/keyrack.$SESSIONID.sock` |

improvement — xdg_runtime_dir is more secure.

---

## what works correctly

| component | status |
|-----------|--------|
| domain objects (fields) | ✅ complete |
| age key generation | ✅ works |
| multi-recipient encryption | ✅ works |
| initKeyrack idempotency | ✅ works |
| recipient operations (set/get/del) | ✅ works |
| daemon env/org storage | ✅ works |
| daemon env filter on relock | ✅ works |
| schema validation | ✅ works |
| per-owner file paths | ✅ works |
| cli flag parse | ✅ works |

---

## root cause analysis

the implementation has **correct data structures** but **broken connections**:

```
data flow intended:
  CLI --for mechanic
    → genKeyrackGrantContext({ owner: 'mechanic' })
      → daoKeyrackHostManifest.get({ owner: 'mechanic' })
        → reads keyrack.host.mechanic.age

data flow actual:
  CLI --for mechanic
    → genKeyrackGrantContext({ gitroot })  // owner NOT passed
      → daoKeyrackHostManifest.get({})     // owner NOT passed
        → reads keyrack.host.age           // WRONG manifest
```

similarly for sudo keys:

```
lookup intended:
  if (env === 'sudo' || !repoManifest.keys[slug]) {
    // check hostManifest.hosts[slug] directly
  }

lookup actual:
  repoManifest.keys[slug] → not found → return "absent"
  // hostManifest never checked for sudo keys
```

---

## prioritized action items

### p0 — critical (blocks feature entirely)

| # | gap | location | effort |
|---|-----|----------|--------|
| 1 | context builders need owner param | genKeyrack*Context.ts | medium |
| 2 | cli list pass owner to context | invokeKeyrack.ts | small |
| 3 | sudo key lookup path | getKeyrackKeyGrant.ts | medium |
| 4 | set sudo without keyrack.yml | invokeKeyrack.ts | small |
| 5 | keyrack.yml write for regular keys | setKeyrackKeyHost.ts | small |
| 6 | maxDuration enforcement | unlockKeyrack.ts | small |
| 7 | vaultRecipient encryption | vaultAdapterOsSecure.ts | medium |

### p1 — high (broken ux)

| # | gap | location | effort |
|---|-----|----------|--------|
| 8 | cross-org sudo unlock | depends on #3 | - |
| 9 | daemon org from stored value | getKeyrackKeyGrant.ts | small |
| 10 | --org flag on get | invokeKeyrack.ts | small |

### p2 — medium (incomplete)

| # | gap | location | effort |
|---|-----|----------|--------|
| 11 | env value validation | schema.ts | small |
| 12 | org validation in GET | handleGetCommand.ts | small |
| 13 | env/org filter params | daemonAccessGet.ts | small |
| 14 | ssh recipient support | ageRecipientCrypto.ts | medium |

---

## acceptance test documentation

the tests explicitly document gaps:

| line | gap |
|------|-----|
| 700-702 | sudo keys show "absent" when should show "locked" |
| 745-746 | configured sudo key shows "absent" |
| 785-786 | after unlock, sudo key still shows "absent" |
| 827 | should be granted after unlock |
| 903 | --org flag only on set, not get |
| 993-996 | cross-org unlock returns 0 keys |

---

## conclusion

the implementation has **correct parts** that are **not connected**:

| layer | status |
|-------|--------|
| domain objects | ✅ fields correct |
| dao layer | ✅ encryption correct |
| daemon layer | ✅ env/org handle correct |
| context builders | ❌ owner param absent |
| lookup operations | ❌ sudo path broken |
| cli wire | ❌ owner not passed through |

**before ship**: must fix context builder connections (#1-2) and sudo lookup path (#3). these are prerequisite for all other sudo functionality.
