# research: production code patterns for keyrack sudo

## 1. host manifest dao pattern

### current pattern

the host manifest is stored as plaintext JSON at `~/.rhachet/keyrack.manifest.json`.

> "resolves the host manifest path... expands ~ to home directory... stores key hosts in ~/.rhachet/keyrack.manifest.json" [1]

the schema lacks env and org fields:

```typescript
schemaKeyrackKeyHost = z.object({
  slug: z.string(),
  exid: z.string().nullable(),
  vault: z.enum(['os.direct', 'os.secure', '1password']),
  mech: z.enum(['REPLICA', 'GITHUB_APP', 'AWS_SSO']),
  createdAt: z.string(),
  updatedAt: z.string(),
});
```
[2]

uses findsert/upsert semantics for idempotent persistence:

> ".note = supports findsert (no update on match) and upsert (update on match)" [1]

### how it relates to wish

- sudo credentials need `env: 'all' | 'sudo'` field
- org-scoped credentials need `org: string` field (e.g., '@ehmpathy', '@all')
- entire manifest needs encryption (keyrack.host.yml.age)
- current plaintext exposes credential metadata

### verdict: [EXTEND]

- add `env` and `org` fields to `schemaKeyrackKeyHost`
- create `daoKeyrackHostManifestEncrypted` with vaultAdapterOsSecure pattern
- migrate from `.json` to `.yml.age` format
- keep findsert/upsert semantics

---

## 2. vault adapter pattern (age encryption)

### current pattern

the `vaultAdapterOsSecure` provides age-based encryption with passphrase:

> "vault adapter for os-secure storage... stores credentials in age-encrypted files with passphrase protection... os.secure requires explicit unlock — the passphrase is held in memory" [3]

passphrase acquisition flow:

> "passphrase can be provided via: 1. input.passphrase (programmatic) 2. KEYRACK_PASSPHRASE env var (secure for cli chained commands) 3. interactive prompt with hidden input (human interactive)" [3]

encryption mechanics:

```typescript
const encrypter = new Encrypter();
encrypter.setPassphrase(passphrase);
const ciphertext = await encrypter.encrypt(input.value);
writeFileSync(path, Buffer.from(ciphertext));
```
[3]

decryption mechanics:

```typescript
const decrypter = new Decrypter();
decrypter.addPassphrase(passphrase);
const plaintext = await decrypter.decrypt(ciphertext, 'text');
```
[3]

session passphrase cache:

> "the passphrase is held in memory only for the session lifetime... KEYRACK_PASSPHRASE env var can be used as fallback for CLI chained commands" [3]

### how it relates to wish

- same encryption pattern applies to host manifest
- passphrase flow already handles interactive + env var
- need to block `--passphrase` arg for sudo credentials (shell history risk)

### verdict: [REUSE]

- reuse exact age encryption pattern from vaultAdapterOsSecure
- adapt for whole manifest encryption instead of individual credentials
- block input.passphrase for sudo unlock (enforce interactive/env-only)

---

## 3. daemon socket creation pattern

### current pattern

daemon creates unix socket without explicit permission set:

```typescript
const server = createServer((socket) => {
  handleKeyrackDaemonConnection({ socket }, { keyStore });
});

server.listen(socketPath, () => {
  console.log(`[keyrack-daemon] server started at ${socketPath}`);
});
```
[4]

> "cleans up stale socket file on start... returns server instance for lifecycle management" [4]

socket path includes session isolation:

> "Format: $XDG_RUNTIME_DIR/keyrack.$SESSIONID.sock... Includes login session ID for per-session isolation" [exploration]

### how it relates to wish

- socket permissions currently inherit from umask (may not be 0600)
- attack surface reduction requires explicit 0600 (owner-only)
- no CI environment detection currently

### verdict: [EXTEND]

- add `chmodSync(socketPath, 0o600)` after `server.listen`
- add CI environment detection before unlock command handler

---

## 4. daemon key store pattern

### current pattern

in-memory key store with TTL enforcement on read:

> "in-memory key store with TTL enforcement... uses simple Map, not external cache library... TTL is enforced on read (get), not via timers" [5]

UnlockedKey interface:

```typescript
interface UnlockedKey {
  slug: string;
  key: KeyrackKey;
  unlockedAt: number; // timestamp ms
  expiresAt: number;  // timestamp ms
}
```
[5]

TTL purge on read:

```typescript
const get = (input: { slug: string }): UnlockedKey | null => {
  const unlockedKey = store.get(input.slug);
  if (!unlockedKey) return null;

  const now = Date.now();
  if (now >= unlockedKey.expiresAt) {
    store.delete(input.slug);
    return null;
  }

  return unlockedKey;
};
```
[5]

### how it relates to wish

- need to track env classification per key for TTL differentiation
- need to track env for filter in status and relock commands
- default 30min TTL for sudo vs 9h for regular

### verdict: [EXTEND]

- add `env: 'all' | 'sudo'` to UnlockedKey interface
- add `org: string` to UnlockedKey for org-scoped access
- use env to filter in entries() for selective relock

---

## 5. unlock keyrack pattern

### current pattern

bulk unlock iterates repo manifest keys:

```typescript
for (const [slug, spec] of Object.entries(repoManifest.keys)) {
  const hostConfig = context.hostManifest.hosts[slug];
  if (!hostConfig) continue;

  const adapter = context.vaultAdapters[vault];
  await adapter.unlock({ passphrase: input.passphrase });
  const secret = await adapter.get({ slug, exid: hostConfig.exid });

  keysToUnlock.push({
    slug,
    key: { secret, grade },
    expiresAt,
    vault,
  });
}
```
[6]

default duration is 9 hours:

> "parse duration (default 9 hours)" [6]

duration parse:

```typescript
const parseDuration = (duration: string): number => {
  const match = duration.match(/^(\d+)(h|m|s)$/);
  // returns milliseconds
};
```
[6]

### how it relates to wish

- sudo unlock must require `--key` flag (no bulk unlock)
- sudo unlock must use 30min default TTL
- sudo unlock must be blocked in CI
- sudo unlock must not accept `--passphrase` arg

### verdict: [EXTEND]

- add `--env` parameter to distinguish sudo vs all
- add `--key` parameter for per-key sudo unlock
- change default TTL based on env (30min sudo, 9h regular)
- add CI detection to block sudo unlock
- reject `--passphrase` for sudo env

---

## 6. daemon access get pattern

### current pattern

SDK sends GET command to daemon:

```typescript
const response = await sendKeyrackDaemonCommand<{
  keys: Array<{
    slug: string;
    key: KeyrackKey;
    expiresAt: number;
  }>;
}>({
  socket,
  command: 'GET',
  payload: { slugs: input.slugs },
});
```
[7]

> "reads credentials from daemon memory for tool access" [7]

response includes expiration time:

```typescript
keys: Array<{
  slug: string;
  key: KeyrackKey;
  expiresAt: number;
}>
```
[7]

### how it relates to wish

- need to add `env` and `org` to response for client-side filter
- need to return grade classification ('sudo' vs 'all') in response

### verdict: [EXTEND]

- add `env: 'all' | 'sudo'` to key response
- add `org: string` to key response
- filter by org on get (return error if org mismatch)

---

## 7. keyrack key grade pattern

### current pattern

KeyrackKey includes grade for protection and duration:

```typescript
interface KeyrackKey {
  secret: KeyrackKeySecret;
  grade: KeyrackKeyGrade;
}

interface KeyrackKeyGrade {
  protection: 'encrypted' | 'plaintext';
  duration: 'permanent' | 'ephemeral' | 'transient';
}
```
[exploration]

grade is inferred from vault and mechanism:

> "infer grade from vault and mechanism" [6]

### how it relates to wish

- need to distinguish sudo vs regular credentials
- could add `security: 'regular' | 'sudo'` to grade
- or track env separately (simpler)

### verdict: [EXTEND]

- add `security?: 'regular' | 'sudo'` to KeyrackKeyGrade
- or track env in UnlockedKey (simpler, less schema change)
- decision: track env in UnlockedKey to minimize domain object changes

---

## 8. vault adapter interface pattern

### current pattern

standard interface for all vault adapters:

```typescript
interface KeyrackHostVaultAdapter {
  unlock(input: { passphrase?: string }): Promise<void>;
  isUnlocked(): Promise<boolean>;
  get(input: { slug: string; exid?: string }): Promise<string | null>;
  set(input: { slug: string; value: string }): Promise<void>;
  del(input: { slug: string }): Promise<void>;
}
```
[3]

multiple implementations:
- `vaultAdapterOsDaemon` — daemon memory (transient)
- `vaultAdapterOsSecure` — age-encrypted files (passphrase)
- `vaultAdapterOsDirect` — plaintext on disk
- `vaultAdapterOsEnvvar` — environment variables
- `vaultAdapter1Password` — external vault via CLI

### how it relates to wish

- 1password adapter already supports secret references via exid
- no changes needed to vault adapters themselves
- unlock flow uses adapters correctly

### verdict: [REUSE]

- keep all vault adapters as-is
- they work correctly for both regular and sudo credentials

---

## 9. rate limit pattern

### current pattern

no rate limit on unlock attempts currently.

> no rate limit logic found in unlock flow [exploration]

### how it relates to wish

- brute force protection requires exponential backoff
- track failed attempts per passphrase unlock
- schedule: 0s, 1s, 2s, 4s, 8s (capped)

### verdict: [NEW]

- create `src/domain.operations/keyrack/access/rateLimitUnlock.ts`
- track failed attempts in daemon memory (per session)
- apply delay before next unlock attempt is allowed

---

## 10. ci environment detection pattern

### current pattern

no CI detection currently.

> no CI environment detection in keyrack codebase [exploration]

### how it relates to wish

- sudo unlock must be blocked in CI
- detect via `CI=true` or `GITHUB_ACTIONS` env vars
- fail fast with clear error message

### verdict: [NEW]

- create `src/domain.operations/keyrack/env/detectCiEnvironment.ts`
- check `process.env.CI === 'true'` or `process.env.GITHUB_ACTIONS`
- call before sudo unlock, throw BadRequestError if detected

---

## summary

| pattern | verdict | action |
|---------|---------|--------|
| host manifest dao | [EXTEND] | add env/org fields, create encrypted variant |
| age encryption (os.secure) | [REUSE] | same pattern for manifest encryption |
| daemon socket creation | [EXTEND] | add chmod 0600 after listen |
| daemon key store | [EXTEND] | add env/org to UnlockedKey |
| unlock keyrack | [EXTEND] | add --env, --key, TTL logic, CI block |
| daemon access get | [EXTEND] | add env/org to response |
| keyrack key grade | [EXTEND] | track env in UnlockedKey |
| vault adapter interface | [REUSE] | no changes needed |
| rate limit | [NEW] | create exponential backoff logic |
| CI detection | [NEW] | create environment detection |

---

## citations

1. [daoKeyrackHostManifest/index.ts](src/access/daos/daoKeyrackHostManifest/index.ts) — host manifest persistence
2. [daoKeyrackHostManifest/schema.ts](src/access/daos/daoKeyrackHostManifest/schema.ts) — host manifest schema
3. [vaultAdapterOsSecure.ts](src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsSecure.ts) — age encryption adapter
4. [createKeyrackDaemonServer.ts](src/domain.operations/keyrack/daemon/svc/src/infra/createKeyrackDaemonServer.ts) — daemon server creation
5. [daemonKeyStore.ts](src/domain.operations/keyrack/daemon/svc/src/domain.objects/daemonKeyStore.ts) — key store with TTL
6. [unlockKeyrack.ts](src/domain.operations/keyrack/session/unlockKeyrack.ts) — unlock flow
7. [daemonAccessGet.ts](src/domain.operations/keyrack/daemon/sdk/src/domain.operations/daemonAccessGet.ts) — get command SDK
