# blueprint: keyrack sudo credentials

## summary

implement elevated credential support for keyrack with env-based classification, org-scoped access, and per-owner isolation.

**builds on commit 24dd6e6**: the keyrack envs feature already implemented:
- `KeyrackKeySpec` has `env` field (for prod, prep, test deployment environments)
- `KeyrackRepoManifest` has `envs: string[]` array
- keyrack.yml uses `org` + `env.*` sections format (e.g., env.prod, env.prep)
- `unlockKeyrack` accepts `env?: string` parameter
- `getAllKeyrackSlugsForEnv` filters by env, treats 'all' as special case
- slug format is `$org.$env.$key` (e.g., `ehmpathy.prod.AWS_PROFILE`)

**key change**: `env=sudo` is a special env value with elevated semantics:
- `env=sudo`: stored in encrypted host manifest ONLY (invisible to codebase)
- `env=$other` (prod, prep, etc): stored in encrypted host manifest AND listed in `keyrack.yml` (visible to codebase)

**recipient-key-based locks**: the host manifest is encrypted to recipient keys (ssh, yubikey, etc) — no passphrases:
- `rhx keyrack init` initializes with default ssh key (or `--pubkey` for explicit key)
- manifest decryption via ssh-agent or yubikey (automatic, no prompt)
- multi-recipient support for backup keys and multi-machine access

**per-owner isolation**: each robot/agent can have its own isolated keyrack:
- `--for mechanic`: uses `keyrack.host.mechanic.age` and `/tmp/keyrack.daemon.mechanic.sock`
- no `--for` flag: uses `keyrack.host.age` and `/tmp/keyrack.daemon.sock` (default)
- full process isolation — each owner has separate daemon, separate manifest
- mechanic cannot access foreman's credentials, even on the same machine

**org scope**: `org` at CLI uses special tokens:
- `@this`: resolves to the org declared in keyrack.yml (default)
- `@all`: cross-org credential (stored as-is)
- any other value is invalid at CLI

at storage time: `@this` is resolved to actual org name (e.g., `ehmpathy`); `@all` stored as-is.

---

## treestruct: filediffs

legend: [○] = already exists, [~] = modify, [+] = add new

```
src/
  domain.objects/keyrack/
    [○] KeyrackKeySpec.ts                           # already has env, name fields (from 24dd6e6)
    [○] KeyrackRepoManifest.ts                      # already has org, envs array (from 24dd6e6)
    [~] KeyrackKeyHost.ts                           # add env, org, vaultRecipient fields
    [~] KeyrackKeyGrant.ts                          # add env, org fields
    [+] KeyrackKeyRecipient.ts                      # new: recipient key for manifest decryption
    [+] KeyrackHostManifest.ts                      # new: manifest with recipients array

  domain.operations/keyrack/
    [○] getAllKeyrackSlugsForEnv.ts                 # already filters by env (from 24dd6e6)
    [○] assertKeyrackEnvIsSpecified.ts              # already validates env (from 24dd6e6)
    [○] getAllKeyrackEnvsFromRepoManifest.ts        # already extracts envs (from 24dd6e6)
    [~] setKeyrackKeyHost.ts                        # add owner, env, org params; route to owner manifest
    [+] initKeyrack.ts                              # new: initialize with owner + recipient key
    [+] getKeyrackHostManifestPath.ts               # new: resolve path based on owner
    [+] discoverIdentityForRecipient.ts             # new: runtime identity discovery

    recipient/
      [+] setKeyrackRecipient.ts                    # new: add recipient to owner manifest
      [+] getKeyrackRecipients.ts                   # new: list recipients from owner manifest
      [+] delKeyrackRecipient.ts                    # new: remove recipient from owner manifest

    session/
      [~] unlockKeyrack.ts                          # add owner, --key required for sudo, 30min TTL
      [~] relockKeyrack.ts                          # add owner, --env filter
      [~] getKeyrackStatus.ts                       # add owner, env/org, recipient info

    daemon/
      [+] getKeyrackDaemonSocketPath.ts             # new: resolve socket path based on owner
      svc/src/
        infra/
          [~] createKeyrackDaemonServer.ts          # add owner param; chmod 0600 after listen
        domain.objects/
          [~] daemonKeyStore.ts                     # add env, org to stored keys; add env filter
        domain.operations/
          [~] handleUnlockCommand.ts                # add env, org to stored keys
          [~] handleGetCommand.ts                   # add env, org to response
          [~] handleRelockCommand.ts                # add env filter
          [~] handleStatusCommand.ts                # add env, org to status

      sdk/src/domain.operations/
        [~] daemonAccessUnlock.ts                   # add owner, env, org
        [~] daemonAccessGet.ts                      # add owner, env, org
        [~] daemonAccessRelock.ts                   # add owner, env filter
        [~] daemonAccessStatus.ts                   # add owner, env, org

  access/daos/
    daoKeyrackHostManifest/
      [~] schema.ts                                 # add owner, env, org, recipients, vaultRecipient
      [~] index.ts                                  # age encryption; runtime identity discovery

  infra/ssh/
    [+] listSshAgentKeys.ts                         # new: list keys from ssh-agent
    [+] sshPrikeyToAgeIdentity.ts                   # new: convert ssh private key to age identity

  contract/commands/keyrack/
    [+] init.ts                                     # new: rhx keyrack init --for, --pubkey, --via
    [+] recipient.ts                                # new: rhx keyrack recipient set|get|del
    [~] unlock.ts                                   # add --for, --key, --duration, --prikey
    [~] set.ts                                      # add --for, --env, --org, --vault-recipient
    [~] get.ts                                      # add --for, --env, --org
    [~] relock.ts                                   # add --for, --env, --key
    [~] status.ts                                   # add --for; show owner, env/org, recipient info
```

---

## domain.objects

```
KeyrackKeyRecipient (new)
  mech: 'ssh' | 'age' | 'yubikey' | 'passkey'
  pubkey: string                                    # e.g., "ssh-ed25519 AAAA..." or "age1..."
  label: string                                     # e.g., "macbook", "yubikey-backup"
  addedAt: string                                   # iso timestamp

KeyrackHostManifest (new)
  owner: string | null                              # null for default, or explicit (e.g., 'mechanic')
  recipients: KeyrackKeyRecipient[]                 # who can decrypt this manifest
  keys: Record<string, KeyrackKeyHost>              # map of slug to host config

KeyrackKeyHost (add fields)
  env: string                                       # 'sudo' | 'prod' | 'prep' | etc
  org: string                                       # resolved org name or '@all'
  vaultRecipient?: string                           # optional: pubkey for os.secure if different
  maxDuration?: string                              # optional: max TTL (e.g., "5m")

KeyrackKeyGrant (add fields)
  env: string                                       # 'sudo' | 'prod' | 'prep' | etc
  org: string                                       # resolved org name or '@all'

daemonKeyStore (add fields)
  env, org in stored keys; entries({ env? }) for env-based filter
```

---

## contracts

### initKeyrack

```typescript
initKeyrack(input: {
  owner?: string | null;            // null for default, explicit for robot
  pubkey?: string;                  // pubkey value, file path, or private key path
  recipientMech?: 'yubikey';        // for discovery modes
}, context): Promise<{ owner, recipient, manifestPath }>

// cipher-aware: passwordless → mech: 'age', pubkey: 'age1...'
//               passphrase → mech: 'ssh', pubkey: 'ssh-ed25519...'
```

### setKeyrackRecipient

```typescript
setKeyrackRecipient(input: {
  owner?: string | null;
  pubkey: string;
  label: string;
  stanza?: 'ssh';                   // force ssh-ed25519 stanza (skip cipher-aware)
}, context): Promise<KeyrackKeyRecipient>

// cipher-aware by default; --stanza ssh for ssh-keygen -p prevention flow
```

### setKeyrackKeyHost

```typescript
setKeyrackKeyHost(input: {
  owner?: string | null;
  slug, mech, vault, exid?,
  env: string;                      // 'sudo' | 'all' | etc
  org: string;                      // '@this' or '@all'
  vaultRecipient?, maxDuration?
}, context): Promise<KeyrackKeyHost>

// env !== 'sudo': also store in keyrack.yml
// @this resolved to actual org name
```

### unlockKeyrack

```typescript
unlockKeyrack(input: {
  owner?: string | null;
  env?: string;                     // default 'all'
  key?: string;                     // required if env === 'sudo'
  duration?: string;                // 30m for sudo, 9h for others
  prikey?: string;                  // explicit path fallback
}, context): Promise<{ unlocked: [...] }>

// BadRequestError if env === 'sudo' && !key
// duration capped by maxDuration
```

### daemonAccess*

```typescript
daemonAccessUnlock(input: { owner?, keys: [...with env, org] }): { unlocked }
daemonAccessGet(input: { owner?, slugs, env?, org? }): { keys }
daemonAccessRelock(input: { owner?, slugs?, env? }): { relocked }
daemonAccessStatus(input: { owner? }): { keys }
```

### daoKeyrackHostManifest

```typescript
interface DaoKeyrackHostManifest {
  get(input: { owner? }): Promise<KeyrackHostManifest | null>;
  // path: keyrack.host.age or keyrack.host.${owner}.age
  // decrypts via recipient key in ssh-agent or yubikey

  set: {
    findsert(manifest): Promise<KeyrackHostManifest>;
    upsert(manifest): Promise<void>;
  };
  // encrypts to all recipients in manifest.recipients
}
```

---

## test infrastructure

```
.test/assets/keyrack/ssh/
  test_key_ed25519        # committed test key (no passphrase)
  test_key_ed25519.pub    # committed test pubkey

.test/infra/
  withTestSshAgent.ts     # spawns isolated agent, loads test key
  withTestHome.ts         # creates temp HOME with test key in .ssh/
```

| test type | pattern |
|-----------|---------|
| explicit `--pubkey` | `initKeyrack({ pubkey: TEST_SSH_KEY_PATH }, context)` |
| default discovery | `withTestHome(async (home) => { ... })` |
| ssh-agent flow | `withTestSshAgent(async () => { ... })` |

---

## security measures

| measure | implementation |
|---------|----------------|
| socket permissions | `chmodSync(socketPath, 0o600)` after `server.listen` |
| recipient key access | ssh-agent (automatic), yubikey (touch required) |
| no passphrases | recipient-key-based locks |
| encrypted at rest | keyrack.host.age via age recipient encryption |
| multi-recipient | backup keys and multi-machine support |
| per-key max TTL | `maxDuration` in KeyrackKeyHost |
| per-owner isolation | separate manifest and daemon per owner |

---

## resolved questions

| question | resolution |
|----------|------------|
| sudo TTL | 30min default |
| verify caller UID | not in v1; socket 0600 sufficient |
| recipient key source | ssh-agent (auto), yubikey (touch) |
| org values | `@this` and `@all` only |
| per-key TTL | `maxDuration` in KeyrackKeyHost |
| default owner | `null` (no suffix); explicit via `--for` |

---

## amendment: hybrid ssh identity resolution

**context**: `sshPrikeyToAgeIdentity` converts ssh keys to age identities. fails on passphrase-protected keys since openssh encrypts the private section.

**decision**: two code paths based on cipher field:

| cipher | path | age CLI |
|--------|------|---------|
| `none` | in-process: ed25519 seed → age identity | no |
| `aes256-ctr` | subprocess: age CLI via ssh-agent | yes |

**who needs what**:
- robot / ci (passphrase-less): in-process, no age CLI
- human (passphrase-protected): age CLI subprocess

**hot path (`get`)** never invokes age CLI — daemon serves from memory.

---

## amendment: recipient-based identity discovery

**context**: identity file pattern was deprecated (metadata leakage, stale risk).

**decision**: runtime discovery by match of manifest recipients against available keys:
1. check ssh-agent for matched key
2. check standard ssh paths
3. check age standard locations
4. if no match: use `--prikey` fallback

covers ~95%+ of real-world cases.

---

## amendment: cipher-aware encrypt path

**context**: npm library produces X25519 stanzas; age CLI with ssh key matches ssh-ed25519 stanzas. incompatible.

**constraint**: CI with passwordless keys must NEVER require age CLI.

**decision**: at init time, detect cipher and store recipient in matched format:

| cipher at init | stored pubkey | encrypt path |
|----------------|---------------|--------------|
| `none` | `age1...` | npm library (X25519) |
| passphrase | `ssh-ed25519...` | age CLI (ssh-ed25519) |

**ssh-keygen -p edge case**: use `--stanza ssh` to add ssh-ed25519 recipient BEFORE passphrase change.

---

## amendment: secure value input and mech inference

**context**: `--value` as CLI arg is security hazard (shell history, ps aux).

**decision**:
- values via stdin only (TTY prompt or pipe)
- `--mech` optional, inferred from `--vault` (os.secure/os.direct/1password → PERMANENT_VIA_REPLICA)

---

## full original

see `3.3.blueprint.v1.i1.md.orig` for complete version with:
- detailed treestruct codepaths
- full composition flows
- complete test coverage specs
- verbose amendment context
