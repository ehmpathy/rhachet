# blackbox criteria: keyrack sudo credentials

## usecase.1 = set sudo credential

```
given('a human with keyrack configured')
  when('they run: rhx keyrack set --key X --org @this --env sudo --vault 1password')
    then('keyrack prompts for vault-specific config (e.g., 1password item path)')
      sothat('the credential can be retrieved from the vault later')
    then('keyrack stores the key config ONLY in keyrack.host.age (encrypted)')
      sothat('even the key name is hidden without the recipient key')
    then('keyrack does NOT add the key to keyrack.yml')
      sothat('sudo credentials are invisible to the codebase')
    then('keyrack returns success with usage instructions')

  when('they run: rhx keyrack set --key X --org @this --env sudo --vault 1password --exid "private/github-pat/credential"')
    then('keyrack skips the vault-specific config prompt')
      sothat('automation can set credentials without interaction')
    then('keyrack stores the key config with the provided exid')
    then('keyrack returns success with usage instructions')

  when('they run: rhx keyrack set --key X --org @this --env sudo --vault 1password (duplicate)')
    then('keyrack returns the prior config (findsert semantics)')
      sothat('re-run is idempotent')

  when('they run: rhx keyrack set --key X --env sudo without --org')
    then('keyrack defaults --org to @this')
      sothat('users dont have to specify org for same-org credentials')

  when('they run: rhx keyrack set --key X --org @invalid --env sudo --vault 1password')
    then('keyrack returns error: "org must be @this or @all"')
      sothat('only valid org tokens are accepted')
```

## usecase.2 = unlock sudo credential

```
given('a human with a sudo credential configured')
  when('they run: rhx keyrack unlock --env sudo --key X')
    then('keyrack decrypts keyrack.host.age via recipient key (ssh-agent, yubikey, etc)')
    then('keyrack fetches the credential from the vault')
    then('keyrack stores the credential in daemon with 30min TTL')
      sothat('sudo credentials have shorter exposure window than regular (9h)')
    then('keyrack returns success with expiry time')

  when('they run: rhx keyrack unlock --env sudo (without --key)')
    then('keyrack returns error: "sudo credentials require --key flag"')
      sothat('bulk unlock of sudo credentials is prevented')

  when('they run: rhx keyrack unlock --env sudo --key X --duration 1h')
    then('keyrack stores the credential with 1h TTL (override default)')
      sothat('users can extend exposure window when needed')

  when('they run: rhx keyrack unlock --env sudo --key X --duration 2h (exceeds maxDuration of 1h)')
    then('keyrack warns that duration exceeds maxDuration')
    then('keyrack caps TTL to maxDuration (1h)')
      sothat('sensitive credentials cannot exceed their configured max exposure')

  when('they run: rhx keyrack unlock --env sudo --key X (key not configured)')
    then('keyrack returns error: "key X not found in host manifest"')
```

## usecase.3 = get sudo credential

```
given('a sudo credential is unlocked in daemon')
  when('they run: rhx keyrack get --key X --env sudo')
    then('keyrack returns the credential value from daemon')
    then('keyrack includes env: "sudo" in response')

  when('they run: rhx keyrack get --key X --env sudo --output json')
    then('keyrack returns {"value": "...", "env": "sudo", "org": "ehmpathy"}')
      sothat('automation can parse the response with full context')

given('a sudo credential is NOT unlocked')
  when('they run: rhx keyrack get --key X --env sudo')
    then('keyrack returns error: "sudo credential X is locked. run: rhx keyrack unlock --env sudo --key X"')
      sothat('users know exactly how to unlock')

given('a sudo credential TTL has expired')
  when('they run: rhx keyrack get --key X --env sudo')
    then('keyrack returns error: "sudo credential X expired. run: rhx keyrack unlock --env sudo --key X"')
      sothat('expired credentials fail fast')
```

## usecase.4 = regular credentials unchanged

```
given('a human with keyrack configured')
  when('they run: rhx keyrack set --key Y --org @this --env all --vault 1password')
    then('keyrack stores the key config in keyrack.host.age')
    then('keyrack ALSO adds the key to keyrack.yml')
      sothat('regular credentials are visible to the codebase')

  when('they run: rhx keyrack unlock --for repo')
    then('keyrack bulk-unlocks all regular credentials (--env all)')
    then('keyrack stores credentials in daemon with 9h TTL')
      sothat('regular credentials have longer session lifetime')

  when('they run: rhx keyrack get --key Y')
    then('keyrack returns the credential (--env all is default)')
```

## usecase.5 = cross-org credentials

```
given('a human with a cross-org sudo credential')
  when('they run: rhx keyrack set --key Z --org @all --env sudo --vault 1password')
    then('keyrack stores the key with org: @all')
      sothat('the credential is available across all orgs')

  when('they run: rhx keyrack get --key Z --env sudo (without --org)')
    then('keyrack returns error: "key Z not found for org @this"')
      sothat('cross-org credentials require explicit --org @all')

  when('they run: rhx keyrack get --key Z --env sudo --org @all')
    then('keyrack returns the credential')
      sothat('explicit org flag grants access')
```

## usecase.6 = recipient-key-based manifest encryption

```
given('a fresh machine with no keyrack.host.age')
  when('they run: rhx keyrack init')
    then('keyrack finds default ssh key (~/.ssh/id_ed25519 or similar)')
    then('keyrack creates keyrack.host.age encrypted to that ssh key')
    then('keyrack records the recipient pubkey in the manifest')
      sothat('future unlocks use the same recipient')

  when('they run: rhx keyrack init --pubkey "ssh-ed25519 AAAA..."')
    then('keyrack uses the explicit pubkey value (type inferred from prefix)')
    then('keyrack creates keyrack.host.age encrypted to that key')
      sothat('user can specify exact pubkey')

  when('they run: rhx keyrack init --pubkey ~/.ssh/id_ed25519_work')
    then('keyrack extracts pubkey from the private key path')
    then('keyrack creates keyrack.host.age encrypted to that key')
      sothat('user can use non-default ssh key')

  when('they run: rhx keyrack init --pubkey ~/.ssh/id_ed25519_work.pub')
    then('keyrack reads pubkey from the .pub file')
    then('keyrack creates keyrack.host.age encrypted to that key')
      sothat('user can point directly to pubkey file')

  when('they run: rhx keyrack init --via yubikey')
    then('keyrack runs age-plugin-yubikey to get recipient pubkey')
    then('keyrack creates keyrack.host.age encrypted to yubikey')
      sothat('unlock requires physical touch')

  when('they run: rhx keyrack init (no ssh key found)')
    then('keyrack returns error with instructions to create ssh key or use --pubkey')
      sothat('user knows how to proceed')

given('keyrack.host.age exists')
  when('any keyrack command needs host manifest')
    then('keyrack decrypts via recipient key in ssh-agent or yubikey')
    then('keyrack decrypts into memory only')
    then('keyrack never writes plaintext manifest to disk')
      sothat('credential metadata is always encrypted at rest')
```

## usecase.7 = recipient management

```
given('keyrack is initialized with a recipient')
  when('they run: rhx keyrack recipient set --pubkey "ssh-ed25519 AAAA... backup"')
    then('keyrack re-encrypts manifest to include new recipient')
    then('both recipients can now decrypt the manifest')
      sothat('backup keys and multi-machine access work')

  when('they run: rhx keyrack recipient get')
    then('keyrack shows all recipients that can decrypt manifest')
      sothat('user can audit who has access')

  when('they run: rhx keyrack recipient del --label "old-laptop"')
    then('keyrack re-encrypts manifest WITHOUT that recipient')
      sothat('revoked keys can no longer decrypt')
```

## usecase.8 = status and relock

```
given('sudo credentials are unlocked')
  when('they run: rhx keyrack status')
    then('keyrack shows unlocked keys with env (all vs sudo) and expiry time')
    then('keyrack shows recipient key info')

  when('they run: rhx keyrack relock')
    then('keyrack purges ALL credentials from daemon (--all is default)')
      sothat('bare relock is the most extreme/safest option')

  when('they run: rhx keyrack relock --all')
    then('keyrack purges ALL credentials from daemon')
      sothat('explicit --all behaves same as default')

  when('they run: rhx keyrack relock --env sudo')
    then('keyrack purges all sudo credentials from daemon')
    then('keyrack retains regular credentials')
      sothat('selective relock is possible')

  when('they run: rhx keyrack relock --env sudo --key X')
    then('keyrack purges only key X from daemon')
      sothat('granular relock is possible')
```

## usecase.9 = os.secure vault with recipient keys

```
given('a human sets a key with os.secure vault')
  when('they run: rhx keyrack set --key X --env sudo --vault os.secure')
    then('keyrack encrypts the credential to the same recipient as the manifest')
      sothat('unlock is seamless with a single recipient key')

  when('they run: rhx keyrack set --key X --env sudo --vault os.secure --vault-recipient "ssh-ed25519 AAAA..."')
    then('keyrack encrypts the credential to the specified recipient')
    then('keyrack stores the vault recipient pubkey in the KeyrackKeyHost')
      sothat('user can use a different key for high-value credentials')

given('an os.secure key with same recipient as manifest')
  when('they run: rhx keyrack unlock --env sudo --key X')
    then('keyrack decrypts manifest with recipient key')
    then('keyrack decrypts os.secure vault with same recipient key')
    then('no additional prompts needed')
      sothat('unlock is seamless')

given('an os.secure key with different recipient')
  when('they run: rhx keyrack unlock --env sudo --key X')
    then('keyrack decrypts manifest with manifest recipient key')
    then('keyrack decrypts os.secure vault with vault recipient key')
      sothat('user with both keys can access')

  when('vault recipient key is not available (not in ssh-agent, yubikey not present)')
    then('keyrack returns error: "recipient key for os.secure vault not available"')
      sothat('user knows to make the key available')
```

## usecase.10 = attack surface reduction

```
given('keyrack daemon is started')
  when('daemon creates socket file')
    then('socket permissions are 0600 (owner-only)')
      sothat('other users on machine cannot access daemon')

given('recipient key requires touch (yubikey)')
  when('keyrack needs to decrypt manifest')
    then('keyrack prompts: "touch yubikey to unlock"')
      sothat('physical presence is required')
```

## usecase.11 = per-owner isolation

```
given('multiple robots on one machine')
  when('they run: rhx keyrack init --for mechanic --via ssh --pubkey ~/.ssh/id_ed25519_mechanic')
    then('keyrack creates keyrack.host.mechanic.age encrypted to mechanic key')
    then('keyrack uses daemon socket /tmp/keyrack.daemon.mechanic.sock')
      sothat('mechanic has isolated manifest and daemon')

  when('they run: rhx keyrack init --for foreman --via ssh --pubkey ~/.ssh/id_ed25519_foreman')
    then('keyrack creates keyrack.host.foreman.age encrypted to foreman key')
    then('keyrack uses daemon socket /tmp/keyrack.daemon.foreman.sock')
      sothat('foreman has isolated manifest and daemon')

given('mechanic and foreman each have their own keyrack')
  when('mechanic runs: rhx keyrack set --for mechanic --key GITHUB_TOKEN --env sudo --vault 1password')
    then('keyrack stores in keyrack.host.mechanic.age only')
      sothat('foreman cannot see mechanic credentials')

  when('foreman runs: rhx keyrack set --for foreman --key GITHUB_TOKEN --env sudo --vault 1password')
    then('keyrack stores in keyrack.host.foreman.age only')
      sothat('mechanic cannot see foreman credentials')

  when('mechanic runs: rhx keyrack get --for mechanic --key GITHUB_TOKEN --env sudo')
    then('keyrack queries mechanic daemon socket')
    then('keyrack returns mechanic GITHUB_TOKEN')

  when('mechanic tries: rhx keyrack get --for foreman --key GITHUB_TOKEN --env sudo')
    then('keyrack cannot decrypt foreman manifest (wrong key)')
      sothat('cross-owner access is impossible')

given('no --for flag specified')
  when('they run: rhx keyrack init')
    then('keyrack creates keyrack.host.age (no owner suffix)')
    then('keyrack uses daemon socket /tmp/keyrack.daemon.sock (no owner suffix)')
      sothat('default case remains simple')

  when('they run: rhx keyrack set --key X --env sudo --vault 1password')
    then('keyrack stores in keyrack.host.age')
      sothat('default manifest is used when no --for specified')

  when('they run: rhx keyrack get --key X --env sudo')
    then('keyrack queries default daemon socket')
      sothat('default daemon is used when no --for specified')
```

## usecase.12 = cipher-aware encrypt path (stanza match guarantee)

```
given('a fresh machine with a PASSWORDLESS ssh key (cipher: none)')
  when('they run: rhx keyrack init')
    then('keyrack detects cipher field is "none"')
    then('keyrack converts ssh pubkey to native age recipient: "age1..."')
    then('keyrack stores recipient with mech: "age" and pubkey: "age1..."')
      sothat('the npm age-encryption library can encrypt AND decrypt without age CLI')
    then('keyrack encrypts manifest via npm library (produces X25519 stanza)')
    then('the age CLI binary is NOT required at any point')
      sothat('CI machines and robots with passwordless keys never need age CLI installed')

  when('they later run: rhx keyrack unlock --env sudo --key X')
    then('keyrack decrypts manifest via npm library (AGE-SECRET-KEY matches X25519 stanza)')
    then('the age CLI binary is NOT invoked')
      sothat('passwordless key decrypt path stays pure node.js')

given('a fresh machine with a PASSPHRASE-PROTECTED ssh key (cipher: aes256-ctr)')
  when('they run: rhx keyrack init')
    then('keyrack detects cipher field is "aes256-ctr"')
    then('keyrack stores recipient with mech: "ssh" and pubkey: "ssh-ed25519 AAAA..."')
      sothat('the age CLI can encrypt AND decrypt with matched stanza type')
    then('keyrack encrypts manifest via age CLI (produces ssh-ed25519 stanza)')
    then('the age CLI binary IS required')
      sothat('ssh-agent can handle passphrase unlock transparently')

  when('age CLI is not installed')
    then('keyrack returns error with install instructions')
      sothat('user knows exactly what to install and why')

  when('they later run: rhx keyrack unlock --env sudo --key X')
    then('keyrack decrypts manifest via age CLI (ssh identity matches ssh-ed25519 stanza)')
    then('no passphrase prompt appears (ssh-agent handles it)')
      sothat('unlock is seamless despite passphrase-protected key')

given('a user who plans to add a passphrase to a PASSWORDLESS key (prevention path)')
  when('they run: rhx keyrack recipient set --pubkey ~/.ssh/id_ed25519.pub --stanza ssh BEFORE ssh-keygen -p')
    then('--stanza ssh overrides cipher-aware conversion (key is passwordless but ssh-ed25519 format forced)')
    then('keyrack re-encrypts manifest to BOTH age1... AND ssh-ed25519 stanzas')
      sothat('the manifest is decryptable by either stanza type')

  when('they then run: ssh-keygen -p (add passphrase)')
    then('the manifest already has an ssh-ed25519 stanza')
    then('age CLI matches the ssh-ed25519 stanza â€” no mismatch')
    then('all keyrack commands work without re-init')
      sothat('prevention via multi-recipient is seamless and lossless')

  when('they clean up the stale age1... recipient')
    then('rhx keyrack recipient del --label "default" removes the old recipient')
    then('re-encrypts manifest with only the ssh-ed25519 recipient')
      sothat('the manifest is clean with a single matched recipient')

given('a user who ALREADY ran ssh-keygen -p without the prevention step (recovery path)')
  when('they run any keyrack command that decrypts the manifest')
    then('keyrack detects stanza mismatch: manifest has X25519 stanza but key now requires ssh-ed25519')
    then('keyrack returns error with recovery instructions:')
    then('  step 1: ssh-keygen -p -f ~/.ssh/id_ed25519 (remove passphrase temporarily)')
    then('  step 2: rhx keyrack recipient set --pubkey ~/.ssh/id_ed25519.pub --stanza ssh')
    then('  step 3: ssh-keygen -p -f ~/.ssh/id_ed25519 (restore passphrase)')
    then('  step 4: rhx keyrack recipient del --label "default"')
      sothat('the user recovers without data loss via temporary passphrase removal')

  when('they follow the 4-step recovery')
    then('all manifest hosts and recipients are preserved')
    then('no keyrack set commands need to be re-run')
      sothat('recovery is lossless')

given('a manifest with MULTIPLE recipients of DIFFERENT types')
  when('manifest has both age1... and ssh-ed25519... recipients')
    then('keyrack encrypts to BOTH recipient types')
    then('age1... recipient produces X25519 stanza (npm library)')
    then('ssh-ed25519... recipient produces ssh-ed25519 stanza (age CLI)')
      sothat('each recipient can decrypt with its own matched stanza type')

given('the encrypt path dispatches by pubkey prefix')
  when('recipient.pubkey starts with "age1"')
    then('keyrack uses npm age-encryption library for encrypt')
      sothat('no external binary needed for native age recipients')

  when('recipient.pubkey starts with "ssh-"')
    then('keyrack shells out to age CLI for encrypt')
      sothat('ssh-ed25519 stanzas are produced that match ssh key identities')
```
