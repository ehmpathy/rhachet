# criteria coverage gap analysis

## summary

analysis of acceptance test coverage against blackbox criteria (2.1.criteria.blackbox.md).

| usecase | coverage | gaps |
|---------|----------|------|
| usecase.1 (set sudo) | ğŸŸ¡ partial | findsert idempotency not tested |
| usecase.2 (unlock sudo) | ğŸ”´ low | duration, TTL, key-not-found not tested |
| usecase.3 (get sudo) | ğŸ”´ low | locked/expired error messages noted as known gaps |
| usecase.4 (regular creds) | ğŸŸ¢ good | covered in keyrack.envs |
| usecase.5 (cross-org) | ğŸŸ¡ partial | get --org @all not fully tested |
| usecase.6 (recipient-key manifest) | ğŸ”´ critical | **ssh key flow not implemented**; uses age keypair; CLI lacks --pubkey/--via |
| usecase.7 (recipient mgmt) | ğŸŸ¡ partial | only age1... pubkeys accepted; ssh keys rejected |
| usecase.8 (status/relock) | ğŸ”´ low | env filter not tested; **status lacks recipient info** |
| usecase.9 (os.secure vault) | ğŸ”´ critical | **uses passphrase, not recipient keys** |
| usecase.10 (attack surface) | ğŸŸ¢ implemented | socket 0600 verified in code |
| usecase.11 (per-owner) | ğŸ”´ low | **CLI --for is scope not owner**; list ignores --for |

**total divergences: 15** (10 from initial analysis + 5 from deeper investigation)

---

## critical implementation divergences

### divergence.1: ssh key init vs age keypair (usecase.6)

**criteria specifies:**
```
rhx keyrack init
â†’ finds ~/.ssh/id_ed25519 (or similar)
â†’ creates keyrack.host.age encrypted to that ssh key
```

**implementation does:**
```ts
// initKeyrack.ts:89
const { identity, recipient } = await generateAgeKeyPair();
```

**impact:**
- criteria vision: use developer's extant ssh keys (no new key management)
- implementation: creates new age keypair (requires managed another key)
- ageRecipientCrypto.ts:28-34 explicitly throws error for non-age mechs:
  ```ts
  if (recipient.mech === 'age') {
    encrypter.addRecipient(recipient.pubkey);
  } else {
    throw new UnexpectedCodePathError(
      `recipient mech '${recipient.mech}' not yet supported; use 'age' mech`,
      { recipient },
    );
  }
  ```

**decision needed:** update criteria to match implementation, or implement ssh key discovery

---

### divergence.2: os.secure uses passphrase, not recipient keys (usecase.9)

**criteria specifies:**
```
rhx keyrack set --key X --env sudo --vault os.secure
â†’ keyrack encrypts the credential to the same recipient as the manifest

rhx keyrack set --key X --env sudo --vault os.secure --vault-recipient "ssh-ed25519 AAAA..."
â†’ keyrack encrypts the credential to the specified recipient
```

**implementation does:**
```ts
// vaultAdapterOsSecure.ts:157-158
const encrypter = new Encrypter();
encrypter.setPassphrase(passphrase);  // â† passphrase, NOT recipient key
```

**impact:**
- criteria vision: seamless unlock when os.secure uses same recipient as manifest
- implementation: requires separate passphrase prompt for os.secure vault
- vaultRecipient field exists in KeyrackKeyHost but is NOT used by vaultAdapterOsSecure

**decision needed:** implement recipient-key-based os.secure, or update criteria

---

### divergence.3: unlockKeyrack bug for sudo keys

**criteria specifies:**
```
rhx keyrack unlock --env sudo --key X
â†’ decrypts manifest, finds key, fetches from vault, stores in daemon
```

**implementation has bug:**
```ts
// unlockKeyrack.ts:86-94
for (const slug of slugsForEnv) {
  const spec = repoManifest.keys[slug];  // â† looks in REPO manifest
  if (!spec) continue;                    // â† sudo keys NOT in repo manifest!
  // ...
}
```

**impact:**
- sudo keys are stored ONLY in host manifest (by design)
- unlockKeyrack looks for spec in repoManifest.keys
- sudo keys will be skipped because they don't exist in repo manifest
- this is likely why tests use direct value env vars instead of unlock flow

---

### divergence.4: maxDuration cap not implemented (usecase.2)

**criteria specifies:**
```
when('they run: rhx keyrack unlock --env sudo --key X --duration 2h (exceeds maxDuration of 1h)')
  then('keyrack warns that duration exceeds maxDuration')
  then('keyrack caps TTL to maxDuration (1h)')
```

**implementation does NOT check maxDuration:**
```ts
// unlockKeyrack.ts:49-52
const defaultDuration = input.env === 'sudo' ? '30m' : '9h';
const durationMs = parseDuration(input.duration ?? defaultDuration);
const expiresAt = Date.now() + durationMs;
// â† no check for hostConfig.maxDuration
```

---

### divergence.5: getKeyrackKeyGrant checks repo manifest FIRST (usecase.3)

**criteria specifies:**
```
rhx keyrack get --key X --env sudo
â†’ queries daemon for unlocked credential
â†’ if not unlocked: returns "locked" error
```

**implementation has fundamental flaw:**
```ts
// getKeyrackKeyGrant.ts:70-79
const keySpec = context.repoManifest?.keys[slug];
if (!keySpec) {
  return {
    status: 'absent',  // â† returns 'absent' immediately!
    slug,
    message: `key '${slug}' not found in repo manifest`,
    fix: `add '${slug}' to .agent/keyrack.yml`,
  };
}
// daemon check at line 131 is NEVER reached for sudo keys
```

**impact:**
- sudo keys are NOT in repo manifest (by design)
- getKeyrackKeyGrant checks repo manifest FIRST (lines 70-79)
- returns 'absent' before ever check of daemon or host manifest
- sudo keys ALWAYS show as "absent" even when unlocked in daemon
- this is the root cause of the "locked vs absent" gap in usecase.3

**evidence from acceptance tests:**
```ts
// keyrack.sudo.acceptance.test.ts:700-702
// .note = current implementation shows sudo keys as "absent" when not in keyrack.yml
//         this is a gap: sudo keys should show as "locked" when in host manifest but not unlocked

// keyrack.sudo.acceptance.test.ts:784-786
// gap: sudo keys unlocked should show granted, but get looks at keyrack.yml first
```

---

### divergence.6: context generators miss owner param

**criteria specifies:**
- per-owner isolation: each owner has separate manifest
- `--for mechanic` uses `keyrack.host.mechanic.age`

**implementation misses owner param:**
```ts
// genKeyrackGrantContext.ts:40
const hostManifest =
  (await daoKeyrackHostManifest.get({})) ??  // â† empty input, no owner param
  new KeyrackHostManifest({...});

// genKeyrackHostContext.ts:32
const hostManifest =
  (await daoKeyrackHostManifest.get({})) ??  // â† same pattern, empty input
  new KeyrackHostManifest({...});
```

**impact:**
- context always loads default manifest (no owner suffix)
- owner param accepted at DAO level but never passed by context generators
- per-owner isolation may be incomplete in grant flow

---

### divergence.7: setKeyrackKeyHost misses keyrack.yml write

**criteria specifies:**
```
rhx keyrack set --key Y --org @this --env all --vault 1password
â†’ stores key config in keyrack.host.age
â†’ ALSO adds key to keyrack.yml
```

**implementation comment vs code:**
```ts
// setKeyrackKeyHost.ts:17-18 (comment)
// .note = sudo credentials (env=sudo) stored only in host manifest
// .note = regular credentials stored in host manifest AND keyrack.yml

// setKeyrackKeyHost.ts:95 (actual code)
await daoKeyrackHostManifest.set({ upsert: manifestUpdated });
// â† ONLY writes to hostManifest
// â† NEVER writes to keyrack.yml, even for regular credentials!
```

**impact:**
- regular credentials (env !== sudo) should appear in keyrack.yml
- code only writes to host manifest for ALL credentials
- keyrack.yml never updated by set command

---

### divergence.8: vaultAdapterOsDaemon hardcodes env/org

**criteria specifies:**
- daemon stores credentials with env and org metadata
- env filter on relock purges only matched env

**implementation hardcodes values:**
```ts
// vaultAdapterOsDaemon.ts:75-85
await daemonAccessUnlock({
  keys: [
    {
      slug: input.slug,
      key: { secret: input.value, grade },
      env: 'all',   // â† HARDCODED, not from input
      org: '@all',  // â† HARDCODED, not from input
      expiresAt,
    },
  ],
});
```

**impact:**
- credentials stored via os.daemon vault lose their actual env/org
- all daemon-stored credentials appear as env='all', org='@all'
- env filter on relock may not work correctly for daemon credentials

---

### divergence.9: daemonAccessGet not passed socketPath for owner isolation

**criteria specifies:**
- each owner has separate daemon socket
- `--for mechanic` queries `keyrack.daemon.mechanic.sock`

**implementation:**
```ts
// getKeyrackKeyGrant.ts:131
const daemonResult = await daemonAccessGet({ slugs: [slug] });
// â† no socketPath param, no owner route

// daemonAccessGet.ts:14-17 (signature accepts socketPath)
export const daemonAccessGet = async (input: {
  slugs: string[];
  socketPath?: string;  // â† optional param exists but caller doesn't use it
}): Promise<...>
```

**impact:**
- getKeyrackKeyGrant always queries default daemon socket
- owner-specific credentials in owner-specific daemons are unreachable
- per-owner isolation incomplete in grant flow

---

### divergence.10: --org flag absent on CLI get command

**criteria specifies:**
```
rhx keyrack get --key Z --env sudo --org @all
â†’ returns cross-org credential
```

**implementation gap:**
```ts
// keyrack.sudo.acceptance.test.ts:903-904
// .note = --org flag is only on `set`, not on `get` (gap in CLI)
//         tests focus on set behavior with @all
```

**impact:**
- cross-org credentials cannot be retrieved via `--org @all` flag
- acceptance test documents this as known gap

---

### divergence.11: setKeyrackRecipient only supports age1... pubkeys

**criteria specifies:**
```
rhx keyrack recipient set --pubkey "ssh-ed25519 AAAA... backup"
â†’ adds recipient, re-encrypts manifest to include new recipient

rhx keyrack init --pubkey ~/.ssh/id_ed25519_work
â†’ extracts pubkey from private key path

rhx keyrack init --pubkey ~/.ssh/id_ed25519_work.pub
â†’ reads pubkey from .pub file
```

**implementation rejects ssh keys:**
```ts
// recipient/setKeyrackRecipient.ts:62-66
const pubkey = input.pubkey.trim();
if (!pubkey.startsWith('age1'))
  throw new BadRequestError(
    'only age pubkeys (age1...) are supported; ssh key support planned',
    { pubkey },
  );
```

**impact:**
- criteria vision: use developer's extant ssh keys
- implementation: only accepts age1... pubkeys
- `.pub` file paths and private key paths are NOT supported
- this is consistent with divergence.1 (age keypair vs ssh key init)

---

### divergence.12: CLI init lacks --pubkey and --via yubikey options

**criteria specifies:**
```
rhx keyrack init --pubkey "ssh-ed25519 AAAA..."
â†’ uses explicit pubkey value

rhx keyrack init --pubkey ~/.ssh/id_ed25519_work
â†’ extracts pubkey from private key

rhx keyrack init --via yubikey
â†’ runs age-plugin-yubikey to discover pubkey
```

**CLI only exposes --for and --label:**
```ts
// invokeKeyrack.ts:36-86
keyrackProg
  .command('init')
  .description('initialize keyrack with an age keypair')
  .option('--for <owner>', 'specify owner (e.g., mechanic, foreman)')
  .option('--label <label>', 'label for the recipient (default: auto-generated)')
  .option('--json', 'output as JSON')
  // â† NOT PRESENT: --pubkey, --via yubikey
```

**impact:**
- users cannot specify custom pubkey at CLI level
- yubikey integration not exposed
- initKeyrack.ts signature (lines 29-31) only accepts owner and label

---

### divergence.13: CLI get --for is scope, not owner isolation

**criteria specifies:**
```
rhx keyrack get --for mechanic --key GITHUB_TOKEN --env sudo
â†’ queries mechanic daemon socket
â†’ returns mechanic GITHUB_TOKEN
```

**implementation uses --for as scope:**
```ts
// invokeKeyrack.ts:190-223
keyrackProg
  .command('get')
  .description('get a secret from keyrack')
  .option('--for <scope>', 'scope: "repo" (default) or "host"')  // â† scope, NOT owner
  // ...

// invokeKeyrack.ts:231-239
if (opts.for === 'repo') {
  // use repo manifest
} else if (opts.for === 'host') {
  // use host manifest (but still default owner)
}
```

**impact:**
- criteria: `--for mechanic` means owner isolation
- implementation: `--for repo` vs `--for host` is scope selection
- per-owner get isolation not available via CLI
- only KEYRACK_OWNER env var provides owner context

---

### divergence.14: CLI list ignores --for owner flag

**criteria specifies:**
```
rhx keyrack list --for mechanic
â†’ lists keys from mechanic's manifest
```

**CLI accepts --for but does NOT pass it:**
```ts
// invokeKeyrack.ts:616-655
keyrackProg
  .command('list')
  .option('--for <owner>', 'specify owner')  // â† accepts flag
  .action(async (opts) => {
    // ...
    const context = await genKeyrackHostContext();  // â† does NOT pass opts.for
    // ...
  });
```

**impact:**
- CLI accepts --for flag but ignores it
- genKeyrackHostContext() called without owner param
- always loads default manifest regardless of --for flag

---

### divergence.15: getKeyrackStatus lacks recipient info

**criteria specifies:**
```
rhx keyrack status
â†’ shows recipient key info
â†’ shows unlocked credentials with TTL left
â†’ shows daemon socket status
```

**implementation only returns key info:**
```ts
// getKeyrackStatus.ts:31-38
return {
  keys: result.keys.map((k) => ({
    slug: k.slug,
    env: k.env,
    org: k.org,
    expiresAt: k.expiresAt,
    ttlLeftMs: k.ttlLeftMs,
  })),
  // â† NOT PRESENT: recipient info
  // â† NOT PRESENT: daemon socket status
};
```

**impact:**
- criteria says "shows recipient key info"
- implementation only shows unlocked keys
- users cannot see which recipients can decrypt their manifest
- daemon socket status not included

---

## detailed gaps by usecase

### usecase.1 = set sudo credential

**covered:**
- `set --key X --env sudo --vault` (keyrack.sudo case1 t0, t1)
- `set --org @all` stores with org @all (case1 t2, case12)
- `set --org invalid` returns error (case3 t0)
- `set --max-duration` (case1 t3)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| findsert semantics (duplicate returns prior) | âŒ | not explicitly tested |
| prompts for vault-specific config | âš ï¸ | not testable in automated blackbox |

---

### usecase.2 = unlock sudo credential

**covered:**
- `unlock --env sudo` without `--key` fails (case2 t0)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| `unlock --env sudo --key X` stores with 30min TTL | âŒ | TTL not verified |
| `unlock --env sudo --key X --duration 1h` | âŒ | custom duration not tested |
| duration exceeds maxDuration caps TTL + warns | âŒ | **not implemented** |
| key not configured returns specific error | âŒ | not tested |
| returns success with expiry time | âŒ | not verified |
| 30min TTL for sudo vs 9h for regular | âš ï¸ | implemented but not verified in tests |

---

### usecase.3 = get sudo credential

**covered:**
- get returns credential value (case10)
- get --json returns env/org fields (implicitly)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| get when not unlocked returns "locked" error | ğŸ”´ | **bug: shows "absent"** |
| get when TTL expired returns "expired" error | âš ï¸ | known gap: not distinguish states |
| error message includes unlock command hint | âŒ | not verified |

**root cause identified:**
```ts
// getKeyrackKeyGrant.ts:70-78
const repoSpec = input.repoManifest?.keys[input.slug] ?? null;
if (!repoSpec) {
  return {
    status: 'absent',  // â† returns 'absent' for sudo keys
    // ...
  };
}
```

sudo keys are NOT in repo manifest (by design), so they always return 'absent' instead of check of host manifest and daemon.

---

### usecase.4 = regular credentials unchanged

**covered:**
- set --env all stores in both manifest and keyrack.yml (keyrack.envs)
- unlock --for repo bulk unlocks (keyrack.envs)
- get without --env defaults to all (implicit)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| 9h TTL explicitly verified | âš ï¸ | implemented but not asserted in tests |

---

### usecase.5 = cross-org credentials

**covered:**
- set --org @all stores with org @all (case1 t2, case12 t0)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| get --key Z --env sudo (without --org) returns error | âš ï¸ | case12 t2 shows "0 keys" not specific error |
| get --key Z --env sudo --org @all returns credential | âŒ | not tested |

---

### usecase.6 = recipient-key-based manifest encryption

**implementation divergence:** criteria specifies ssh-key-based init, but implementation uses age keypair generation.

| criterion | status | notes |
|-----------|--------|-------|
| init finds default ssh key (~/.ssh/id_ed25519) | ğŸ”´ | **not implemented**; uses age keygen |
| init --pubkey "ssh-ed25519 AAAA..." | ğŸ”´ | **not implemented** |
| init --pubkey ~/.ssh/id_ed25519_work | ğŸ”´ | **not implemented** |
| init --pubkey ~/.ssh/id_ed25519_work.pub | ğŸ”´ | **not implemented** |
| init --via yubikey | ğŸ”´ | **not implemented** |
| init with no ssh key returns error with instructions | âŒ | not applicable (uses age keygen) |
| decrypts via recipient key in ssh-agent | ğŸ”´ | **not implemented**; uses KEYRACK_IDENTITY env var |
| never writes plaintext manifest to disk | âš ï¸ | assumed true but not tested |

**code evidence:**
```ts
// initKeyrack.ts â€” uses age, not ssh
const { identity, recipient } = await generateAgeKeyPair();

// ageRecipientCrypto.ts â€” explicitly rejects non-age mechs
if (recipient.mech === 'age') {
  encrypter.addRecipient(recipient.pubkey);
} else {
  throw new UnexpectedCodePathError(
    `recipient mech '${recipient.mech}' not yet supported; use 'age' mech`,
```

---

### usecase.7 = recipient management

**covered:**
- recipient set --pubkey adds recipient (case1 t1)
- recipient get shows all recipients (case1 t0, t2, t4)
- recipient del removes recipient (case1 t3)
- duplicate label error (case2 t0)
- delete last recipient error (case2 t1)
- delete non-existent label error (case2 t2)
- invalid pubkey error (case2 t3)
- per-owner recipient management (case3)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| both recipients can decrypt after add | âš ï¸ | re-encryption tested but not decryption verification |
| recipient set --pubkey "ssh-ed25519..." | ğŸ”´ | **not implemented**; only age1... pubkeys accepted |
| recipient from .pub file path | ğŸ”´ | **not implemented**; path resolution not supported |
| recipient from private key path | ğŸ”´ | **not implemented**; pubkey extraction not supported |

**code evidence:**
```ts
// recipient/setKeyrackRecipient.ts:62-66
if (!pubkey.startsWith('age1'))
  throw new BadRequestError(
    'only age pubkeys (age1...) are supported; ssh key support planned',
    { pubkey },
  );
```

---

### usecase.8 = status and relock

**covered:**
- status output (case5 t0, t1)
- bare relock purges ALL (case4 t0)
- relock --json (case4 t1)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| status shows recipient key info | ğŸ”´ | **not implemented**; getKeyrackStatus returns keys only |
| status shows daemon socket status | âŒ | not implemented |
| relock --env sudo purges only sudo keys | âŒ | **not tested at acceptance layer** |
| relock --env sudo --key X purges specific key | âŒ | not tested |
| relock retains regular credentials when env filtered | âŒ | not tested |

**code evidence (status):**
```ts
// getKeyrackStatus.ts:31-38 â€” only returns keys, not recipients
return {
  keys: result.keys.map((k) => ({
    slug: k.slug,
    env: k.env,
    org: k.org,
    expiresAt: k.expiresAt,
    ttlLeftMs: k.ttlLeftMs,
  })),
  // recipient info NOT included
};
```

**note:** relock env filter IS implemented and unit tested in handleCommands.test.ts:279-351, but no acceptance test coverage.

---

### usecase.9 = os.secure vault with recipient keys

**critical divergence:** criteria specifies recipient-key-based encryption, but implementation uses passphrase.

| criterion | status | notes |
|-----------|--------|-------|
| set --vault os.secure encrypts to manifest recipient | ğŸ”´ | **not implemented**; uses passphrase |
| set --vault os.secure --vault-recipient stores recipient | ğŸ”´ | field exists but not used |
| unlock os.secure with same recipient is seamless | ğŸ”´ | **not implemented** |
| unlock os.secure with different recipient requires both keys | ğŸ”´ | **not implemented** |
| vault recipient not available returns specific error | ğŸ”´ | **not implemented** |

**code evidence:**
```ts
// vaultAdapterOsSecure.ts:157-158
const encrypter = new Encrypter();
encrypter.setPassphrase(passphrase);  // â† passphrase, NOT recipient
```

---

### usecase.10 = attack surface reduction

**covered at implementation level:**

| criterion | status | notes |
|-----------|--------|-------|
| socket permissions are 0600 | âœ… | `chmodSync(socketPath, 0o600)` in createKeyrackDaemonServer.ts |
| yubikey prompts for touch | âš ï¸ | not testable; yubikey not implemented |

---

### usecase.11 = per-owner isolation

**covered:**
- init --for mechanic creates keyrack.host.mechanic.age (keyrack.init case2 t0)
- init --for foreman creates separate manifest (case2 t1)
- set with KEYRACK_OWNER stores in owner manifest (keyrack.sudo case7 t0)
- status --for mechanic (case7 t1)
- relock --for mechanic (case7 t2)
- no --for uses default (keyrack.init case1)

**gaps:**
| criterion | status | notes |
|-----------|--------|-------|
| daemon socket path includes owner | âœ… | verified: `$XDG_RUNTIME_DIR/keyrack.$SESSIONID.$owner.sock` |
| cross-owner access is impossible | âŒ | not tested; criteria says "mechanic cannot decrypt foreman manifest" |
| mechanic cannot see foreman credentials | âŒ | not tested |
| `get --for mechanic` queries mechanic daemon | ğŸ”´ | **not implemented**; CLI --for is scope (repo/host), not owner |
| `list --for mechanic` lists mechanic keys | ğŸ”´ | **not implemented**; CLI ignores --for param (line 624) |
| `unlock --for mechanic` unlocks in mechanic daemon | âš ï¸ | uses KEYRACK_OWNER env var, not CLI --for |

**code evidence:**
```ts
// invokeKeyrack.ts:190-223 â€” get uses --for as scope
.option('--for <scope>', 'scope: "repo" (default) or "host"')

// invokeKeyrack.ts:624 â€” list ignores opts.for
const context = await genKeyrackHostContext();  // â† no owner param
```

**workaround:** per-owner isolation currently requires KEYRACK_OWNER env var, not CLI --for flag

---

## priority recommendations

### critical (blocks criteria fulfillment)

1. **usecase.6 divergence**: criteria specifies ssh-key-based manifest encryption, but implementation uses age keypair. either:
   - update criteria to match implementation (age keypair is acceptable for v1)
   - or implement ssh key discovery flow (larger scope)

2. **usecase.9 divergence**: os.secure vault uses passphrase, not recipient keys. either:
   - update criteria to reflect passphrase-based os.secure
   - or implement recipient-key-based os.secure

3. **usecase.3 get states**: sudo keys show "absent" instead of "locked" or "expired". the bug is in getKeyrackKeyGrant.ts:70-78 â€” it checks repo manifest first, but sudo keys are only in host manifest.

4. **usecase.2 maxDuration**: duration cap to maxDuration is specified in criteria but not implemented.

5. **divergence.11-12: ssh key support absent**:
   - setKeyrackRecipient rejects all non-age1... pubkeys (recipient/setKeyrackRecipient.ts:62-66)
   - CLI init lacks --pubkey and --via yubikey options (invokeKeyrack.ts:36-86)
   - consistent with divergence.1, but worth consolidating as unified ssh key gap

6. **divergence.13-14: per-owner CLI gaps**:
   - CLI get --for is "repo" vs "host" scope, NOT owner isolation (invokeKeyrack.ts:190-239)
   - CLI list ignores --for owner flag entirely (invokeKeyrack.ts:624 â€” opts.for not passed)
   - per-owner isolation only available via KEYRACK_OWNER env var

### high (significant gaps)

7. **unlock TTL verification** (usecase.2): no tests verify that sudo uses 30min TTL vs 9h for regular
8. **relock env filter acceptance test** (usecase.8): implemented and unit tested, but no acceptance coverage for `relock --env sudo`
9. **cross-owner isolation** (usecase.11): no test verifies mechanic cannot access foreman's credentials
10. **divergence.15: status lacks recipient info**: getKeyrackStatus.ts returns keys only, not recipients (criteria says "shows recipient key info")

### medium (test coverage gaps)

11. **findsert idempotency** (usecase.1): set duplicate should return prior config
12. **cross-org get** (usecase.5): `get --org @all` flow not tested
13. **unlockKeyrack bug**: sudo keys skipped because unlockKeyrack checks repoManifest.keys

### low (nice to have)

14. **duration override** (usecase.2): `--duration` flag not tested
15. **recipient decryption verification** (usecase.7): multi-recipient decryption not verified

---

## implementation status summary

| feature | criteria | implemented | tested |
|---------|----------|-------------|--------|
| ssh key init | âœ“ | âœ— (uses age) | n/a |
| age keypair init | âœ— (not in criteria) | âœ“ | âœ“ |
| recipient management | âœ“ | âš ï¸ (age only) | âœ“ |
| ssh pubkey as recipient | âœ“ | âœ— (age1... only) | n/a |
| sudo env classification | âœ“ | âœ“ | âœ“ |
| 30min TTL for sudo | âœ“ | âœ“ | âœ— |
| maxDuration cap | âœ“ | âœ— | âœ— |
| os.secure with recipient | âœ“ | âœ— (uses passphrase) | n/a |
| vaultRecipient field | âœ“ | âœ“ (stored) | âœ— (not used) |
| relock env filter | âœ“ | âœ“ | unit only |
| socket 0600 | âœ“ | âœ“ | âœ— |
| per-owner manifest | âœ“ | âœ“ | âœ“ |
| per-owner daemon | âœ“ | âœ“ | partial |
| cross-owner block | âœ“ | âœ“ (implicit) | âœ— |
| sudo key unlock flow | âœ“ | âš ï¸ (bug) | âœ— |
| locked/expired states | âœ“ | âœ— (shows "absent") | n/a |
| CLI --pubkey option | âœ“ | âœ— | n/a |
| CLI --via yubikey | âœ“ | âœ— | n/a |
| CLI --for owner isolation | âœ“ | âœ— (is scope) | n/a |
| CLI list --for owner | âœ“ | âœ— (ignored) | n/a |
| status recipient info | âœ“ | âœ— | n/a |

**divergence count: 15**
