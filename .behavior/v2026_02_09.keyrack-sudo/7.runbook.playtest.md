# runbook: playtest keyrack sudo

## prereqs

```sh
# build the cli
npm run build

# ensure you have an ed25519 ssh key (let ssh-keygen prompt for a passphrase)
ls ~/.ssh/id_ed25519 || ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519

# ensure ssh-agent is active and key is loaded
ssh-add -l || eval $(ssh-agent) && ssh-add ~/.ssh/id_ed25519
```

---

## scenario 1: init keyrack with ssh key

```sh
# init with default ssh key (discovers ~/.ssh/id_ed25519 via ssh-agent)
./bin/run keyrack init

# verify manifest created
ls ~/.rhachet/keyrack/keyrack.host.age
```

expected: init finds the ssh key, converts to age recipient, creates encrypted manifest. no age key generation. no identity file — discovery happens at runtime via recipient match.

---

## scenario 2: init without ssh key (graceful error)

```sh
# temporarily hide ssh keys to test error path
HOME_BACKUP=$HOME
export HOME=$(mktemp -d)

./bin/run keyrack init
# expect: graceful error message with instructions:
#   no ssh key found. create one with:
#     ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519
#   then run: rhx keyrack init

export HOME=$HOME_BACKUP
```

---

## scenario 3: set a sudo credential

```sh
# set a sudo credential with os.secure vault (invisible to keyrack.yml)
# note: --mech is inferred from --vault (os.secure → PERMANENT_VIA_REPLICA)
# note: value is prompted via secure stdin (never passed as CLI arg)
./bin/run keyrack set \
  --key MY_SUDO_TOKEN \
  --env sudo \
  --vault os.secure
# expect: prompt "enter value for MY_SUDO_TOKEN: " (hidden input)
# type your secret value and press enter

# alternatively, pipe the value from a secure source
cat /path/to/secret.txt | ./bin/run keyrack set \
  --key MY_SUDO_TOKEN \
  --env sudo \
  --vault os.secure

# verify it's NOT in keyrack.yml
cat .agent/keyrack.yml | grep -i sudo
# expect: no matches (sudo keys are invisible to repo)

# list shows it in host manifest
./bin/run keyrack list --json | jq '.[] | select(.env == "sudo")'
```

---

## scenario 4: set a regular credential (comparison)

```sh
# set a regular credential (env=all) — this one CAN use os.direct
# note: --mech is inferred from --vault (os.direct → PERMANENT_VIA_REPLICA)
# note: value is prompted via secure stdin (never passed as CLI arg)
./bin/run keyrack set \
  --key MY_API_KEY \
  --env all \
  --vault os.direct
# expect: prompt "enter value for MY_API_KEY: " (hidden input)

# verify it IS in keyrack.yml
cat .agent/keyrack.yml | grep MY_API_KEY
# expect: the key appears in repo manifest
```

---

## scenario 5: unlock sudo requires --key

```sh
# try to unlock sudo without --key (should fail)
./bin/run keyrack unlock --env sudo
# expect: error "sudo credentials require --key flag"

# unlock sudo WITH --key (should succeed)
./bin/run keyrack unlock --env sudo --key MY_SUDO_TOKEN

# check status shows it unlocked
./bin/run keyrack status
```

---

## scenario 6: get sudo credential

```sh
# get the unlocked sudo credential
./bin/run keyrack get --key MY_SUDO_TOKEN --env sudo

# get with json output
./bin/run keyrack get --key MY_SUDO_TOKEN --env sudo --json
# expect: {"status": "granted", "grant": {..., "env": "sudo", "org": "..."}}
```

---

## scenario 7: get sudo credential WITHOUT unlock (should fail)

```sh
# relock first
./bin/run keyrack relock

# try to get without unlock
./bin/run keyrack get --key MY_SUDO_TOKEN --env sudo
# expect: "locked" status — credential requires unlock via daemon
# MUST NOT return "granted" from os.direct fallback cache
```

---

## scenario 8: relock behaviors

```sh
# unlock both regular and sudo keys
./bin/run keyrack unlock --env all
./bin/run keyrack unlock --env sudo --key MY_SUDO_TOKEN

# check status shows both
./bin/run keyrack status

# relock only sudo keys
./bin/run keyrack relock --env sudo

# status shows regular still unlocked, sudo gone
./bin/run keyrack status

# bare relock purges all keys
./bin/run keyrack relock
./bin/run keyrack status
# expect: no keys unlocked
```

---

## scenario 9: cross-org credential (@all)

```sh
# set a cross-org sudo credential
# value is prompted via secure stdin (never passed as CLI arg)
./bin/run keyrack set \
  --key CROSS_ORG_TOKEN \
  --env sudo \
  --org @all \
  --vault os.secure
# expect: prompt "enter value for CROSS_ORG_TOKEN: " (hidden input)

# list shows org: @all
./bin/run keyrack list --json | jq '.[] | select(.org == "@all")'

# unlock by full slug (includes @all)
./bin/run keyrack unlock --env sudo --key "@all.sudo.CROSS_ORG_TOKEN"
```

---

## scenario 10: per-owner isolation (robots)

```sh
# create a second ssh key for mechanic (no passphrase ok for robot keys)
ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519_mechanic

# init keyrack for mechanic
./bin/run keyrack init --for mechanic --pubkey ~/.ssh/id_ed25519_mechanic

# verify separate manifest
ls ~/.rhachet/keyrack/keyrack.host.mechanic.age

# set a credential for mechanic (value prompted via secure stdin)
./bin/run keyrack set \
  --for mechanic \
  --key MECHANIC_TOKEN \
  --env sudo \
  --vault os.secure
# expect: prompt "enter value for MECHANIC_TOKEN: " (hidden input)

# list for mechanic shows the key
./bin/run keyrack list --for mechanic --json

# list for default owner does NOT show mechanic's key
./bin/run keyrack list --json | grep MECHANIC_TOKEN
# expect: no matches (cross-owner isolation)
```

---

## scenario 11: max duration cap

```sh
# set a credential with max duration (value prompted via secure stdin)
./bin/run keyrack set \
  --key SHORT_LIVED_TOKEN \
  --env sudo \
  --vault os.secure \
  --max-duration 5m
# expect: prompt "enter value for SHORT_LIVED_TOKEN: " (hidden input)

# unlock with duration longer than max (gets capped)
./bin/run keyrack unlock --env sudo --key SHORT_LIVED_TOKEN --duration 1h
# expect: duration capped to 5m (warn emitted)

# status shows 5m expiry (not 1h)
./bin/run keyrack status
```

---

## scenario 12: os.secure vault with vault-recipient

```sh
# set credential with os.secure vault (uses manifest recipient by default)
# value prompted via secure stdin (never passed as CLI arg)
./bin/run keyrack set \
  --key SECURE_TOKEN \
  --env sudo \
  --vault os.secure
# expect: prompt "enter value for SECURE_TOKEN: " (hidden input)

# verify .age file created
ls ~/.rhachet/keyrack.secure/

# unlock and get (seamless - same recipient as manifest)
./bin/run keyrack unlock --env sudo --key SECURE_TOKEN
./bin/run keyrack get --key SECURE_TOKEN --env sudo
```

---

## scenario 13: --prikey fallback for non-standard key paths

```sh
# create a key in a non-standard location
mkdir -p ~/.ssh/custom
ssh-keygen -t ed25519 -N "" -f ~/.ssh/custom/special_key

# init keyrack with the custom key
./bin/run keyrack init --pubkey ~/.ssh/custom/special_key

# remove the key from ssh-agent (simulate discovery failure)
ssh-add -d ~/.ssh/custom/special_key

# try unlock without --prikey (should fail if key not in standard paths)
./bin/run keyrack unlock --env sudo --key SMOKE_SUDO
# expect: error about discovery failure with suggestion to use --prikey

# use --prikey fallback to unlock
./bin/run keyrack unlock --env sudo --key SMOKE_SUDO --prikey ~/.ssh/custom/special_key
# expect: success — explicit path bypasses discovery

# cleanup custom key
rm -rf ~/.ssh/custom
```

---

## scenario 14: --stanza ssh for ssh-keygen -p prevention flow

this scenario tests the addition of an ssh-ed25519 recipient BEFORE a passphrase is set on a passwordless key.

```sh
# setup: create a fresh passwordless key for this test
ssh-keygen -t ed25519 -N "" -f ~/.ssh/test_stanza_key
ssh-add ~/.ssh/test_stanza_key

# init keyrack with the passwordless key
# (cipher-aware: stores age1... recipient since key is passwordless)
./bin/run keyrack init --for stanza-test --pubkey ~/.ssh/test_stanza_key

# verify recipient is age format (default cipher-aware behavior for passwordless keys)
./bin/run keyrack recipient get --for stanza-test
# expect: mech: age, pubkey: age1...

# set a sudo credential for this test (value piped via stdin)
echo "stanza-test-secret" | ./bin/run keyrack set \
  --for stanza-test \
  --key STANZA_TEST_TOKEN \
  --env sudo \
  --vault os.secure

# verify credential works before any changes
./bin/run keyrack unlock --for stanza-test --env sudo --key STANZA_TEST_TOKEN
./bin/run keyrack get --for stanza-test --key STANZA_TEST_TOKEN --env sudo
./bin/run keyrack relock --for stanza-test

# =============================
# PREVENTION FLOW: add ssh recipient BEFORE passphrase
# =============================

# add ssh recipient with --stanza ssh
# (--stanza ssh forces ssh-ed25519 format despite passwordless key)
./bin/run keyrack recipient set \
  --for stanza-test \
  --pubkey ~/.ssh/test_stanza_key.pub \
  --label "ssh-backup" \
  --stanza ssh

# verify both recipients exist
./bin/run keyrack recipient get --for stanza-test
# expect: 2 recipients
#   - default: mech: age, pubkey: age1...
#   - ssh-backup: mech: ssh, pubkey: ssh-ed25519...

# NOW set passphrase on the key (simulate ssh-keygen -p)
# (the manifest is now decryptable via the ssh-ed25519 stanza)
ssh-keygen -p -f ~/.ssh/test_stanza_key
# enter empty for old passphrase, enter new passphrase

# reload key into agent with new passphrase
ssh-add ~/.ssh/test_stanza_key

# verify unlock still works (via ssh-ed25519 stanza)
./bin/run keyrack unlock --for stanza-test --env sudo --key STANZA_TEST_TOKEN
./bin/run keyrack get --for stanza-test --key STANZA_TEST_TOKEN --env sudo
# expect: success — age CLI matches ssh-ed25519 stanza

# cleanup: remove old age1... recipient (now stale — can't decrypt with passphrase key)
./bin/run keyrack recipient del --for stanza-test --label "default"

# verify only ssh-backup remains
./bin/run keyrack recipient get --for stanza-test
# expect: 1 recipient: mech: ssh, pubkey: ssh-ed25519...

# cleanup
./bin/run keyrack relock --for stanza-test
rm -f ~/.rhachet/keyrack/keyrack.host.stanza-test.age
rm -f ~/.ssh/test_stanza_key*
```

---

## scenario 15: --stanza ssh error when used with age pubkey

```sh
# --stanza ssh requires an ssh pubkey, not an age pubkey
./bin/run keyrack recipient set \
  --pubkey "age1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpvclx4" \
  --label "test" \
  --stanza ssh
# expect: error "--stanza ssh requires ssh pubkey (ssh-ed25519, ssh-rsa, etc.)"
```

---

## cleanup

```sh
# relock all keys
./bin/run keyrack relock

# remove test credentials from host manifest
# (manual: edit ~/.rhachet/keyrack/keyrack.host.age or re-init)

# remove mechanic's keyrack if created
rm -f ~/.rhachet/keyrack/keyrack.host.mechanic.age
rm -f ~/.ssh/id_ed25519_mechanic*
```

---

## quick smoke test (copy-paste)

```sh
# one-liner smoke test (pipes value from stdin for security)
npm run build && \
./bin/run keyrack init && \
echo "smoke-test" | ./bin/run keyrack set --key SMOKE_SUDO --env sudo --vault os.secure && \
./bin/run keyrack list --json | jq '.[] | select(.env == "sudo")' && \
./bin/run keyrack unlock --env sudo --key SMOKE_SUDO && \
./bin/run keyrack get --key SMOKE_SUDO --env sudo && \
./bin/run keyrack relock && \
echo "smoke test passed"
```
