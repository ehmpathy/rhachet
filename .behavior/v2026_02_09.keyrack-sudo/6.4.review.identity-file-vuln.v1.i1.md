# review: keyrack.identity file vulnerability

## summary

the `~/.rhachet/keyrack/keyrack.identity` file is unnecessary and introduces metadata leakage. it can be eliminated via recipient-based identity discovery.

---

## current state

### what the file contains

```
SSH_KEY_PATH:/home/vlad/.ssh/id_ed25519
```

### why it exists (current rationale)

the file is written at `initKeyrack.ts:89-93`:

```ts
// save identity for subsequent operations (recipient set/del, manifest access)
const identityPath = getKeyrackIdentityPath({ owner });
writeFileSync(identityPath, ageIdentity, { mode: 0o600 });
```

the intent: remember which private key to use when decrypt of the manifest later.

### where it's used

1. `daoKeyrackHostManifest` reads it to get the identity for decrypt
2. `genKeyrackHostContext` loads it for operations that need manifest access
3. `genKeyrackGrantContext` loads it for credential resolution

---

## problems

### problem 1: metadata leakage

the file reveals:
- **which ssh key** the user chose for keyrack
- **the exact path** to that key
- **the fact that keyrack is initialized** on this machine

anyone who can read `~/.rhachet/keyrack/keyrack.identity` now knows exactly which key to target. while the key itself is protected by passphrase + ssh-agent, the metadata exposure is unnecessary.

**severity**: low-medium — the path is sensitive metadata, not the key itself

### problem 2: redundant with manifest recipients

the encrypted manifest already stores `recipients[]` — the pubkeys that can decrypt it:

```ts
interface KeyrackHostManifest {
  recipients: KeyrackKeyRecipient[];  // pubkeys
  // ...
}
```

age's design allows read of recipients from the encrypted file header WITHOUT decrypt. we can match recipients against:
1. ssh-agent loaded keys
2. standard ssh key paths (`~/.ssh/id_ed25519`, etc.)

the identity file duplicates information that's already derivable.

### problem 3: stale identity risk

if the user changes ssh keys, the identity file becomes stale. the manifest is re-encrypted to new recipients, but the identity file still points to the old key.

---

## fix: recipient-based identity discovery

### the approach

```
manifest decrypt:
  ├─ read age recipients from encrypted file header (no decrypt needed)
  ├─ for each recipient:
  │     ├─ check ssh-agent for matched key
  │     └─ check standard paths (~/.ssh/id_ed25519, etc.)
  ├─ if match found: use that identity for decrypt
  └─ if no match: error with helpful message
```

this is how `age` CLI works — it doesn't require you to specify which identity to use. it tries all identities in ssh-agent or specified identity files.

### implementation sketch

```ts
/**
 * .what = discover identity that matches a recipient
 * .why = eliminates need for identity file
 */
const discoverIdentityForRecipient = async (input: {
  recipient: string;  // age recipient (age1...) or ssh pubkey
}): Promise<string | null> => {
  // check ssh-agent first (most likely to have the unlocked key)
  const agentKeys = await listSshAgentKeys();
  for (const agentKey of agentKeys) {
    const agentRecipient = sshPubkeyToAgeRecipient({ pubkey: agentKey.pubkey });
    if (agentRecipient === input.recipient) {
      // found match — return identity marker for age CLI fallback
      return `SSH_KEY_PATH:${agentKey.path}`;
    }
  }

  // check standard paths
  for (const stdPath of ['~/.ssh/id_ed25519', '~/.ssh/id_rsa', '~/.ssh/id_ecdsa']) {
    const expanded = expandPath(stdPath);
    if (!existsSync(expanded)) continue;
    const pubkey = readSshPubkey({ keyPath: expanded });
    const stdRecipient = sshPubkeyToAgeRecipient({ pubkey });
    if (stdRecipient === input.recipient) {
      return sshPrikeyToAgeIdentity({ keyPath: expanded });
    }
  }

  return null;
};
```

### migration

1. read recipients from manifest header
2. discover matched identity via ssh-agent or standard paths
3. delete identity file if present (cleanup)
4. update `daoKeyrackHostManifest` to use discovery instead of file read

---

## edge cases: when discovery would fail

### case 1: non-standard ssh key path (not in agent)

**scenario**: user's key is at `~/.ssh/work/project_x/special_key`, not loaded in ssh-agent.

**discovery result**: fails — key not in agent, not in standard paths.

**mitigation**:
- at init time, we know the path — we can prompt user to load it in agent
- OR accept `--identity` flag on unlock as fallback (but this re-introduces path exposure at cli level)

**likelihood**: low — most users keep keys in standard locations or use ssh-agent.

---

### case 2: native age keys (not ssh)

**scenario**: user ran `keyrack init --via age` with a native age key (not ssh-backed).

**discovery approach**:
- check `$AGE_IDENTITY_FILE` env var
- check `~/.config/age/keys.txt` (age's standard location)
- parse for `AGE-SECRET-KEY-...` lines and convert to recipients for match

**discovery result**: works if key is in standard location or env var set.

**mitigation**: document that native age keys must be in standard location or `$AGE_IDENTITY_FILE`.

---

### case 3: ssh-agent not active

**scenario**: minimal environment (some ci, docker containers) without ssh-agent.

**discovery result**: agent check fails, falls back to standard path check.

**outcome**:
- works if key is at standard path
- fails if key is at non-standard path AND no agent

**mitigation**: none needed — standard path fallback covers most cases.

---

### case 4: yubikey / hardware tokens

**scenario**: user initialized with yubikey-backed ssh key.

**discovery result**: works — ssh-agent knows about hardware-backed keys. the pubkey is available for match; actual use triggers touch/pin.

**outcome**: discovery succeeds; hardware interaction happens at decrypt time, not discovery time.

---

### case 5: pubkey file absent

**scenario**: private key at `~/.ssh/id_ed25519` but `.pub` file was deleted.

**discovery approach**:
- for unencrypted keys: extract pubkey from private key (already done in `sshPrikeyToAgeIdentity`)
- for passphrase-protected keys: can't extract without decryption

**discovery result**:
- passphrase-protected + not in agent + no .pub = fails
- unencrypted OR in agent = works

**mitigation**: if discovery fails, prompt user to ensure key is in ssh-agent.

---

### case 6: remote agent forward

**scenario**: `SSH_AUTH_SOCK` points to forwarded agent from another machine.

**discovery approach**: agent query returns keys, but they have no local path.

**outcome**:
- if we match by recipient (pubkey → age recipient comparison): works
- we don't need the local path — we just need the agent to sign

**key insight**: for agent-backed keys, we return the `SSH_KEY_PATH:` marker that points to... what? the forwarded agent doesn't have local paths.

**solution**: for agent keys, return a special marker like `SSH_AGENT_KEY:<fingerprint>` that tells `decryptWithIdentity` to use the agent directly (via age CLI's `-i -` stdin mode or similar).

---

## edge case summary

| case | discovery works? | notes |
|------|-----------------|-------|
| standard ssh path | ✅ yes | most common case |
| non-standard path + in agent | ✅ yes | agent match works |
| non-standard path + not in agent | ❌ no | no way to find it |
| native age key in standard location | ✅ yes | check age paths |
| native age key in custom location | ❌ no | need env var |
| yubikey / hardware token | ✅ yes | agent knows pubkey |
| pubkey file absent + in agent | ✅ yes | agent has pubkey |
| pubkey file absent + not in agent | ❌ no | can't extract |
| remote agent forward | ✅ yes | agent-backed decrypt |

### the unavoidable failure case

**non-standard path + not in agent + no pubkey file** = discovery impossible.

this is the only scenario where the identity file provides value. but this is also an unusual setup — users with non-standard paths typically either:
1. use ssh-agent (best practice)
2. keep the .pub file alongside the private key

### fallback option

for users who hit the unavoidable case, we could accept `--identity <path>` on `unlock` as a manual override:

```bash
rhx keyrack unlock --identity ~/.ssh/work/special_key
```

this re-introduces path exposure at cli level (visible in shell history), but only for the rare edge case where automatic discovery fails.

---

## tradeoffs

| aspect | current (identity file) | proposed (recipient discovery) |
|--------|------------------------|-------------------------------|
| metadata leakage | exposes key path | no leakage |
| stale risk | yes (key change) | no (always discovers) |
| latency | ~0ms (file read) | ~10-50ms (agent query) |
| complexity | simple file read | recipient match logic |
| multi-key support | one key per owner | natural (first match wins) |

the latency increase is negligible — manifest decrypt already takes ~50-100ms for passphrase-protected keys via age CLI.

---

## recommendation

**delete the identity file pattern and implement recipient-based discovery.**

### confidence assessment

discovery covers **~95%+ of real-world cases**:
- standard ssh paths: most users
- ssh-agent loaded keys: best practice users
- yubikey / hardware tokens: works via agent
- native age keys in standard locations: works

the only failure case (non-standard path + not in agent + no .pub) is rare and represents a non-standard setup that should use ssh-agent anyway.

### implementation

**primary path**: recipient-based discovery (covers 95%+ cases)

**fallback path**: `--identity <path>` flag on unlock for edge cases

```bash
# normal flow (discovery)
rhx keyrack unlock --env sudo --key X

# edge case fallback (explicit path)
rhx keyrack unlock --env sudo --key X --identity ~/.ssh/work/special_key
```

the fallback re-introduces path exposure at cli level (shell history), but only for users who explicitly opt into it for their non-standard setup.

### files to touch

- `initKeyrack.ts` — remove identity file write
- `genKeyrackHostContext.ts` — use discovery instead of file read
- `daoKeyrackHostManifest/index.ts` — implement `discoverIdentityForRecipient`
- `getKeyrackIdentityPath.ts` — delete (no longer needed)
- `unlockKeyrack.ts` — add optional `--identity` fallback flag
- `infra/ssh/listSshAgentKeys.ts` — new: list keys from ssh-agent with pubkeys

---

## severity assessment

| aspect | level |
|--------|-------|
| security impact | low-medium (metadata, not key) |
| functional impact | none (file works, just unnecessary) |
| fix complexity | medium (recipient discovery logic) |
| urgency | low (not a blocker, but should fix before v1 release) |

this is a **design improvement**, not a critical vulnerability. the file has 0600 permissions, so only the user can read it. but the principle of minimum necessary metadata argues for removal.
