# research: test code patterns for keyrack sudo

## 1. BDD test structure pattern

### current pattern

all tests use `test-fns` library with given/when/then structure:

> "import { given, then, useBeforeAll, when } from 'test-fns'" [1]

numbered case labels organize scenarios:

```typescript
given('[case1] daemon server lifecycle', () => {
  when('[t0] server is created', () => {
    then('socket file exists', () => { ... });
    then('daemon is reachable', async () => { ... });
  });
});
```
[1]

shared setup via useBeforeAll:

```typescript
const scene = useBeforeAll(async () => {
  return createKeyrackDaemonServer({ socketPath: testSocketPath });
});

afterAll(() => {
  scene.server.close();
});
```
[1]

error capture via getError:

> "import { getError, given, then, when } from 'test-fns'" [4]

```typescript
const error = await getError(
  daoKeyrackHostManifest.set({ findsert: manifestDesired }),
);
expect(error).toBeDefined();
expect(error?.message).toContain('different uri');
```
[4]

### how it relates to wish

- same BDD structure for sudo credential tests
- case labels: `[case1] sudo credential set`, `[case2] sudo unlock blocked in CI`, etc.
- test step labels: `[t0] before changes`, `[t1] after unlock`, etc.

### verdict: [REUSE]

- use identical BDD structure for all sudo tests
- follow case/step number convention

---

## 2. temp home isolation pattern

### current pattern

isolated HOME directory prevents real `~/.rhachet` pollution:

> "provides isolated HOME directory for tests... prevents host manifest tests from pollution of real ~/.rhachet" [2]

```typescript
export const withTempHome = (input: {
  name: string;
}): {
  path: string;
  setup: () => void;
  teardown: () => void;
} => {
  const tempHome = join(os.tmpdir(), 'rhachet-test', input.name);
  const originalHome = process.env.HOME;

  return {
    path: tempHome,
    setup: () => {
      rmSync(tempHome, { recursive: true, force: true });
      mkdirSync(tempHome, { recursive: true });
      process.env.HOME = tempHome;
    },
    teardown: () => {
      process.env.HOME = originalHome;
      rmSync(tempHome, { recursive: true, force: true });
    },
  };
};
```
[2]

usage in tests:

```typescript
const tempHome = withTempHome({ name: 'daoKeyrackHostManifest' });
beforeAll(() => tempHome.setup());
afterAll(() => tempHome.teardown());
```
[4]

### how it relates to wish

- encrypted host manifest (keyrack.host.yml.age) needs same isolation
- sudo credential tests must not touch real ~/.rhachet

### verdict: [REUSE]

- use withTempHome for all sudo credential tests
- no changes needed to isolation pattern

---

## 3. mock vault adapter pattern

### current pattern

mock vault adapter for unit tests without real vault access:

> "generates a mock vault adapter for tests... enables isolated unit tests without real vault access" [3]

```typescript
export const genMockVaultAdapter = (input?: {
  isUnlocked?: boolean;
  storage?: Record<string, string>;
}): KeyrackHostVaultAdapter => {
  let unlocked = input?.isUnlocked ?? true;
  const storage: Record<string, string> = input?.storage ?? {};

  return {
    unlock: async () => { unlocked = true; },
    isUnlocked: async () => unlocked,
    get: async ({ slug }) => storage[slug] ?? null,
    set: async ({ slug, value }) => { storage[slug] = value; },
    del: async ({ slug }) => { delete storage[slug]; },
  };
};
```
[3]

### how it relates to wish

- sudo tests need mock vault adapters
- can simulate locked/unlocked states
- can pre-populate credential storage for tests

### verdict: [REUSE]

- use genMockVaultAdapter for sudo unit tests
- no changes needed

---

## 4. mock host manifest pattern

### current pattern

mock host manifest with sensible defaults:

> "generates a mock KeyrackHostManifest for tests... provides reusable fixture with sensible defaults" [5]

```typescript
export const genMockKeyrackHostManifest = (input?: {
  uri?: string;
  hosts?: Record<string, Partial<KeyrackKeyHost>>;
}): KeyrackHostManifest => {
  const hosts: Record<string, KeyrackKeyHost> = {};

  for (const [slug, partialHost] of Object.entries(input?.hosts ?? {})) {
    hosts[slug] = new KeyrackKeyHost({
      slug,
      mech: partialHost.mech ?? 'REPLICA',
      vault: partialHost.vault ?? 'os.direct',
      exid: partialHost.exid ?? null,
      createdAt: partialHost.createdAt ?? new Date().toISOString(),
      updatedAt: partialHost.updatedAt ?? new Date().toISOString(),
    });
  }

  return new KeyrackHostManifest({ uri: input?.uri ?? '...', hosts });
};
```
[5]

### how it relates to wish

- sudo credentials need `env` and `org` fields in KeyrackKeyHost
- mock generator needs extension to support new fields

### verdict: [EXTEND]

- add `env?: 'all' | 'sudo'` to genMockKeyrackHostManifest input
- add `org?: string` to genMockKeyrackHostManifest input
- default env to 'all' for backwards compatibility

---

## 5. daemon integration test pattern

### current pattern

unique socket path per test process prevents conflicts:

> "use a unique socket path for tests to avoid conflicts" [1]

```typescript
const testSocketPath = `/tmp/keyrack-test-${process.pid}.sock`;
```
[1]

cleanup before and after:

```typescript
beforeAll(() => {
  if (existsSync(testSocketPath)) unlinkSync(testSocketPath);
});

afterAll(() => {
  if (existsSync(testSocketPath)) unlinkSync(testSocketPath);
});
```
[1]

command sequence tests:

```typescript
when('[t0] UNLOCK command', () => {
  then('stores keys in daemon', async () => {
    const result = await daemonAccessUnlock({
      keys: [
        {
          slug: 'TEST_KEY_1',
          key: { secret: 'secret-1', grade: { ... } },
          expiresAt: Date.now() + 60000,
        },
      ],
      socketPath: testSocketPath,
    });
    expect(result.unlocked.sort()).toEqual(['TEST_KEY_1', 'TEST_KEY_2']);
  });
});
```
[1]

unreachable daemon handler:

```typescript
given('[case3] daemon not reachable', () => {
  const unreachableSocketPath = '/tmp/keyrack-nonexistent.sock';

  when('[t0] GET is called', () => {
    then('returns null', async () => {
      const result = await daemonAccessGet({
        slugs: ['ANY_KEY'],
        socketPath: unreachableSocketPath,
      });
      expect(result).toBeNull();
    });
  });
});
```
[1]

### how it relates to wish

- sudo credential tests follow same daemon pattern
- need tests for sudo-specific behaviors: 30min TTL, env filter, CI block

### verdict: [EXTEND]

- add `[caseN] sudo credential lifecycle` tests
- add `[caseN] CI environment blocks sudo unlock` tests
- add `[caseN] relock --env sudo filters correctly` tests

---

## 6. daemon key store test pattern

### current pattern

TTL enforcement tested via expiration scenarios:

```typescript
given('[case3] key is stored with expired TTL', () => {
  const store = createDaemonKeyStore();
  const expiresAt = Date.now() - 1000; // 1 second ago (expired)

  beforeEach(() => {
    store.set({
      slug: 'EXPIRED_KEY',
      key: { secret: 'expired-secret', grade: { ... } },
      expiresAt,
    });
  });

  when('[t0] get by slug', () => {
    then('returns null (expired key purged)', () => {
      const result = store.get({ slug: 'EXPIRED_KEY' });
      expect(result).toBeNull();
    });

    then('size decreases after read (lazy purge)', () => {
      expect(store.size()).toBe(1); // still in store before read
      store.get({ slug: 'EXPIRED_KEY' }); // triggers purge
      expect(store.size()).toBe(0); // now gone
    });
  });
});
```
[6]

update (same slug) replaces value:

```typescript
given('[case6] key is updated (same slug)', () => {
  when('[t0] set is called with same slug', () => {
    then('new value replaces old', () => {
      store.set({
        slug: 'UPDATABLE_KEY',
        key: { secret: 'updated-secret', grade: { ... } },
        expiresAt: Date.now() + 120000,
      });

      const result = store.get({ slug: 'UPDATABLE_KEY' });
      expect(result?.key.secret).toBe('updated-secret');
    });
  });
});
```
[6]

### how it relates to wish

- sudo credentials need env classification tracked in store
- need tests for env-based filter in entries()
- need tests for 30min vs 9h TTL differentiation

### verdict: [EXTEND]

- add `env` field to test data structures
- add `[caseN] entries filtered by env` tests
- add `[caseN] sudo key 30min TTL vs regular 9h` tests

---

## 7. host manifest dao test pattern

### current pattern

round-trip persistence tests:

```typescript
then('round-trips correctly', async () => {
  const keyHost = new KeyrackKeyHost({
    slug: 'XAI_API_KEY',
    mech: 'REPLICA',
    vault: 'os.direct',
    exid: null,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  });

  const manifest = new KeyrackHostManifest({
    uri: '~/.rhachet/keyrack.manifest.json',
    hosts: { XAI_API_KEY: keyHost },
  });

  await daoKeyrackHostManifest.set({ upsert: manifest });
  const result = await daoKeyrackHostManifest.get({});

  expect(result).not.toBeNull();
  expect(result?.hosts.XAI_API_KEY?.slug).toEqual('XAI_API_KEY');
});
```
[4]

findsert vs upsert semantics:

```typescript
when('[t0] set.findsert called with same uri', () => {
  then('returns found manifest without update', async () => {
    const result = await daoKeyrackHostManifest.set({
      findsert: manifestDesired,
    });
    // findsert returns the found manifest, not the desired one
    expect(result.hosts.OLD_KEY).toBeDefined();
    expect(result.hosts.NEW_KEY).toBeUndefined();
  });
});
```
[4]

invalid JSON/schema error tests:

```typescript
given('[case3] manifest has invalid json', () => {
  beforeEach(async () => {
    writeFileSync(join(dir, 'keyrack.manifest.json'), '{ invalid json }');
  });

  when('[t0] get called', () => {
    then('throws error about invalid json', async () => {
      const error = await getError(daoKeyrackHostManifest.get({}));
      expect(error?.message).toContain('invalid json');
    });
  });
});
```
[4]

### how it relates to wish

- encrypted manifest (keyrack.host.yml.age) needs same test patterns
- need tests for passphrase prompt/decrypt flow
- need tests for env/org fields in schema

### verdict: [EXTEND]

- add `daoKeyrackHostManifestEncrypted.integration.test.ts`
- test passphrase unlock flow
- test env/org field persistence

---

## 8. env var management pattern

### current pattern

backup and restore for process.env:

```typescript
const originalHome = process.env.HOME;

setup: () => {
  process.env.HOME = tempHome;
},

teardown: () => {
  process.env.HOME = originalHome;
},
```
[2]

### how it relates to wish

- CI detection tests need to set/restore CI and GITHUB_ACTIONS env vars
- KEYRACK_PASSPHRASE env var tests need same pattern

### verdict: [EXTEND]

- add CI env var management for sudo block tests
- pattern: backup → set → test → restore

---

## 9. socket cleanup pattern

### current pattern

cleanup socket files in beforeAll/afterAll:

```typescript
beforeAll(() => {
  if (existsSync(testSocketPath)) unlinkSync(testSocketPath);
  if (existsSync(testPidPath)) unlinkSync(testPidPath);
});

afterAll(() => {
  if (existsSync(testSocketPath)) unlinkSync(testSocketPath);
  if (existsSync(testPidPath)) unlinkSync(testPidPath);
});
```
[1]

### how it relates to wish

- sudo daemon tests use same cleanup pattern
- no changes needed

### verdict: [REUSE]

- use identical cleanup pattern for sudo tests

---

## 10. TTL extension test pattern

### current pattern

re-unlock with new TTL updates expiration:

```typescript
given('[case5] TTL extension on re-unlock', () => {
  when('[t0] key is re-unlocked with new TTL', () => {
    then('TTL is updated', async () => {
      const originalExpiresAt = Date.now() + 30000;
      const newExpiresAt = Date.now() + 120000;

      // initial unlock
      await daemonAccessUnlock({
        keys: [{ slug: 'TTL_TEST_KEY', ..., expiresAt: originalExpiresAt }],
        socketPath: testSocketPath,
      });

      // re-unlock with longer TTL
      await daemonAccessUnlock({
        keys: [{ slug: 'TTL_TEST_KEY', ..., expiresAt: newExpiresAt }],
        socketPath: testSocketPath,
      });

      const status = await daemonAccessStatus({ socketPath: testSocketPath });
      const key = status!.keys.find((k) => k.slug === 'TTL_TEST_KEY');
      expect(key!.expiresAt).toBe(newExpiresAt);
    });
  });
});
```
[1]

### how it relates to wish

- sudo credentials have 30min TTL by default
- re-unlock should extend TTL
- need explicit tests for sudo TTL behavior

### verdict: [REUSE]

- apply same TTL extension pattern to sudo credentials
- test 30min default specifically

---

## 11. new test patterns needed

### CI environment block test

```typescript
given('[caseN] CI environment detected', () => {
  const originalCI = process.env.CI;

  beforeEach(() => {
    process.env.CI = 'true';
  });

  afterEach(() => {
    if (originalCI) process.env.CI = originalCI;
    else delete process.env.CI;
  });

  when('[t0] sudo unlock is attempted', () => {
    then('throws error about CI block', async () => {
      const error = await getError(
        unlockKeyrack({ env: 'sudo', key: 'SUDO_KEY' }, context),
      );
      expect(error?.message).toContain('cannot be unlocked in CI');
    });
  });
});
```

### verdict: [NEW]

- create CI detection test pattern
- apply to all sudo unlock tests

---

### passphrase arg rejection test

```typescript
given('[caseN] sudo unlock with --passphrase arg', () => {
  when('[t0] passphrase provided as arg', () => {
    then('throws error about shell history risk', async () => {
      const error = await getError(
        unlockKeyrack({ env: 'sudo', key: 'KEY', passphrase: 'secret' }, context),
      );
      expect(error?.message).toContain('--passphrase arg not allowed for sudo');
    });
  });
});
```

### verdict: [NEW]

- create passphrase rejection test for sudo env

---

### rate limit test

```typescript
given('[caseN] multiple failed unlock attempts', () => {
  when('[t0] third attempt after failures', () => {
    then('delay is enforced before attempt', async () => {
      // attempt 1: fail
      // attempt 2: fail
      // attempt 3: should wait 2s before allowed
    });
  });
});
```

### verdict: [NEW]

- create rate limit test with time assertions

---

## summary

| pattern | verdict | action |
|---------|---------|--------|
| BDD given/when/then | [REUSE] | use identical structure |
| temp home isolation | [REUSE] | withTempHome for all sudo tests |
| mock vault adapter | [REUSE] | genMockVaultAdapter unchanged |
| mock host manifest | [EXTEND] | add env/org fields |
| daemon integration | [EXTEND] | add sudo-specific cases |
| daemon key store | [EXTEND] | add env filter tests |
| host manifest dao | [EXTEND] | add encrypted variant tests |
| env var management | [EXTEND] | add CI env var tests |
| socket cleanup | [REUSE] | use identical pattern |
| TTL extension | [REUSE] | apply to sudo credentials |
| CI block test | [NEW] | create for sudo unlock |
| passphrase rejection | [NEW] | create for sudo env |
| rate limit test | [NEW] | create with time assertions |

---

## citations

1. [daemon.integration.test.ts](src/domain.operations/keyrack/daemon/daemon.integration.test.ts) — daemon socket tests
2. [withTempHome.ts](src/.test/infra/withTempHome.ts) — temp home isolation
3. [genMockVaultAdapter.ts](src/.test/assets/genMockVaultAdapter.ts) — mock vault adapter
4. [daoKeyrackHostManifest/index.integration.test.ts](src/access/daos/daoKeyrackHostManifest/index.integration.test.ts) — host manifest tests
5. [genMockKeyrackHostManifest.ts](src/.test/assets/genMockKeyrackHostManifest.ts) — mock host manifest
6. [daemonKeyStore.test.ts](src/domain.operations/keyrack/daemon/svc/src/domain.objects/daemonKeyStore.test.ts) — key store tests
