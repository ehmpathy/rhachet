# vision: keyrack sudo credentials

## builds on

keyrack already supports env-scoped credentials (from commit 24dd6e6):
- keyrack.yml uses `org` + `env.*` sections (e.g., env.prod, env.prep)
- `KeyrackKeySpec` has `env` field for deployment environments
- `unlockKeyrack` accepts `--env` flag to filter keys

this feature adds:
1. `env=sudo` as a special permission tier (invisible to codebase)
2. **recipient-key-based locks** â€” no passphrases, use ssh keys / yubikeys instead
3. **per-owner isolation** â€” each robot/agent has its own manifest and daemon

---

## domain distillation

### the four "keys" in keyrack

keyrack has four distinct concepts that all involve "keys" â€” clarity requires precise terms:

| term | what it is | where it lives | lifecycle |
|------|-----------|----------------|-----------|
| **KeyrackKeyOwner** | identity that owns a manifest (human, robot, agent) | manifest filename | permanent |
| **KeyrackKeyRecipient** | key that can decrypt the host manifest | ssh-agent, yubikey | long-lived (years) |
| **KeyrackKeySpec** | specification of a credential the project needs | keyrack.yml (repo) | project lifetime |
| **KeyrackKeyHost** | config for how to fetch a credential on this host | keyrack.host.${owner}.age | machine lifetime |
| **KeyrackKeyGrant** | the actual credential value after fetch | owner's daemon memory | session (TTL) |

### mental model

```
KeyrackKeyOwner (null for default, or explicit: mechanic, foreman, etc)
  â””â”€> owns keyrack.host.age or keyrack.host.${owner}.age (isolated manifest)
        â””â”€> encrypted to owner's KeyrackKeyRecipient (ssh key, yubikey, etc)
              â””â”€> contains KeyrackKeyHost entries (vault pointers)
                    â””â”€> fetch from vaults
                          â””â”€> produces KeyrackKeyGrant (actual secrets)
                                â””â”€> stored in owner's daemon with TTL

KeyrackKeySpec (in keyrack.yml)
  â””â”€> declares what credentials the project needs
        â””â”€> matched against KeyrackKeyHost to determine what to unlock

Per-owner isolation:
  ~/.rhachet/keyrack/
    keyrack.host.age             # default manifest (no --for flag)
    keyrack.host.mechanic.age    # mechanic's isolated manifest
    keyrack.host.foreman.age     # foreman's isolated manifest

  /tmp/
    keyrack.daemon.sock            # default daemon (no --for flag)
    keyrack.daemon.mechanic.sock   # mechanic's daemon
    keyrack.daemon.foreman.sock    # foreman's daemon
```

### why "Recipient" for the unlock key

follows age's terminology:
- age encrypts TO **recipients** (public keys)
- age decrypts WITH **identities** (private keys)
- keyrack tracks **recipients** who can decrypt the manifest

`KeyrackKeyRecipient` matches age's model: **the recipient of the encrypted manifest**.

### security implication

**the manifest is exactly as secure as your recipient key.**

| recipient key mech | manifest security |
|-----------------|-------------------|
| software ssh key | compromised if machine compromised |
| YubiKey-backed ssh | requires physical possession + touch |
| passkey-backed | requires biometric + device |

key-based access is stronger than passphrase because:
- 256-bit random entropy (not human-chosen)
- can be hardware-bound (non-extractable)
- can require physical presence (touch)

---

## the outcome world

### before

a developer needs to install a github app for their org. this requires an org manager's personal access token â€” a credential so powerful it can modify billing, teams, repositories, and settings across the entire organization.

today, they face a dilemma:
- put it in keyrack.yml? now everyone who clones the repo knows this credential exists and might be pressured to expose it
- put it in keyrack.host.yml? that file is plaintext â€” anyone with machine access can enumerate all available sudo-level credentials
- use a separate secret manager? now they have two systems to remember

the mere existence of high-privilege credentials becomes visible metadata. even without the credential values, knowing "EHMPATHY_ORG_MANAGER_GITHUB_TOKEN exists on vlad's machine" is a security leak.

### after

```bash
# one-time: initialize keyrack with default ssh key
rhx keyrack init
# â†’ uses ~/.ssh/id_ed25519
# â†’ creates keyrack.host.age encrypted to that key
# â†’ no passphrase to remember

# vlad sets up the sudo credential
rhx keyrack set \
  --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN \
  --org @this \
  --env sudo \
  --vault 1password

# keyrack walks him through the link to 1password
# the credential goes ONLY into keyrack.host.age (encrypted)
# keyrack.yml remains unaware of it
```

later, when a workflow needs it:

```bash
# unlock the specific sudo key (decrypts via ssh key, loads that one key into daemon)
. rhx keyrack unlock --env sudo --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN
# â†’ finds ssh key in agent (automatic, no passphrase prompt)
# â†’ decrypts manifest
# â†’ fetches credential from vault
# â†’ stores in daemon with 30min TTL

# get the sudo credential (now available from daemon)
rhx keyrack get --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN --env sudo
```

for robots with their own credentials:

```bash
# initialize mechanic's keyrack with its own ssh key
rhx keyrack init --for mechanic --via ssh --pubkey ~/.ssh/id_ed25519_mechanic
# â†’ creates keyrack.host.mechanic.age encrypted to mechanic's key

# set mechanic's github token (different from default)
rhx keyrack set --for mechanic --key GITHUB_TOKEN --env sudo --vault 1password

# mechanic unlocks and uses its own credentials
rhx keyrack unlock --for mechanic --env sudo --key GITHUB_TOKEN
rhx keyrack get --for mechanic --key GITHUB_TOKEN --env sudo
# â†’ only mechanic can access mechanic's credentials
```

the workflow works. the credential existed only in:
1. 1password (encrypted at rest)
2. the encrypted host manifest (metadata only)
3. memory during the session

no plaintext file ever revealed that this credential exists. no passphrase was typed.

### the "aha" moment

> "wait â€” my keyrack.host.age is now encrypted to my ssh key? so even if someone gets my laptop, they can't see *which* sudo credentials I have access to without my ssh key? and I never have to type a passphrase?"
>
> "exactly. the ssh key you chose is already in ssh-agent. keyrack just uses it. and keyrack.yml in the repo only shows regular credentials. sudo credentials are invisible to the codebase entirely."
>
> "and my robots can each have their own keyrack? mechanic can't see foreman's credentials?"
>
> "right. `--for mechanic` uses keyrack.host.mechanic.age and its own daemon. full process isolation."

---

## user experience

### usecase 1: first-time setup

**goal**: initialize keyrack on a new machine

```bash
# most developers: use default ssh key (recommended)
rhx keyrack init
# â†’ finds ~/.ssh/id_ed25519
# â†’ creates keyrack.host.age encrypted to that key
# done. no passphrase to remember.

# security-conscious: use yubikey
rhx keyrack init --via yubikey
# â†’ runs age-plugin-yubikey
# â†’ creates manifest encrypted to yubikey
# â†’ every unlock requires physical touch

# robot setup: isolated keyrack for mechanic
rhx keyrack init --for mechanic --via ssh --pubkey ~/.ssh/id_ed25519_mechanic
# â†’ creates keyrack.host.mechanic.age encrypted to mechanic's key
# â†’ mechanic's daemon is separate from default daemon
```

### usecase 2: set a sudo credential

**goal**: store an org manager token that should never appear in any plaintext file

```bash
rhx keyrack set \
  --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN \
  --org @this \
  --env sudo \
  --vault 1password \
  --exid "private/github-pat/credential"

# keyrack outputs:
#   ðŸ” sudo credential setup
#
#   this credential will be stored in your encrypted host manifest only.
#   it will NOT appear in keyrack.yml or any plaintext file.
#
#   âœ“ credential configured
#
#   to use: rhx keyrack get --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN --env sudo
```

**timeline**:
1. `t=0`: human runs set command with `--env sudo`
2. `t=5s`: keyrack validates the vault, prompts for 1password path
3. `t=15s`: keyrack re-encrypts host manifest with new entry
4. `t=15s`: done â€” no plaintext evidence remains

### usecase 3: use a sudo credential in a terraform workflow

**goal**: a terraform apply needs org-level github permissions

```bash
# before running terraform, unlock the specific sudo key needed:
. rhx keyrack unlock --env sudo --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN
# â†’ decrypts manifest via ssh key (automatic, no prompt)
# â†’ fetches credential from 1password
# â†’ stores in daemon with 30min TTL

# terraform.tf uses:
# provider "github" {
#   token = data.external.keyrack.result.value
# }

# data.external invokes:
rhx keyrack get --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN --env sudo --output json
# returns: {"value": "ghp_xxx...", "env": "sudo"}
```

**timeline**:
1. `t=0`: workflow sources unlock (automatic via ssh-agent)
2. `t=2s`: terraform runs, data.external calls keyrack get
3. `t=2s`: daemon returns credential from memory (no vault roundtrip)
4. `t=5m`: terraform completes
5. `t=30m`: daemon TTL expires, sudo credential purged from memory

### usecase 4: regular credentials still work the same

**goal**: set a normal API key that's fine to enumerate in keyrack.yml

```bash
rhx keyrack set \
  --key OPENAI_API_KEY \
  --org @this \
  --env prod \
  --vault 1password

# this DOES appear in keyrack.yml (in the env.prod section)
# because --env prod means "visible to the codebase for prod deployments"
```

### usecase 5: multi-machine setup

```bash
# new machine: option A â€” rebuild from vaults
rhx keyrack init
rhx keyrack set --key X --env sudo --vault 1password
# vaults are the source of truth; manifest is just an index

# new machine: option B â€” add new key as recipient from old machine
# on old machine:
rhx keyrack recipient set --pubkey "ssh-ed25519 AAAA... newmachine"
# transfer keyrack.host.age to new machine
# new machine can now decrypt with its key
```

### usecase 6: multiple robots on one machine

```bash
# each robot gets its own isolated keyrack
rhx keyrack init --for mechanic --via ssh --pubkey ~/.ssh/id_ed25519_mechanic
rhx keyrack init --for foreman --via ssh --pubkey ~/.ssh/id_ed25519_foreman

# each robot sets its own credentials
rhx keyrack set --for mechanic --key GITHUB_TOKEN --env sudo --vault 1password --exid "mechanic/pat"
rhx keyrack set --for foreman --key GITHUB_TOKEN --env sudo --vault 1password --exid "foreman/pat"

# each robot unlocks and uses only its own credentials
rhx keyrack unlock --for mechanic --env sudo --key GITHUB_TOKEN
rhx keyrack get --for mechanic --key GITHUB_TOKEN --env sudo
# â†’ mechanic cannot access foreman's GITHUB_TOKEN
```

---

## mental model

### how users would describe it to a friend

> "keyrack has two tiers now. regular keys go in keyrack.yml in env sections (env.prod, env.prep) â€” everyone can see what keys the project needs for each environment. but *sudo* keys are invisible. they only exist in my encrypted host file. even if you clone the repo and look at keyrack.yml, you'd have no idea I have org manager credentials on my machine."
>
> "and the best part? no passphrase. it uses my ssh key. just works."

### analogies

| concept | analogy |
|---------|---------|
| `--env prod/prep` | a keyring on your belt â€” visible, functional, normal |
| `--env sudo` | a safe deposit box key you keep in a hidden pocket |
| `keyrack.yml` | the building directory lists apartment numbers by floor (env.prod, env.prep) |
| `keyrack.host.age` | a lockbox that holds your actual keys â€” need your ssh key to open |
| `keyrack.host.mechanic.age` | mechanic's personal lockbox â€” only mechanic's key opens it |
| `keyrack init --via ssh` | give your lockbox your fingerprint |
| `--for mechanic` | specify whose lockbox to access |
| daemon unlock | open the lockbox for the session |

### terminology

| user term | system term | meaning |
|-----------|-------------|---------|
| "env key" | `env: prod`, `env: prep`, etc | deployment-scoped credential in repo manifest |
| "sudo key" | `env: sudo` | elevated credential only in encrypted host manifest |
| "unlock" (regular) | `unlock --env prod` | bulk unlock credentials for a deployment env |
| "unlock" (sudo) | `unlock --env sudo --key X` | unlock ONE sudo credential at a time |
| "my keyrack" | `keyrack.host.age` | default encrypted credential index |
| "robot's keyrack" | `keyrack.host.${owner}.age` | owner-specific encrypted credential index |
| "the project's keyrack" | `keyrack.yml` | per-repo credential requirements (env.prod, env.prep sections) |
| "recipient key" | `KeyrackKeyRecipient` | ssh key / yubikey that can decrypt the manifest |
| "owner" | `--for` flag | identity that owns a manifest (null for default, or explicit name) |

---

## commands

### keyrack init

initialize keyrack with a recipient.

```bash
# with default ssh key (recommended)
rhx keyrack init
# â†’ finds ~/.ssh/id_ed25519 (or id_rsa, etc)
# â†’ creates keyrack.host.age encrypted to that key
# â†’ records recipient in manifest

# with explicit pubkey value (type inferred from "ssh-" prefix)
rhx keyrack init --pubkey "ssh-ed25519 AAAA..."

# with non-default ssh key (path to pubkey or private key)
rhx keyrack init --pubkey ~/.ssh/id_ed25519_work

# with yubikey (runs age-plugin-yubikey to discover)
rhx keyrack init --via yubikey
# â†’ runs age-plugin-yubikey to get recipient
# â†’ creates keyrack.host.age encrypted to yubikey
# â†’ unlock requires physical touch

# for a specific owner (robot isolation)
rhx keyrack init --for mechanic --via ssh --pubkey ~/.ssh/id_ed25519_mechanic
# â†’ creates keyrack.host.mechanic.age encrypted to mechanic's key
# â†’ mechanic's daemon socket: /tmp/keyrack.daemon.mechanic.sock
```

### keyrack recipient

manage recipients (who can decrypt the manifest).

```bash
# add a recipient
rhx keyrack recipient set --pubkey "ssh-ed25519 AAAA... macbook"
# â†’ re-encrypts manifest to include new recipient
# â†’ both keys can now decrypt

# list recipients
rhx keyrack recipient get
# â†’ shows all recipients that can decrypt manifest

# remove a recipient
rhx keyrack recipient del --label "old-laptop"
# â†’ re-encrypts manifest WITHOUT that recipient
```

**key rotation** is just `recipient set` + `recipient del`:
```bash
rhx keyrack recipient set --pubkey ~/.ssh/id_ed25519_new.pub
rhx keyrack recipient del --label "old-laptop"
```

### keyrack set

add a credential to the host manifest.

```bash
rhx keyrack set --key GITHUB_TOKEN --env sudo --org @this --vault 1password
# â†’ decrypts manifest (via recipient key)
# â†’ prompts for 1password item path (if --exid not provided)
# â†’ stores KeyrackKeyHost entry
# â†’ re-encrypts manifest
# â†’ if env !== 'sudo': also adds to keyrack.yml

# with explicit item path (skips prompt)
rhx keyrack set --key GITHUB_TOKEN --env sudo --org @this --vault 1password --exid "private/github-pat/credential"

# for a specific owner
rhx keyrack set --for mechanic --key GITHUB_TOKEN --env sudo --vault 1password
# â†’ stores in keyrack.host.mechanic.age
```

### keyrack unlock

unlock credentials for use.

```bash
# unlock specific sudo key
rhx keyrack unlock --env sudo --key GITHUB_TOKEN
# â†’ decrypts manifest (via recipient key in agent)
# â†’ fetches credential from vault
# â†’ stores in daemon with 30min TTL

# unlock all keys for an env
rhx keyrack unlock --env prod
# â†’ decrypts manifest
# â†’ fetches all prod credentials
# â†’ stores in daemon with 9h TTL

# for a specific owner
rhx keyrack unlock --for mechanic --env sudo --key GITHUB_TOKEN
# â†’ decrypts keyrack.host.mechanic.age
# â†’ stores in mechanic's daemon (/tmp/keyrack.daemon.mechanic.sock)
```

### keyrack get

retrieve an unlocked credential.

```bash
rhx keyrack get --key GITHUB_TOKEN --env sudo
# â†’ queries daemon
# â†’ returns credential value

# for a specific owner
rhx keyrack get --for mechanic --key GITHUB_TOKEN --env sudo
# â†’ queries mechanic's daemon
# â†’ returns credential value
```

### keyrack relock

purge credentials from daemon.

```bash
rhx keyrack relock                # relock all keys (--all is default, most extreme)
rhx keyrack relock --all          # explicit: relock all keys
rhx keyrack relock --env sudo     # relock only sudo credentials
rhx keyrack relock --key X        # relock specific key
```

### keyrack status

show current state.

```bash
rhx keyrack status
# â†’ shows recipient key info
# â†’ shows unlocked credentials with TTL remaining
# â†’ shows daemon socket status
```

---

## evaluation

### how well does it solve the goals?

| goal | solution | rating |
|------|----------|--------|
| hide sudo credential *values* | already done via vault storage | âœ… |
| hide sudo credential *existence* | encrypted host manifest | âœ… |
| no plaintext metadata leakage | keyrack.host.yml â†’ keyrack.host.yml.age | âœ… |
| backward compatible | env.prod/prep work as before, sudo is opt-in | âœ… |
| simple mental model | env envs vs sudo, visible vs invisible | âœ… |
| no passphrase friction | recipient-key-based locks via ssh/yubikey | âœ… |

### pros

- **zero plaintext leakage** â€” even credential names are encrypted
- **no passphrase to type** â€” ssh key / yubikey handles unlock
- **graceful degradation** â€” if you don't use sudo, behavior is unchanged
- **consistent UX** â€” same get/set/unlock flow, just with --env flag
- **defense in depth** â€” manifest encrypted to your ssh key
- **multi-recipient** â€” add backup keys, share across machines

### cons

- **requires ssh key** â€” but developers already have one
- **added complexity** â€” users must understand the all/sudo distinction
- **unlock required** â€” can't get sudo credentials without recipient key

### edgecases and pit of success

| edgecase | pit of success |
|----------|----------------|
| user forgets `--env sudo` for sensitive cred | prompt: "this key name contains 'ORG_MANAGER'. did you mean --env sudo?" |
| user tries to enumerate sudo keys in keyrack.yml | error: "sudo credentials cannot be added to repo manifest" |
| user tries `get --env sudo` without unlock | error: "sudo credentials require unlock. run: rhx keyrack unlock --env sudo --key X" |
| recipient key lost | re-run set commands to rebuild (vaults are source of truth) |
| machine compromised while unlocked | TTL limits exposure window; relock available |
| no ssh key | error with instructions to create one or use `--pubkey` with explicit key |

### what's awkward

1. **sudo unlock granularity** â€” sudo credentials require per-key unlock, not bulk unlock
   - `rhx keyrack unlock --env sudo --key EHMPATHY_ORG_MANAGER_GITHUB_TOKEN`
   - this prevents over-exposure: you can't accidentally unlock all sudo credentials at once
   - env credentials (`--env prod`, `--env prep`) can still bulk unlock as before
   - sudo credentials default to 30min TTL (vs 9h for regular) â€” shorter exposure window

2. **naming: "sudo"** â€” is this clear enough? alternatives: `privileged`, `elevated`, `hidden`, `private`
   - resolution: "sudo" is familiar from unix, implies "requires extra permission"

3. **org scope** â€” what if a sudo credential spans multiple orgs?
   - resolution: `--org @all` for cross-org credentials
   - note: `--org` defaults to the org declared in keyrack.yml, so cross-org credentials require explicit `--org @all` on both set AND get

---

## summary

the world after:

```
keyrack.yml (in repo, plaintext, git-tracked):
  - org: ehmpathy
  - env.prod: lists prod credentials
  - env.prep: lists prep credentials
  - no sudo credentials ever appear here

~/.rhachet/keyrack/ (on machine, encrypted to recipient keys):
  keyrack.host.age             # default manifest (no --for)
  keyrack.host.mechanic.age    # mechanic's isolated manifest
  keyrack.host.foreman.age     # foreman's isolated manifest

/tmp/ (daemon sockets):
  keyrack.daemon.sock            # default daemon (no --for)
  keyrack.daemon.mechanic.sock   # mechanic's daemon
  keyrack.daemon.foreman.sock    # foreman's daemon

each manifest:
  - maps credential slugs to vault locations
  - includes ALL credentials (prod, prep, sudo)
  - encrypted to ssh key / yubikey â€” no passphrase
  - even credential names are hidden
  - tracks recipients who can decrypt

each daemon (in memory, session-scoped):
  - holds decrypted credentials after unlock
  - TTL-based expiration: 9h for regular, 30min for sudo
  - purged on relock or timeout
  - process-isolated from other owners
```

the separation is clean:
- **env credentials**: enumerated in repo (env.prod, env.prep), everyone knows they exist
- **sudo credentials**: enumerated only in encrypted host manifest, invisible to codebase
- **owner isolation**: each robot/agent has its own manifest and daemon, cannot access others

a developer with sudo access is indistinguishable from one without â€” until they unlock and use it.

**key-based locks** follow age's philosophy: keys are better than passphrases. developers already have ssh keys. ssh-agent is already active. keyrack leverages this instead of inventing its own passphrase system.

**per-owner isolation** ensures robots can only access their own credentials. mechanic cannot read foreman's keys, even on the same machine.
