# Demo: Invoking Claude Code with Isolated Context

This demo shows how to invoke Claude Code with restricted access to files, directories, and tools - useful for security, safety monitoring, or controlled environments.

## Why Isolated Contexts?

Isolated contexts allow you to:
- Limit Claude's access to specific directories or files
- Control which tools/commands Claude can execute
- Run Claude in sandboxed environments
- Monitor and filter external tool calls (like web searches)
- Provide only necessary context for specific tasks

## Isolation Technique 1: Working Directory + Tool Restrictions

### Basic Example: Restrict to Current Directory Only
```bash
# Create an isolated workspace
mkdir -p /tmp/claude-workspace
cd /tmp/claude-workspace

# Copy only the files you want Claude to access
cp ~/project/src/feature.ts .
cp ~/project/src/utils.ts .

# Run Claude with limited tools (no Bash, only Read/Edit)
claude --tools "Read,Edit,Write" "Fix type errors in feature.ts"

# Claude can only:
# - Read files in /tmp/claude-workspace
# - Edit files in /tmp/claude-workspace
# - Cannot execute arbitrary bash commands
# - Cannot access files outside this directory
```

### Disable All Tools (Pure Text Mode)
```bash
# Run Claude without any tool access - just text analysis
cat error.log | claude --tools "" "Analyze these errors and explain the root cause"

# Useful for:
# - Safe analysis of untrusted content
# - Code review without modification
# - Generating documentation from code
```

## Isolation Technique 2: Symlink-Based Partial Repository Access

### Example: Expose Only Specific Directories
```bash
#!/bin/bash
# create-isolated-view.sh

WORKSPACE="/tmp/claude-isolated-view"
REPO="/home/user/my-project"

# Create workspace
mkdir -p "$WORKSPACE"
cd "$WORKSPACE"

# Symlink only the directories you want to expose
ln -s "$REPO/src" ./src
ln -s "$REPO/tests" ./tests
ln -s "$REPO/package.json" ./package.json
ln -s "$REPO/tsconfig.json" ./tsconfig.json

# Do NOT link sensitive directories
# - .env files
# - .git directory
# - node_modules
# - private/ directory
# - credentials/

# Now run Claude in this isolated view
cd "$WORKSPACE"
claude "Add unit tests for the authentication module"

# Claude sees a limited view:
# /tmp/claude-isolated-view/
#   src/ -> /home/user/my-project/src
#   tests/ -> /home/user/my-project/tests
#   package.json -> /home/user/my-project/package.json
#   tsconfig.json -> /home/user/my-project/tsconfig.json
```

### Example: Expose Only Subset of `.briefs` Directory
```bash
#!/bin/bash
# isolate-briefs.sh

WORKSPACE="/tmp/claude-briefs-isolated"
REPO="/home/user/my-project"

mkdir -p "$WORKSPACE/.briefs"
cd "$WORKSPACE"

# Copy repo structure (without .git)
rsync -a --exclude='.git' --exclude='node_modules' "$REPO/" ./ --max-size=1M

# Replace .briefs with limited subset
rm -rf .briefs
mkdir -p .briefs

# Link only public/safe briefs
ln -s "$REPO/.briefs/architecture.md" .briefs/
ln -s "$REPO/.briefs/api-design.md" .briefs/
ln -s "$REPO/.briefs/testing-strategy.md" .briefs/

# Do NOT link sensitive briefs:
# - .briefs/security-audit.md
# - .briefs/production-credentials.md
# - .briefs/internal-roadmap.md

# Run Claude with this limited brief context
cd "$WORKSPACE"
claude "Review the architecture and suggest improvements"
```

## Isolation Technique 3: Allowed Tools Whitelist

### Example: Only Allow Safe Read-Only Operations
```bash
# Allow only file reading and searching
claude \
  --allowed-tools "Read,Grep,Glob,WebFetch" \
  "Analyze the codebase structure and document the API"

# Claude can:
# - Read files
# - Search code
# - Find files by pattern
# - Fetch web documentation
# But CANNOT:
# - Edit files
# - Run bash commands
# - Write new files
```

### Example: Allow Git But Not Other Bash Commands
```bash
# Allow only git commands, no other bash access
claude \
  --allowed-tools "Read,Edit,Bash(git:*)" \
  --disallowed-tools "Bash(rm:*),Bash(curl:*)" \
  "Review recent commits and suggest documentation updates"

# Claude can:
# - Run git commands (git status, git diff, etc.)
# - Read and edit files
# But CANNOT:
# - Run rm commands
# - Make network requests with curl
# - Execute arbitrary bash
```

### Example: Disable Dangerous Operations
```bash
# Deny potentially dangerous tools
claude \
  --disallowed-tools "Bash(rm:*),Bash(sudo:*),Bash(dd:*),Write" \
  "Refactor the authentication module"

# Prevents:
# - File deletion (rm)
# - Privilege escalation (sudo)
# - Low-level disk operations (dd)
# - Creating new files (Write tool)
```

## Isolation Technique 4: Container-Based Isolation

### Example: Docker Container with Limited Filesystem
```bash
# Dockerfile
cat > Dockerfile.claude-isolated << 'EOF'
FROM ubuntu:22.04

# Install Claude Code
RUN apt-get update && apt-get install -y curl
RUN curl -fsSL https://install.claude.ai | sh

# Create limited workspace
RUN mkdir -p /workspace
WORKDIR /workspace

# Copy only specific files
COPY src/ /workspace/src/
COPY tests/ /workspace/tests/
COPY package.json /workspace/

# No .env, no .git, no secrets
# The container has zero access to host filesystem beyond what's COPYed

ENTRYPOINT ["claude"]
EOF

# Build container
docker build -f Dockerfile.claude-isolated -t claude-isolated .

# Run Claude in isolated container
docker run -it --rm \
  --network none \
  -v "$(pwd)/src:/workspace/src:ro" \
  claude-isolated \
  "Review the code for security issues"

# Isolation guarantees:
# - No network access (--network none)
# - Read-only volume mount (:ro)
# - No access to host system
# - Limited to container filesystem
```

### Example: Docker with Controlled Network Access
```bash
# Allow network but route through monitoring proxy
docker run -it --rm \
  -e HTTP_PROXY=http://safety-monitor:8080 \
  -e HTTPS_PROXY=http://safety-monitor:8080 \
  -v "$(pwd)/src:/workspace/src" \
  claude-isolated \
  --allowed-tools "Read,Edit,WebFetch" \
  "Research best practices for this codebase and suggest improvements"

# All web requests go through safety-monitor proxy which can:
# - Log all requests
# - Block dangerous domains
# - Rate limit
# - Filter responses
```

## Isolation Technique 5: Custom MCP Server for Controlled Operations

### Example: Safe Web Search via Custom MCP Server
```bash
# Create a custom MCP server that provides safe web search
# mcp-safe-search.json
cat > mcp-safe-search.json << 'EOF'
{
  "mcpServers": {
    "safe-search": {
      "command": "node",
      "args": ["/path/to/safe-search-mcp-server.js"],
      "description": "Web search with safety filtering"
    }
  }
}
EOF

# The safe-search MCP server can:
# - Filter search queries
# - Block certain domains
# - Rate limit requests
# - Log all searches
# - Sanitize results

# Run Claude with ONLY this MCP server (strict mode)
claude \
  --strict-mcp-config \
  --mcp-config mcp-safe-search.json \
  --tools "Read" \
  "Search for best practices for authentication and update our docs"

# Claude can:
# - Read local files
# - Use safe-search MCP tool (monitored)
# But CANNOT:
# - Use built-in WebFetch (unrestricted)
# - Access other MCP servers
# - Execute bash commands
```

### Safe Search MCP Server Implementation (Node.js)
```typescript
// safe-search-mcp-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const BLOCKED_DOMAINS = ['malware.com', 'untrusted.net'];
const RATE_LIMIT = 10; // requests per minute

class SafeSearchServer {
  private requestCount = 0;

  async search(query: string): Promise<string> {
    // 1. Validate query
    if (this.containsDangerousPatterns(query)) {
      throw new Error('Query contains potentially dangerous patterns');
    }

    // 2. Check rate limit
    if (this.requestCount >= RATE_LIMIT) {
      throw new Error('Rate limit exceeded');
    }
    this.requestCount++;

    // 3. Perform search (with safety filters)
    const results = await this.performSearch(query);

    // 4. Filter results
    const safeResults = results.filter(r =>
      !BLOCKED_DOMAINS.some(domain => r.url.includes(domain))
    );

    // 5. Log the search
    console.error(`[AUDIT] Search query: ${query}, Results: ${safeResults.length}`);

    return JSON.stringify(safeResults);
  }

  private containsDangerousPatterns(query: string): boolean {
    const dangerousPatterns = [
      /exploit/i,
      /hack/i,
      /crack/i,
    ];
    return dangerousPatterns.some(p => p.test(query));
  }

  private async performSearch(query: string): Promise<any[]> {
    // Implementation using safe search API
    // (e.g., Google Safe Browsing API, filtered Brave Search, etc.)
    return [];
  }
}

// Set up MCP server
const server = new Server({
  name: 'safe-search',
  version: '1.0.0',
});

server.setRequestHandler('tools/list', async () => ({
  tools: [{
    name: 'safe_search',
    description: 'Search the web with safety filtering and monitoring',
    inputSchema: {
      type: 'object',
      properties: {
        query: { type: 'string' }
      },
      required: ['query']
    }
  }]
}));

const searchServer = new SafeSearchServer();
server.setRequestHandler('tools/call', async (request) => {
  if (request.params.name === 'safe_search') {
    return {
      content: [{
        type: 'text',
        text: await searchServer.search(request.params.arguments.query)
      }]
    };
  }
  throw new Error('Unknown tool');
});

const transport = new StdioServerTransport();
server.connect(transport);
```

## Isolation Technique 6: Chroot-Style Isolation

### Example: Create Minimal Filesystem View
```bash
#!/bin/bash
# create-chroot-workspace.sh

CHROOT="/tmp/claude-chroot"

# Create minimal filesystem
mkdir -p "$CHROOT"/{bin,lib,lib64,usr,workspace}

# Copy only essential binaries (if Claude needs them)
cp /bin/bash "$CHROOT/bin/"
cp /bin/ls "$CHROOT/bin/"

# Copy required libraries
ldd /bin/bash | grep "=>" | awk '{print $3}' | xargs -I {} cp {} "$CHROOT/lib/"

# Set up workspace with project files
cp -r ~/project/src "$CHROOT/workspace/"

# Run Claude with chroot (requires root)
sudo chroot "$CHROOT" /bin/bash -c "
  cd /workspace
  claude 'Review the code in src/'
"

# Claude is completely isolated to $CHROOT filesystem
# No access to parent directories, /etc, /home, etc.
```

## Isolation Technique 7: Combined Multi-Layer Isolation

### Example: Production-Grade Isolated Environment
```bash
#!/bin/bash
# run-claude-isolated.sh

# Layer 1: Container isolation
# Layer 2: Filesystem restrictions
# Layer 3: Tool whitelist
# Layer 4: Network monitoring
# Layer 5: Custom MCP with audit logging

docker run -it --rm \
  --name claude-isolated \
  --network monitoring-network \
  --read-only \
  --tmpfs /tmp \
  -v "$(pwd)/safe-workspace:/workspace:ro" \
  -v "$(pwd)/mcp-config.json:/config/mcp.json:ro" \
  claude-isolated-image \
  --tools "Read,Grep,Glob" \
  --allowed-tools "mcp__safe-search__*" \
  --strict-mcp-config \
  --mcp-config /config/mcp.json \
  --dangerously-skip-permissions \
  --append-system-prompt "You are operating in a restricted environment. All web searches are logged and monitored." \
  "Analyze the codebase and suggest security improvements"

# This provides:
# ✓ Container isolation
# ✓ Read-only filesystem (except /tmp)
# ✓ Monitored network access
# ✓ Limited tools (only Read, Grep, Glob)
# ✓ Safe search via custom MCP
# ✓ Audit logging
# ✓ No write access to workspace
```

## Practical Use Cases

### Use Case 1: Code Review Bot (Untrusted Code)
```bash
# Review PR without allowing code execution
PR_NUMBER=$1

# Create isolated workspace
WORKSPACE="/tmp/pr-review-$PR_NUMBER"
mkdir -p "$WORKSPACE"

# Fetch PR diff
gh pr diff "$PR_NUMBER" > "$WORKSPACE/changes.diff"

# Run Claude with zero execution permissions
cd "$WORKSPACE"
claude \
  --tools "" \
  "Review this PR for security issues, code quality, and best practices:" \
  < changes.diff > review.md

# Safe because:
# - No tool access
# - Isolated workspace
# - Cannot execute code
# - Cannot modify files
```

### Use Case 2: Documentation Generator (Limited Context)
```bash
# Generate docs with access to only public API
WORKSPACE="/tmp/doc-gen"
mkdir -p "$WORKSPACE"

# Copy only public interface files
find src/ -name "*.public.ts" -exec cp {} "$WORKSPACE/" \;

cd "$WORKSPACE"
claude \
  --tools "Read,Write" \
  --disallowed-tools "Bash(*)" \
  "Generate API documentation for all files in current directory"

# Only sees public APIs, not internal implementation
```

### Use Case 3: CI/CD Integration (Sandboxed)
```bash
# In CI pipeline - analyze test failures safely
#!/bin/bash

# Run tests and capture output
npm test 2>&1 | tee test-output.log || true

# Analyze in container with no repo access
docker run --rm \
  -v "$(pwd)/test-output.log:/input/test-output.log:ro" \
  -v "$(pwd)/analysis:/output" \
  --network none \
  claude-isolated \
  --tools "" \
  "Analyze test failures and suggest fixes:" \
  < /input/test-output.log \
  > /output/analysis.md

# Upload analysis
cat analysis/analysis.md | gh issue comment "$ISSUE_NUMBER" --body-file -
```

## Security Considerations

### Best Practices
1. **Principle of Least Privilege**: Only grant the minimum tools/access needed
2. **Defense in Depth**: Combine multiple isolation techniques
3. **Audit Logging**: Log all tool usage in isolated environments
4. **Network Isolation**: Use `--network none` or monitoring proxies
5. **Read-Only Mounts**: Use `:ro` flag for Docker volumes when possible
6. **Timeout Limits**: Set execution timeouts for isolated sessions
7. **Resource Limits**: Use container resource limits (CPU, memory)

### Dangerous Patterns to Avoid
```bash
# ❌ BAD: Mounting entire home directory
docker run -v "$HOME:/workspace" claude-isolated

# ✓ GOOD: Mount specific project directory only
docker run -v "$HOME/project/public:/workspace:ro" claude-isolated

# ❌ BAD: Running with --dangerously-skip-permissions on untrusted code
claude --dangerously-skip-permissions "Review this untrusted code"

# ✓ GOOD: Use permissions in non-sandboxed environments
claude "Review this code"  # Asks for permission before tool use

# ❌ BAD: Allowing unrestricted Bash access
claude --allowed-tools "Bash(*)"

# ✓ GOOD: Whitelist specific safe commands
claude --allowed-tools "Bash(git:*),Bash(npm:test)"
```

## Environment Variables for Isolation

```bash
# Limit Claude's awareness of system
export HOME=/tmp/fake-home
export USER=isolated-user
export SHELL=/bin/sh

# Prevent access to user-level configs
unset ANTHROPIC_API_KEY  # Force re-auth or use explicit key
unset CLAUDE_CONFIG_PATH

# Run with isolated environment
env -i \
  HOME=/tmp/fake-home \
  PATH=/usr/bin:/bin \
  claude "Task in isolated environment"
```

## Monitoring and Auditing

### Example: Log All Tool Calls
```bash
# Wrapper script that logs all Claude activity
cat > claude-audited.sh << 'EOF'
#!/bin/bash

AUDIT_LOG="/var/log/claude-audit.log"

echo "$(date -Is) [START] User: $USER, PWD: $PWD, Args: $*" >> "$AUDIT_LOG"

# Run Claude with monitoring
claude "$@" 2>&1 | tee -a "$AUDIT_LOG"

EXIT_CODE=${PIPESTATUS[0]}
echo "$(date -Is) [END] Exit Code: $EXIT_CODE" >> "$AUDIT_LOG"

exit $EXIT_CODE
EOF

chmod +x claude-audited.sh

# Use audited wrapper
./claude-audited.sh --tools "Read,Edit" "Fix the bug"
```

## Summary

Isolation techniques from most restrictive to least:

1. **No Tools** (`--tools ""`) - Pure analysis, no file access
2. **Read-Only** (`--tools "Read,Grep,Glob"`) - Can read but not modify
3. **Tool Whitelist** (`--allowed-tools "specific,tools"`) - Limited capabilities
4. **Directory Restriction** (working directory + symlinks) - Limited scope
5. **Container Isolation** (Docker with network/volume restrictions) - System-level
6. **Custom MCP** (filtered/monitored external operations) - Controlled integrations

Choose the appropriate level based on:
- Trust level of the code/environment
- Required capabilities
- Security requirements
- Monitoring needs

Remember: Isolation is about reducing risk, not eliminating it. Always validate Claude's output before using it in production.
