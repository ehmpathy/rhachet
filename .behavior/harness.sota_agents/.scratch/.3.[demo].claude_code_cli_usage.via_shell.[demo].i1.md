# Demo: Invoking Claude Code via Shell

This demo shows various ways to invoke Claude Code from the shell for automation, scripting, and integration purposes.

## Basic Usage

### 1. Interactive Mode (Default)
```bash
# Start an interactive session
claude
```

### 2. Single Prompt Mode
```bash
# Execute a single prompt and exit
claude "List all TypeScript files in src/"

# With output to file
claude "Explain this codebase structure" > explanation.md
```

### 3. Piping Input
```bash
# Pipe content to Claude
echo "Explain this error: TypeError: Cannot read property 'foo' of undefined" | claude

# Process file content
cat error.log | claude "Analyze these errors and suggest fixes"

# Chain with other commands
git diff | claude "Review this diff and suggest improvements"
```

## Advanced Shell Integration

### 4. Using stdin with Here Documents
```bash
# Multi-line input
claude << EOF
Please review this code:
$(cat src/main.ts)

Focus on:
- Error handling
- Type safety
- Performance
EOF
```

### 5. Batch Processing
```bash
# Process multiple files
for file in src/**/*.ts; do
  echo "=== Processing $file ==="
  claude "Add JSDoc comments to this code:" < "$file" > "${file}.documented"
done
```

### 6. Integration with CI/CD
```bash
# In a CI pipeline
#!/bin/bash
set -e

# Run tests and get analysis
test_output=$(npm test 2>&1) || true

echo "$test_output" | claude "Analyze these test failures and suggest fixes" > analysis.md

# Create GitHub issue if there are failures
if [ $? -ne 0 ]; then
  gh issue create --title "Test Failures" --body "$(cat analysis.md)"
fi
```

### 7. Using with Environment Variables
```bash
# Set API key
export ANTHROPIC_API_KEY="your-key-here"

# Configure model preference
export CLAUDE_MODEL="claude-sonnet-4-5-20250929"

# Then invoke
claude "Hello, Claude!"
```

### 8. Non-Interactive Automation
```bash
# Generate code review report
review_report() {
  local branch=$1
  git diff main..."$branch" | claude "
    Create a code review report with:
    1. Summary of changes
    2. Potential issues
    3. Security concerns
    4. Performance impacts
  " > "review-${branch}.md"
}

review_report feature-branch
```

### 9. Command Substitution
```bash
# Use Claude's output in scripts
commit_message=$(git diff --staged | claude "Write a concise commit message for these changes")
git commit -m "$commit_message"
```

### 10. Error Analysis Pipeline
```bash
# Automated error analysis
analyze_logs() {
  tail -n 100 /var/log/app.log | \
    grep ERROR | \
    claude "Categorize these errors and provide solutions" | \
    mail -s "Daily Error Report" dev-team@example.com
}
```

## Scripting Examples

### Example 1: Automated Documentation
```bash
#!/bin/bash
# generate-docs.sh

echo "Generating documentation for codebase..."

# Get file structure
tree -I 'node_modules|dist' > /tmp/structure.txt

# Generate overview
claude << EOF > docs/ARCHITECTURE.md
Based on this project structure:
$(cat /tmp/structure.txt)

And these key files:
$(cat src/index.ts)
$(cat package.json)

Create an architecture overview document.
EOF

echo "Documentation generated at docs/ARCHITECTURE.md"
```

### Example 2: Code Quality Gate
```bash
#!/bin/bash
# quality-check.sh

echo "Running quality checks..."

# Get code to review
code_changes=$(git diff main...HEAD)

# Ask Claude to review
review=$(echo "$code_changes" | claude "
Review this code for:
- Security vulnerabilities
- Code smells
- Best practice violations

Return 'PASS' or 'FAIL' followed by issues.
")

# Check result
if echo "$review" | grep -q "^FAIL"; then
  echo "Quality gate failed:"
  echo "$review"
  exit 1
else
  echo "Quality gate passed!"
  exit 0
fi
```

### Example 3: Interactive Shell Helper
```bash
# Add to .bashrc or .zshrc

# Quick code explanation
explain() {
  local file=$1
  [ -f "$file" ] || { echo "File not found: $file"; return 1; }
  claude "Explain what this code does concisely:" < "$file"
}

# Quick refactor suggestion
refactor() {
  local file=$1
  [ -f "$file" ] || { echo "File not found: $file"; return 1; }
  claude "Suggest refactoring improvements for:" < "$file"
}

# Usage:
# explain src/utils.ts
# refactor src/legacy.js
```

## Tips for Shell Integration

1. **Use quotes properly**: Wrap multi-line prompts in quotes or use here-docs
2. **Handle exit codes**: Check `$?` for success/failure
3. **Stream large outputs**: Use `>` or `tee` to handle large responses
4. **Combine with tools**: Integrate with git, grep, awk, etc.
5. **Error handling**: Wrap in try-catch equivalent (`set -e`, `|| true`)
6. **Environment setup**: Use `.env` files or export variables
7. **Rate limiting**: Add delays between calls in loops

## Common Patterns

```bash
# Pattern 1: Analyze → Decide → Act
analysis=$(git status | claude "Should I commit these changes? Yes/No with reason")
if echo "$analysis" | grep -q "Yes"; then
  git add . && git commit -m "Auto commit"
fi

# Pattern 2: Filter → Transform → Output
find . -name "*.ts" -type f | \
  head -10 | \
  xargs -I {} claude "Generate test file for {}" > tests/auto-generated.test.ts

# Pattern 3: Watch → Detect → Alert
tail -f app.log | \
  grep --line-buffered ERROR | \
  xargs -I {} claude "Severity level (1-10) for: {}"
```

## Notes

- Claude Code respects standard input/output conventions
- Exit codes indicate success (0) or failure (non-zero)
- Supports both streaming and batch modes
- Can be integrated into any shell script or automation workflow
- Works with pipes, redirects, and process substitution
- Compatible with CI/CD platforms (GitHub Actions, GitLab CI, Jenkins, etc.)
