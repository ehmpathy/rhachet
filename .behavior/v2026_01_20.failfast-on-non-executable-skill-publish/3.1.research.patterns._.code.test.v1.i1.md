# research: test codepath patterns

## summary

the `invokeRepoIntrospect` command has comprehensive integration tests that cover yaml generation, file output, and package.json updates. the test patterns include temp directory setup, console.log spy, error capture via `getError()`, and file permission management via `chmodSync`. we need to extend the test suite with cases for non-executable skill detection.

---

## pattern.1 = temp directory setup for integration tests

**[REUSE]**

### file
`src/contract/cli/invokeRepoIntrospect.integration.test.ts`

### description
test setup creates a `.temp/` subdirectory under `__dirname` with complete mock rhachet-roles-* package structure.

### citations

[1] test directory and cwd management (lines 15-18, 93-97):
```ts
describe('invokeRepoIntrospect (integration)', () => {
  given('a CLI program with invokeRepoIntrospect registered', () => {
    const testDir = resolve(__dirname, './.temp/invokeRepoIntrospect');
    const originalCwd = process.cwd();
```

```ts
    afterAll(() => {
      process.chdir(originalCwd);
      // cleanup test directory
      rmSync(testDir, { recursive: true, force: true });
    });
```

[2] git init for getGitRepoRoot (lines 24-29):
```ts
      // initialize as a git repo for getGitRepoRoot to work
      try {
        execSync('git init', { cwd: testDir, stdio: 'pipe' });
      } catch {
        // already a git repo
      }
```

[3] mock package.json setup (lines 31-43):
```ts
      // create package.json with rhachet-roles-* name and main entry point
      writeFileSync(
        resolve(testDir, 'package.json'),
        JSON.stringify(
          {
            name: 'rhachet-roles-test',
            version: '1.0.0',
            main: 'dist/index.js',
          },
          null,
          2,
        ),
      );
```

### relationship to wish
reuse this pattern for new test cases. for non-executable skill tests, add `.sh` files to the mock skills directory WITHOUT chmod to make them non-executable.

---

## pattern.2 = mock getRoleRegistry export

**[EXTEND]**

### file
`src/contract/cli/invokeRepoIntrospect.integration.test.ts`

### description
creates a dist/index.js that exports `getRoleRegistry()` with mock Role and RoleRegistry objects.

### citations

[4] mock registry with skills.dirs (lines 48-76):
```ts
      // create dist/index.js that exports getRoleRegistry
      writeFileSync(
        resolve(testDir, 'dist/index.js'),
        `
const { RoleRegistry, Role } = require('${resolve(__dirname, '../../domain.objects')}');

const testDir = '${testDir}';

const mechanic = new Role({
  slug: 'mechanic',
  name: 'Mechanic',
  purpose: 'fix things',
  readme: { uri: testDir + '/src/roles/mechanic/readme.md' },
  traits: [],
  briefs: { dirs: { uri: testDir + '/src/roles/mechanic/briefs' } },
  skills: {
    dirs: { uri: testDir + '/src/roles/mechanic/skills' },
    refs: [],
  },
});

const registry = new RoleRegistry({
  slug: 'ehmpathy',
  readme: { uri: testDir + '/readme.md' },
  roles: [mechanic],
});

exports.getRoleRegistry = () => registry;
`,
      );
```

### relationship to wish
extend this pattern to add actual `.sh` files to the skills directory. for failure cases, omit `chmodSync` to leave files non-executable.

---

## pattern.3 = console.log spy for output assertions

**[REUSE]**

### file
`src/contract/cli/invokeRepoIntrospect.integration.test.ts`

### description
spy on console.log to capture and assert on command output messages.

### citations

[5] spy setup and clear (lines 99-104):
```ts
    const program = new Command('rhachet');
    const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

    beforeEach(() => {
      logSpy.mockClear();
      process.chdir(testDir);
```

[6] log assertion pattern (lines 148-154):
```ts
      then('logs success message', async () => {
        await program.parseAsync(['repo', 'introspect'], { from: 'user' });

        const logs = logSpy.mock.calls.map((c) => c.join(' ')).join('\n');
        expect(logs).toContain('Done');
        expect(logs).toContain('rhachet.repo.yml');
      });
```

### relationship to wish
reuse this pattern to assert that error messages list the non-executable skill paths when validation fails.

---

## pattern.4 = bdd test structure with test-fns

**[REUSE]**

### file
`src/contract/cli/invokeRepoIntrospect.integration.test.ts`

### description
uses `given`, `when`, `then` from `test-fns` for readable test structure.

### citations

[7] import and structure (lines 3, 115-155):
```ts
import { given, then, when } from 'test-fns';
```

```ts
    when('[t0] repo introspect is invoked with default output', () => {
      then('it creates rhachet.repo.yml file', async () => {
        await program.parseAsync(['repo', 'introspect'], { from: 'user' });

        const outputPath = resolve(testDir, 'rhachet.repo.yml');
        expect(existsSync(outputPath)).toBe(true);
      });

      then('yaml contains registry slug', async () => {
        await program.parseAsync(['repo', 'introspect'], { from: 'user' });

        const outputPath = resolve(testDir, 'rhachet.repo.yml');
        const content = readFileSync(outputPath, 'utf8');
        expect(content).toContain('slug: ehmpathy');
      });
```

### relationship to wish
follow this pattern for new test cases. add `when('[tN] skills directory contains non-executable .sh files')` scenarios.

---

## pattern.5 = file permission setup with chmodSync

**[REUSE]**

### file
`src/contract/cli/invokeRolesLink.integration.test.ts`

### description
uses `chmodSync` with octal mode to set executable permissions on skill files.

### citations

[8] create executable skill files (lines 77-87):
```ts
      // Create mock skill files (with execute bit, as git would preserve)
      writeFileSync(
        resolve(skillsDir, 'skill1.sh'),
        '#!/bin/bash\n# Skill 1\necho "test skill 1"',
      );
      chmodSync(resolve(skillsDir, 'skill1.sh'), 0o755);
      writeFileSync(
        resolve(skillsDir, 'skill2.sh'),
        '#!/bin/bash\n# Skill 2\necho "test skill 2"',
      );
      chmodSync(resolve(skillsDir, 'skill2.sh'), 0o755);
```

### relationship to wish
reuse for success cases (executable skills). for failure cases, omit `chmodSync` after `writeFileSync` — files default to non-executable (0o644).

---

## pattern.6 = file permission assertions with statSync

**[REUSE]**

### file
`src/contract/cli/invokeRolesLink.integration.test.ts`

### description
reads file mode with `statSync` and masks with `0o777` to assert on permission bits.

### citations

[9] execute bit assertion (lines 284-288):
```ts
          const skill1Stats = statSync(skill1Path);
          // eslint-disable-next-line no-bitwise
          const skill1Mode = skill1Stats.mode & 0o777;
          expect(skill1Mode & 0o200).toBe(0o200); // owner write bit set
          expect(skill1Mode & 0o111).toBe(0o111); // execute bits set (rwx r-x r-x)
```

[10] exact mode assertion (lines 647-650):
```ts
        const skillStats = statSync(skillPath);
        // eslint-disable-next-line no-bitwise
        const skillMode = skillStats.mode & 0o777;
        expect(skillMode).toBe(0o555);
```

### relationship to wish
use this pattern to verify test setup — confirm that non-executable files lack execute bits before command invocation.

---

## pattern.7 = error capture with getError

**[REUSE]**

### file
`src/domain.operations/actor/genActor.test.ts`

### description
uses `getError()` from `test-fns` to capture errors from async operations for assertions.

### citations

[11] import and usage (lines 1, 93-95):
```ts
import { getError, given, then, when } from 'test-fns';
```

```ts
        const error = await getError(() =>
          genActor({ role: testRole, brains: [] }),
        );
```

[12] error message assertion (from findActorRoleSkillBySlug.test.ts lines 101-110):
```ts
            const error = await getError(() =>
              findActorRoleSkillBySlug({
                slug: 'wordcount',
                role: testRole,
              }),
            );

            expect(error).toBeInstanceOf(BadRequestError);
            expect(error?.message).toContain('skill "wordcount" not found');
```

### relationship to wish
use this pattern for failure case tests. capture error from `program.parseAsync()` and assert that error message contains non-executable file paths.

---

## pattern.8 = genTestTempDir helper

**[REUSE]**

### file
`src/.test/infra/genTestTempDir.ts`

### description
utility that provides setup/teardown for managed temp directories with cwd switch.

### citations

[13] full implementation (lines 8-43):
```ts
export const genTestTempDir = (input: {
  /** base directory (typically __dirname) */
  base: string;
  /** subdirectory name under .temp */
  name: string;
}): {
  /** absolute path to the test directory */
  path: string;
  /** call in beforeAll to setup directory and switch cwd */
  setup: () => void;
  /** call in afterAll to restore original cwd */
  teardown: () => void;
  /** call to remove a file or directory within the test dir */
  rm: (relativePath: string) => void;
} => {
  const testDir = resolve(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,

    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },

    teardown: () => {
      process.chdir(originalCwd);
    },

    rm: (relativePath: string) => {
      rmSync(resolve(testDir, relativePath), { force: true, recursive: true });
    },
  };
};
```

### relationship to wish
can optionally use this helper instead of manual setup/teardown if refactored. prior introspect tests use manual approach.

---

## pattern.9 = beforeEach state reset

**[REUSE]**

### file
`src/contract/cli/invokeRepoIntrospect.integration.test.ts`

### description
uses `beforeEach` within `when` blocks to reset test state for each test case.

### citations

[14] cleanup prior output (lines 102-111):
```ts
    beforeEach(() => {
      logSpy.mockClear();
      process.chdir(testDir);

      // cleanup any prior rhachet.repo.yml
      const outputPath = resolve(testDir, 'rhachet.repo.yml');
      if (existsSync(outputPath)) {
        rmSync(outputPath);
      }
    });
```

[15] reset package.json for specific tests (lines 207-222):
```ts
    when('[t3] package.json has no files array', () => {
      beforeEach(() => {
        // reset package.json without files array
        writeFileSync(
          resolve(testDir, 'package.json'),
          JSON.stringify(
            {
              name: 'rhachet-roles-test',
              version: '1.0.0',
              main: 'dist/index.js',
            },
            null,
            2,
          ),
        );
      });
```

### relationship to wish
reuse this pattern for test cases that need different skill file configurations. reset skills directory content in `beforeEach`.

---

## pattern.10 = commander parseAsync invocation

**[REUSE]**

### file
`src/contract/cli/invokeRepoIntrospect.integration.test.ts`

### description
invokes cli commands via `program.parseAsync()` with args array.

### citations

[16] command invocation (lines 117, 159):
```ts
        await program.parseAsync(['repo', 'introspect'], { from: 'user' });
```

```ts
        await program.parseAsync(['repo', 'introspect', '-o', '-'], {
          from: 'user',
        });
```

### relationship to wish
reuse this invocation pattern. for failure cases, wrap in `getError()` to capture thrown BadRequestError.

---

## summary of patterns

| pattern | disposition | rationale |
|---------|-------------|-----------|
| temp directory setup | **[REUSE]** | same structure for new test cases |
| mock getRoleRegistry | **[EXTEND]** | add .sh files to skills dir for validation tests |
| console.log spy | **[REUSE]** | assert on error message output |
| bdd test structure | **[REUSE]** | follow given/when/then format |
| chmodSync for permissions | **[REUSE]** | set executable for success, omit for failure |
| statSync mode assertions | **[REUSE]** | verify test setup (non-executable bits) |
| getError for exceptions | **[REUSE]** | capture BadRequestError for assertions |
| genTestTempDir helper | **[REUSE]** | optional, prior tests use manual approach |
| beforeEach state reset | **[REUSE]** | reset skills directory per test case |
| parseAsync invocation | **[REUSE]** | wrap in getError for failure cases |

---

## new test scenarios needed

based on blackbox criteria, add these test cases:

```
when('[tN] skills directory contains only executable .sh files')
  then('command succeeds with exit code 0')
  then('rhachet.repo.yml is generated')

when('[tN+1] skills directory contains a non-executable .sh file')
  then('command fails')
  then('error message contains path to non-executable file')
  then('rhachet.repo.yml is NOT generated')

when('[tN+2] skills directory contains multiple non-executable .sh files')
  then('error message lists ALL non-executable files')

when('[tN+3] skills directory contains only .ts/.md files')
  then('command succeeds (no .sh files to check)')

when('[tN+4] role has no skills directory')
  then('command succeeds')
```
