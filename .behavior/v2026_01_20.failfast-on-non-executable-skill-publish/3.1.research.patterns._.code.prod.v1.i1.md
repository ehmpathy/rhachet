# research: production codepath patterns

## summary

the `npx rhachet repo introspect` command generates `rhachet.repo.yml` from a `rhachet-roles-*` package's `getRoleRegistry()` export. the command currently performs no validation of skill file executability. we need to extend the introspect flow to validate that all `.sh` files in skills directories are executable before manifest generation.

---

## pattern.1 = cli command entry point

**[EXTEND]**

### file
`src/contract/cli/invokeRepoIntrospect.ts`

### description
the entry point for `repo introspect` command. registers with commander, performs validation, calls `getRoleRegistry()`, and generates manifest.

### citations

[1] command registration and fail-fast validation (lines 21-54):
```ts
export const invokeRepoIntrospect = ({
  program,
}: {
  program: Command;
}): void => {
  const repoCommand = program
    .command('repo')
    .description('repository management commands');

  repoCommand
    .command('introspect')
    .description(
      'generate rhachet.repo.yml from package getRoleRegistry export',
    )
    .option(
      '-o, --output <path>',
      'output path (default: rhachet.repo.yml, use "-" for stdout)',
      'rhachet.repo.yml',
    )
    .action(async (options: { output: string }) => {
      const cwd = process.cwd();
      const gitRoot = await getGitRepoRoot({ from: cwd });

      // read package.json to get package name
      const packageJsonPath = resolve(gitRoot, 'package.json');
      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
      const packageName: string = packageJson.name;

      // fail fast if not a rhachet-roles-* package
      if (!packageName.startsWith('rhachet-roles-'))
        throw new BadRequestError(
          `repo introspect must be run inside a rhachet-roles-* package`,
          { packageName },
        );
```

[2] registry load and manifest generation (lines 69-85):
```ts
      // fail fast if getRoleRegistry not exported
      if (!packageExports.getRoleRegistry)
        throw new BadRequestError(`package does not export getRoleRegistry`, {
          packageName,
        });

      const registry = packageExports.getRoleRegistry();

      // generate manifest
      console.log(``);
      console.log(`✨ Generate manifest for "${registry.slug}"...`);

      const manifest = castIntoRoleRegistryManifest({
        registry,
        packageRoot: gitRoot,
      });
      const yaml = serializeRoleRegistryManifest({ manifest });
```

### relationship to wish
this is where skill executability validation should be inserted — after `getRoleRegistry()` returns the registry but before `castIntoRoleRegistryManifest()` generates the manifest. the registry contains `skills.dirs` with absolute paths to skill directories.

---

## pattern.2 = Role domain object with skills.dirs

**[REUSE]**

### file
`src/domain.objects/Role.ts`

### description
the Role interface defines `skills.dirs` which holds references to skill directories. this is the data source for skill file enumeration.

### citations

[3] skills.dirs structure (lines 84-99):
```ts
  skills: {
    /**
     * .what = solid skills (deterministic, no brain)
     * .why = type-safe .run() invocation
     */
    solid?: TSolid;

    /**
     * .what = rigid skills (deterministic harness, brain operations)
     * .why = type-safe .act() invocation
     */
    rigid?: TRigid;

    dirs: { uri: string } | { uri: string }[];
    refs: RoleSkill<any>[];
  };
```

[4] comment on directory-based skills (lines 79-82):
```ts
   *   - dirs: directory-based skills (e.g., .sh scripts) for link/boot
   *     - single { uri: string }: symlinks this dir as the full skills dir
   *     - array { uri: string }[]: symlinks each dir within the skills dir
```

### relationship to wish
`skills.dirs` contains the absolute paths to skill directories. we can enumerate files from these directories to find `.sh` files and check their executability.

---

## pattern.3 = recursive file enumeration

**[REUSE]**

### file
`src/infra/filesystem/getAllFilesFromDir.ts`

### description
utility that recursively collects all files from a directory, with graceful symlink error handle.

### citations

[5] full implementation (lines 9-36):
```ts
export const getAllFilesFromDir = (dir: string): string[] => {
  // skip if directory does not exist
  if (!existsSync(dir)) return [];

  const entries = readdirSync(dir);
  const files: string[] = [];

  for (const entry of entries) {
    const fullPath = resolve(dir, entry);

    // skip broken symlinks gracefully
    let stats: ReturnType<typeof statSync>;
    try {
      stats = statSync(fullPath);
    } catch (error: unknown) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') continue;
      throw error;
    }

    if (stats.isDirectory()) {
      files.push(...getAllFilesFromDir(fullPath));
    } else if (stats.isFile()) {
      files.push(fullPath);
    }
  }

  return files;
};
```

### relationship to wish
reuse this utility to enumerate all files in skill directories, then filter to `.sh` files for executability checks.

---

## pattern.4 = shell skill slug extraction

**[REUSE]**

### file
`src/domain.operations/invoke/discoverSkillExecutables.ts`

### description
shows the pattern for how `.sh` files are identified as skills.

### citations

[6] .sh extension detection (lines 11-15):
```ts
const extractSlugFromFilename = (filename: string): string => {
  // remove .sh extension if present
  if (filename.endsWith('.sh')) return filename.slice(0, -3);
  return filename;
};
```

### relationship to wish
confirms that `.sh` files are the target for executability validation. any file with `.sh` extension in a skills directory should be executable.

---

## pattern.5 = BadRequestError fail-fast pattern

**[REUSE]**

### file
`src/contract/cli/invokeRepoIntrospect.ts` (and many others)

### description
errors use `BadRequestError` from `helpful-errors` with descriptive messages and metadata context.

### citations

[7] fail-fast with metadata (lines 49-54):
```ts
      // fail fast if not a rhachet-roles-* package
      if (!packageName.startsWith('rhachet-roles-'))
        throw new BadRequestError(
          `repo introspect must be run inside a rhachet-roles-* package`,
          { packageName },
        );
```

[8] validation error pattern from getRoleRegistryManifest.ts (lines 127-132):
```ts
  // validate against raw schema
  const result = schemaRoleRegistryManifestRaw.safeParse(parsed);
  if (!result.success)
    throw new BadRequestError('rhachet.repo.yml has invalid schema', {
      packageRoot: input.packageRoot,
      manifestPath,
      errors: result.error.issues,
    });
```

### relationship to wish
use the same `BadRequestError` pattern with metadata that includes the list of non-executable skill paths. this enables clear error messages that identify exactly which files need to be fixed.

---

## pattern.6 = manifest generation from registry

**[REUSE]**

### file
`src/domain.operations/manifest/castIntoRoleRegistryManifest.ts`

### description
transforms a `RoleRegistry` into serializable manifest format. extracts `skills.dirs` from each role.

### citations

[9] extractDirUris helper (lines 42-47):
```ts
const extractDirUris = (
  dirs: { uri: string } | { uri: string }[],
): string[] => {
  if (Array.isArray(dirs)) return dirs.map((d) => d.uri);
  return [dirs.uri];
};
```

[10] skills.dirs transformation (lines 76-79):
```ts
  // transform skills dirs
  const skillsDirs = extractDirUris(role.skills.dirs).map((uri) =>
    makeRelative({ absolutePath: uri, packageRoot }),
  );
```

### relationship to wish
the `extractDirUris` helper shows how to normalize `skills.dirs` (single vs array) into a flat array of directory paths. reuse this pattern for the validation logic.

---

## pattern.7 = RoleRegistry domain object

**[REUSE]**

### file
`src/domain.objects/RoleRegistry.ts`

### description
the registry contains an array of `Role` objects, each with their own `skills.dirs`.

### citations

[11] registry structure (lines 16-42):
```ts
export interface RoleRegistry {
  /**
   * .what = unique identifier for this registry
   * .note = this is also used as the "repo" slug in CLI commands
   */
  slug: string;

  /**
   * .what = reference to markdown file with overview of what this registry contains
   * .why = provides documentation, context, and intended use
   */
  readme: { uri: string };

  /**
   * .what = the roles that this registry has collected
   */
  roles: Role[];
}
```

### relationship to wish
the registry's `roles` array is the iteration target. for each role, extract `skills.dirs`, enumerate files, filter to `.sh`, and check executability.

---

## pattern.8 = no current permission check

**[NEW PATTERN NEEDED]**

### observation
there is NO current production code that checks file permissions (no `accessSync` with `X_OK` or `constants.X_OK` in src/).

### citations

[12] grep result for permission checks:
```
grep -r "accessSync|constants\.(X_OK|R_OK)" src/
# No matches found
```

### relationship to wish
a new validation operation is needed: `assertSkillsExecutable` or similar that:
1. takes `skills.dirs` from a Role
2. enumerates all `.sh` files
3. checks each for execute permission via `accessSync(path, constants.X_OK)`
4. collects non-executable paths
5. throws `BadRequestError` if any found

---

## summary of patterns

| pattern | disposition | rationale |
|---------|-------------|-----------|
| cli command entry point | **[EXTEND]** | add validation call after registry load, before manifest generation |
| Role.skills.dirs | **[REUSE]** | data source for skill directories |
| getAllFilesFromDir | **[REUSE]** | enumerate files recursively from skill dirs |
| .sh extension detection | **[REUSE]** | filter files to shell skills |
| BadRequestError pattern | **[REUSE]** | error format with metadata for non-executable list |
| extractDirUris helper | **[REUSE]** | normalize skills.dirs to flat array |
| RoleRegistry structure | **[REUSE]** | iterate over roles to validate each |
| permission check | **[NEW]** | new operation needed with `accessSync` + `X_OK` |
