# blueprint: fail fast on non-executable skills publish

## summary

add executability validation to `npx rhachet repo introspect` that checks all `.sh` files in skills directories are marked executable before manifest generation. fail fast with clear error messages that list all non-executable paths.

---

## architecture

### new domain operation

create `src/domain.operations/manifest/assertRegistrySkillsExecutable.ts`

```
input: { registry: RoleRegistry }
output: void (throws BadRequestError if validation fails)

flow:
1. iterate registry.roles
2. for each role, extract skills.dirs via extractDirUris pattern
3. for each dir, enumerate files via getAllFilesFromDir
4. filter to .sh files
5. check each .sh file for execute permission via accessSync(path, constants.X_OK)
6. collect all non-executable paths
7. if any found, throw BadRequestError with full list
```

### integration point

modify `src/contract/cli/invokeRepoIntrospect.ts` at line ~69:

```ts
const registry = packageExports.getRoleRegistry();

// NEW: validate skill executability before manifest generation
assertRegistrySkillsExecutable({ registry });

const manifest = castIntoRoleRegistryManifest({
  registry,
  packageRoot: gitRoot,
});
```

### helper operation

create `src/domain.operations/manifest/findNonExecutableShellSkills.ts`

```
input: { registry: RoleRegistry }
output: string[] (paths to non-executable .sh files)

flow:
1. iterate registry.roles
2. extract and normalize skills.dirs to flat array
3. enumerate all files recursively
4. filter to .sh extension
5. check execute permission via accessSync
6. return paths that fail the check
```

this separation enables:
- unit testable pure logic (find operation)
- thin assertion wrapper (assert operation)
- reuse in other contexts if needed

---

## file structure

```
src/domain.operations/manifest/
├── assertRegistrySkillsExecutable.ts      # throws if non-executable found
├── assertRegistrySkillsExecutable.test.ts # unit tests
├── findNonExecutableShellSkills.ts        # pure enumeration + check
├── findNonExecutableShellSkills.test.ts   # unit tests

src/contract/cli/
├── invokeRepoIntrospect.ts                # MODIFY: add validation call
├── invokeRepoIntrospect.integration.test.ts # EXTEND: add test cases
```

---

## test coverage

### unit tests: `findNonExecutableShellSkills.test.ts`

| case | given | expect |
|------|-------|--------|
| [case1] | registry with no roles | empty array |
| [case2] | role with no skills.dirs | empty array |
| [case3] | skills dir with only .ts/.md files | empty array |
| [case4] | skills dir with executable .sh files | empty array |
| [case5] | skills dir with one non-executable .sh | array with that path |
| [case6] | skills dir with mixed executable/non-executable | array with only non-executable paths |
| [case7] | multiple roles, one with non-executable | array with that path |
| [case8] | skills.dirs as single object | handles correctly |
| [case9] | skills.dirs as array | handles correctly |

test setup:
- create temp directory structure
- use `writeFileSync` + `chmodSync` for executable files
- use `writeFileSync` only for non-executable files (defaults to 0o644)
- use `genTestTempDir` helper for managed cleanup

### unit tests: `assertRegistrySkillsExecutable.test.ts`

| case | given | expect |
|------|-------|--------|
| [case1] | registry with all executable skills | no error thrown |
| [case2] | registry with one non-executable skill | BadRequestError with path |
| [case3] | registry with multiple non-executable skills | BadRequestError with all paths |

test setup:
- reuse temp directory pattern
- use `getError()` from `test-fns` for exception capture
- assert error message contains expected paths

### integration tests: `invokeRepoIntrospect.integration.test.ts`

extend prior test structure with new `when` blocks:

```ts
when('[tN] skills directory contains only executable .sh files', () => {
  // setup: create .sh files with chmodSync(path, 0o755)
  then('command succeeds with exit code 0', async () => { ... });
  then('rhachet.repo.yml is generated', async () => { ... });
});

when('[tN+1] skills directory contains a non-executable .sh file', () => {
  // setup: create .sh file WITHOUT chmodSync (defaults to 0o644)
  then('command fails', async () => { ... });
  then('error message contains path to non-executable file', async () => { ... });
  then('rhachet.repo.yml is NOT generated', async () => { ... });
});

when('[tN+2] skills directory contains multiple non-executable .sh files', () => {
  then('error message lists ALL non-executable files', async () => { ... });
});

when('[tN+3] skills directory contains only .ts/.md files', () => {
  then('command succeeds (no .sh files to check)', async () => { ... });
});

when('[tN+4] role has no skills directory', () => {
  then('command succeeds', async () => { ... });
});
```

test setup:
- extend mock `dist/index.js` to create actual `.sh` files in skills directory
- use `beforeEach` to reset skills directory state per test case
- wrap `program.parseAsync()` in `getError()` for failure cases

### acceptance tests

create `src/accept.blackbox/cli/repo.introspect.executability.acceptance.test.ts`

blackbox validation per criteria:

| usecase | test |
|---------|------|
| usecase.1 | valid package with executable skills → success |
| usecase.2 | package with non-executable skill → fail with path in message |
| usecase.3 | package with multiple non-executable → all paths in message |
| boundary.1 | package with no skills dirs → success |
| boundary.2 | skills dir with non-.sh files only → success |
| boundary.3 | mixed valid/invalid → fail, only invalid identified |

test setup:
- use `genTestTempRepo` with custom fixture
- invoke via `invokeRhachetCliBinary` subprocess
- assert on stdout/stderr and exit status

---

## implementation sequence

### phase 1: core logic

1. create `findNonExecutableShellSkills.ts`
   - implement file enumeration + permission check
   - write unit tests

2. create `assertRegistrySkillsExecutable.ts`
   - implement thin assertion wrapper
   - write unit tests

### phase 2: integration

3. modify `invokeRepoIntrospect.ts`
   - import and call `assertRegistrySkillsExecutable`
   - place after `getRoleRegistry()`, before `castIntoRoleRegistryManifest()`

4. extend `invokeRepoIntrospect.integration.test.ts`
   - add test cases per integration test plan

### phase 3: acceptance

5. create acceptance test file
   - implement blackbox tests per criteria

### phase 4: validation

6. run full test suite
   - `npm run test:unit`
   - `npm run test:integration`
   - `npm run test:acceptance`

7. manual validation
   - test against real `rhachet-roles-*` package
   - verify error message format and clarity

---

## error message format

```
BadRequestError: non-executable skill files detected

these .sh files in skills directories are not marked executable:
  - src/roles/mechanic/skills/broken-skill.sh
  - src/roles/designer/skills/another-broken.sh

fix: run `chmod +x <path>` for each file, or ensure git preserves execute bits
```

metadata object:
```ts
{
  nonExecutablePaths: string[],
  rolesSlugs: string[], // which roles had issues
}
```

---

## dependencies

### imports needed

```ts
// in findNonExecutableShellSkills.ts
import { accessSync, constants } from 'fs';
import { getAllFilesFromDir } from '../../infra/filesystem/getAllFilesFromDir';

// in assertRegistrySkillsExecutable.ts
import { BadRequestError } from 'helpful-errors';
import { findNonExecutableShellSkills } from './findNonExecutableShellSkills';
import type { RoleRegistry } from '../../domain.objects/RoleRegistry';
```

### reused patterns

- `getAllFilesFromDir` for recursive enumeration
- `extractDirUris` pattern (inline or extract to shared helper)
- `BadRequestError` for fail-fast
- `getError` from `test-fns` for test assertions
- `chmodSync` / `statSync` for test setup and verification

---

## risk considerations

### cross-platform

- `accessSync` with `X_OK` works on unix-like systems
- windows does not have the same permission model
- mitigation: skill publish is primarily a unix workflow; document limitation

### symlink handle

- `getAllFilesFromDir` already handles broken symlinks gracefully
- symlinked skills will be checked at their target location
- no additional work needed

### empty skills directories

- `getAllFilesFromDir` returns empty array for non-existent dirs
- validation naturally passes for roles with no skills
- matches boundary.1 criteria

---

## success criteria

- [ ] all blackbox criteria pass as acceptance tests
- [ ] unit test coverage for core logic
- [ ] integration test coverage for cli flow
- [ ] error messages clearly identify non-executable files
- [ ] no regression in prior `repo introspect` behavior
- [ ] build passes: `npm run test:types && npm run test:lint`
