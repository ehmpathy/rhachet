# vision: keyrack get exits non-zero when keys can't be fetched

## the outcome world

### a day-in-the-life

**before:**
```bash
# mechanic skill tries to use keyrack
if RESULT=$(npx rhachet keyrack get --key MY_TOKEN --json); then
  TOKEN=$(echo "$RESULT" | jq -r '.grant.value')
  do_the_thing "$TOKEN"
fi

# BUT: keyrack returns {"status": "locked"} with exit 0
# so the `if` thinks it succeeded
# TOKEN becomes empty or "null"
# do_the_thing fails mysteriously downstream
# mechanic says "i don't have auth" — but couldn't explain why
```

**after:**
```bash
# keyrack exits 2 when key can't be fetched
if RESULT=$(npx rhachet keyrack get --key MY_TOKEN --json); then
  TOKEN=$(echo "$RESULT" | jq -r '.grant.value')
  do_the_thing "$TOKEN"
else
  # we get here! can handle it properly
  echo "⛈️ key unavailable: $(echo "$RESULT" | jq -r '.message')"
  exit 2  # propagate the constraint
fi
```

### before/after contrast

| aspect | before | after |
|--------|--------|-------|
| exit code when locked | 0 ✗ | 2 ✓ |
| exit code when absent | 0 ✗ | 2 ✓ |
| exit code when blocked | 0 ✗ | 2 ✓ |
| bash `if` works correctly | no | yes |
| skills can auto-recover | no | yes |
| fail-fast possible | no | yes |

### the "aha" moment

when `git.commit.push.sh` can do this and it just works:

```bash
# try default owner
if RESULT=$(keyrack get --key TOKEN --json 2>/dev/null); then
  TOKEN=$(echo "$RESULT" | jq -r '.grant.value')
else
  # fallback to alternate owner
  keyrack unlock --owner alt
  RESULT=$(keyrack get --key TOKEN --owner alt --json)
  TOKEN=$(echo "$RESULT" | jq -r '.grant.value')
fi
```

the exit code is the signal. no json parse needed to detect failure. bash works as expected.

## user experience

### usecases

1. **skill authors** — write bash that fetches credentials and handles failure gracefully
2. **ci pipelines** — fail-fast when credentials unavailable (vs mysterious downstream errors)
3. **interactive users** — get clear feedback when unlock is needed
4. **composed workflows** — cascade unlock attempts across owners

### contract inputs & outputs

**input:** same as today
```bash
npx rhachet keyrack get --key MY_TOKEN [--owner mechanic] [--env prod] [--json]
```

**output:** same json structure, different exit codes

| status | exit code | semantics |
|--------|-----------|-----------|
| granted | 0 | key fetched successfully |
| locked | 2 | key exists but vault is locked |
| absent | 2 | key not found in manifest |
| blocked | 2 | key exists but blocked by firewall |

exit 2 = "blocked by constraints" — the unix convention for controlled failure

### timeline

```
t0: user runs skill that needs auth
t1: skill calls keyrack get --key TOKEN
t2: keyrack checks daemon → locked
t3: keyrack exits 2 with json: {"status": "locked", "fix": "rhx keyrack unlock"}
t4: skill catches exit 2 → attempts recovery or propagates error
t5: user sees clear error message with actionable fix
```

## mental model

### how users would describe this

> "keyrack tells me when it can't get my keys by a non-zero exit — not just output but an actual exit code so my scripts know if it worked"

### analogies

- **like `grep`** — exits 0 when found, 1 when not found. you don't parse output to know if it worked.
- **like `test -f`** — exits 0 when file exists, 1 when not. the exit code IS the answer.
- **like http status codes** — 200 = got it, 4xx = client problem, 5xx = server problem. clear categories.

### terms

| user says | we say |
|-----------|--------|
| "it failed" | status = locked \| absent \| blocked |
| "it worked" | status = granted |
| "can't get my key" | exit code = 2 |
| "got my key" | exit code = 0 |

## evaluation

### how well does it solve the goals?

**goal: skills can auto-fetch tokens invisibly**
- ✓ exit code lets bash `if` work correctly
- ✓ skills can cascade unlock attempts
- ✓ fail-fast when truly unavailable

**goal: mechanics never say "i don't have auth"**
- ✓ keyrack get fails visibly — skill can explain why
- ✓ fix hint included in json output
- ✓ human sees actionable error, not mysterious failure

### pros

1. **unix-native** — exit codes are the standard way to signal success/failure
2. **bash-friendly** — `if result=$(cmd); then` pattern works
3. **backwards-compatible** — json output unchanged, only exit code added
4. **composable** — enables cascade fallback patterns
5. **fail-fast** — skills stop immediately on constraint, not downstream

### cons

1. **breaks scripts that ignore exit codes** — but those scripts were already broken (they ignored the status field)
2. **exit 2 is non-standard** — but 1 is for errors, 2 is established for "blocked by constraint" (bash uses it for builtins)

### edgecases and pit of success

| edgecase | behavior | pit of success |
|----------|----------|----------------|
| key granted | exit 0, json has value | ✓ expected |
| key locked | exit 2, json has fix hint | ✓ recoverable |
| key absent | exit 2, json has fix hint | ✓ actionable |
| key blocked | exit 2, json has reasons | ✓ explains why |
| daemon not active | exit 2, status=locked | ✓ same as locked |
| network error | exit 1, error message | distinct from constraint |

**exit code semantics:**
- 0 = success (key granted)
- 1 = error (unexpected failure, bug)
- 2 = blocked by constraints (key locked, absent, or blocked)

this lets callers distinguish "a bug" (1) from "key unavailable" (2).

## awkward discoveries

### none found

the current behavior is simply a bug — keyrack get should have always exited non-zero for non-granted statuses. the json output already signals the status; the exit code just wasn't aligned.

### implementation note

the fix is localized to `invokeKeyrack.ts` — after output of json, check if status !== 'granted' and `process.exit(2)`.

```ts
// after console.log(JSON.stringify(attemptResolved, null, 2));
if (attemptResolved.status !== 'granted') {
  process.exit(2);
}
```

same pattern for `--for repo` mode with multiple keys — exit 2 if ANY key is not granted.
