# vision: how users will use brain.choice

## before (extant)

every brain invocation requires the brain ref:

```ts
const context = genContextBrain({ atoms, repls });

// must specify brain on every call
const result1 = await context.brain.atom.ask({
  brain: { slug: 'xai/grok-3-fast' },
  role: { briefs },
  prompt: 'analyze this code',
  schema: { output: z.object({ analysis: z.string() }) },
});

// again, must specify brain
const result2 = await context.brain.repl.act({
  brain: { slug: 'anthropic/claude-code' },
  role: { briefs },
  prompt: 'fix the bug',
  schema: { output: z.object({ fixed: z.boolean() }) },
});
```

## after (with choice)

choose once at context creation, invoke without repeat:

```ts
const context = genContextBrain({
  atoms,
  repls,
  choice: 'xai/grok-3-fast',
});

// no brain ref needed — pre-bound to choice
const result1 = await context.brain.choice.ask({
  role: { briefs },
  prompt: 'analyze this code',
  schema: { output: z.object({ analysis: z.string() }) },
});

// same brain, no repeat
const result2 = await context.brain.choice.act({
  role: { briefs },
  prompt: 'fix the bug',
  schema: { output: z.object({ fixed: z.boolean() }) },
});
```

## cli integration

```ts
// skill that accepts --brain flag (consumer declares their own default)
const context = genContextBrain({
  atoms,
  repls,
  choice: flags.brain ?? 'anthropic/claude-sonnet', // consumer's default
});

// skill logic uses brain.choice without concern for which brain
await context.brain.choice.ask({ ... });
```

## type precision

consumers prescribe whether they require a chosen brain or accept null:

```ts
// function that REQUIRES a chosen brain — no null check needed
const analyzeCode = async (
  input: { code: string },
  context: { brain: ContextBrain<BrainChoice> },
) => {
  // brain.choice is BrainChoice — guaranteed non-null
  return context.brain.choice.ask({
    prompt: `analyze: ${input.code}`,
    schema: { output: z.object({ analysis: z.string() }) },
  });
};

// function that ACCEPTS null — brain.choice is optional
const maybeAnalyze = async (
  input: { code: string },
  context: { brain: ContextBrain },  // default: TBrainChoice = BrainChoice | null
) => {
  // brain.choice could be null — must check
  if (!context.brain.choice) return null;
  return context.brain.choice.ask({ ... });
};
```

callers get compile-time feedback:

```ts
// ✓ compiles — choice provided, brain.choice is non-null
const ctx1 = genContextBrain({ atoms, repls, choice: 'xai/grok-3-fast' });
await analyzeCode({ code }, { brain: ctx1 });

// ✗ compile error — choice omitted, brain.choice is null
const ctx2 = genContextBrain({ atoms, repls });
await analyzeCode({ code }, { brain: ctx2 });
//                           ^^^^^^^^^^^^^^
// Type 'ContextBrain<null>' is not assignable to 'ContextBrain<BrainChoice>'
```

## typed choice: require atom or repl

some skills require a specific brain type (e.g., `.act()` only on repls):

```ts
// skill that REQUIRES a repl — brain.choice.act() available
const executeTask = async (
  input: { task: string },
  context: { brain: ContextBrain<BrainRepl> },
) => {
  // brain.choice is BrainRepl — .act() is available
  return context.brain.choice.act({
    prompt: input.task,
    schema: { output: z.object({ done: z.boolean() }) },
  });
};

// caller specifies repl requirement via typed choice
const ctx = genContextBrain({
  atoms,
  repls,
  choice: { repl: 'anthropic/claude-code' },  // ← typed choice
});
// ctx.brain.choice is BrainRepl — compile-time guarantee

await executeTask({ task: 'fix the bug' }, { brain: ctx });
```

compile-time error if wrong type:

```ts
// ✗ compile error — atom choice passed to function that requires repl
const ctx = genContextBrain({
  atoms,
  repls,
  choice: { atom: 'xai/grok-3-fast' },
});
await executeTask({ task }, { brain: ctx });
//                           ^^^^^^^^^^^^^^
// Type 'ContextBrain<BrainAtom>' is not assignable to 'ContextBrain<BrainRepl>'
```

runtime error if slug is wrong type:

```ts
// runtime error — slug exists but is an atom, not a repl
const ctx = genContextBrain({
  atoms,
  repls,
  choice: { repl: 'xai/grok-3-fast' },  // xai/grok-3-fast is an atom
});
// => BadRequestError: brain 'xai/grok-3-fast' is not a repl
```

## runtime type guards

for adhoc validation when choice type is not known at compile time:

```ts
// skill uses generic choice but some flows require a repl
const flexibleSkill = async (
  input: { task: string; needsExecution: boolean },
  context: { brain: ContextBrain<BrainChoice> },
) => {
  // analyze works with any brain
  const analysis = await context.brain.choice.ask({ prompt: 'analyze' });

  // execution requires a repl — guard at runtime
  if (input.needsExecution) {
    if (!isBrainRepl(context.brain.choice)) {
      throw new BadRequestError('execution requires a repl brain', {
        choice: context.brain.choice.slug,
      });
    }
    // type narrowed to BrainRepl after guard
    await context.brain.choice.act({ prompt: 'execute' });
  }

  return analysis;
};
```

type guards available:

```ts
import { isBrainAtom, isBrainRepl } from 'rhachet';

if (isBrainRepl(brain.choice)) {
  // brain.choice is BrainRepl here
  brain.choice.act({ ... });
}

if (isBrainAtom(brain.choice)) {
  // brain.choice is BrainAtom here
  brain.choice.ask({ ... });  // atoms only have .ask()
}
```

## discovery

```ts
// autocomplete or validation
const slugs = getAvailableBrainSlugs();
// => ['xai/grok-3-fast', 'anthropic/claude-sonnet', 'openai/gpt-4o', ...]

// help output
printBrainHelp({ atoms, repls });
// => available brains:
//      atoms: xai/grok-3-fast, anthropic/claude-sonnet, openai/gpt-4o
//      repls: anthropic/claude-code, openai/codex
```

## error: not found

```ts
const context = genContextBrain({
  atoms,
  repls,
  choice: 'typo/not-real',
});
// => BadRequestError: brain not found: typo/not-real
//
//    available brains:
//      atoms:
//        xai/grok-3-fast
//        ...
//      repls:
//        anthropic/claude-code
//        ...
```

## error: ambiguous

```ts
// if 'some/brain' exists in both atoms and repls (supplier bug)
const context = genContextBrain({
  atoms,
  repls,
  choice: 'some/brain',
});
// => BadRequestError: ambiguous brain slug: some/brain
//    matches multiple brains — repair brain suppliers
```
