# blackbox criteria = experience bounds

## summary: extant vs netnew

### extant (genContextBrain today)
- input: `{ atoms?: BrainAtom[], repls?: BrainRepl[] }`
- output: `ContextBrain` with `brain.atom.ask()`, `brain.repl.ask()`, `brain.repl.act()`
- each call requires `brain` ref to specify which brain to use

### netnew (this wish)
- input: add optional `choice` param to genContextBrain
  - `choice: string` → `brain.choice` is `BrainChoice`
  - `choice: { repl: string }` → `brain.choice` is `BrainRepl`
  - `choice: { atom: string }` → `brain.choice` is `BrainAtom`
  - `choice?: undefined` → `brain.choice` is `null`
- output: `brain.choice` is the matched `BrainChoice`, or `null` if no choice
- callers invoke `brain.choice.ask()` directly on the brain object
- validation: chosen brain exists and is unambiguous at context creation time
- error messages: list available brains when not found, fail fast when ambiguous
- type guards: `isBrainAtom()`, `isBrainRepl()` for runtime checks
- helpers: `getAvailableBrainSlugs()`, `printBrainHelp()`


---


## usecase.1 = choose a brain at context creation

given('a user wants a context with a pre-bound brain')
  when('they call genContextBrain with a valid choice slug')
    then('they receive a ContextBrain with brain.choice set to the matched brain')
    then('brain.choice is the BrainAtom or BrainRepl that matched the slug')
      sothat('callers can invoke brain.choice.ask() directly')

  when('they call genContextBrain without a choice')
    then('they receive a ContextBrain with brain.choice set to null')
    then('brain.atom and brain.repl work as before')
      sothat('extant behavior is preserved')


## usecase.2 = error: brain not found

given('a user calls genContextBrain with an invalid choice slug')
  when('the slug matches no atom and no repl')
    then('they receive a BadRequestError')
    then('the error message includes the invalid slug they provided')
    then('the error message lists all available brains')
      sothat('they can discover valid options without need to consult docs')


## usecase.3 = discover available brains

given('a user wants to know which brains are available')
  when('they call getAvailableBrainSlugs()')
    then('they receive an array of all valid brain slug strings')
      sothat('they can use these for autocomplete or validation')

  when('they call printBrainHelp()')
    then('the available brains are printed to console')
    then('brains are grouped by type: atoms and repls')
    then('each brain shows its slug')


## usecase.4 = error: ambiguous slug

given('a choice slug matches multiple brains (e.g., both an atom and a repl)')
  when('genContextBrain is called with that choice slug')
    then('BadRequestError is thrown')
    then('the error message indicates the slug is ambiguous')
      sothat('brain suppliers are repaired rather than silent priority applied')


## usecase.5 = typed choice for compile-time precision

given('a skill requires a specific brain type')
  when('they call genContextBrain with choice: { repl: slug }')
    then('brain.choice is typed as BrainRepl')
    then('BadRequestError is thrown if the slug is not a repl')
      sothat('callers can invoke brain.choice.act() without type errors')

  when('they call genContextBrain with choice: { atom: slug }')
    then('brain.choice is typed as BrainAtom')
    then('BadRequestError is thrown if the slug is not an atom')
      sothat('callers get compile-time assurance of brain type')


## usecase.6 = runtime type guards

given('a skill receives a generic BrainChoice and needs to verify its type')
  when('they call isBrainRepl(brain.choice)')
    then('returns true if the brain is a BrainRepl')
    then('narrows the type to BrainRepl in the truthy branch')
      sothat('callers can guard before flows that require a repl')

  when('they call isBrainAtom(brain.choice)')
    then('returns true if the brain is a BrainAtom')
    then('narrows the type to BrainAtom in the truthy branch')
      sothat('callers can guard before flows that require an atom')

given('a skill uses choice: string but needs to enforce repl at runtime')
  when('brain.choice is an atom but the flow requires a repl')
    then('isBrainRepl(brain.choice) returns false')
    then('caller can throw BadRequestError with clear message')
      sothat('adhoc guards are possible without typed choice syntax')
