# blueprint: context brain choice

## summary

extend `genContextBrain` to accept an optional `choice` slug that pre-binds a brain to `context.brain.choice`.

---

## filediff treestruct

```
src/
  domain.objects/
    [~] ContextBrain.ts                           # add brain.choice to interface, make generic
  domain.operations/
    context/
      [~] genContextBrain.ts                      # add choice param, bind brain.choice
      [~] genContextBrain.test.ts                 # add unit tests for choice behavior
      [+] genContextBrain.types.test.ts           # add type constraint tests with ts-expect-error
  contract/
    [~] sdk.ts                                    # export getAvailableBrainSlugs, printBrainHelp, isBrainAtom, isBrainRepl
accept.blackbox/
  sdk/
    [+] genContextBrain.acceptance.test.ts        # blackbox usage demos for each choice variant
```

---

## codepath treestruct

```
genContextBrain({ atoms, repls, choice })
  │
  ├─ [extant] validate no duplicate atoms
  ├─ [extant] validate no duplicate repls
  │
  ├─ [netnew] if choice provided:
  │     ├─ if choice is string:
  │     │     ├─ atomsMatched = atoms.filter(a => a.slug === choice)
  │     │     ├─ replsMatched = repls.filter(r => r.slug === choice)
  │     │     ├─ if zero matches → BadRequestError with available slugs
  │     │     ├─ if multiple matches → BadRequestError "ambiguous"
  │     │     └─ brain.choice = matched brain
  │     ├─ if choice is { repl: string }:
  │     │     ├─ replMatched = repls.find(r => r.slug === choice.repl)
  │     │     ├─ if not found → BadRequestError with available repls
  │     │     └─ brain.choice = replMatched
  │     └─ if choice is { atom: string }:
  │           ├─ atomMatched = atoms.find(a => a.slug === choice.atom)
  │           ├─ if not found → BadRequestError with available atoms
  │           └─ brain.choice = atomMatched
  │
  ├─ [extant] return brain.atom.ask()
  ├─ [extant] return brain.repl.ask() / .act()
  └─ [netnew] return brain.choice (BrainChoice | null)
```

---

## domain changes

### ContextBrain.ts (update interface)

```ts
// type alias for a chosen brain
export type BrainChoice = BrainAtom | BrainRepl;

// make interface generic over choice type
export interface ContextBrain<TBrainChoice = BrainChoice | null> {
  brain: {
    atom: { ... };  // extant
    repl: { ... };  // extant
    choice: TBrainChoice;
  };
}

// type guards for runtime checks
export const isBrainAtom = (brain: BrainChoice): brain is BrainAtom =>
  'ask' in brain && !('act' in brain);

export const isBrainRepl = (brain: BrainChoice): brain is BrainRepl =>
  'ask' in brain && 'act' in brain;
```

### genContextBrain.ts (update)

```ts
// overloads for return type precision
export function genContextBrain(input: {
  atoms?: BrainAtom[];
  repls?: BrainRepl[];
  choice: { repl: string };
}): ContextBrain<BrainRepl>;
export function genContextBrain(input: {
  atoms?: BrainAtom[];
  repls?: BrainRepl[];
  choice: { atom: string };
}): ContextBrain<BrainAtom>;
export function genContextBrain(input: {
  atoms?: BrainAtom[];
  repls?: BrainRepl[];
  choice: string;
}): ContextBrain<BrainChoice>;
export function genContextBrain(input: {
  atoms?: BrainAtom[];
  repls?: BrainRepl[];
  choice?: undefined;
}): ContextBrain<null>;
export function genContextBrain(input: {
  atoms?: BrainAtom[];
  repls?: BrainRepl[];
  choice?: string | { repl: string } | { atom: string };
}): ContextBrain {
  // ... extant validation ...

  // netnew: resolve choice if provided
  const brainChoice = (() => {
    if (!input.choice) return null;

    // typed choice: { repl: string }
    if (typeof input.choice === 'object' && 'repl' in input.choice) {
      const replMatched = repls.find((r) => r.slug === input.choice.repl);
      if (!replMatched)
        throw new BadRequestError(`repl brain not found: ${input.choice.repl}`, {
          choice: input.choice,
          available: { repls: repls.map((r) => r.slug) },
        });
      return replMatched;
    }

    // typed choice: { atom: string }
    if (typeof input.choice === 'object' && 'atom' in input.choice) {
      const atomMatched = atoms.find((a) => a.slug === input.choice.atom);
      if (!atomMatched)
        throw new BadRequestError(`atom brain not found: ${input.choice.atom}`, {
          choice: input.choice,
          available: { atoms: atoms.map((a) => a.slug) },
        });
      return atomMatched;
    }

    // generic choice: string
    const atomsMatched = atoms.filter((a) => a.slug === input.choice);
    const replsMatched = repls.filter((r) => r.slug === input.choice);
    const allMatched = [...atomsMatched, ...replsMatched];

    if (allMatched.length === 0)
      throw new BadRequestError(`brain not found: ${input.choice}`, {
        choice: input.choice,
        available: { atoms: atoms.map((a) => a.slug), repls: repls.map((r) => r.slug) },
      });

    if (allMatched.length > 1)
      throw new BadRequestError(`ambiguous brain slug: ${input.choice}`, {
        choice: input.choice,
        matched: allMatched.map((b) => b.slug),
      });

    return allMatched[0]!;
  })();

  return {
    brain: {
      // ... extant atom/repl ...
      choice: brainChoice,
    },
  };
};

export const getAvailableBrainSlugs = (input: {
  atoms: BrainAtom[];
  repls: BrainRepl[];
}): string[] => [...input.atoms.map((a) => a.slug), ...input.repls.map((r) => r.slug)];

export const printBrainHelp = (input: {
  atoms: BrainAtom[];
  repls: BrainRepl[];
}): void => {
  console.log('available brains:');
  console.log('  atoms:', input.atoms.map((a) => a.slug).join(', ') || '(none)');
  console.log('  repls:', input.repls.map((r) => r.slug).join(', ') || '(none)');
};
```

---

## test coverage

### genContextBrain.test.ts (add cases)

| case | coverage |
|------|----------|
| `[caseN] choice: string matches an atom` | brain.choice is the matched BrainAtom |
| `[caseN] choice: string matches a repl` | brain.choice is the matched BrainRepl |
| `[caseN] choice: string not found` | throws BadRequestError with available slugs |
| `[caseN] choice: string ambiguous` | throws BadRequestError with matched slugs |
| `[caseN] choice: { repl } matches` | brain.choice is typed as BrainRepl |
| `[caseN] choice: { repl } not found` | throws BadRequestError with available repls |
| `[caseN] choice: { atom } matches` | brain.choice is typed as BrainAtom |
| `[caseN] choice: { atom } not found` | throws BadRequestError with available atoms |
| `[caseN] no choice provided` | brain.choice is null, extant behavior preserved |
| `[caseN] isBrainRepl guard` | returns true for repls, false for atoms |
| `[caseN] isBrainAtom guard` | returns true for atoms, false for repls |
| `[caseN] getAvailableBrainSlugs` | returns combined atom and repl slugs |
| `[caseN] printBrainHelp` | prints atoms and repls to console |

---

## acceptance test coverage

### genContextBrain.acceptance.test.ts (blackbox usage demos)

```ts
import { given, when, then } from 'test-fns';
import {
  genContextBrain,
  isBrainAtom,
  isBrainRepl,
  type BrainAtom,
  type BrainRepl,
} from 'rhachet';

describe('genContextBrain choice', () => {
  const atoms: BrainAtom[] = [{ slug: 'xai/grok-3-fast', ask: async () => ({}) }];
  const repls: BrainRepl[] = [{ slug: 'anthropic/claude-code', ask: async () => ({}), act: async () => ({}) }];

  given('[case1] choice: string (generic)', () => {
    when('[t0] choice matches an atom', () => {
      const ctx = genContextBrain({ atoms, repls, choice: 'xai/grok-3-fast' });

      then('brain.choice is the matched atom', () => {
        // no ! needed — choice: string returns BrainChoice (not null)
        expect(ctx.brain.choice.slug).toEqual('xai/grok-3-fast');
      });

      then('brain.choice.ask() is callable', async () => {
        const result = await ctx.brain.choice.ask({ prompt: 'test' });
        expect(result).toBeDefined();
      });

      then('isBrainAtom guard returns true for atom', () => {
        expect(isBrainAtom(ctx.brain.choice)).toEqual(true);
      });

      then('isBrainRepl guard returns false for atom', () => {
        expect(isBrainRepl(ctx.brain.choice)).toEqual(false);
      });
    });

    when('[t1] choice matches a repl', () => {
      const ctx = genContextBrain({ atoms, repls, choice: 'anthropic/claude-code' });

      then('brain.choice is the matched repl', () => {
        expect(ctx.brain.choice.slug).toEqual('anthropic/claude-code');
      });

      then('isBrainRepl guard returns true for repl', () => {
        expect(isBrainRepl(ctx.brain.choice)).toEqual(true);
      });

      then('isBrainAtom guard returns false for repl', () => {
        expect(isBrainAtom(ctx.brain.choice)).toEqual(false);
      });

      then('after isBrainRepl guard, .act() is callable', async () => {
        if (!isBrainRepl(ctx.brain.choice)) throw new Error('expected repl');
        // type narrowed to BrainRepl — .act() available
        const result = await ctx.brain.choice.act({ prompt: 'test' });
        expect(result).toBeDefined();
      });
    });

    when('[t2] choice not found', () => {
      then('throws BadRequestError with available slugs', () => {
        expect(() => genContextBrain({ atoms, repls, choice: 'invalid/brain' }))
          .toThrow('brain not found: invalid/brain');
      });
    });

    when('[t3] choice ambiguous', () => {
      const ambiguousAtoms = [{ slug: 'shared/brain', ask: async () => ({}) }];
      const ambiguousRepls = [{ slug: 'shared/brain', ask: async () => ({}), act: async () => ({}) }];

      then('throws BadRequestError', () => {
        expect(() => genContextBrain({ atoms: ambiguousAtoms, repls: ambiguousRepls, choice: 'shared/brain' }))
          .toThrow('ambiguous brain slug: shared/brain');
      });
    });
  });

  given('[case2] choice: { repl: string } (typed)', () => {
    when('[t0] choice matches a repl', () => {
      const ctx = genContextBrain({ atoms, repls, choice: { repl: 'anthropic/claude-code' } });

      then('brain.choice is the matched repl', () => {
        expect(ctx.brain.choice.slug).toEqual('anthropic/claude-code');
      });

      then('brain.choice.act() is callable without guard', async () => {
        // no isBrainRepl check needed — type is BrainRepl
        const result = await ctx.brain.choice.act({ prompt: 'test' });
        expect(result).toBeDefined();
      });
    });

    when('[t1] repl not found', () => {
      then('throws BadRequestError with available repls', () => {
        expect(() => genContextBrain({ atoms, repls, choice: { repl: 'invalid/repl' } }))
          .toThrow('repl brain not found: invalid/repl');
      });
    });
  });

  given('[case3] choice: { atom: string } (typed)', () => {
    when('[t0] choice matches an atom', () => {
      const ctx = genContextBrain({ atoms, repls, choice: { atom: 'xai/grok-3-fast' } });

      then('brain.choice is the matched atom', () => {
        expect(ctx.brain.choice.slug).toEqual('xai/grok-3-fast');
      });

      then('brain.choice.ask() is callable', async () => {
        const result = await ctx.brain.choice.ask({ prompt: 'test' });
        expect(result).toBeDefined();
      });
    });

    when('[t1] atom not found', () => {
      then('throws BadRequestError with available atoms', () => {
        expect(() => genContextBrain({ atoms, repls, choice: { atom: 'invalid/atom' } }))
          .toThrow('atom brain not found: invalid/atom');
      });
    });
  });

  given('[case4] no choice provided', () => {
    when('[t0] choice omitted', () => {
      const ctx = genContextBrain({ atoms, repls });

      then('brain.choice is null', () => {
        expect(ctx.brain.choice).toBeNull();
      });

      then('brain.atom and brain.repl work as before', async () => {
        const atomResult = await ctx.brain.atom.ask({ brain: atoms[0]!, prompt: 'test' });
        expect(atomResult).toBeDefined();
      });
    });
  });

  given('[case5] runtime guards for adhoc validation', () => {
    when('[t0] skill requires repl but receives atom', () => {
      const ctx = genContextBrain({ atoms, repls, choice: 'xai/grok-3-fast' });

      then('isBrainRepl returns false for atom', () => {
        expect(isBrainRepl(ctx.brain.choice)).toEqual(false);
      });

      then('caller can throw descriptive error', () => {
        const executeTask = (brain: BrainChoice) => {
          if (!isBrainRepl(brain))
            throw new Error('execution requires a repl brain');
          return brain.act({ prompt: 'test' });
        };

        expect(() => executeTask(ctx.brain.choice)).toThrow('execution requires a repl brain');
      });
    });
  });
});
```

---

## type constraint tests

### genContextBrain.types.test.ts (compile-time verification)

```ts
import {
  genContextBrain,
  type ContextBrain,
  type BrainAtom,
  type BrainRepl,
  type BrainChoice,
} from 'rhachet';

describe('genContextBrain type constraints', () => {
  const atoms: BrainAtom[] = [];
  const repls: BrainRepl[] = [];

  describe('return type precision', () => {
    it('choice: string returns ContextBrain<BrainChoice>', () => {
      const ctx = genContextBrain({ atoms, repls, choice: 'any/brain' });

      // positive: brain.choice is BrainChoice (not null)
      const _choice: BrainChoice = ctx.brain.choice;

      // positive: can call .ask() without null check
      ctx.brain.choice.ask;

      // negative: cannot narrow to just BrainRepl without guard
      // @ts-expect-error - Type 'BrainChoice' is not assignable to type 'BrainRepl'
      const _repl: BrainRepl = ctx.brain.choice;
    });

    it('choice: { repl } returns ContextBrain<BrainRepl>', () => {
      const ctx = genContextBrain({ atoms, repls, choice: { repl: 'any/repl' } });

      // positive: brain.choice is BrainRepl
      const _repl: BrainRepl = ctx.brain.choice;

      // positive: .act() is available without guard
      ctx.brain.choice.act;

      // negative: cannot assign to BrainAtom
      // @ts-expect-error - Type 'BrainRepl' is not assignable to type 'BrainAtom'
      const _atom: BrainAtom = ctx.brain.choice;
    });

    it('choice: { atom } returns ContextBrain<BrainAtom>', () => {
      const ctx = genContextBrain({ atoms, repls, choice: { atom: 'any/atom' } });

      // positive: brain.choice is BrainAtom
      const _atom: BrainAtom = ctx.brain.choice;

      // negative: .act() is not available on atoms
      // @ts-expect-error - Property 'act' does not exist on type 'BrainAtom'
      ctx.brain.choice.act;

      // negative: cannot assign to BrainRepl
      // @ts-expect-error - Type 'BrainAtom' is not assignable to type 'BrainRepl'
      const _repl: BrainRepl = ctx.brain.choice;
    });

    it('no choice returns ContextBrain<null>', () => {
      const ctx = genContextBrain({ atoms, repls });

      // positive: brain.choice is null
      const _null: null = ctx.brain.choice;

      // negative: cannot invoke methods on null
      // @ts-expect-error - 'ctx.brain.choice' is possibly 'null'
      ctx.brain.choice.ask;

      // negative: cannot assign to BrainChoice
      // @ts-expect-error - Type 'null' is not assignable to type 'BrainChoice'
      const _choice: BrainChoice = ctx.brain.choice;
    });
  });

  describe('type guard precision', () => {
    it('isBrainRepl narrows BrainChoice to BrainRepl', () => {
      const ctx = genContextBrain({ atoms, repls, choice: 'any/brain' });

      // negative: cannot call .act() on BrainChoice without guard
      // @ts-expect-error - Property 'act' does not exist on type 'BrainAtom'
      ctx.brain.choice.act;

      if (isBrainRepl(ctx.brain.choice)) {
        // positive: after guard, .act() is available
        ctx.brain.choice.act;
        const _repl: BrainRepl = ctx.brain.choice;
      }
    });

    it('isBrainAtom narrows BrainChoice to BrainAtom', () => {
      const ctx = genContextBrain({ atoms, repls, choice: 'any/brain' });

      if (isBrainAtom(ctx.brain.choice)) {
        // positive: after guard, type is BrainAtom
        const _atom: BrainAtom = ctx.brain.choice;

        // negative: .act() is not available on BrainAtom
        // @ts-expect-error - Property 'act' does not exist on type 'BrainAtom'
        ctx.brain.choice.act;
      }
    });
  });

  describe('context type requirements', () => {
    it('fn that requires ContextBrain<BrainRepl> rejects ContextBrain<BrainAtom>', () => {
      const requiresRepl = (ctx: ContextBrain<BrainRepl>) => ctx.brain.choice.act;

      const ctxRepl = genContextBrain({ atoms, repls, choice: { repl: 'any/repl' } });
      const ctxAtom = genContextBrain({ atoms, repls, choice: { atom: 'any/atom' } });

      // positive: repl context accepted
      requiresRepl(ctxRepl);

      // negative: atom context rejected
      // @ts-expect-error - Type 'ContextBrain<BrainAtom>' is not assignable to type 'ContextBrain<BrainRepl>'
      requiresRepl(ctxAtom);
    });

    it('fn that requires ContextBrain<BrainChoice> rejects ContextBrain<null>', () => {
      const requiresChoice = (ctx: ContextBrain<BrainChoice>) => ctx.brain.choice.ask;

      const ctxWithChoice = genContextBrain({ atoms, repls, choice: 'any/brain' });
      const ctxNoChoice = genContextBrain({ atoms, repls });

      // positive: context with choice accepted
      requiresChoice(ctxWithChoice);

      // negative: context without choice rejected
      // @ts-expect-error - Type 'ContextBrain<null>' is not assignable to type 'ContextBrain<BrainChoice>'
      requiresChoice(ctxNoChoice);
    });

    it('fn that accepts ContextBrain (default) accepts all variants', () => {
      const acceptsAny = (ctx: ContextBrain) => ctx.brain.choice;

      const ctxRepl = genContextBrain({ atoms, repls, choice: { repl: 'any/repl' } });
      const ctxAtom = genContextBrain({ atoms, repls, choice: { atom: 'any/atom' } });
      const ctxString = genContextBrain({ atoms, repls, choice: 'any/brain' });
      const ctxNull = genContextBrain({ atoms, repls });

      // positive: all variants accepted
      acceptsAny(ctxRepl);
      acceptsAny(ctxAtom);
      acceptsAny(ctxString);
      acceptsAny(ctxNull);
    });
  });
});
```

---

## backward compatibility

- `genContextBrain({ atoms, repls })` unchanged
- `brain.choice` always present: `null` if no choice param, `BrainChoice` if choice param
- all extant tests pass without modification
