# roadmap: context brain choice

## overview

ordered checklist to execute the blueprint at `3.3.blueprint.v1.i1.md`.

each phase has:
- dependencies (what must be complete before)
- deliverables (what gets created or changed)
- acceptance criteria (behavioral verification)
- verification (how to prove it works)

---

## phase 1: domain types

### dependencies
- none (first phase)

### deliverables
- [ ] `src/domain.objects/ContextBrain.ts` — add `BrainChoice` type alias
- [ ] `src/domain.objects/ContextBrain.ts` — make `ContextBrain<TBrainChoice>` generic
- [ ] `src/domain.objects/ContextBrain.ts` — add `isBrainAtom()` type guard
- [ ] `src/domain.objects/ContextBrain.ts` — add `isBrainRepl()` type guard

### acceptance criteria
- `BrainChoice = BrainAtom | BrainRepl` is exported
- `ContextBrain<T>` defaults to `BrainChoice | null`
- `brain.choice` property exists on interface
- `isBrainAtom` returns `true` for atoms, `false` for repls
- `isBrainRepl` returns `true` for repls, `false` for atoms

### verification
```sh
npm run test:types
```
- types compile without error
- extant tests still pass (no behavioral change to extant code)

---

## phase 2: genContextBrain overloads

### dependencies
- phase 1 complete (types exist)

### deliverables
- [ ] `src/domain.operations/context/genContextBrain.ts` — add function overloads for:
  - `choice: { repl: string }` → `ContextBrain<BrainRepl>`
  - `choice: { atom: string }` → `ContextBrain<BrainAtom>`
  - `choice: string` → `ContextBrain<BrainChoice>`
  - `choice?: undefined` → `ContextBrain<null>`

### acceptance criteria
- overload signatures exist
- implementation signature accepts union type
- type inference works for each overload

### verification
```sh
npm run test:types
```
- type inference matches expected return type for each overload variant

---

## phase 3: choice resolution logic

### dependencies
- phase 2 complete (overloads exist)

### deliverables
- [ ] `src/domain.operations/context/genContextBrain.ts` — implement IIFE for choice resolution:
  - if `choice: { repl: string }` → find in repls, throw if not found
  - if `choice: { atom: string }` → find in atoms, throw if not found
  - if `choice: string` → find in atoms + repls, throw if not found or ambiguous
  - if no choice → return `null`
- [ ] return `brain.choice` in context object

### acceptance criteria
- `choice: string` that matches atom → `brain.choice` is that atom
- `choice: string` that matches repl → `brain.choice` is that repl
- `choice: string` not found → `BadRequestError` with available slugs
- `choice: string` ambiguous → `BadRequestError` with matched slugs
- `choice: { repl }` matches → `brain.choice` is that repl
- `choice: { repl }` not found → `BadRequestError` with available repls
- `choice: { atom }` matches → `brain.choice` is that atom
- `choice: { atom }` not found → `BadRequestError` with available atoms
- no choice → `brain.choice` is `null`

### verification
```sh
npm run test:unit -- genContextBrain.test.ts
```
- all unit test cases pass

---

## phase 4: unit tests

### dependencies
- phase 3 complete (logic implemented)

### deliverables
- [ ] `src/domain.operations/context/genContextBrain.test.ts` — add test cases:
  - `[caseN] choice: string matches an atom`
  - `[caseN] choice: string matches a repl`
  - `[caseN] choice: string not found`
  - `[caseN] choice: string ambiguous`
  - `[caseN] choice: { repl } matches`
  - `[caseN] choice: { repl } not found`
  - `[caseN] choice: { atom } matches`
  - `[caseN] choice: { atom } not found`
  - `[caseN] no choice provided`
  - `[caseN] isBrainRepl guard`
  - `[caseN] isBrainAtom guard`

### acceptance criteria
- each test case verifies one behavioral assertion
- error cases verify error message content
- guard tests verify boolean return value

### verification
```sh
npm run test:unit -- genContextBrain.test.ts
```
- all new test cases pass
- all extant test cases still pass

---

## phase 5: type constraint tests

### dependencies
- phase 3 complete (logic implemented)

### deliverables
- [ ] `src/domain.operations/context/genContextBrain.types.test.ts` — add type tests:
  - return type precision tests with `@ts-expect-error`
  - type guard precision tests with `@ts-expect-error`
  - context type requirement tests with `@ts-expect-error`

### acceptance criteria
- `@ts-expect-error` on lines that should fail type check
- positive assignments compile without error
- type guards narrow types correctly after check

### verification
```sh
npm run test:types
```
- all `@ts-expect-error` directives trigger (would fail without directive)
- all positive assertions compile

---

## phase 6: helper exports

### dependencies
- phase 3 complete (logic implemented)

### deliverables
- [ ] `src/domain.operations/context/genContextBrain.ts` — add:
  - `getAvailableBrainSlugs({ atoms, repls }): string[]`
  - `printBrainHelp({ atoms, repls }): void`
- [ ] `src/domain.operations/context/genContextBrain.test.ts` — add test cases:
  - `[caseN] getAvailableBrainSlugs`
  - `[caseN] printBrainHelp`

### acceptance criteria
- `getAvailableBrainSlugs` returns combined atom and repl slugs
- `printBrainHelp` logs atoms and repls to console

### verification
```sh
npm run test:unit -- genContextBrain.test.ts
```
- helper test cases pass

---

## phase 7: sdk exports

### dependencies
- phase 6 complete (helpers exist)

### deliverables
- [ ] `src/contract/sdk.ts` — export:
  - `BrainChoice` type
  - `isBrainAtom` function
  - `isBrainRepl` function
  - `getAvailableBrainSlugs` function
  - `printBrainHelp` function

### acceptance criteria
- all exports are accessible via `import { ... } from 'rhachet'`

### verification
```sh
npm run test:types
```
- exports compile
- no duplicate export errors

---

## phase 8: acceptance tests

### dependencies
- phase 7 complete (sdk exports exist)

### deliverables
- [ ] `accept.blackbox/sdk/genContextBrain.acceptance.test.ts` — add blackbox tests:
  - `[case1] choice: string (generic)` — runtime behavior
  - `[case2] choice: { repl: string } (typed)` — typed choice
  - `[case3] choice: { atom: string } (typed)` — typed choice
  - `[case4] no choice provided` — null case
  - `[case5] runtime guards for adhoc validation` — guard demos

### acceptance criteria
- tests import from `rhachet` (blackbox)
- each choice variant is demonstrated
- runtime guards are demonstrated with adhoc validation pattern
- error cases verify error messages

### verification
```sh
npm run test:acceptance -- genContextBrain.acceptance.test.ts
```
- all acceptance tests pass

---

## phase 9: backward compatibility verification

### dependencies
- phase 8 complete (all implementation done)

### deliverables
- [ ] run full test suite

### acceptance criteria
- all extant tests pass without modification
- `genContextBrain({ atoms, repls })` behaves exactly as before
- `brain.choice` is `null` when no choice param (no runtime error)

### verification
```sh
npm run test
```
- full test suite passes

---

## completion checklist

- [ ] phase 1: domain types
- [ ] phase 2: genContextBrain overloads
- [ ] phase 3: choice resolution logic
- [ ] phase 4: unit tests
- [ ] phase 5: type constraint tests
- [ ] phase 6: helper exports
- [ ] phase 7: sdk exports
- [ ] phase 8: acceptance tests
- [ ] phase 9: backward compatibility verification

---

## refs

- blueprint: `3.3.blueprint.v1.i1.md`
- criteria: `2.criteria.blackbox.md`
- vision: `1.vision.md`
