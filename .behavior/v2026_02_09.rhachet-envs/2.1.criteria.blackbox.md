# blackbox criteria: env-scoped keyrack keys

ref:
- wish: `.behavior/v2026_02_09.rhachet-envs/0.wish.md`
- proposal: `.behavior/v2026_02_09.rhachet-envs/.refs/proposal.keys-per-env.md`

---

# usecase.1 = declare env-scoped keys in keyrack.yml

given('a repo with keyrack.yml that uses env.all and env-specific sections')
  when('keyrack.yml declares env.all keys')
    then('those keys are required in every declared env')
      sothat('common keys like XAI_API_KEY dont need to be repeated per env')
    then('envs are inferred from the env.* sections present in the file (except env.all)')
      sothat('no redundant env list declaration is needed')

  when('keyrack.yml declares env.prod keys')
    then('those keys are required only in the prod env')
      sothat('env-specific keys like AWS_PROFILE are scoped to where they belong')

  when('keyrack.yml declares env.prep keys')
    then('those keys are required only in the prep env')

  when('keyrack.yml declares env.test keys')
    then('those keys are required only in the test env')

  when('keyrack.yml declares a key under env.all AND the same key under a specific env')
    then('the env-specific declaration overrides the env.all grade for that env')
      sothat('a key can be encrypted in prod but plaintext in test')

  when('keyrack.yml has no env.* sections and uses flat `keys:` format')
    then('error; the old keys: format is no longer supported')
      sothat('users migrate to env-scoped keys with a hard cut')

---

# usecase.2 = slug resolution from env-scoped keys

given('keyrack.yml with org and env-scoped keys')
  when('a key is declared under env.all')
    then('it resolves to one slug per declared env: $org.$env.$key')
      sothat('each env gets its own credential value for the same key name')

  when('a key is declared under env.prod')
    then('it resolves to slug: $org.prod.$key')

  when('a key is declared under env.prep')
    then('it resolves to slug: $org.prep.$key')

  when('a key is declared under env.test')
    then('it resolves to slug: $org.test.$key')

  when('two repos declare the same key name under different orgs')
    then('slugs differ by org prefix: ehmpathy.prod.AWS_PROFILE vs ahbode.prod.AWS_PROFILE')
      sothat('orgs are isolated from each other')

---

# usecase.3 = unlock with env filter

given('keyrack has env-scoped keys configured on host')
  when('user runs `rhx keyrack unlock --env prep`')
    then('only keys for env prep (env.prep + env.all resolved to prep) are unlocked')
      sothat('prod keys are not exposed when only prep access is needed')
    then('output shows which env was unlocked and how many keys')

  when('user runs `rhx keyrack unlock --env prod`')
    then('only keys for env prod are unlocked')
    then('prep and test keys remain locked')
      sothat('blast radius is minimized')

  when('user runs `rhx keyrack unlock --env all`')
    then('keys for all declared envs are unlocked')
      sothat('admin tasks that need cross-env access are still possible')

  when('user runs `rhx keyrack unlock` without --env and keyrack.yml has env-specific sections')
    then('error: --env is required')
    then('error message lists available envs')
      sothat('user never gets wrong credentials from a silent default')

  when('user runs `rhx keyrack unlock` without --env and keyrack.yml only has env.all')
    then('unlocks env.all keys (only one choice, so --env is not required)')
      sothat('env.all-only repos dont need a redundant flag')

---

# usecase.4 = get with env filter

given('keyrack has env-scoped keys unlocked for prep')
  when('user runs `source rhx keyrack get --for repo --env prep`')
    then('only prep keys are exported to the shell')
    then('exported env var names are the raw key names (e.g., AWS_PROFILE, not ehmpathy.prep.AWS_PROFILE)')
      sothat('tools see standard env var names without any slug prefix')

  when('user runs `source rhx keyrack get --for repo --env prod`')
    then('fails with locked status since prod was not unlocked')
    then('error message shows which keys are locked and how to unlock')
      sothat('user knows exactly what to do to fix it')

  when('user runs `source rhx keyrack get --for repo` without --env and keyrack.yml has env-specific sections')
    then('error: --env is required')
    then('error message lists available envs')
      sothat('user never gets wrong credentials from a silent default')

  when('user runs `source rhx keyrack get --for repo` without --env and keyrack.yml only has env.all')
    then('gets env.all keys (only one choice, so --env is not required)')
      sothat('env.all-only repos dont need a redundant flag')

  when('user requests a specific key with `rhx keyrack get --for key --key XAI_API_KEY --env prod`')
    then('returns the prod-scoped value for that key')
    then('exported as XAI_API_KEY (not the full slug)')

---

# usecase.5 = set (configure host storage) with --org and --env

given('user wants to configure storage for env-scoped keys')
  when('user runs `rhx keyrack set --key AWS_PROFILE` without --org or --env')
    then('defaults to --org @this --env all')
    then('configures host storage for every env that declares AWS_PROFILE')
      sothat('the common case requires minimal flags')

  when('user runs `rhx keyrack set --key AWS_PROFILE --env prod`')
    then('configures host storage for $org.prod.AWS_PROFILE only')
    then('--org defaults to @this (inferred from keyrack.yml org field)')
      sothat('prod AWS_PROFILE can use aws.sso with profile ehmpathy.prod')

  when('user runs `rhx keyrack set --key AWS_PROFILE --env prep`')
    then('configures host storage for $org.prep.AWS_PROFILE only')
    then('does not affect the prod host configuration for AWS_PROFILE')
      sothat('each env has independent host storage config')

  when('user runs `rhx keyrack set --key AWS_PROFILE --org @this --env all`')
    then('same as omitted --org and --env (explicit form of the default)')

  when('user runs `rhx keyrack set --key XAI_API_KEY --org ehmpathy --env prod`')
    then('configures host storage for ehmpathy.prod.XAI_API_KEY')
    then('--org ehmpathy is accepted because it matches keyrack.yml org')

  when('user runs `rhx keyrack set --key XAI_API_KEY --org foreign-org`')
    then('error: org "foreign-org" does not match this repo keyrack.yml org')
      sothat('users cannot configure keys for orgs they dont own from this repo')

  when('keyrack.yml has no org field and user omits --org')
    then('error: --org is required when keyrack.yml does not declare org')

  when('user runs `rhx keyrack set --key AWS_PROFILE --env all` and AWS_PROFILE is declared in env.prod and env.prep')
    then('configures host storage for both $org.prod.AWS_PROFILE and $org.prep.AWS_PROFILE')
      sothat('--env all expands to all envs that declare the key')

---

# usecase.6 = list and status with env awareness

given('keyrack has env-scoped keys')
  when('user runs `rhx keyrack list`')
    then('output groups keys by env')
    then('shows which keys are configured on host vs absent')

  when('user runs `rhx keyrack status`')
    then('output shows unlocked keys grouped by env')
    then('shows lock/unlock state per env')

---

# usecase.7 = export behavior preserves raw key names

given('keys are env-scoped with slug format $org.$env.$key')
  when('keys are exported via `source rhx keyrack get --for repo --env prep`')
    then('the shell receives `AWS_PROFILE=value` not `ehmpathy.prep.AWS_PROFILE=value`')
      sothat('no code changes are needed in tools that consume env vars')
    then('the shell receives `XAI_API_KEY=value` not `ehmpathy.prep.XAI_API_KEY=value`')

  when('env.all key XAI_API_KEY is exported for prep')
    then('the shell receives `XAI_API_KEY=<prep-specific-value>`')
    then('the value is the prep-specific secret, not the prod secret')
      sothat('env isolation is maintained at the value level')

---

# usecase.8 = env isolation security

given('prod and prep keys are separate slugs')
  when('user has only unlocked prep keys')
    then('get --env prod fails with locked status')
    then('prod secrets are never exposed')
      sothat('accidental prod access is prevented')

  when('user unlocks prep, then later unlocks prod')
    then('both envs are accessible')
    then('get --env prep returns prep values, get --env prod returns prod values')
      sothat('multiple envs can coexist when needed')

---

# usecase.9 = --env required when env-specific sections exist

given('keyrack.yml declares env.prod and env.prep sections')
  when('user runs `rhx keyrack unlock` without --env')
    then('error: --env is required')
    then('error lists available envs: prod, prep, all')
      sothat('user never gets wrong credentials from a silent default')

  when('user runs `source rhx keyrack get --for repo` without --env')
    then('error: --env is required')
      sothat('explicit env selection prevents credential mismatch')

  when('user runs `rhx keyrack set --key AWS_PROFILE` without --env')
    then('defaults to --env all (set configures host storage, not credential access)')
      sothat('set can still configure all envs at once for convenience')

given('keyrack.yml only declares env.all (no env-specific sections)')
  when('user runs `rhx keyrack unlock` without --env')
    then('env.all keys are unlocked')
      sothat('there is only one choice, so --env is not required')

  when('user runs `source rhx keyrack get --for repo` without --env')
    then('env.all keys are exported')

  when('user runs `rhx keyrack unlock --env all`')
    then('same as without --env (explicit form of the only choice)')

---

# usecase.10 = grade requirements per env

given('keyrack.yml with different grades per env')
  when('env.prod declares `DB_PASSWORD: encrypted`')
    then('prod DB_PASSWORD requires encrypted storage')
  when('env.test declares `DB_PASSWORD` (no grade)')
    then('test DB_PASSWORD allows plaintext storage')
      sothat('local test databases dont need encrypted credential management')

---

# usecase.11 = keyrack.yml validation

given('keyrack.yml with env-scoped sections')
  when('org field is absent')
    then('error: org is required for env-scoped keys')

  when('env.all is declared but no env-specific sections exist')
    then('error: env.all requires at least one env.* section to expand into')

  when('a key name contains dots or org prefix characters')
    then('the key is accepted as-is (key names are opaque strings)')

  when('an unknown section like `env.sandbox` is declared')
    then('it is accepted as a valid env name')
      sothat('env names are not restricted to a fixed set')

---

# usecase.12 = github action requires explicit env

given('.github/actions/rhachet/keyrack action is used in a workflow')
  when('action is invoked with `env: test`')
    then('test keys are granted to the workflow')

  when('action is invoked with `env: prod`')
    then('prod keys are granted to the workflow')

  when('action is invoked with `env: all`')
    then('keys for all declared envs are granted')

  when('action is invoked without `env` input')
    then('error: env is a required input, no default')
      sothat('every workflow is forced to be explicit about which env it operates in')

  when('action is invoked with `env: all` in every workflow')
    then('works â€” if they always want all envs, they prescribe `all` always')
      sothat('there is no hidden default; intent is always visible in the workflow file')
