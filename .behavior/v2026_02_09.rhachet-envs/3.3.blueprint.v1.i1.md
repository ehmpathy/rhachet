# blueprint: env-scoped keyrack keys

ref:
- wish: `.behavior/v2026_02_09.rhachet-envs/0.wish.md`
- vision: `.behavior/v2026_02_09.rhachet-envs/1.vision.md`
- criteria: `.behavior/v2026_02_09.rhachet-envs/2.1.criteria.blackbox.md`
- matrix: `.behavior/v2026_02_09.rhachet-envs/2.2.criteria.blackbox.matrix.md`
- patterns: `.behavior/v2026_02_09.rhachet-envs/3.1.research.patterns._.code.prod.v1.i1.md`

---

## filediff treestruct

```
src/
  domain.objects/keyrack/
    [~] KeyrackRepoManifest.ts          ‚Äî add org, envs, env-scoped keys map
    [~] KeyrackKeySpec.ts               ‚Äî add env, name, grade (inline nested shape)
  domain.operations/keyrack/
    [+] asKeyrackKeyName.ts        ‚Äî extract raw key name from slug ($org.$env.$key -> $key)
    [+] asKeyrackKeyName.test.ts   ‚Äî unit tests for slug-to-keyname extraction
    [+] getAllKeyrackSlugsForEnv.ts    ‚Äî filter manifest keys by env
    [+] getAllKeyrackSlugsForEnv.test.ts ‚Äî unit tests for env filter
    [+] getAllKeyrackEnvsFromRepoManifest.ts           ‚Äî derive declared envs from manifest
    [+] getAllKeyrackEnvsFromRepoManifest.test.ts      ‚Äî unit tests for env derivation
    [+] assertKeyrackEnvIsSpecified.ts            ‚Äî fail-fast when --env omitted but env-specific sections exist
    [+] assertKeyrackEnvIsSpecified.test.ts       ‚Äî unit tests for env requirement assertion
    [+] assertKeyrackOrgMatchesManifest.ts              ‚Äî fail-fast when --org does not match keyrack.yml org
    [+] assertKeyrackOrgMatchesManifest.test.ts         ‚Äî unit tests for org match assertion
    [~] getKeyrackKeyGrant.ts           ‚Äî accept env filter, pass to slug iteration
    [~] getKeyrackKeyGrant.test.ts      ‚Äî extend tests for env-scoped grant
    [~] getKeyrackKeyGrant.integration.test.ts ‚Äî extend for env-scoped scenarios
    [~] setKeyrackKeyHost.ts            ‚Äî accept env + org to compute slugs
    [~] setKeyrackKeyHost.test.ts       ‚Äî extend for env-scoped set
    session/
      [~] unlockKeyrack.ts              ‚Äî accept env filter, filter slug iteration
      [~] getKeyrackStatus.ts           ‚Äî group output by env
  access/daos/
    daoKeyrackRepoManifest/
      [~] schema.ts                     ‚Äî replace flat keys: with org + env.* sections
      [~] index.ts                      ‚Äî replace hydration with env expansion + slug generation
      [+] schema.test.ts               ‚Äî unit tests for new schema validation
      [+] index.test.ts                ‚Äî unit tests for hydration + env expansion
  contract/
    cli/
      [~] invokeKeyrack.ts             ‚Äî add --env and --org flags; strip slug on export
    [~] sdk.keyrack.ts                  ‚Äî add env parameter to get/set/unlock
.github/actions/keyrack/
  [~] action.yml                        ‚Äî add env input (required, no default); strip slug on export

test/
  acceptance/
    [~] keyrack.validation.acceptance.test.ts   ‚Äî add env-scoped validation cases
    [~] keyrack.session.acceptance.test.ts       ‚Äî add env-scoped unlock/get cases
    [~] keyrack.set.acceptance.test.ts           ‚Äî add env-scoped set cases
    [~] keyrack.cli.acceptance.test.ts           ‚Äî add env-scoped cli cases
    [+] keyrack.envs.acceptance.test.ts          ‚Äî env isolation acceptance tests
```

---

## codepath treestruct

```
keyrack.yml parse + validate
  [~] daoKeyrackRepoManifest.get()
    [‚óã] read file from disk
    [‚óã] parse yaml
    [~] validate schema
      [~] schemaKeyrackRepoManifest (flat keys: -> org + env.* sections)
      [+] validate: reject flat keys: format with clear error
      [+] validate: org field required
      [+] validate: env.all requires at least one env.* section
      [+] validate: accept open-ended env names (env.sandbox, etc)
    [~] hydrate domain objects
      [-] flat slug iteration (keys[slug] -> KeyrackKeySpec)
      [+] env expansion: env.all keys -> one slug per declared env
      [+] env-specific keys: direct slug for declared env
      [+] grade override: env-specific grade wins over env.all grade
      [+] slug generation: $org.$env.$key format

domain object contracts
  [~] KeyrackRepoManifest
    [+] org: string
    [+] envs: string[]                     ‚Äî derived from env.* section names (except env.all)
    [‚óã] keys: Record<string, KeyrackKeySpec>  ‚Äî keyed by slug ($org.$env.$key)
  [~] KeyrackKeySpec
    [‚óã] slug: string                       ‚Äî now $org.$env.$key format
    [‚óã] mech: KeyrackGrantMechanism
    [+] env: string                        ‚Äî which env this key belongs to
    [+] name: string                    ‚Äî raw key name (e.g., AWS_PROFILE)
    [+] grade: { protection, duration } | null ‚Äî inline grade minimum (no separate dobj)

slug + env helper operations
  [+] asKeyrackKeyName({ slug })
    ‚Äî extract raw key name: 'ehmpathy.prod.AWS_PROFILE' -> 'AWS_PROFILE'
    ‚Äî split on '.', take last segment
  [+] getAllKeyrackSlugsForEnv({ manifest, env })
    ‚Äî filter manifest.keys to slugs that match the requested env
    ‚Äî env='all' returns all slugs
    ‚Äî env='prep' returns slugs where spec.env === 'prep'
  [+] getAllKeyrackEnvsFromRepoManifest({ manifest })
    ‚Äî derive declared envs from manifest.envs field
    ‚Äî returns string[] of env names (e.g., ['prod', 'prep'])
  [+] assertKeyrackEnvIsSpecified({ manifest, env })
    ‚Äî if manifest.envs.length > 0 and env is null: throw BadRequestError
    ‚Äî if manifest.envs.length === 0: env defaults to 'all' (only env.all keys)
  [+] assertKeyrackOrgMatchesManifest({ manifest, org })
    ‚Äî if org === '@this' or org === manifest.org: pass
    ‚Äî if org !== manifest.org: throw BadRequestError

credential resolution
  [~] getKeyrackKeyGrant()
    [~] repo grant overload
      [+] accept env parameter in input
      [+] call assertKeyrackEnvIsSpecified() before iteration
      [+] call getAllKeyrackSlugsForEnv() to filter slugs
      [‚óã] iterate filtered slugs via attemptGrantKey()
    [‚óã] key grant overload ‚Äî retain as-is (slug is explicit)
    [‚óã] attemptGrantKey() ‚Äî retain as-is (slug-agnostic)
    [‚óã] toKeyrackKey() ‚Äî retain as-is (grade inference from vault+mech)
    [‚óã] priority chain: os.envvar -> os.daemon -> os.direct -> vault

session management
  [~] unlockKeyrack()
    [+] accept env parameter in input
    [+] call assertKeyrackEnvIsSpecified() before iteration
    [+] call getAllKeyrackSlugsForEnv() to filter slugs
    [~] iterate filtered slugs instead of all manifest keys
    [‚óã] daemon batch unlock ‚Äî retain as-is (slug-agnostic)
  [~] getKeyrackStatus()
    [+] group output by env (derive env from slug format)

host storage
  [‚óã] setKeyrackKeyHost() ‚Äî retain as-is (slug-agnostic findsert)
  [~] CLI set command
    [+] accept --env and --org flags
    [+] compute slug(s) from org + env + key name
    [+] --env all: expand to all envs that declare the key
    [+] --org @this: resolve from manifest org field
    [+] --org mismatch: fail fast
    [‚Üê] call setKeyrackKeyHost() once per computed slug

CLI surface
  [~] invokeKeyrack get
    [+] add --env <env> option
    [+] call assertKeyrackEnvIsSpecified() before grant
    [+] pass env to getKeyrackKeyGrant()
    [~] export: strip slug to raw key name via asKeyrackKeyName()
    [~] tree output: show org and env context
  [~] invokeKeyrack set
    [+] add --env <env> option (default: 'all')
    [+] add --org <org> option (default: '@this')
    [+] resolve org from manifest when @this
    [+] compute slugs: $org.$env.$key for each target env
    [‚Üê] call setKeyrackKeyHost() per slug
  [~] invokeKeyrack unlock
    [+] add --env <env> option
    [+] call assertKeyrackEnvIsSpecified() before unlock
    [+] pass env to unlockKeyrack()
    [~] tree output: show org and env context
  [‚óã] invokeKeyrack relock ‚Äî retain as-is (slug-level purge)
  [~] invokeKeyrack status ‚Äî group by env
  [~] invokeKeyrack list ‚Äî group by env

github action
  [~] action.yml
    [+] add env input (required, no default)
    [+] pass --env $env to rhx keyrack get
    [+] strip slug to raw key name on export to $GITHUB_ENV

sdk
  [~] keyrack.get()
    [+] accept env parameter
  [~] keyrack.set()
    [+] accept env and org parameters
  [~] keyrack.unlock()
    [+] accept env parameter

reuse (no changes)
  [‚óã] KeyrackHostManifest ‚Äî slug-agnostic
  [‚óã] KeyrackKeyHost ‚Äî slug-agnostic
  [‚óã] KeyrackKeyGrant ‚Äî slug-agnostic
  [‚óã] KeyrackGrantAttempt ‚Äî four statuses cover all env scenarios
  [‚óã] KeyrackKey + KeyrackKeyGrade ‚Äî grade inference is env-independent
  [‚óã] genKeyrackGrantContext ‚Äî extended manifest flows through naturally
  [‚óã] genKeyrackHostContext ‚Äî slug-agnostic
  [‚óã] all vault adapters ‚Äî slug-agnostic
  [‚óã] all mechanism adapters ‚Äî mechanism-specific, env-agnostic
  [‚óã] daemon svc + sdk ‚Äî slug-agnostic key store
```

---

## domain object contracts

### KeyrackRepoManifest (extend)

```ts
interface KeyrackRepoManifest {
  org: string;                             // [+] org name (e.g., 'ehmpathy')
  envs: string[];                          // [+] declared envs derived from env.* sections
  keys: Record<string, KeyrackKeySpec>;    // [‚óã] keyed by slug ($org.$env.$key)
}
```

the `keys` map retains its shape but slugs shift from `KEY_NAME` to `$org.$env.$key`. the `envs` field is derived at parse time from `env.*` section names (except `env.all`). the `org` field is required.

### KeyrackKeySpec (extend)

```ts
interface KeyrackKeySpec {
  slug: string;                            // [‚óã] now $org.$env.$key format
  mech: KeyrackGrantMechanism;             // [‚óã] mechanism constraint
  env: string;                             // [+] which env this key belongs to
  name: string;                         // [+] raw key name (e.g., 'AWS_PROFILE')
  grade: {                              // [+] inline grade minimum, null for none
    protection: 'encrypted' | null;        //     null = any protection accepted
    duration: 'ephemeral' | null;          //     null = any duration accepted
  } | null;
}
```

`env` and `name` enable the system to filter by env and export raw names. `grade` captures what the keyrack.yml author declared (e.g., `encrypted`, `ephemeral`). inlined on `KeyrackKeySpec` ‚Äî no separate domain object needed (single-usage shape, two fields, no identity).

yaml shorthand parse: `encrypted` -> `{ protection: 'encrypted', duration: null }`, `ephemeral` -> `{ protection: null, duration: 'ephemeral' }`, `encrypted,ephemeral` -> `{ protection: 'encrypted', duration: 'ephemeral' }`, bare key name -> `null` (no grade minimum).

---

## keyrack.yml schema contract

### before (flat)

```yaml
keys:
  XAI_API_KEY:
    mech: REPLICA
```

### after (env-scoped)

```yaml
org: ehmpathy

env.all:
  - XAI_API_KEY: encrypted

env.prod:
  - AWS_PROFILE: ephemeral

env.prep:
  - AWS_PROFILE: ephemeral
```

### schema rules

1. `org` field is required (string)
2. at least one `env.*` section must exist
3. `env.all` requires at least one env-specific section (env.all needs envs to expand into)
4. each `env.*` value is an array of key declarations
5. key declaration formats accepted:
   - `KEY_NAME` (bare, no grade requirement)
   - `KEY_NAME: encrypted` (protection constraint)
   - `KEY_NAME: ephemeral` (duration constraint)
   - `KEY_NAME: encrypted,ephemeral` (both constraints)
6. flat `keys:` format is rejected with a clear error
7. env names are open-ended (env.sandbox, env.stage, etc)

### hydration logic

for each `env.*` section (except `env.all`):
- register env name in `manifest.envs`
- for each key in the section:
  - compute slug: `$org.$env.$key`
  - parse grade shorthand to `grade`
  - create `KeyrackKeySpec({ slug, mech: null, env, name, grade })`
  - store in `manifest.keys[slug]`

for `env.all` keys:
- for each declared env in `manifest.envs`:
  - compute slug: `$org.$env.$key`
  - parse grade shorthand
  - if env-specific section also declares same key: env-specific grade overrides
  - create `KeyrackKeySpec` and store in `manifest.keys[slug]`

note: `mech` in keyrack.yml is removed from the spec ‚Äî mechanism lives on the host side (`setKeyrackKeyHost`). the `KeyrackKeySpec.mech` field retains a default value for backwards compat in the transition, but the new yaml format does not declare mechanism.

---

## operation contracts

### asKeyrackKeyName

```ts
/**
 * .what = extract raw key name from env-scoped slug
 * .why = export layer needs raw names (AWS_PROFILE, not ehmpathy.prep.AWS_PROFILE)
 */
const asKeyrackKeyName = (input: { slug: string }): string
// 'ehmpathy.prod.AWS_PROFILE' -> 'AWS_PROFILE'
// 'ehmpathy.prep.XAI_API_KEY' -> 'XAI_API_KEY'
```

implementation: `slug.split('.').slice(2).join('.')` ‚Äî supports key names that contain dots.

### getAllKeyrackSlugsForEnv

```ts
/**
 * .what = filter manifest keys to slugs for a specific env
 * .why = unlock and get must only operate on the requested env
 */
const getAllKeyrackSlugsForEnv = (input: {
  manifest: KeyrackRepoManifest;
  env: string;
}): string[]
// env='all' -> all slugs
// env='prep' -> slugs where spec.env === 'prep'
```

### getAllKeyrackEnvsFromRepoManifest

```ts
/**
 * .what = derive the list of declared envs from a manifest
 * .why = error messages and cli output need to list available envs
 */
const getAllKeyrackEnvsFromRepoManifest = (input: {
  manifest: KeyrackRepoManifest;
}): string[]
// returns manifest.envs (e.g., ['prod', 'prep'])
```

### assertKeyrackEnvIsSpecified

```ts
/**
 * .what = fail fast if --env is omitted when env-specific sections exist
 * .why = prevent accidental credential mismatch from silent defaults
 */
const assertKeyrackEnvIsSpecified = (input: {
  manifest: KeyrackRepoManifest;
  env: string | null;
}): string
// returns resolved env:
//   if env is provided: returns env
//   if env is null and manifest.envs is empty: returns 'all' (only env.all)
//   if env is null and manifest.envs has entries: throws BadRequestError
```

### assertKeyrackOrgMatchesManifest

```ts
/**
 * .what = fail fast if --org does not match the manifest org
 * .why = prevent cross-org credential configuration
 */
const assertKeyrackOrgMatchesManifest = (input: {
  manifest: KeyrackRepoManifest;
  org: string;
}): string
// returns resolved org:
//   if org is '@this': returns manifest.org
//   if org === manifest.org: returns org
//   if org !== manifest.org: throws BadRequestError
```

---

## cli contract changes

### get command

```
rhx keyrack get --for repo --env prep          # get prep keys
rhx keyrack get --for repo --env prod          # get prod keys
rhx keyrack get --for repo --env all           # get all keys
rhx keyrack get --for repo                     # error if env-specific sections exist
rhx keyrack get --key XAI_API_KEY --env prod   # get specific key for prod
```

export format: `export AWS_PROFILE="value"` (raw key name, not slug)

### set command

```
rhx keyrack set --key AWS_PROFILE --env prod --mech EPHEMERAL_VIA_AWS_SSO --vault os.secure
rhx keyrack set --key AWS_PROFILE --env prep --mech EPHEMERAL_VIA_AWS_SSO --vault os.secure
rhx keyrack set --key XAI_API_KEY                 # defaults --env all --org @this
rhx keyrack set --key XAI_API_KEY --org ehmpathy  # explicit org (must match manifest)
```

set defaults: `--env all`, `--org @this`

### unlock command

```
rhx keyrack unlock --env prep                  # unlock prep keys only
rhx keyrack unlock --env prod                  # unlock prod keys only
rhx keyrack unlock --env all                   # unlock all envs
rhx keyrack unlock                             # error if env-specific sections exist
```

tree output:

```
üîì keyrack unlock (org: ehmpathy, env: prep)
   ‚îú‚îÄ ehmpathy.prep.XAI_API_KEY
   ‚îÇ  ‚îú‚îÄ vault: os.secure
   ‚îÇ  ‚îî‚îÄ expires in: 540m
   ‚îú‚îÄ ehmpathy.prep.AWS_PROFILE
   ‚îÇ  ‚îú‚îÄ vault: os.secure
   ‚îÇ  ‚îî‚îÄ expires in: 540m
   ‚îî‚îÄ ‚ú® 2 keys unlocked
```

---

## github action contract

```yaml
inputs:
  env:
    description: 'target env: prod, prep, test, or all (required, no default)'
    required: true
  keys:
    description: 'space-separated list of key slugs (optional, default: all keys for env)'
    required: false
    default: ''
  vault:
    description: 'vault type for resolution'
    required: false
    default: 'os.direct'
  passphrase:
    description: 'passphrase for encrypted vaults'
    required: false
    default: ''
```

export behavior: strip slug to raw key name before write to `$GITHUB_ENV`

```bash
# before: echo "${SLUG}=${VALUE}" >> $GITHUB_ENV
# after:  KEY_NAME extracted from slug, then echo "${KEY_NAME}=${VALUE}" >> $GITHUB_ENV
```

---

## test coverage

### unit tests

| file | covers |
|------|--------|
| `asKeyrackKeyName.test.ts` | slug-to-keyname extraction for all slug formats |
| `getAllKeyrackSlugsForEnv.test.ts` | env filter: all, specific env, env.all-only manifest |
| `getAllKeyrackEnvsFromRepoManifest.test.ts` | env derivation from manifest |
| `assertKeyrackEnvIsSpecified.test.ts` | --env omission with/without env-specific sections |
| `assertKeyrackOrgMatchesManifest.test.ts` | @this resolution, exact match, mismatch |
| `schema.test.ts` | new yaml format validation, flat keys: rejection, grade shorthand parse |
| `index.test.ts` (dao) | hydration: env expansion, slug generation, grade overrides |

### integration tests

| file | covers |
|------|--------|
| `getKeyrackKeyGrant.integration.test.ts` | env-filtered credential resolution end-to-end |
| `daoKeyrackRepoManifest.integration.test.ts` | yaml parse from disk with env-scoped format |

### acceptance tests

| file | covers |
|------|--------|
| `keyrack.envs.acceptance.test.ts` | env isolation: unlock prep, get prep succeeds, get prod fails (usecase 8) |
| `keyrack.validation.acceptance.test.ts` | flat keys: rejection, org required, env.all without envs error (usecase 11) |
| `keyrack.session.acceptance.test.ts` | unlock with --env, env filter on get (usecases 3, 4, 9) |
| `keyrack.set.acceptance.test.ts` | set with --env, --org, org mismatch (usecase 5) |
| `keyrack.cli.acceptance.test.ts` | --env required error, raw key name export (usecases 7, 9) |

### coverage matrix alignment

| usecase | test type | test file |
|---------|-----------|-----------|
| 1 (declare env-scoped keys) | unit | `schema.test.ts`, `index.test.ts` |
| 2 (slug resolution) | unit | `index.test.ts`, `asKeyrackKeyName.test.ts` |
| 3 (unlock with env filter) | acceptance | `keyrack.session.acceptance.test.ts` |
| 4 (get with env filter) | acceptance | `keyrack.session.acceptance.test.ts` |
| 5 (set with --org/--env) | acceptance | `keyrack.set.acceptance.test.ts` |
| 6 (list and status) | acceptance | `keyrack.cli.acceptance.test.ts` |
| 7 (raw key name export) | unit + acceptance | `asKeyrackKeyName.test.ts`, `keyrack.cli.acceptance.test.ts` |
| 8 (env isolation) | acceptance | `keyrack.envs.acceptance.test.ts` |
| 9 (--env required) | unit + acceptance | `assertKeyrackEnvIsSpecified.test.ts`, `keyrack.cli.acceptance.test.ts` |
| 10 (grade per env) | unit | `schema.test.ts`, `index.test.ts` |
| 11 (yml validation) | unit + acceptance | `schema.test.ts`, `keyrack.validation.acceptance.test.ts` |
| 12 (github action env) | manual verification | `action.yml` (composite action, tested via workflow runs) |

---

## architectural insight

the work concentrates in two layers:

1. **manifest layer** (REPLACE): the schema and hydration logic are fully rewritten to support `org` + `env.*` sections. this is where the flat-to-env transformation happens.

2. **command surface** (EXTEND): the CLI, SDK, and GitHub Action gain `--env` and `--org` parameters. export logic strips slugs to raw key names. error messages guide env selection.

the core resolution chain (host config -> daemon -> grant -> grade inference) requires zero structural change. the new `$org.$env.$key` slug format flows through every layer automatically. this is the key architectural advantage: env isolation is achieved by a format change at the manifest boundary, not by restructure of the resolution chain.

new helper operations (`asKeyrackKeyName`, `getAllKeyrackSlugsForEnv`, `assertKeyrackEnvIsSpecified`, `assertKeyrackOrgMatchesManifest`) are leaf functions with clear contracts, each with its own unit test suite. they compose into the command handlers without entangle of the core resolution logic.
