# research: production codepath patterns for env-scoped keyrack keys

ref:
- wish: `.behavior/v2026_02_09.rhachet-envs/0.wish.md`
- vision: `.behavior/v2026_02_09.rhachet-envs/1.vision.md`
- criteria: `.behavior/v2026_02_09.rhachet-envs/2.1.criteria.blackbox.md`

---

## pattern.1 = KeyrackRepoManifest domain object [EXTEND]

the repo manifest declares which keys a repo needs. today it uses a flat `keys:` map keyed by slug.

> ```ts
> export interface KeyrackRepoManifest {
>   keys: Record<string, KeyrackKeySpec>;
> }
> export class KeyrackRepoManifest
>   extends DomainLiteral<KeyrackRepoManifest>
>   implements KeyrackRepoManifest {}
> ```
> â€” citation [1]: `src/domain.objects/keyrack/KeyrackRepoManifest.ts:3-9`

**relation to wish**: must extend to hold `org: string` and `env.*` sections. the flat `keys:` map must be replaced with env-scoped key declarations. the interface will grow to hold an `org` field plus env-resolved key records.

---

## pattern.2 = KeyrackKeySpec domain object [EXTEND]

each key spec holds a slug and a mechanism. no grade requirement today.

> ```ts
> export interface KeyrackKeySpec {
>   slug: string;
>   mech: KeyrackGrantMechanism;
> }
> export class KeyrackKeySpec
>   extends DomainLiteral<KeyrackKeySpec>
>   implements KeyrackKeySpec {}
> ```
> â€” citation [2]: `src/domain.objects/keyrack/KeyrackKeySpec.ts:3-10`

**relation to wish**: must extend to hold optional grade requirements (e.g., `encrypted`, `ephemeral`). the `mech` field may become optional or be removed from the spec (it lives on the host side), while grade becomes the declared requirement per env. the slug will shift from raw key name to `$org.$env.$key` format.

---

## pattern.3 = dao schema for keyrack.yml validation [REPLACE]

zod schema validates the flat `keys:` map structure.

> ```ts
> export const schemaKeyrackKeySpecYaml = z.object({
>   mech: z.enum(['REPLICA', 'GITHUB_APP', 'AWS_SSO']),
> });
> export const schemaKeyrackRepoManifest = z.object({
>   keys: z.record(z.string(), schemaKeyrackKeySpecYaml),
> });
> ```
> â€” citation [3]: `src/access/daos/daoKeyrackRepoManifest/schema.ts:4-9`

**relation to wish**: must replace entirely. the new schema must validate `org:` field, `env.all:` and `env.*:` sections, reject the old flat `keys:` format, accept key grade shorthand (`encrypted`, `ephemeral`, `encrypted,ephemeral`, or bare key name), and infer env list from `env.*` section names (except `env.all`). per usecase.11, `env.all` without any `env.*` sections must error.

---

## pattern.4 = dao keyrack.yml parse and hydrate [REPLACE]

the dao reads keyrack.yml, validates via zod, and hydrates into domain objects with a flat slug iteration.

> ```ts
> const content = readFileSync(path, 'utf8');
> let parsed: unknown;
> try { parsed = parseYaml(content); } catch {
>   throw new BadRequestError('keyrack.yml has invalid yaml', { path });
> }
> const result = schemaKeyrackRepoManifest.safeParse(parsed);
> if (!result.success) {
>   throw new BadRequestError('keyrack.yml has invalid schema', { path, issues: result.error.issues });
> }
> const keys: Record<string, KeyrackKeySpec> = {};
> for (const [slug, spec] of Object.entries(result.data.keys)) {
>   keys[slug] = new KeyrackKeySpec({ ...spec, slug });
> }
> return new KeyrackRepoManifest({ keys });
> ```
> â€” citation [4]: `src/access/daos/daoKeyrackRepoManifest/index.ts:13-32`

**relation to wish**: must replace. the new hydration logic must expand `env.all` keys into one slug per declared env (`$org.$env.$key`), handle env-specific key declarations, apply grade overrides when a key appears in both `env.all` and a specific env section, and populate the extended `KeyrackRepoManifest` with org + env-scoped entries.

---

## pattern.5 = KeyrackHostManifest domain object [REUSE]

the host manifest maps slugs to host storage configs. it is slug-agnostic â€” it does not care what format the slug takes.

> ```ts
> export interface KeyrackHostManifest {
>   uri: string;
>   hosts: Record<string, KeyrackKeyHost>;
> }
> export class KeyrackHostManifest extends DomainEntity<KeyrackHostManifest>
>   implements KeyrackHostManifest {
>   public static unique = ['uri'] as const;
> }
> ```
> â€” citation [5]: `src/domain.objects/keyrack/KeyrackHostManifest.ts:4-12`

**relation to wish**: reuse as-is. the `Record<string, KeyrackKeyHost>` keyed by slug naturally supports the new `$org.$env.$key` slug format. no structural change needed â€” the host manifest just stores whatever slugs are configured.

---

## pattern.6 = KeyrackKeyHost domain object [REUSE]

each host entry stores how a slug is resolved on this machine.

> ```ts
> export interface KeyrackKeyHost {
>   slug: string;
>   exid: string | null;
>   vault: KeyrackHostVault;
>   mech: KeyrackGrantMechanism;
>   createdAt: string;
>   updatedAt: string;
> }
> ```
> â€” citation [6]: `src/domain.objects/keyrack/KeyrackKeyHost.ts:5-12`

**relation to wish**: reuse as-is. the slug field is opaque â€” it accepts any string. new slugs like `ehmpathy.prod.AWS_PROFILE` work without change.

---

## pattern.7 = KeyrackKeyGrant domain object [REUSE]

a granted credential with slug, key (secret + grade), source info, and optional expiry.

> ```ts
> export interface KeyrackKeyGrant {
>   slug: string;
>   key: KeyrackKey;
>   source: { vault: KeyrackHostVault; mech: KeyrackGrantMechanism; };
>   expiresAt?: IsoTimeStamp;
> }
> ```
> â€” citation [7]: `src/domain.objects/keyrack/KeyrackKeyGrant.ts:6-11`

**relation to wish**: reuse as-is. grants are slug-agnostic. the grant holds the full slug (`ehmpathy.prep.AWS_PROFILE`) and the resolved credential. the export layer will strip org+env prefix to produce raw key names.

---

## pattern.8 = KeyrackGrantAttempt discriminated union [REUSE]

four-status discriminated union for credential resolution outcomes.

> ```ts
> export type KeyrackGrantAttempt =
>   | KeyrackGrantAttemptGranted
>   | KeyrackGrantAttemptAbsent
>   | KeyrackGrantAttemptLocked
>   | KeyrackGrantAttemptBlocked;
> ```
> â€” citation [8]: `src/domain.objects/keyrack/KeyrackGrantAttempt.ts:25-29`

**relation to wish**: reuse as-is. the four statuses (`granted`, `absent`, `locked`, `blocked`) cover all env-scoped scenarios. when a user tries to get prod keys without unlock, the `locked` status fires â€” no new status needed.

---

## pattern.9 = KeyrackKey + KeyrackKeyGrade domain objects [REUSE]

the credential value plus its grade (protection + duration).

> ```ts
> export interface KeyrackKeyGrade {
>   protection: 'encrypted' | 'plaintext';
>   duration: 'permanent' | 'ephemeral' | 'transient';
> }
> ```
> â€” citation [9]: `src/domain.objects/keyrack/KeyrackKeyGrade.ts:1-4`

> ```ts
> export interface KeyrackKey {
>   secret: KeyrackKeySecret;
>   grade: KeyrackKeyGrade;
> }
> ```
> â€” citation [10]: `src/domain.objects/keyrack/KeyrackKey.ts:3-6`

**relation to wish**: reuse as-is. grades are inferred from vault + mechanism at resolution time, not declared in the spec. the new grade shorthand in keyrack.yml (`encrypted`, `ephemeral`) maps to minimum grade requirements â€” a separate concern from the resolved grade.

---

## pattern.10 = getKeyrackKeyGrant credential resolution [EXTEND]

the core grant function resolves credentials through a priority chain: os.envvar â†’ os.daemon â†’ os.direct â†’ host manifest vault.

> ```ts
> const attemptGrantKey = async (
>   input: { slug: string; unlock?: boolean },
>   context: KeyrackGrantContext,
> ): Promise<KeyrackGrantAttempt> => {
>   const { slug } = input;
>   const keySpec = context.repoManifest?.keys[slug];
> ```
> â€” citation [11]: `src/domain.operations/keyrack/getKeyrackKeyGrant.ts:29-34`

flat slug iteration for repo-level grants:

> ```ts
> const slugs = Object.keys(context.repoManifest.keys);
> ```
> â€” citation [12]: `src/domain.operations/keyrack/getKeyrackKeyGrant.ts:107`

**relation to wish**: must extend. the function signature needs an `env` filter parameter. when `--env prep` is specified, only slugs for that env should be resolved. the slug lookup `context.repoManifest.keys[slug]` works unchanged if the manifest is pre-filtered by env. the priority chain itself (envvar â†’ daemon â†’ direct â†’ vault) is env-agnostic and reusable.

---

## pattern.11 = toKeyrackKey grade inference [REUSE]

grade is inferred from vault + mechanism via IIFE early-return chains.

> ```ts
> const toKeyrackKey = (input: {
>   secret: KeyrackKeySecret;
>   vault: KeyrackHostVault;
>   mech: KeyrackGrantMechanism;
> }): KeyrackKey => {
>   const grade: KeyrackKeyGrade = (() => {
>     if (input.vault === 'os.daemon') return { protection: 'encrypted' as const, duration: 'transient' as const };
>     if (input.vault === 'os.envvar') return { protection: 'plaintext' as const, duration: 'transient' as const };
>     if (input.vault === 'os.direct') return { protection: 'plaintext' as const, duration: 'permanent' as const };
> ```
> â€” citation [13]: `src/domain.operations/keyrack/getKeyrackKeyGrant.ts:9-18`

**relation to wish**: reuse as-is. grade inference is independent of env scoping. grades are inferred from how a credential is stored, not from which env it belongs to. the new grade requirements in keyrack.yml are a *validation* concern (check that resolved grade meets declared minimum), separate from this inference.

---

## pattern.12 = setKeyrackKeyHost host configuration [REUSE]

findsert semantics for host storage config. slug-agnostic.

> ```ts
> export const setKeyrackKeyHost = async (
>   input: { slug: string; mech: KeyrackGrantMechanism; vault: KeyrackHostVault; exid?: string | null; },
>   context: KeyrackHostContext,
> ): Promise<KeyrackKeyHost> => {
> ```
> â€” citation [14]: `src/domain.operations/keyrack/setKeyrackKeyHost.ts:14-18`

findsert check:

> ```ts
> const hostFound = context.hostManifest.hosts[input.slug];
> if (hostFound) {
>   if (hostFound.mech === input.mech && hostFound.vault === input.vault && hostFound.exid === (input.exid ?? null)) {
>     return new KeyrackKeyHost(hostFound);
>   }
> }
> ```
> â€” citation [15]: `src/domain.operations/keyrack/setKeyrackKeyHost.ts:25-31`

**relation to wish**: reuse as-is. the `set` command will call this function once per env-slug (e.g., `ehmpathy.prod.AWS_PROFILE`, `ehmpathy.prep.AWS_PROFILE`). the function itself is slug-agnostic â€” it just stores whatever slug is given. the CLI layer handles the `--env` and `--org` flags to compute the correct slugs before call.

---

## pattern.13 = unlockKeyrack session management [EXTEND]

iterates flat manifest keys to unlock credentials into the daemon.

> ```ts
> for (const [slug, spec] of Object.entries(repoManifest.keys)) {
>   const hostConfig = context.hostManifest.hosts[slug];
>   if (!hostConfig) continue;
> ```
> â€” citation [16]: `src/domain.operations/keyrack/session/unlockKeyrack.ts:32-34`

daemon batch unlock:

> ```ts
> if (keysToUnlock.length > 0) {
>   await daemonAccessUnlock({ keys: keysToUnlock.map((k) => ({ slug: k.slug, key: k.key, expiresAt: k.expiresAt })) });
> }
> ```
> â€” citation [17]: `src/domain.operations/keyrack/session/unlockKeyrack.ts:62-64`

**relation to wish**: must extend. needs an `env` filter parameter. when `--env prep` is specified, only prep-scoped slugs should be unlocked. the daemon itself is slug-agnostic â€” it stores whatever slugs are given. the env filter applies at the iteration level: select only slugs that match the requested env before unlock.

---

## pattern.14 = genKeyrackGrantContext context assembly [REUSE]

assembles the grant context with host manifest, repo manifest, and adapters.

> ```ts
> export interface KeyrackGrantContext {
>   hostManifest: KeyrackHostManifest;
>   repoManifest: KeyrackRepoManifest | null;
>   vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter>;
>   mechAdapters: Record<KeyrackGrantMechanism, KeyrackGrantMechanismAdapter>;
> }
> ```
> â€” citation [18]: `src/domain.operations/keyrack/genKeyrackGrantContext.ts:8-13`

**relation to wish**: reuse as-is. the context holds the repo manifest (which will be extended with org + env data) and host manifest (slug-agnostic). no structural change needed to the context interface â€” the extended manifest flows through naturally.

---

## pattern.15 = invokeKeyrack CLI command surface [EXTEND]

the CLI defines `get`, `set`, `unlock`, `relock`, `status`, and `list` subcommands.

current `get` command flags:

> ```ts
> .option('--for <scope>', 'grant scope: repo | key')
> .option('--key <slug>', 'specific key slug (required when --for key)')
> .option('--json', 'output as json')
> ```
> â€” citation [19]: `src/contract/cli/invokeKeyrack.ts:17-19`

current `set` command flags:

> ```ts
> .requiredOption('--key <slug>', 'key slug to configure')
> .requiredOption('--mech <mechanism>', 'grant mechanism')
> .requiredOption('--vault <vault>', 'host vault')
> ```
> â€” citation [20]: `src/contract/cli/invokeKeyrack.ts:80-82`

current `unlock` command flags:

> ```ts
> .option('--duration <duration>', 'unlock duration (default: 8h)')
> .option('--passphrase <passphrase>', 'unlock passphrase')
> .option('--json', 'output as json')
> ```
> â€” citation [21]: `src/contract/cli/invokeKeyrack.ts:50-52`

tree-format output with unicode box-draw characters:

> ```ts
> console.log(`ðŸ” keyrack get (scope: ${scope})`);
> console.log(`   â”œâ”€ ${slug}`);
> ```
> â€” citation [22]: `src/contract/cli/invokeKeyrack.ts:35-36`

slug exported as env var name:

> ```ts
> process.stdout.write(`export ${slug}="${grant.key.secret.value}"\n`);
> ```
> â€” citation [23]: `src/contract/cli/invokeKeyrack.ts:42`

**relation to wish**: must extend. the `get` and `unlock` commands need `--env <env>` flag. the `set` command needs `--env <env>` and `--org <org>` flags (both optional, default to `all` and `@this`). on export, the slug `ehmpathy.prep.AWS_PROFILE` must be stripped to just `AWS_PROFILE` â€” the raw key name. error messages must list available envs when `--env` is omitted and env-specific sections exist. tree output must show env context (e.g., `org: ehmpathy, env: prep`).

---

## pattern.16 = github action keyrack integration [EXTEND]

the github action grants keys to CI workflows.

current inputs:

> ```yaml
> inputs:
>   keys:
>     description: 'comma-separated list of key slugs to grant'
>     required: false
>   vault:
>     description: 'vault to use for credential resolution'
>     required: false
>   passphrase:
>     description: 'passphrase for encrypted vaults'
>     required: false
> ```
> â€” citation [24]: `.github/actions/keyrack/action.yml:4-13`

slug exported as env var:

> ```yaml
> echo "${SLUG}=${VALUE}" >> $GITHUB_ENV
> ```
> â€” citation [25]: `.github/actions/keyrack/action.yml:38`

**relation to wish**: must extend. needs a new `env` input (required, no default). per usecase.12, every workflow must explicitly declare which env it operates in. on export, the slug must be stripped to the raw key name. if `env` is omitted, the action must error with a clear message.

---

## pattern.17 = slug as universal key [REUSE]

the slug is the universal identifier that threads through every layer: manifest â†’ host config â†’ daemon â†’ grant â†’ export.

manifest lookup by slug:

> ```ts
> const keySpec = context.repoManifest?.keys[slug];
> ```
> â€” citation [26]: `src/domain.operations/keyrack/getKeyrackKeyGrant.ts:34`

host lookup by slug:

> ```ts
> const hostFound = context.hostManifest.hosts[input.slug];
> ```
> â€” citation [27]: `src/domain.operations/keyrack/setKeyrackKeyHost.ts:25`

daemon operations by slug:

> ```ts
> await daemonAccessUnlock({ keys: keysToUnlock.map((k) => ({ slug: k.slug, key: k.key, expiresAt: k.expiresAt })) });
> ```
> â€” citation [28]: `src/domain.operations/keyrack/session/unlockKeyrack.ts:62`

grant carries slug:

> ```ts
> export interface KeyrackKeyGrant {
>   slug: string;
> ```
> â€” citation [29]: `src/domain.objects/keyrack/KeyrackKeyGrant.ts:6-7`

export uses slug as env var name:

> ```ts
> process.stdout.write(`export ${slug}="${grant.key.secret.value}"\n`);
> ```
> â€” citation [30]: `src/contract/cli/invokeKeyrack.ts:42`

**relation to wish**: reuse. the slug-as-universal-key architecture means that the format change from `KEY_NAME` to `$org.$env.$key` propagates env isolation through every layer automatically. no intermediate adapter is needed â€” the slug flows through host config, daemon, and grants unchanged. the only new concern is the export layer, which must strip org+env prefix to produce raw key names for the shell.

---

## summary

| # | pattern | verdict | reason |
|---|---------|---------|--------|
| 1 | KeyrackRepoManifest | EXTEND | add `org` field, env-scoped key structure |
| 2 | KeyrackKeySpec | EXTEND | add grade requirements, remove `mech` from spec |
| 3 | dao schema (zod) | REPLACE | flat `keys:` â†’ `org` + `env.*:` sections |
| 4 | dao parse + hydrate | REPLACE | flat iteration â†’ env expansion with slug generation |
| 5 | KeyrackHostManifest | REUSE | slug-agnostic, supports new format |
| 6 | KeyrackKeyHost | REUSE | slug-agnostic |
| 7 | KeyrackKeyGrant | REUSE | slug-agnostic |
| 8 | KeyrackGrantAttempt | REUSE | four statuses cover all env scenarios |
| 9 | KeyrackKey + KeyrackKeyGrade | REUSE | grade inference is env-independent |
| 10 | getKeyrackKeyGrant | EXTEND | add env filter to slug iteration |
| 11 | toKeyrackKey | REUSE | grade inference is env-independent |
| 12 | setKeyrackKeyHost | REUSE | slug-agnostic findsert |
| 13 | unlockKeyrack | EXTEND | add env filter to unlock iteration |
| 14 | genKeyrackGrantContext | REUSE | context flows extended manifest naturally |
| 15 | invokeKeyrack CLI | EXTEND | add --env, --org flags; strip slug on export |
| 16 | github action | EXTEND | add `env` input (required); strip slug on export |
| 17 | slug as universal key | REUSE | format change propagates isolation automatically |

**counts**: REUSE = 9, EXTEND = 6, REPLACE = 2

**architectural insight**: the two REPLACE patterns concentrate at the manifest layer (schema + parser). the six EXTEND patterns add env awareness to commands and iteration. the nine REUSE patterns confirm that the core credential resolution chain (host config â†’ daemon â†’ grant â†’ grade inference) is slug-agnostic and requires zero structural change â€” the new `$org.$env.$key` slug format flows through every layer automatically.
