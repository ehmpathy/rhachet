# vision: env-scoped keyrack keys

---

## the outcome world

### before

```yaml
# keyrack.yml â€” the old world
keys:
  AWS_PROFILE_PROD: encrypted,ephemeral
  AWS_PROFILE_PREP: encrypted,ephemeral
  XAI_API_KEY: encrypted
```

```sh
# unlock dumps all keys â€” prod, prep, test. all at once.
$ rhx keyrack unlock
ðŸ”“ 3 keys unlocked

# tools expect AWS_PROFILE, not AWS_PROFILE_PROD
# so you end up with hacks:
$ export AWS_PROFILE=$AWS_PROFILE_PROD   # manual, fragile, error-prone
```

the problem: `AWS_PROFILE` must be the exact envvar name. every tool expects it. but today, keyrack has no concept of "this key is for prod" vs "this key is for prep." so users invent suffix conventions (`_PROD`, `_PREP`) and manually re-export. fragile. easy to forget. easy to leak prod when you meant prep.

### after

```yaml
# keyrack.yml â€” the new world
org: ehmpathy

env.all:
  - XAI_API_KEY: encrypted

env.prod:
  - AWS_PROFILE: ephemeral

env.prep:
  - AWS_PROFILE: ephemeral
```

```sh
# unlock only what you need
$ rhx keyrack unlock --env prep
ðŸ”“ keyrack unlock (org: ehmpathy, env: prep)
   â”œâ”€ ehmpathy.prep.XAI_API_KEY
   â”œâ”€ ehmpathy.prep.AWS_PROFILE
   â””â”€ âœ¨ 2 keys unlocked

# get exports raw key names â€” tools see AWS_PROFILE, not the slug
$ source rhx keyrack get --for repo --env prep
ðŸ” done. 2 granted (env: prep)

$ echo $AWS_PROFILE
ehmpathy.prep

# prod is still locked. no accidental exposure.
$ source rhx keyrack get --for repo --env prod
ðŸ” status: ðŸ”’ locked
   â””â”€ required keys not unlocked: ehmpathy.prod.AWS_PROFILE
```

### the aha moment

you unlock prep. you get `AWS_PROFILE=ehmpathy.prep`. your tools work. prod is locked. you cant accidentally hit production. when you need prod, you unlock prod explicitly. the envvar is still `AWS_PROFILE` â€” just with the prod value. no suffix hacks. no manual re-export. the right credentials for the right env, always.

---

## user experience

### goal 1: developer works on prep environment

```sh
# start of day: unlock prep
$ rhx keyrack unlock --env prep

# run integration tests
$ source rhx keyrack get --for repo --env prep
$ npm run test:integration
# âœ“ AWS_PROFILE=ehmpathy.prep, XAI_API_KEY=sk-prep-xxx

# later: need to check a detail in prod
$ rhx keyrack unlock --env prod
$ source rhx keyrack get --for repo --env prod
# âœ“ AWS_PROFILE=ehmpathy.prod, XAI_API_KEY=sk-prod-xxx

# switch back to prep
$ source rhx keyrack get --for repo --env prep
# âœ“ AWS_PROFILE=ehmpathy.prep (both envs still unlocked)
```

### goal 2: cicd runs tests with test credentials

```yaml
# .github/workflows/test.yml
jobs:
  test:
    steps:
      - uses: ./.github/actions/rhachet/keyrack
        with:
          env: test          # required â€” no default, must be explicit
      - run: npm run test
      # âœ“ AWS_PROFILE=ehmpathy.test, XAI_API_KEY=sk-test-xxx

  deploy-prep:
    steps:
      - uses: ./.github/actions/rhachet/keyrack
        with:
          env: prep          # explicit â€” prep keys for prep deploy
      - run: npm run deploy

  deploy-prod:
    steps:
      - uses: ./.github/actions/rhachet/keyrack
        with:
          env: prod          # explicit â€” prod keys for prod deploy
      - run: npm run deploy
```

no magic defaults. every workflow declares which env it operates in. if you want all envs, say `env: all` explicitly.

### goal 3: configure host storage per env

```sh
# set up prod AWS_PROFILE
$ rhx keyrack set --key AWS_PROFILE --env prod
# configures host storage for ehmpathy.prod.AWS_PROFILE

# set up prep AWS_PROFILE
$ rhx keyrack set --key AWS_PROFILE --env prep
# configures host storage for ehmpathy.prep.AWS_PROFILE

# set up XAI_API_KEY for all envs at once
$ rhx keyrack set --key XAI_API_KEY
# defaults to --org @this --env all
# configures for every env that declares XAI_API_KEY
```

each `set` call configures how the key is stored on this host. `--env` scopes which slug gets configured. `--org` defaults to `@this` (inferred from keyrack.yml).

### goal 4: --env is required when env-specific sections exist

if keyrack.yml declares any `env.$slug` sections beyond `env.all`, then `--env` is required on all commands. no defaults. no guesses. if the user only declares `env.all` (no env-specific sections), then `--env` is not required â€” there's only one choice.

```sh
# keyrack.yml has env.prod and env.prep â†’ --env is required
$ rhx keyrack unlock
â›ˆï¸  error: --env is required (keyrack.yml declares env.prod, env.prep)
   â””â”€ specify --env prod, --env prep, or --env all

$ rhx keyrack unlock --env prep
ðŸ”“ keyrack unlock (org: ehmpathy, env: prep)
   â”œâ”€ ehmpathy.prep.XAI_API_KEY
   â”œâ”€ ehmpathy.prep.AWS_PROFILE
   â””â”€ âœ¨ 2 keys unlocked
```

```yaml
# keyrack.yml â€” only env.all, no env-specific sections
org: ehmpathy

env.all:
  - XAI_API_KEY: encrypted
```

```sh
# only env.all â†’ --env is not required (only one choice)
$ rhx keyrack unlock
ðŸ”“ keyrack unlock (org: ehmpathy, env: all)
   â”œâ”€ ehmpathy.all.XAI_API_KEY
   â””â”€ âœ¨ 1 key unlocked
```

this prevents the headache of a missed `--env` and time lost to wrong credentials.

---

## mental model

### how a user would describe this to a friend

> "keyrack now knows about environments. you declare which keys each env needs. when you unlock, you pick the env â€” prep, prod, test. the right credentials show up with the right names. AWS_PROFILE is AWS_PROFILE, not AWS_PROFILE_PROD. and prod stays locked until you explicitly ask for it."

### analogy

like a hotel key card system. each floor (env) has its own key card. the prep card opens prep rooms. the prod card opens prod rooms. you carry only the card you need. the doors (tools) dont care which card you used â€” they just see a valid key. and if you dont have the prod card, you simply cant get in.

### terms

| user says | system says |
|-----------|-------------|
| "my prod key" | `ehmpathy.prod.AWS_PROFILE` (slug) |
| "the key itself" | `AWS_PROFILE` (raw key name) |
| "which environment" | `--env prod` (required when env-specific sections exist) |
| "my org" | `org: ehmpathy` or `--org @this` |
| "keys for all envs" | `env.all` section |
| "just for prod" | `env.prod` section |

---

## evaluation

### how well does it solve the goals?

| goal | solved? | how |
|------|---------|-----|
| AWS_PROFILE must be exact envvar name | âœ“ | export strips org+env prefix â€” tools see `AWS_PROFILE` |
| different values per env | âœ“ | each env has its own slug â†’ own secret value |
| dont leak prod when in prep | âœ“ | env isolation: unlock prep â‰  unlock prod |
| cicd needs per-env control | âœ“ | github action requires explicit `env` input |
| no accidental env mismatch | âœ“ | `--env` required when env-specific sections exist; no silent defaults |
| set up host storage per env | âœ“ | `--env prod` vs `--env prep` on `set` command |

### pros

- **zero suffix hacks** â€” `AWS_PROFILE` is `AWS_PROFILE`, period
- **env isolation by default** â€” unlock one env at a time, prod protected
- **clean migration** â€” hard cut from `keys:` to `env.*:`, no compat baggage
- **flexible env names** â€” not restricted to prod/prep/test; `env.sandbox` works too
- **cicd native** â€” github action requires explicit `env` input
- **dry via env.all** â€” common keys declared once, expanded to all envs

### cons

- **hard cut** â€” prior `keys:` format rejected (not yet in use, so no migration needed)
- **more yaml structure** â€” `env.all` + `env.prod` vs flat `keys:` map
- **slug length** â€” `ehmpathy.prod.AWS_PROFILE` is verbose (but users rarely see it)

### edgecases and pit of success

| edgecase | what happens |
|----------|--------------|
| user forgets `--env` | error if env-specific sections exist; tells user which envs are available |
| user tries to get prod while only prep unlocked | locked status, shows exactly which keys need unlock |
| user specifies `--org foreign-org` on set | error: org mismatch, cant configure keys for other orgs |
| user declares env.all with no env.* sections | validation error: env.all needs envs to expand into |
| user omits `org:` from keyrack.yml | validation error: org is required |
| same key in env.all and env.prod with different grades | env.prod grade overrides env.all for prod |
| user declares `env.sandbox` (custom env name) | accepted â€” env names are open-ended |
