# research: domain

## domain objects

### entities (identity matters, lifecycle exists)

| entity | exists | location | unique key | notes |
|--------|--------|----------|------------|-------|
| **BrainAtom** | ✓ | `src/domain.objects/BrainAtom.ts` | `{ repo, slug }` | single-turn inference |
| **BrainRepl** | ✓ | `src/domain.objects/BrainRepl.ts` | `{ repo, slug }` | multi-turn agentic repl |
| **Role** | ✓ | `src/domain.objects/Role.ts` | `slug` | bundle of skills + briefs |
| **RoleRegistry** | ✓ | `src/domain.objects/RoleRegistry.ts` | `slug` | collection of roles (synonymous with "repo") |
| **Actor** | ✗ | — | `{ repo, role }` | **to create**: role + brains allowlist |

### literals (immutable value objects)

| literal | exists | location | notes |
|---------|--------|----------|-------|
| **RoleSkill** | ✓ | `src/domain.objects/RoleSkill.ts` | generic `RoleSkill<TStitcher>` |
| **RoleTrait** | ✓ | `src/domain.objects/RoleTrait.ts` | behavioral modifier |
| **RoleSkillExecutable** | ✓ | `src/domain.objects/RoleSkillExecutable.ts` | discovered shell skill |
| **Thread** | ✓ | `src/domain.objects/Thread.ts` | thought thread primitive |
| **Stitcher** | ✓ | `src/domain.objects/Stitcher.ts` | generic stitcher contract |
| **StitchStep** | ✓ | `src/domain.objects/StitchStep.ts` | atomic stitcher unit |

### events (domain signals)

| event | exists | location | notes |
|-------|--------|----------|-------|
| **StitchSetEvent** | ✓ | `src/domain.objects/` | stitch history observability |


## domain operations

### existing operations

| operation | pattern | location | notes |
|-----------|---------|----------|-------|
| **genContextBrain** | gen (factory) | `src/domain.operations/context/` | creates ContextBrain from atoms + repls |
| **findBrainAtomByRef** | find (lookup) | `src/domain.operations/context/` | lookup by { repo, slug } |
| **findBrainReplByRef** | find (lookup) | `src/domain.operations/context/` | lookup by { repo, slug } |
| **genRoleSkill** | gen (factory) | `src/domain.operations/role/` | creates RoleSkill<TStitcher> |
| **getRoleBriefs** | get (retrieve) | `src/domain.operations/role/` | retrieves briefs for role |
| **genThread** | gen (factory) | `src/domain.operations/thread/` | creates Thread<C> |
| **genStitchRoute** | gen (factory) | `src/domain.operations/weave/compose/` | creates sequential composition |
| **genStitchChoice** | gen (factory) | `src/domain.operations/weave/compose/` | creates conditional composition |
| **genStitchFanout** | gen (factory) | `src/domain.operations/weave/compose/` | creates parallel composition |

### operations to create

| operation | pattern | notes |
|-----------|---------|-------|
| **genActor** | gen (factory) | creates Actor from { role, brains } |
| **actorAct** | invoke | Actor.act({ skill, brain? }) |
| **actorRun** | invoke | Actor.run({ skill }) |
| **actorAsk** | invoke | Actor.ask({ prompt }) |
| **validateBrainInAllowlist** | validate | throws if brain not in allowlist |


## relationships

### treestruct of composition

```
Actor
├── role: Role
│   ├── skills: { solid, rigid, dirs, refs }
│   ├── briefs: { dirs }
│   └── traits: RoleTrait[]
└── brains: BrainRepl[]  (allowlist, first is default)

Role
├── skills.solid: { [slug]: { input, output } }  (zod schemas)
├── skills.rigid: { [slug]: { input, output } }  (zod schemas)
├── skills.dirs: string[]  (directory paths)
├── skills.refs: RoleSkill[]  (programmatic refs)
└── briefs.dirs: string[]

BrainRepl
├── repo: string  (e.g., 'anthropic')
├── slug: string  (e.g., 'claude/code')
└── imagine(): Promise<TOutput>
```

### treestruct of subdomains

```
rhachet
├── brain/  (inference providers)
│   ├── BrainAtom  (single-turn)
│   └── BrainRepl  (multi-turn)
├── role/  (capability bundles)
│   ├── Role
│   ├── RoleSkill
│   ├── RoleTrait
│   └── RoleRegistry
├── actor/  (role + brain composition) **NEW**
│   └── Actor
├── thread/  (thought execution)
│   ├── Thread
│   └── Threads
└── weave/  (stitcher composition)
    ├── Stitcher
    ├── StitchStep
    ├── StitchRoute
    ├── StitchFanout
    └── StitchChoice
```

### dependencies

```
Actor
  → depends on: Role, BrainRepl[]
  → exposes: .act(), .run(), .ask()

genActor
  → depends on: Role, BrainRepl[]
  → produces: Actor

Actor.act()
  → depends on: BrainRepl (from allowlist), Role.skills.rigid
  → validates: brain in allowlist
  → executes: skill with brain

Actor.run()
  → depends on: Role.skills.solid
  → executes: shell skill via spawn (no brain)

Actor.ask()
  → depends on: BrainRepl (default from allowlist)
  → executes: fluid conversation
```


## composition for wish fulfillment

### sdk pattern

```ts
// 1. roles package exports actors (generated via genActor)
// rhachet-roles-ehmpathy/src/actors/mechanic.ts
export const mechanic = genActor({
  role: mechanicRole,
  brains: [
    genBrainRepl({ slug: 'claude/code' }),
    genBrainRepl({ slug: 'claude/code/sonnet/v4.5' }),
  ],
});

// 2. sdk user imports actor
import { mechanic } from 'rhachet-roles-ehmpathy';

// 3. sdk user invokes skills
await mechanic.act({ skill: { review: { input: '...' } } });
await mechanic.run({ skill: { 'gh.workflow.logs': { workflow: 'test' } } });
await mechanic.ask({ prompt: '...' });
```

### cli pattern

```sh
# maps to Actor.run()
npx rhachet run --repo ehmpathy --role mechanic --skill gh.workflow.logs

# maps to Actor.act()
npx rhachet act --repo ehmpathy --role mechanic --skill review --brain anthropic/claude/code

# maps to Actor.ask()
npx rhachet ask --repo ehmpathy --role mechanic --ask "..."
```

### type inference composition

```ts
// role declares skills with zod schemas
role.skills = {
  solid: {
    'gh.workflow.logs': {
      input: z.object({ workflow: z.string() }),
      output: z.object({ logs: z.string() }),
    },
  },
  rigid: {
    review: {
      input: z.object({ input: z.string() }),
      output: z.object({ decision: z.enum([...]) }),
    },
  },
};

// genActor infers skill types from role
const actor = genActor({ role, brains });

// actor.act() and actor.run() have inferred skill types
actor.act({ skill: { review: { input: '...' } } });  // ✓ type-safe
actor.run({ skill: { 'gh.workflow.logs': { workflow: 'test' } } });  // ✓ type-safe
```


## citations

_no external research required — domain fully defined in codebase and behavior documents_

| # | source | quote |
|---|--------|-------|
| 1 | `src/domain.objects/BrainRepl.ts` | unique key: `{ repo, slug }` |
| 2 | `src/domain.objects/Role.ts` | properties: `slug`, `skills`, `briefs`, `traits` |
| 3 | `.behavior/v2025_12_31.sdk-brain-actor/0.wish.md` | "Actor = BrainRepl + BrainReplPlugs + Role" |
| 4 | `.behavior/v2025_12_31.sdk-brain-actor/1.vision.md` | "actor = genActor({ role }) + brain (at invocation time)" |
| 5 | `.behavior/v2025_12_31.sdk-brain-actor/1.vision.md` | "sdk exports actors. actors are generated from roles via genActor" |
