# blueprint: sdk-brain-actor

## summary

implement the Actor pattern as described in:
- wish: `0.wish.md`
- vision: `1.vision.md`
- blackbox criteria: `2.criteria.blackbox.md`
- blueprint criteria: `2.criteria.blueprint.md`
- domain distillation: `3.2.distill.domain._.v1.i1.md`


## implementation plan

### phase 1: domain objects

#### 1.1 extend Role with typed skills

**file**: `src/domain.objects/Role.ts`

extend the existing `Role` interface to support typed skill schemas:

```ts
// extend skills property
skills: {
  /**
   * .what = solid skills (deterministic, no brain)
   * .why = type-safe .run() invocation
   */
  solid?: {
    [slug: string]: {
      input: z.ZodSchema;
      output: z.ZodSchema;
    };
  };

  /**
   * .what = rigid skills (deterministic harness, brain operations)
   * .why = type-safe .act() invocation
   */
  rigid?: {
    [slug: string]: {
      input: z.ZodSchema;
      output: z.ZodSchema;
    };
  };

  // existing properties remain
  dirs: { uri: string } | { uri: string }[];
  refs: RoleSkill<any>[];
};
```

#### 1.2 create Actor domain entity

**file**: `src/domain.objects/Actor.ts`

```ts
import { DomainEntity } from 'domain-objects';
import type { RefByUnique } from 'domain-objects';
import type { z } from 'zod';

import type { BrainRepl } from './BrainRepl';
import type { Role } from './Role';

/**
 * .what = a role assumed by a brain, ready for invocation
 * .why =
 *   - enables sdk users to import and invoke actors directly
 *   - composes role (skills + briefs) with brain allowlist
 *   - provides type-safe .act(), .run(), .ask() methods
 */
export interface Actor<TRole extends Role = Role> {
  role: TRole;
  brains: BrainRepl[];
  act: ActorActOp<TRole>;
  run: ActorRunOp<TRole>;
  ask: ActorAskOp;
}
export class Actor<TRole extends Role = Role>
  extends DomainEntity<Actor<TRole>>
  implements Actor<TRole>
{
  public static unique = ['role.slug'] as const;
}

// method type definitions (see 3.2.distill for full signatures)
```

#### 1.3 export Actor from domain.objects

**file**: `src/domain.objects/index.ts`

add export:
```ts
export * from './Actor';
```


### phase 2: domain operations

#### 2.1 create genActor factory

**file**: `src/domain.operations/actor/genActor.ts`

```ts
import { BadRequestError } from 'helpful-errors';

import { Actor } from '@src/domain.objects/Actor';
import type { BrainRepl } from '@src/domain.objects/BrainRepl';
import type { Role } from '@src/domain.objects/Role';

import { actorAct } from './actorAct';
import { actorAsk } from './actorAsk';
import { actorRun } from './actorRun';

/**
 * .what = creates an Actor from a role and brains allowlist
 * .why = enables sdk exports of typed actors
 */
export const genActor = <TRole extends Role>(input: {
  role: TRole;
  brains: BrainRepl[];
}): Actor<TRole> => {
  // validate brains array is not empty
  if (input.brains.length === 0)
    throw new BadRequestError('actor must have at least one brain');

  // construct actor with bound methods
  return new Actor({
    role: input.role,
    brains: input.brains,
    act: (actInput: {
      brain?: { repo: string; slug: string } | BrainRepl;
      skill: Record<string, unknown>;
    }) => {
      // resolve brain: use provided or default to first in allowlist
      const brainResolved = actInput.brain
        ? findBrainInAllowlist({ brain: actInput.brain, allowlist: input.brains })
        : input.brains[0];

      return actorAct({
        role: input.role,
        brain: brainResolved,
        skill: actInput.skill,
      });
    },
    run: (runInput: { skill: Record<string, unknown> }) =>
      actorRun({
        role: input.role,
        skill: runInput.skill,
      }),
    ask: (askInput: { prompt: string }) =>
      actorAsk({
        role: input.role,
        brain: input.brains[0],
        prompt: askInput.prompt,
      }),
  });
};
```

#### 2.2 create actorAct operation

**file**: `src/domain.operations/actor/actorAct.ts`

```ts
/**
 * .what = executes a rigid skill with a brain
 * .why = deterministic harness with probabilistic brain operations
 * .note = brain is already resolved and validated by genActor
 */
export const actorAct = async (input: {
  role: Role;
  brain: BrainRepl;
  skill: Record<string, unknown>;
}): Promise<unknown> => {
  // resolve skill slug and args
  const [skillSlug, skillArgs] = Object.entries(input.skill)[0];
  const skill = findSkillBySlug({
    slug: skillSlug,
    role: input.role,
    route: 'rigid',
  });

  // execute rigid skill with brain
  return executeRigidSkill({ skill, args: skillArgs, brain: input.brain });
};
```

#### 2.3 create actorRun operation

**file**: `src/domain.operations/actor/actorRun.ts`

```ts
/**
 * .what = executes a solid skill via spawn
 * .why = deterministic shell execution, no brain
 */
export const actorRun = async (input: {
  role: Role;
  skill: Record<string, unknown>;
}): Promise<unknown> => {
  // resolve skill slug and args
  const [skillSlug, skillArgs] = Object.entries(input.skill)[0];
  const skill = findSkillBySlug({
    slug: skillSlug,
    role: input.role,
    route: 'solid',
  });

  // execute solid skill via spawn
  return executeSolidSkill({ skill, args: skillArgs });
};
```

#### 2.4 create actorAsk operation

**file**: `src/domain.operations/actor/actorAsk.ts`

```ts
/**
 * .what = starts a fluid conversation with a brain
 * .why = open-ended exploration, brain decides path
 */
export const actorAsk = async (input: {
  role: Role;
  brain: BrainRepl;
  prompt: string;
}): Promise<{ response: string }> => {
  // start fluid conversation with brain
  return executeFluidConversation({
    brain: input.brain,
    role: input.role,
    prompt: input.prompt,
  });
};
```

#### 2.5 create findBrainInAllowlist operation

**file**: `src/domain.operations/actor/findBrainInAllowlist.ts`

pattern follows existing `findBrainReplByRef.ts`:
- accepts `{ brain, allowlist }`
- handles both ref lookup and direct BrainRepl
- throws if brain not in allowlist
- returns matched BrainRepl

#### 2.6 create findSkillBySlug operation

**file**: `src/domain.operations/actor/findSkillBySlug.ts`

pattern follows existing `findUniqueSkillExecutable.ts`:
- accepts `{ slug, role, route: 'solid' | 'rigid' }`
- checks role.skills[route] first
- falls back to .agent/ dirs via `discoverSkillExecutables`
- throws if not found


### phase 3: cli commands

#### 3.1 create invokeAct command

**file**: `src/contract/cli/invokeAct.ts`

pattern follows existing `invokeRun.ts` and `invokeAsk.ts`:
- parses: `--repo`, `--role`, `--skill`, `--brain`, `--attempts`, `--concurrency`, `--output`
- resolves actor from registries
- validates brain against actor's allowlist
- invokes `actor.act()` with resolved args
- supports `onInvokeActInput` hooks
- writes output to `--output` path or stdout

#### 3.2 register invokeAct in invoke.ts

**file**: `src/contract/cli/invoke.ts`

add:
```ts
import { invokeAct } from './invokeAct';
// ...
invokeAct({ program, config: { path: configPath }, registries, hooks });
```

#### 3.3 update invokeRun to use Actor.run()

**file**: `src/contract/cli/invokeRun.ts`

update to resolve actor and invoke `actor.run()` instead of direct `executeSkill()`:
- resolve role from `--repo` + `--role`
- construct actor (default brains from registry context)
- invoke `actor.run({ skill: { [skillSlug]: args } })`

#### 3.4 update invokeAsk to use Actor.ask()

**file**: `src/contract/cli/invokeAsk.ts`

update to invoke `actor.ask()`:
- resolve role from `--repo` + `--role`
- construct actor (default brains from registry context)
- invoke `actor.ask({ prompt })`


### phase 4: sdk exports

#### 4.1 export genActor from sdk

**file**: `src/contract/sdk.ts`

add:
```ts
export { genActor } from '@src/domain.operations/actor/genActor';
```

#### 4.2 export Actor type from sdk

already handled via `export * from '@src/domain.objects'`


### phase 5: tests

#### 5.1 unit tests for Actor domain object

**file**: `src/domain.objects/Actor.test.ts`

- test unique key definition
- test interface conformance

#### 5.2 unit tests for genActor

**file**: `src/domain.operations/actor/genActor.test.ts`

- test creating actor with brains allowlist
- test empty brains array throws

#### 5.3 unit tests for actorAct

**file**: `src/domain.operations/actor/actorAct.test.ts`

- test .act() with default brain
- test .act() with explicit brain (ref lookup)
- test .act() with explicit brain (direct pass-in)
- test .act() with brain not in allowlist (throws)

#### 5.4 unit tests for actorRun

**file**: `src/domain.operations/actor/actorRun.test.ts`

- test .run() finds and executes solid skill

#### 5.5 unit tests for actorAsk

**file**: `src/domain.operations/actor/actorAsk.test.ts`

- test .ask() uses default brain

#### 5.6 integration tests for actorAct (isolated boundary)

**file**: `src/domain.operations/actor/actorAct.integration.test.ts`

uses `genBrainRepl({ slug: 'openai/codex' })` from `rhachet-brain-openai` (faster than claude/code for testing):
- test actorAct executes rigid skill with default brain
- test actorAct executes rigid skill with explicit brain ref
- test actorAct executes rigid skill with direct BrainRepl pass-in
- test actorAct throws when brain not in allowlist

#### 5.7 integration tests for actorRun (isolated boundary)

**file**: `src/domain.operations/actor/actorRun.integration.test.ts`

- test actorRun executes solid skill via spawn
- test actorRun passes args through to skill
- test actorRun throws when skill not found

#### 5.8 integration tests for actorAsk (isolated boundary)

**file**: `src/domain.operations/actor/actorAsk.integration.test.ts`

uses `genBrainRepl({ slug: 'openai/codex' })` from `rhachet-brain-openai` (faster than claude/code for testing):
- test actorAsk starts fluid conversation with default brain
- test actorAsk returns response from brain

#### 5.9 unit tests for findBrainInAllowlist

**file**: `src/domain.operations/actor/findBrainInAllowlist.test.ts`

- test ref lookup finds brain
- test direct BrainRepl validates against allowlist
- test throws on brain not in allowlist

#### 5.10 unit tests for findSkillBySlug

**file**: `src/domain.operations/actor/findSkillBySlug.test.ts`

- test role.skills.rigid precedence over .agent/ dirs
- test role.skills.solid precedence over .agent/ dirs
- test throws on skill not found

#### 5.11 SDK integration tests for genActor

tests both role discovery patterns in separate files:
1. **published** - source in `src/`, linked to `.agent/` via `rhachet roles link`
2. **collocated** - skills/briefs directly under `.agent/repo=.this/role=*/`

**file 1**: `src/contract/sdk/genActor.brain.casePublished.integration.test.ts`
**file 2**: `src/contract/sdk/genActor.brain.caseCollocated.integration.test.ts`

**fixture 1 (published pattern)**: `.test/assets/example.repo/rhachet-roles-example.published/`

```
rhachet-roles-example.published/
├── package.json                    # declares as rhachet-roles-example package
├── .gitignore                      # ignores .agent/ (created via link, not checked in)
├── src/
│   ├── index.ts                    # exports { author } actor
│   └── domain.roles/
│       └── author/
│           ├── role.ts             # defines authorRole with skills.solid + skills.rigid
│           ├── actor.ts            # genActor({ role: authorRole, brains: [...] })
│           ├── briefs/
│           │   └── style-guide.md  # briefs for the author role
│           └── skills/
│               ├── solid/
│               │   └── wordcount.sh    # solid skill (deterministic, no brain)
│               └── rigid/
│                   └── draft.ts        # rigid skill (uses brain to write prose)
└── .agent/                         # ⚠️ created via `rhachet roles link` at test setup
    └── repo=.this/
        └── role=author/ -> symlinked from src/domain.roles/author/
```

**note**: for the published pattern, `.agent/` is NOT checked in. it is created at test setup via `rhachet roles link`, which symlinks briefs/skills from `src/domain.roles/author/` into `.agent/`. this validates the real linking mechanism.

**fixture 2 (collocated pattern)**: `.test/assets/example.repo/rhachet-roles-example.collocated/`

```
rhachet-roles-example.collocated/
├── package.json                    # declares as rhachet-roles-example.collocated package
├── src/
│   └── index.ts                    # re-exports { scribe } from .agent/
└── .agent/                         # ✓ checked in directly (collocated pattern)
    └── repo=.this/
        └── role=scribe/
            ├── role.ts             # defines scribeRole
            ├── actor.ts            # genActor({ role: scribeRole, brains: [...] })
            ├── readme.md
            ├── briefs/
            │   └── voice-guide.md
            └── skills/
                ├── solid/
                │   └── linecount.sh
                └── rigid/
                    └── summarize.ts
```

**note**: for the collocated pattern, `.agent/` IS checked in. the entire role (definition, actor, briefs, skills) lives under `.agent/repo=.this/role=scribe/`. `src/index.ts` just re-exports from `.agent/`. this validates repos that prefer keeping everything in one place.

the `authorRole` (published pattern) in `src/domain.roles/author/role.ts`:
```ts
export const authorRole: Role = {
  slug: 'author',
  name: 'Author',
  purpose: 'writes prose about the sunshine ocean surfer turtles',
  readme: 'an author who crafts tales of turtles surfing sunny ocean waves',
  traits: [],
  skills: {
    solid: {
      'wordcount': {
        input: z.object({ text: z.string() }),
        output: z.object({ count: z.number() }),
      },
    },
    rigid: {
      'draft': {
        input: z.object({ topic: z.string() }),
        output: z.object({ prose: z.string() }),
      },
    },
    // dirs point to collocated skills; rhachet roles link creates .agent/ symlinks
    dirs: { uri: 'src/domain.roles/author/skills' },
    refs: [],
  },
  briefs: { dirs: { uri: 'src/domain.roles/author/briefs' } },
};
```

the `scribeRole` (collocated pattern) in `.agent/repo=.this/role=scribe/role.ts`:
```ts
export const scribeRole: Role = {
  slug: 'scribe',
  name: 'Scribe',
  purpose: 'summarizes and counts content',
  readme: 'a scribe who condenses verbose text into concise summaries',
  traits: [],
  skills: {
    solid: {
      'linecount': {
        input: z.object({ text: z.string() }),
        output: z.object({ lines: z.number() }),
      },
    },
    rigid: {
      'summarize': {
        input: z.object({ content: z.string() }),
        output: z.object({ summary: z.string() }),
      },
    },
    // dirs are relative to .agent/ (collocated pattern)
    dirs: { uri: '.agent/repo=.this/role=scribe/skills' },
    refs: [],
  },
  briefs: { dirs: { uri: '.agent/repo=.this/role=scribe/briefs' } },
};
```

the actor definitions:

```ts
// src/domain.roles/author/actor.ts (published pattern)
import { genActor } from 'rhachet';
import { genBrainRepl } from 'rhachet-brain-openai';
import { authorRole } from './role';

export const author = genActor({
  role: authorRole,
  brains: [
    genBrainRepl({ slug: 'openai/codex' }),  // default (fast for tests)
  ],
});
```

```ts
// .agent/repo=.this/role=scribe/actor.ts (collocated pattern)
import { genActor } from 'rhachet';
import { genBrainRepl } from 'rhachet-brain-openai';
import { scribeRole } from './role';

export const scribe = genActor({
  role: scribeRole,
  brains: [
    genBrainRepl({ slug: 'openai/codex' }),  // default (fast for tests)
  ],
});
```

the package entrypoints:

```ts
// src/index.ts (published pattern - rhachet-roles-example.published)
export { author } from './domain.roles/author/actor';
```

```ts
// src/index.ts (collocated pattern - rhachet-roles-example.collocated)
// re-export from .agent/
export { scribe } from '../.agent/repo=.this/role=scribe/actor';
```

**test pattern 1 (published, runs in isolated tmp dir)**:

`src/contract/sdk/genActor.brain.casePublished.integration.test.ts`:
```ts
import { execSync } from 'child_process';
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { given, when, then, useBeforeAll } from 'test-fns';

const FIXTURE_PATH = '.test/assets/example.repo/rhachet-roles-example.published';

describe('genActor.brain.casePublished.integration', () => {
  given('[case1] published pattern (rhachet-roles-example.published)', () => {
    // clone fixture into isolated tmp dir
    const scene = useBeforeAll(async () => {
      const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'rhachet-test-published-'));
      await fs.cp(FIXTURE_PATH, tmpDir, { recursive: true });

      // run `rhachet roles link` to create .agent/ symlinks
      execSync('npx rhachet roles link', { cwd: tmpDir, stdio: 'inherit' });

      // dynamically import the actor from the cloned fixture
      const { author } = await import(path.join(tmpDir, 'src', 'index.ts'));
      return { tmpDir, author };
    });
    afterAll(async () => fs.rm(scene.tmpDir, { recursive: true, force: true }));

    when('[t0] author.run({ skill: { wordcount: { text } } })', () => {
      then('executes solid skill via spawn', async () => {
        const result = await scene.author.run({ skill: { wordcount: { text: 'hello world' } } });
        expect(result.count).toEqual(2);
      });
    });

    when('[t1] author.act({ skill: { draft: { topic } } })', () => {
      then('executes rigid skill with default brain', async () => {
        const result = await scene.author.act({ skill: { draft: { topic: 'surfer turtles' } } });
        expect(result.prose).toBeDefined();
      });
    });

    when('[t2] author.act({ brain: { repo, slug }, skill })', () => {
      then('executes with explicit brain from allowlist', async () => {
        const result = await scene.author.act({
          brain: { repo: 'openai', slug: 'codex' },
          skill: { draft: { topic: 'ocean waves' } },
        });
        expect(result.prose).toBeDefined();
      });
    });

    when('[t3] author.act({ brain: notInAllowlist, skill })', () => {
      then('throws error', async () => {
        await expect(
          scene.author.act({
            brain: { repo: 'anthropic', slug: 'claude/code' },
            skill: { draft: { topic: 'sunshine' } },
          }),
        ).rejects.toThrow(/not in.*allowlist/);
      });
    });

    when('[t4] author.ask({ prompt })', () => {
      then('starts fluid conversation with default brain', async () => {
        const result = await scene.author.ask({ prompt: 'tell me about the turtles' });
        expect(result.response).toBeDefined();
      });
    });
  });
});
```

test cases (published):
- test `.run()` executes solid skill via spawn
- test `.act()` executes rigid skill with default brain
- test `.act()` executes rigid skill with explicit brain ref
- test `.act()` with brain not in allowlist (throws)
- test `.ask()` starts fluid conversation with default brain

**test pattern 2 (collocated, runs in isolated tmp dir)**:

`src/contract/sdk/genActor.brain.caseCollocated.integration.test.ts`:
```ts
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { given, when, then, useBeforeAll } from 'test-fns';

const FIXTURE_PATH = '.test/assets/example.repo/rhachet-roles-example.collocated';

describe('genActor.brain.caseCollocated.integration', () => {
  given('[case1] collocated pattern (rhachet-roles-example.collocated)', () => {
    // clone fixture into isolated tmp dir
    const scene = useBeforeAll(async () => {
      const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'rhachet-test-collocated-'));
      await fs.cp(FIXTURE_PATH, tmpDir, { recursive: true });

      // no `rhachet roles link` needed - .agent/ is already checked in
      // dynamically import the actor from the cloned fixture
      const { scribe } = await import(path.join(tmpDir, 'src', 'index.ts'));
      return { tmpDir, scribe };
    });
    afterAll(async () => fs.rm(scene.tmpDir, { recursive: true, force: true }));

    when('[t0] scribe.run({ skill: { linecount: { text } } })', () => {
      then('executes solid skill via spawn', async () => {
        const result = await scene.scribe.run({ skill: { linecount: { text: 'line1\nline2\nline3' } } });
        expect(result.lines).toEqual(3);
      });
    });

    when('[t1] scribe.act({ skill: { summarize: { content } } })', () => {
      then('executes rigid skill with default brain', async () => {
        const result = await scene.scribe.act({
          skill: { summarize: { content: 'a long verbose text about many things' } },
        });
        expect(result.summary).toBeDefined();
      });
    });

    when('[t2] scribe.ask({ prompt })', () => {
      then('starts fluid conversation with default brain', async () => {
        const result = await scene.scribe.ask({ prompt: 'summarize the concept of brevity' });
        expect(result.response).toBeDefined();
      });
    });
  });
});
```

test cases (collocated):
- test `.run()` executes solid skill via spawn
- test `.act()` executes rigid skill with default brain
- test `.ask()` starts fluid conversation with default brain

#### 5.12 CLI integration tests for invokeAct

**file**: `src/contract/cli/invokeAct.integration.test.ts`

**test fixture**: `.test/assets/example.repo/repo-with-role-with-rigid-skill/`

```
repo-with-role-with-rigid-skill/
├── rhachet.use.ts              # exports role registry with brains allowlist
├── .agent/
│   └── repo=.this/
│       └── role=tester/
│           ├── readme.md
│           ├── briefs/
│           └── skills/
│               └── rigid/
│                   └── echo.review.ts   # rigid skill that writes to --output
```

the `echo.review.ts` skill:
- accepts `--input` arg
- writes structured output to `--output` path
- supports `--attempts` (each attempt writes to `output.i{n}.json`)

test pattern:
```ts
given('[case1] repo-with-role-with-rigid-skill', () => {
  const scene = useBeforeAll(async () => {
    // clone fixture into tmp dir
    const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'rhachet-test-'));
    await fs.cp(FIXTURE_PATH, tmpDir, { recursive: true });
    return { tmpDir };
  });
  afterAll(async () => fs.rm(scene.tmpDir, { recursive: true, force: true }));

  when('[t0] act with default brain', () => {
    then('executes skill and writes output', async () => { ... });
  });

  when('[t1] act with --brain (explicit)', () => {
    then('uses specified brain from allowlist', async () => { ... });
  });

  when('[t2] act with --attempts 3 --output result.json', () => {
    then('creates result.i1.json, result.i2.json, result.i3.json', async () => { ... });
  });

  when('[t3] act with --brain not in allowlist', () => {
    then('throws error', async () => { ... });
  });
});
```

test cases:
- test `act` with default brain
- test `act` with `--brain` (explicit brain selection)
- test `act` with `--attempts` and `--output` (verifies each attempt file created)
- test `act` error on invalid brain (not in allowlist)

#### 5.13 CLI integration tests for invokeRun

**file**: `src/contract/cli/invokeRun.integration.test.ts`

- test `run` discovers and executes solid skill
- test `run` with `--repo` and `--role` filters
- test `run` error on skill not found

#### 5.14 CLI integration tests for invokeAsk

**file**: `src/contract/cli/invokeAsk.integration.test.ts`

- test `ask` uses default brain
- test `ask` with `--ask` prompt
- test `ask` error boundaries (no role, invalid role)

#### 5.15 type tests for skill inference

**file**: `src/domain.operations/actor/Actor.types.test.ts`

- verify skill name inference from zod schemas
- verify skill args inference from zod schemas


## file tree summary

```
.test/
└── assets/
    └── example.repo/
        ├── rhachet-roles-example.published/      # SDK tests (published pattern)
        │   ├── package.json
        │   ├── .gitignore                        # ignores .agent/
        │   ├── src/
        │   │   ├── index.ts                      # exports { author }
        │   │   └── domain.roles/
        │   │       └── author/
        │   │           ├── role.ts               # authorRole definition
        │   │           ├── actor.ts              # genActor({ role, brains })
        │   │           ├── briefs/
        │   │           │   └── style-guide.md
        │   │           └── skills/
        │   │               ├── solid/
        │   │               │   └── wordcount.sh
        │   │               └── rigid/
        │   │                   └── draft.ts
        │   └── .agent/                           # ⚠️ NOT checked in; created via link
        ├── rhachet-roles-example.collocated/     # SDK tests (collocated pattern)
        │   ├── package.json
        │   ├── src/
        │   │   └── index.ts                      # re-exports { scribe } from .agent/
        │   └── .agent/                           # ✓ checked in directly
        │       └── repo=.this/
        │           └── role=scribe/
        │               ├── role.ts               # scribeRole definition
        │               ├── actor.ts              # genActor({ role, brains })
        │               ├── readme.md
        │               ├── briefs/
        │               │   └── voice-guide.md
        │               └── skills/
        │                   ├── solid/
        │                   │   └── linecount.sh
        │                   └── rigid/
        │                       └── summarize.ts
        └── repo-with-role-with-rigid-skill/      # CLI invokeAct tests
            ├── rhachet.use.ts
            └── .agent/
                └── repo=.this/
                    └── role=tester/
                        ├── readme.md
                        ├── briefs/
                        └── skills/
                            └── rigid/
                                └── echo.review.ts
src/
├── domain.objects/
│   ├── Actor.ts                    # new
│   ├── Role.ts                     # extend skills structure
│   └── index.ts                    # add Actor export
├── domain.operations/
│   └── actor/                      # new directory
│       ├── genActor.ts
│       ├── genActor.test.ts
│       ├── actorAct.ts
│       ├── actorAct.test.ts
│       ├── actorAct.integration.test.ts    # isolated boundary test
│       ├── actorRun.ts
│       ├── actorRun.test.ts
│       ├── actorRun.integration.test.ts    # isolated boundary test
│       ├── actorAsk.ts
│       ├── actorAsk.test.ts
│       ├── actorAsk.integration.test.ts    # isolated boundary test
│       ├── findBrainInAllowlist.ts
│       ├── findBrainInAllowlist.test.ts
│       ├── findSkillBySlug.ts
│       ├── findSkillBySlug.test.ts
│       └── Actor.types.test.ts
├── contract/
│   ├── cli/
│   │   ├── invoke.ts               # register invokeAct
│   │   ├── invokeAct.ts            # new
│   │   ├── invokeAct.integration.test.ts  # new
│   │   ├── invokeRun.ts            # update to use actor.run()
│   │   ├── invokeRun.integration.test.ts  # update coverage
│   │   ├── invokeAsk.ts            # update to use actor.ask()
│   │   └── invokeAsk.integration.test.ts  # update coverage
│   ├── sdk/
│   │   ├── genActor.brain.casePublished.integration.test.ts   # published pattern
│   │   └── genActor.brain.caseCollocated.integration.test.ts  # collocated pattern
│   └── sdk.ts                      # add genActor export
```


## dependencies

no new external dependencies required. uses:
- `domain-objects` (existing)
- `helpful-errors` (existing)
- `zod` (existing)


## backwards compatibility

- existing `invokeRun` behavior preserved via actor abstraction
- existing `invokeAsk` behavior preserved via actor abstraction
- existing `Role.skills.dirs` and `Role.skills.refs` unchanged
- new `Role.skills.solid` and `Role.skills.rigid` are optional extensions

