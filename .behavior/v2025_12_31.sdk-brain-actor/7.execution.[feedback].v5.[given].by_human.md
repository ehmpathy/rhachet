emit your response to the feedback into
- .behavior/v2025_12_31.sdk-brain-actor/7.execution.[feedback].v5.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

bootup you context about the wish, vision, and blueprint
- .behavior/v2025_12_31.sdk-brain-actor/0.wish.md
- .behavior/v2025_12_31.sdk-brain-actor/1.vision.md (if declared)
- .behavior/v2025_12_31.sdk-brain-actor/2.criteria.blackbox.md (if declared)
- .behavior/v2025_12_31.sdk-brain-actor/2.criteria.blueprint.md (if declared)
- .behavior/v2025_12_31.sdk-brain-actor/3.3.blueprint.v1.i1.md

---
---
---

# blocker.1


export const genActor = <TRole extends Role>(input: {
  role: TRole;
  brains: BrainRepl[];
}): Actor<TRole> => {

genActor needs to return an Actor with a Role.typed, to support strongly typed .act and .run operations

also, there should be unit test coverage

use @ts-expect-error to prove that the types flow through successfully

prove with both positive and negative assertions


# blocker.2


/**
 * .what = a role skill that has been resolved and can be acted upon
 * .why =
 *   - unified return type for skill resolution
 *   - explicit domain object for skill invocation
 *   - replaces adhoc return shapes
 */
export interface RoleSkillActable {
  slug: string;
  route: 'solid' | 'rigid';
  source: 'role.skills' | '.agent/';
  schema?: RoleSkillSchema;
  executable?: RoleSkillExecutable;
}

RoleSkillActable is a Domain.Object and should be treated as such

further, it needs to explain that it is for actors to use

maybe ActorRoleSkill is a better term for it to make that explicit


similarly, findActorRoleSkillBySlug instead of findSkillBySlug

since its only used for actors


# blocker.3

why is


  onInvokeActInput?: (input: {
    skill: string;
    input: Record<string, unknown>;
  }) => Record<string, unknown>;

not strongly typed?



# blocker.4

skill needs to be passed INTO actorRun as an INPUT

actorRun should not be responsible for looking up the skill

the caller of actorRun should have resolved the skill already and passed it in

along with the args it needs

same with actorAct

there should never be a case where it can't execute a skill, because the skill shouldn't be passed into it if its not executable

because ActorRoleSkill should not be definable without an executable!


# blocker.5

findBrainInAllowlist -> findActorBrainInAllowlist

always namespace things for their purpose

via treestruct and $noun$adj pattern


# blocker.6

add a 'todo: support --interactive mode for cli invocations'

for

export const actorAsk = async (input: {
