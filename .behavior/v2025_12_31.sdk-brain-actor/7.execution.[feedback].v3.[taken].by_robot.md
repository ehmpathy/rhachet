# response to feedback v3

## response checklist

- [x] blocker.1: find and eliminate all failhide cases
- [x] blocker.2: eliminate all hardcoded test asset paths (use portable directory.ts exports)
- [x] blocker.3: import Role from test assets instead of inline creation
- [x] blocker.4: create RoleSkillActable domain object instead of adhoc Record<string, unknown>

---

## blocker.1: find and eliminate all failhide cases

**issue**: findSkillBySlug should fail-fast when skill is declared but no executable found

**analysis**:
- already fixed findSkillBySlug to throw BadRequestError when skill in role.skills has no executable
- need to search for other potential failhide patterns in actor operations

**search scope**:
- actorAct.ts
- actorRun.ts
- actorAsk.ts
- genActor.ts
- any other actor-related operations

---

## blocker.2: eliminate all hardcoded test asset paths

**issue**: `resolve(__dirname, '../../../.test/assets/example.repo/...')` is not portable

**analysis**:
- already created `.test/assets/example.repo/directory.ts` with exports
- already updated actorAct.integration.test.ts and actorAsk.integration.test.ts
- need to find and update all other tests that use hardcoded .test/assets paths

---

## blocker.3: import Role from test assets instead of inline creation

**issue**: integration tests create inline Role objects instead of importing from test asset fixtures

**analysis**:
- integration tests should import Role from `.test/assets/` fixtures
- test fixtures should define the Role that matches their .agent/ structure
- this validates that the role definition and .agent/ structure are consistent

---

## blocker.4: create RoleSkillActable domain object

**issue**: `skill: Record<string, unknown>` is an adhoc bag of words, not a domain object

**analysis**:
- current pattern: `actor.act({ skill: { summarize: { content: 'hello' } } })`
- extracts slug and args via `Object.entries(input.skill)[0]`
- should use explicit domain object with treestruct naming: `RoleSkillActable`

**proposed domain object**:
```ts
interface RoleSkillActable {
  slug: string;
  args: unknown;
}
```

**proposed API change**:
```ts
// before
actor.act({ skill: { summarize: { content: 'hello' } } })

// after
actor.act({ skill: { slug: 'summarize', args: { content: 'hello' } } })
```

---

## execution plan

1. search for failhide patterns in actor operations
2. search for hardcoded .test/assets paths
3. create Role exports in test fixtures
4. create RoleSkillActable domain object
5. update actorAct, actorRun to use RoleSkillActable
6. update tests to use new patterns

---

## checkoffs

### blocker.1: failhide cases ✅

searched for:
- `try/catch` patterns that swallow errors
- `return undefined` / `return null` patterns without proper handling

**result**: no failhide cases found in actor operations. findSkillBySlug already throws BadRequestError when skill declared but no executable found.

### blocker.2: hardcoded test asset paths ✅

updated files:
- `actorAct.integration.test.ts` - uses EXAMPLE_REPO_WITH_RIGID_SKILL from directory.ts
- `actorAsk.integration.test.ts` - uses EXAMPLE_REPO_WITH_RIGID_SKILL from directory.ts
- `genActor.brain.caseCollocated.integration.test.ts` - uses EXAMPLE_REPO_COLLOCATED from directory.ts
- `genActor.brain.casePublished.integration.test.ts` - uses EXAMPLE_REPO_PUBLISHED from directory.ts

### blocker.3: import Role from test assets ✅

created `role.ts` exports in each example repo:
- `.test/assets/example.repo/repo-with-role-with-rigid-skill/role.ts` → exports `testerRole`
- `.test/assets/example.repo/rhachet-roles-example.published/role.ts` → exports `authorRole`
- `.test/assets/example.repo/rhachet-roles-example.collocated/role.ts` → exports `scribeRole`

updated `.test/assets/example.repo/directory.ts` to only export paths (not roles)

updated integration tests to import roles from their respective example repos:
- `actorAct.integration.test.ts` - imports testerRole from repo-with-role-with-rigid-skill/role
- `actorAsk.integration.test.ts` - imports testerRole from repo-with-role-with-rigid-skill/role
- `genActor.brain.caseCollocated.integration.test.ts` - imports scribeRole from rhachet-roles-example.collocated/role
- `genActor.brain.casePublished.integration.test.ts` - imports authorRole from rhachet-roles-example.published/role

### blocker.4: RoleSkillActable domain object ✅

renamed `ResolvedSkill` → `RoleSkillActable` in `findSkillBySlug.ts`:
```ts
export interface RoleSkillActable {
  slug: string;
  route: 'solid' | 'rigid';
  source: 'role.skills' | '.agent/';
  schema?: RoleSkillSchema;
  executable?: RoleSkillExecutable;
}
```

updated actor operations to use strong generic types instead of `Record<string, unknown>`:

`actorAct.ts`:
```ts
export const actorAct = async <
  TRole extends Role,
  TSkillSlug extends keyof NonNullable<TRole['skills']['rigid']>,
>(input: {
  role: TRole;
  brain: BrainRepl;
  skill: { [K in TSkillSlug]: SkillInput<NonNullable<TRole['skills']['rigid']>[K]> };
}): Promise<SkillOutput<NonNullable<TRole['skills']['rigid']>[TSkillSlug]>> => { ... }
```

`actorRun.ts`:
```ts
export const actorRun = async <
  TRole extends Role,
  TSkillSlug extends keyof NonNullable<TRole['skills']['solid']>,
>(input: {
  role: TRole;
  skill: { [K in TSkillSlug]: SkillInput<NonNullable<TRole['skills']['solid']>[K]> };
}): Promise<SkillOutput<NonNullable<TRole['skills']['solid']>[TSkillSlug]>> => { ... }
```

`genActor.ts`:
```ts
const act: ActorActOp<TRole> = async (actInput) => { ... };
const run: ActorRunOp<TRole> = async (runInput) => { ... };
```

**result**: skill invocation is now fully type-safe with zod schema inference for inputs and outputs

---

## additional fix: findSkillBySlug executable requirement

**issue**: findSkillBySlug was requiring executables for all skills, but rigid skills don't need executables (they use brain.act())

**fix**: only require executables for solid skills:
```ts
// fail fast if solid skill is declared but no executable found
// note: rigid skills use brain.act() and only need the schema, not an executable
if (input.route === 'solid' && executables.length === 0)
  throw new BadRequestError(...)
```

**test added**: `[case2c] rigid skill declared in role.skills but no executable` verifies rigid skills work without executables
