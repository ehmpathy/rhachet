# response to feedback v4

## response checklist

- [x] blocker.1: make actor.act/run strongly typed with literal skill names from zod schemas
- [x] blocker.2: add @ts-expect-error type assertions for positive and negative cases
- [x] blocker.3: make rigid skills failfast if declared but no executable found
- [x] blocker.4: review everything against vision and ensure test coverage
- [x] blocker.5: ensure tests conform to .test/assets/example.repo patterns
- [x] blocker.6: eliminate all `as unknown as x` casts - types must fit naturally

---

## blocker.1: strong typing for actor.act/run

**issue**: `actor.act({ skill: { $name: $input.args }})` should have `$name` and `$input.args` strongly typed from zod schemas

**root cause**: `Role.skills.solid` and `Role.skills.rigid` use `Record<string, RoleSkillSchema>` which widens skill names to `string`

**fix**:
1. make Role interface generic over its skill maps
2. use `as const` pattern to preserve literal types through role definition
3. actor types then infer literal skill names via `keyof TRole['skills']['rigid']`

---

## blocker.2: @ts-expect-error type assertions

**issue**: prove types flow through successfully with positive and negative assertions

**fix**:
1. positive assertions: valid skill names and args should compile
2. negative assertions: use `@ts-expect-error` to prove invalid skill names and args fail at compile time
3. test in Actor.test.ts against fixture roles from .test/assets/example.repo

---

## blocker.3: rigid skills failfast on missing executable

**issue**: rigid skills should throw BadRequestError if declared in role.skills.rigid but no executable found in .agent/

**fix**: update findSkillBySlug.ts to require executables for BOTH solid and rigid routes

---

## blocker.4: review against vision

**issue**: ensure all contracts match the vision and have exhaustive test coverage

**review scope**:
- 1.vision.md contracts for .act(), .run(), .ask()
- type inference from zod schemas
- brain allowlist enforcement
- skill resolution from role.skills vs .agent/ dirs

---

## blocker.5: tests conform to .test/assets/example.repo patterns

**issue**: tests must use roles from .test/assets/example.repo fixtures, not inline creation

**fix**:
1. import roles from fixture role.ts files
2. use directory.ts exports for paths
3. no `as unknown as Role` casts

---

## blocker.6: eliminate `as unknown as x` casts

**issue**: types should fit naturally, no escape hatches

**root cause**: types don't flow through because Role interface widens skill names

**fix**: same as blocker.1 - make Role generic to preserve literal types

---

## execution plan

1. fix Role.ts to be generic over skill maps
2. update fixture roles to use `as const` and proper generic types
3. update Actor.ts types to work with generic Role
4. add type tests with @ts-expect-error assertions
5. verify findSkillBySlug.ts failfast for rigid skills
6. run tests to verify everything works

---

## checkoffs

### blocker.1: strong typing ✅

changes:
- renamed `RoleSkillRecord` to `RoleSkillRegistry` (per user feedback)
- made `Role<TSolid, TRigid>` generic over skill registries
- added `Role.typed()` factory method to preserve literal types
- updated fixture roles to use `Role.typed()`
- `Actor<TRole>` types now infer literal skill names via `ActorActOp` and `ActorRunOp`

### blocker.2: @ts-expect-error assertions ✅

changes:
- Actor.test.ts: added positive tests for valid skill names + args
- Actor.test.ts: added negative tests with @ts-expect-error for unknown skills
- actorAct.test.ts: added @ts-expect-error for nonexistent skill tests
- actorRun.test.ts: added @ts-expect-error for nonexistent + multiple skill tests
- actorAct.integration.test.ts: added @ts-expect-error for negative case
- actorRun.integration.test.ts: added @ts-expect-error for negative cases

### blocker.3: rigid skills failfast ✅

already implemented in `findSkillBySlug.ts` lines 44-54:
- throws `BadRequestError` with helpful hint when skill is declared in role.skills but no executable exists
- tested in `findSkillBySlug.test.ts` cases [case2b] and [case2c]

### blocker.4: vision review ✅

verified test coverage for:
- `genActor({ role, brains })` creates actor (genActor.test.ts)
- `actor.act({ skill })` calls rigid skill (actorAct.test.ts, actorAct.integration.test.ts)
- `actor.run({ skill })` calls solid skill (actorRun.test.ts, actorRun.integration.test.ts)
- `actor.ask({ prompt })` calls fluid route (actorAsk.test.ts)
- brain allowlist enforcement (findBrainInAllowlist.test.ts, genActor.test.ts)
- type-safe skill invocation from zod schemas (Actor.test.ts)

### blocker.5: test asset patterns ✅

verified .test/assets/example.repo/repo-with-role-with-rigid-skill:
- role.ts uses `Role.typed()` for literal type preservation
- .agent/repo=.this/role=tester/skills/echo.review.sh executable created
- .agent/repo=.this/role=tester/briefs/ directory present
- directory.ts exports paths for portable test references

### blocker.6: eliminate casts ✅

- removed all `as unknown as Role` casts
- Actor.test.ts now uses `Role.typed()` directly
- types flow naturally through generic Role → Actor → ActorActOp/ActorRunOp

---

## verification

```sh
npm run test:types              # ✅ passes
npm run test:unit -- Actor      # ✅ 53 tests pass
npm run test:integration        # ✅ passes (with api keys)
```
