wish =


given that for the BrainRepl's we actually have two fundamental modes
- readonly (i.e., 'ask')
- canwrite (i.e., 'act')

maybe we should update the interface to standardize on that

i.e.,

instead of just `.imagine()`

we can update

BrainAtom.imagine -> BrainAtom.ask

BrainRepl.imagine -> BrainRepl.ask && BrainRepl.act

where ask = readonly privs && act = read+write

---

given that the Repl is actually capable of action

&&

will need permission manager, memory manager, etc

seems like this is closer to


- https://github.com/ehmpathy/rhachet-roles-bhrain/blob/de02781608837ab791c61af2d4034c77c6fd5964/src/domain.objects/BrainArch1/BrainArch1Actor.ts

than originally anticipated


in that case, lets update the term from `BrainRepl` -> `BrainActor`

and add placeholder

plugs: {
- toolboxes?: never, // BrainActorToolbox[], // e.g., toolset plugins
- memory?: never, // BrainActorMemory, // e.g., memory managmenet plugin (e.g., context compression()
- access?: never, // BrainActorAccess, // e.g., permission guard plugin
}

leave jsdoc .what and .why comments over each property

and a // todo: allow configuration


then, ultimately, the usage will look like


context.brain.atom.ask({ brain: { repo: 'anthropic', slug: '' }, role: {}, prompt, schema })
context.brain.actor.ask({ brain: { repo: 'anthropic', slug: 'claude-code' }, role: {}, prompt, schema })
context.brain.actor.act({ brain: { repo: 'anthropic', slug: 'claude-code' }, role: {}, prompt, schema })


or, actually,

maybe actors should compose their plugs

i.e.,

repos can expose actors

built on repls

so,

BrainReplPlugs {
  toolboxes?: never, // BrainActorToolbox[], // e.g., toolset plugins
  memory?: never, // BrainActorMemory, // e.g., memory managmenet plugin (e.g., context compression()
  access?: never, // BrainActorAccess, // e.g., permission guard plugin
}

BrainRepl {
  repo: string;
  slug: string;
  description: string;

  ask: <TOutput>( // readonly
    input: {
      plugs: BrainReplPlugs,
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;

  act: <TOutput>( // read + write
    input: {
      plugs: BrainReplPlugs,
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
}


---

then, we can later expose composite actors

e.g.,


genBrainActor({
  // e.g., choose claude-code repl as the brain
  brain: BrainRepl,
  plugs: BrainReplPlugs, // a predefined set of plugs
  role: Role, // a predefined role (which can itself be a role composite)
})


and then later, when you try and use it, it eliinates the config that users have to pass in, to create a bigger pit of success. (no more need to manage brain plugs (permissions, memory, etc) && no more need to specify role on each invocation either (e.g., could include super-role that auto-boots and progressively discloses & delegates to subroles))


so that callers can later use


context.brain.actor.act({ actor: { repo: 'bhuild', role: 'behaver' }, prompt, schema })

or even

context.brain.actor.act({ actor: { repo: 'bhuild', role: 'behaver' }, skill: ... })

hmmm

makes me wonder if the declastruct provider pattern would be more useful for composition here

---

i.e.,

1. genContextBrainAnthropic({ ... })
   1. -> each provider can customize the inputs it requires to instantiate context
   2. -> the ContextBrainAnthropic could eventually extend a common ContextBrain, if there are shared deps

2. use it via normal procedures which then leverage that shared context && implement the standard contracts of BrainAtom | BrainRepl | BrainActor

e.g.,


```ts
import { brainReplClaudeCode } from 'rhachet-brain-anthropic';

// ...

const response = await brainReplClaudeCode.act({ plugs, prompt, schema })
```

the advantage is that this would give us greater type safety for subsequent usages like if we want that repl to limit its supported plugs to ones that fulfill certain generics

e.g.,

BrainReplPlugs.atom = BrainAtomClaudeOpus | BrainAtomClaudeSonnet | BrainAtomClaudeHaiku

rather than just _any_ atom

for brainReplClaudeCode

---

and later, to be able to register an allowlist of skills that are supported by a BrainActor

so that we can call something like

```ts
import { brainActorMechanic as mechanic } from 'rhachet-roles-ehmpathy';

mechanic.act({ skill: { review: { rules: ['@role/briefs/practics/pitofsuccess**/*'] } }})
```

just like today, we can call

```sh
npx rhachet run --role mechanic --skill review --rules '@role/briefs/practics/pitofsuccess**/*'
```
which does not yet support brain specification, cause we haven't gotten to allow that to be configurable

...

there seems to be some fuzzyness on role -vs- actor still, but this should be pretty close directionally

---

alternatively, would it be possible to access a strongly typed registry via the context?

i.e.,


context.brain.actor.mechanic ?

where actor = Record<RegisteredActorName, RegisteredActorPerName> ?


or, similarly

context.brain.repl.act({ brain: { repo: "$repo", slug: "$slug" } })

where $repo and $slug are constrained to the well declared types?


-----

also,

seems like maybe

Actor = a root Rhachet concept (like Role) (no Brain prefix)

and

BrainAtom
&
BrainRepl


are the Brain level concepts
