# blueprint criteria = mechanism bounds

## blackbox criteria satisfied

- usecase.1 = sdk actor import ✓
- usecase.2 = sdk `.act()` invocation ✓
- usecase.3 = sdk `.run()` invocation ✓
- usecase.4 = sdk `.ask()` invocation ✓
- usecase.5 = cli `act` command ✓
- usecase.6 = cli `run` command ✓
- usecase.7 = cli `ask` command ✓
- usecase.8 = skill resolution from multiple sources ✓
- usecase.9 = actor-role uniqueness ✓
- usecase.10 = error boundaries ✓
- usecase.11 = output handling ✓
- usecase.12 = type-safe skill invocation ✓
- usecase.13 = brain allowlist in genActor ✓


## subcomponent contracts

given('Actor contract')
  then('exposes: .act({ skill, brain? }) => Promise<Result>')
  then('exposes: .run({ skill }) => Promise<Result>')
  then('exposes: .ask({ prompt }) => Promise<Response>')
  then('exposes: .brains as BrainRepl[] (the allowlist)')
  then('exposes: .role as Role')

given('genActor contract')
  then('exposes: genActor({ role, brains }) => Actor')
  then('throws if brains array is empty')
  then('first brain in array is the default')

given('BrainRepl contract')
  then('has unique key: { repo, slug }')
  then('is generated via genBrainRepl({ slug, ...config })')

given('Role contract')
  then('exposes: .skills.solid with zod schemas')
  then('exposes: .skills.rigid with zod schemas')
  then('exposes: .briefs')

given('cli `act` command contract')
  then('parses: --repo, --role, --skill, --brain, --attempts, --concurrency, --output')
  then('invokes actor.act() with resolved args')
  then('supports onInvokeActInput hooks')

given('cli `run` command contract')
  then('parses: --repo, --role, --skill')
  then('invokes actor.run() with resolved args')

given('cli `ask` command contract')
  then('parses: --repo, --role, --ask')
  then('invokes actor.ask() with resolved args')


## composition boundaries

given('Actor.act() composition')
  then('validates brain against allowlist if provided')
  then('uses default brain (first in allowlist) if not provided')
  then('resolves skill from role.skills.rigid or .agent/ dirs')
  then('executes skill with brain')

given('Actor.run() composition')
  then('resolves skill from role.skills.solid or .agent/ dirs')
  then('spawns shell execution, no brain involved')

given('Actor.ask() composition')
  then('uses default brain')
  then('starts fluid conversation')

given('cli commands composition')
  then('resolve actor from --repo + --role')
  then('invoke appropriate actor method')
  then('handle output to --output path or stdout')


## test coverage criteria

given('Actor')
  then('has unit tests for .act() with default brain')
  then('has unit tests for .act() with explicit brain (ref lookup)')
  then('has unit tests for .act() with explicit brain (direct pass-in)')
  then('has unit tests for .act() with brain not in allowlist (throws)')
  then('has unit tests for .run()')
  then('has unit tests for .ask()')

given('genActor')
  then('has unit tests for creating actor with brains allowlist')
  then('has unit tests for empty brains array (throws)')

given('cli commands')
  then('has integration tests for `act` with --brain')
  then('has integration tests for `run`')
  then('has integration tests for `ask`')
  then('has integration tests for --attempts and --output')

given('skill resolution')
  then('has unit tests for role.skills.rigid precedence over .agent/ dirs')
  then('has unit tests for role.skills.solid precedence over .agent/ dirs')

given('type inference')
  then('has type tests verifying skill name and args inference from zod schemas')
