emit your response to the feedback into
- .behavior/v2025_12_31.sdk-brain-actor/7.execution.[feedback].v3.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

bootup you context about the wish, vision, and blueprint
- .behavior/v2025_12_31.sdk-brain-actor/0.wish.md
- .behavior/v2025_12_31.sdk-brain-actor/1.vision.md (if declared)
- .behavior/v2025_12_31.sdk-brain-actor/2.criteria.blackbox.md (if declared)
- .behavior/v2025_12_31.sdk-brain-actor/2.criteria.blueprint.md (if declared)
- .behavior/v2025_12_31.sdk-brain-actor/3.3.blueprint.v1.i1.md

---
---
---

# blocker.1

failfast if not found but expected!

    if (skillsForRoute && skillsForRoute[input.slug]) {
      // find executable from .agent/ dirs (skill schema defines
  type, but executable runs)
      const executables = discoverSkillExecutables({
        roleSlug: input.role.slug,
        skillSlug: input.slug,
      });
      const executable: RoleSkillExecutable | undefined =
        executables.length > 0 ? executables[0] : undefined;

      return {
        slug: input.slug,
        route: input.route,
        source: 'role.skills',
        schema: skillsForRoute[input.slug],
        executable,
      };
    }

find and eliminate all other cases where we should have failfasted but failhided instead too


# blocker.2

  > make
    // use test asset directory
    const testAssetDir = resolve(
      __dirname,
      '../../../.test/assets/example.repo/repo-with-role-with-rigi
  d-skill',
    ); more portable via `export const EXAMPLE_REPO_DIR =
  __dirname` from .test/assets/example.repo

eliminate that defect in all tests that leverage .test/assets via paths


# blocker.3

why is role created instead of imported?


  // create test role matching .agent/ structure in test asset
  const testRole = new Role({
    slug: 'tester',
    name: 'Tester',
    purpose: 'test role for integration tests',
    readme: 'a role for testing actorAsk',
    traits: [],
    skills: {
      dirs: { uri: '.agent/repo=.this/role=tester/skills' },
      refs: [],
    },
    briefs: { dirs: { uri: '.agent/repo=.this/role=tester/briefs' } },
  });

eliminate that adhoc implmentation in all tests that have a .test/assets/ availabl efor import instead


# blocker.4


  skill: Record<string, unknown>;
}): Promise<unknown> => {
  // extract skill slug and args from skill object
  const entries = Object.entries(input.skill);
  if (entries.length !== 1)
    throw new BadRequestError('actorAct expects exactly one skill entry', {
      entriesCount: entries.length,
    });
  const [skillSlug, skillArgs] = entries[0]!;



why is skill not an explicit skill passed in?

e.g.,

instead of


  // extract skill slug and args from skill object
  const entries = Object.entries(input.skill);
  if (entries.length !== 1)
    throw new BadRequestError('actorAct expects exactly one skill entry', {
      entriesCount: entries.length,
    });
  const [skillSlug, skillArgs] = entries[0]!;

  // resolve skill from role
  const skill = findSkillBySlug({
    slug: skillSlug,
    role: input.role,
    route: 'rigid',
  });


pass in that skill


and name the domain.object with treestruct $noun$adj pattern

e.g.,

RoleSkillActable


ensure that we consistently use well named domain.objects instead of adhoc bags of words
