# distill: domain

## usecases and contracts

### usecase.1 = sdk actor import

```ts
// contract: import actor from roles package
import { mechanic } from 'rhachet-roles-ehmpathy';

// mechanic is an Actor, ready for invocation
// mechanic.act(), mechanic.run(), mechanic.ask() are available
```

### usecase.2 = sdk .act() invocation

```ts
// contract: invoke rigid skill with default brain
const result = await mechanic.act({
  skill: { review: { input: '...' } },
});

// contract: invoke rigid skill with brain by ref
const result = await mechanic.act({
  brain: { repo: 'anthropic', slug: 'claude/code' },
  skill: { review: { input: '...' } },
});

// contract: invoke rigid skill with brain instance
const result = await mechanic.act({
  brain: genBrainRepl({ slug: 'claude/code', temperature: 0.2 }),
  skill: { review: { input: '...' } },
});
```

### usecase.3 = sdk .run() invocation

```ts
// contract: invoke solid skill (no brain)
const result = await mechanic.run({
  skill: { 'gh.workflow.logs': { workflow: 'test' } },
});
```

### usecase.4 = sdk .ask() invocation

```ts
// contract: invoke fluid conversation
const response = await mechanic.ask({
  prompt: 'review my latest changes',
});
```

### usecase.5 = genActor factory

```ts
// contract: create actor from role + brains
export const mechanic = genActor({
  role: mechanicRole,
  brains: [
    genBrainRepl({ slug: 'claude/code' }),
    genBrainRepl({ slug: 'claude/code/sonnet/v4.5' }),
  ],
});
```


## domain.objects

### Actor (new)

```ts
import { DomainEntity } from 'domain-objects';
import type { z } from 'zod';

import type { BrainRepl } from './BrainRepl';
import type { Role } from './Role';

/**
 * .what = a role assumed by a brain, ready for invocation
 * .why =
 *   - enables sdk users to import and invoke actors directly
 *   - composes role (skills + briefs) with brain allowlist
 *   - provides type-safe .act(), .run(), .ask() methods
 */
export interface Actor<TRole extends Role = Role> {
  /**
   * .what = the role this actor assumes
   */
  role: TRole;

  /**
   * .what = the brains allowlisted for this actor
   * .note = first brain is the default
   */
  brains: BrainRepl[];

  /**
   * .what = invoke a rigid skill with optional brain selection
   * .why = deterministic harness with probabilistic operations
   */
  act: <TSkillSlug extends keyof TRole['skills']['rigid']>(
    input: {
      brain?: { repo: string; slug: string } | BrainRepl;
      skill: { [K in TSkillSlug]: z.infer<TRole['skills']['rigid'][K]['input']> };
    },
  ) => Promise<z.infer<TRole['skills']['rigid'][TSkillSlug]['output']>>;

  /**
   * .what = invoke a solid skill (no brain)
   * .why = deterministic shell execution
   */
  run: <TSkillSlug extends keyof TRole['skills']['solid']>(
    input: {
      skill: { [K in TSkillSlug]: z.infer<TRole['skills']['solid'][K]['input']> };
    },
  ) => Promise<z.infer<TRole['skills']['solid'][TSkillSlug]['output']>>;

  /**
   * .what = invoke a fluid conversation
   * .why = open-ended exploration, brain decides path
   */
  ask: (
    input: { prompt: string },
  ) => Promise<{ response: string }>;
}
export class Actor<TRole extends Role = Role>
  extends DomainEntity<Actor<TRole>>
  implements Actor<TRole>
{
  public static unique = ['role.slug'] as const;
}
```

### Role (extend skills structure)

```ts
// extend existing Role to support typed skills
export interface Role {
  // ... existing properties ...

  /**
   * .what = the skills known by the role
   * .why = declares what the role can do
   */
  skills: {
    /**
     * .what = solid skills (deterministic, no brain)
     * .why = type-safe .run() invocation
     */
    solid?: {
      [slug: string]: {
        input: z.ZodSchema;
        output: z.ZodSchema;
      };
    };

    /**
     * .what = rigid skills (deterministic harness, brain operations)
     * .why = type-safe .act() invocation
     */
    rigid?: {
      [slug: string]: {
        input: z.ZodSchema;
        output: z.ZodSchema;
      };
    };

    /**
     * .what = directory-based skills for linking/booting
     */
    dirs: { uri: string } | { uri: string }[];

    /**
     * .what = programmatic RoleSkill references (legacy, to deprecate)
     */
    refs: RoleSkill<any>[];
  };
}
```

### BrainRepl (existing, no changes needed)

```ts
// existing: src/domain.objects/BrainRepl.ts
export interface BrainRepl {
  repo: string;
  slug: string;
  description: string;
  imagine: <TOutput>(...) => Promise<TOutput>;
}
export class BrainRepl extends DomainEntity<BrainRepl> {
  public static unique = ['repo', 'slug'] as const;
}
```


## domain.operations

### genActor (new)

```ts
/**
 * .what = creates an Actor from a role and brains allowlist
 * .why = enables sdk exports of typed actors
 */
export const genActor = <TRole extends Role>(
  input: {
    role: TRole;
    brains: BrainRepl[];
  },
): Actor<TRole> => {
  // validate brains array is not empty
  if (input.brains.length === 0)
    throw new BadRequestError('actor must have at least one brain');

  // construct actor with bound methods
  return new Actor({
    role: input.role,
    brains: input.brains,
    act: actorAct({ role: input.role, brains: input.brains }),
    run: actorRun({ role: input.role }),
    ask: actorAsk({ role: input.role, brains: input.brains }),
  });
};
```

### actorAct (new)

```ts
/**
 * .what = invokes a rigid skill on an actor
 * .why = deterministic harness with probabilistic brain operations
 */
export const actorAct = (
  config: { role: Role; brains: BrainRepl[] },
) => async <TSkillSlug extends string>(
  input: {
    brain?: { repo: string; slug: string } | BrainRepl;
    skill: { [K in TSkillSlug]: unknown };
  },
): Promise<unknown> => {
  // resolve brain
  const brain = input.brain
    ? findBrainInAllowlist({ brain: input.brain, allowlist: config.brains })
    : config.brains[0]; // default = first

  // resolve skill
  const [skillSlug, skillArgs] = Object.entries(input.skill)[0];
  const skill = findSkillBySlug({
    slug: skillSlug,
    role: config.role,
    route: 'rigid',
  });

  // execute skill with brain
  return executeRigidSkill({ skill, args: skillArgs, brain });
};
```

### actorRun (new)

```ts
/**
 * .what = invokes a solid skill on an actor
 * .why = deterministic shell execution, no brain
 */
export const actorRun = (
  config: { role: Role },
) => async <TSkillSlug extends string>(
  input: {
    skill: { [K in TSkillSlug]: unknown };
  },
): Promise<unknown> => {
  // resolve skill
  const [skillSlug, skillArgs] = Object.entries(input.skill)[0];
  const skill = findSkillBySlug({
    slug: skillSlug,
    role: config.role,
    route: 'solid',
  });

  // execute skill via spawn
  return executeSolidSkill({ skill, args: skillArgs });
};
```

### actorAsk (new)

```ts
/**
 * .what = invokes a fluid conversation on an actor
 * .why = open-ended exploration, brain decides path
 */
export const actorAsk = (
  config: { role: Role; brains: BrainRepl[] },
) => async (
  input: { prompt: string },
): Promise<{ response: string }> => {
  // use default brain
  const brain = config.brains[0];

  // start fluid conversation
  return executeFluidConversation({ brain, role: config.role, prompt: input.prompt });
};
```

### findBrainInAllowlist (new)

```ts
/**
 * .what = finds a brain in the allowlist by ref or validates instance
 * .why = enforces brain allowlist security
 */
export const findBrainInAllowlist = (
  input: {
    brain: { repo: string; slug: string } | BrainRepl;
    allowlist: BrainRepl[];
  },
): BrainRepl => {
  // extract ref
  const ref = 'imagine' in input.brain
    ? { repo: input.brain.repo, slug: input.brain.slug }
    : input.brain;

  // find in allowlist
  const found = input.allowlist.find(
    (b) => b.repo === ref.repo && b.slug === ref.slug,
  );

  // throw if not found
  if (!found)
    throw new BadRequestError(
      `brain '${ref.repo}/${ref.slug}' is not in actor's allowlist`,
      { ref, allowlist: input.allowlist.map((b) => `${b.repo}/${b.slug}`) },
    );

  // return the brain (use passed instance if BrainRepl, else use found)
  return 'imagine' in input.brain ? input.brain : found;
};
```

### findSkillBySlug (new)

```ts
/**
 * .what = finds a skill by slug from role.skills or .agent/ dirs
 * .why = supports multiple skill discovery modes
 */
export const findSkillBySlug = (
  input: {
    slug: string;
    role: Role;
    route: 'solid' | 'rigid';
  },
): Skill => {
  // check role.skills first
  const registeredSkill = input.role.skills[input.route]?.[input.slug];
  if (registeredSkill) return registeredSkill;

  // check .agent/ dirs second
  const dirSkill = findSkillExecutableBySlug({
    slug: input.slug,
    dirs: input.role.skills.dirs,
  });
  if (dirSkill) return dirSkill;

  // throw if not found
  throw new BadRequestError(`skill '${input.slug}' not found`, {
    slug: input.slug,
    route: input.route,
    availableSkills: Object.keys(input.role.skills[input.route] ?? {}),
  });
};
```


## access.daos

_none required — Actor is an in-memory composition, not persisted_


## composition summary

```
genActor({ role, brains })
  → validates brains.length > 0
  → constructs Actor with bound .act(), .run(), .ask()

Actor.act({ brain?, skill })
  → findBrainInAllowlist() or use default
  → findSkillBySlug(route: 'rigid')
  → executeRigidSkill()

Actor.run({ skill })
  → findSkillBySlug(route: 'solid')
  → executeSolidSkill()

Actor.ask({ prompt })
  → use default brain
  → executeFluidConversation()
```
