# blackbox criteria = experience bounds

ref: `.agent/repo=.this/role=any/briefs/define.thought-routes.md` for solid vs rigid vs fluid concepts


## usecase.1 = sdk actor import

given('an sdk user imports an actor from a roles package')
  when('they import the actor')
    then('the actor is ready for invocation')
    then('the actor exposes .act(), .run(), and .ask() methods')


## usecase.2 = sdk `.act()` invocation (rigid route)

given('an sdk user invokes actor.act()')
  when('they call actor.act({ skill: { ... } })')
    then('the skill executes with the default brain')
    then('skill args are passed through to execution')
    then('result is returned to the caller')

  when('they call actor.act({ brain: { repo, slug }, skill: { ... } })')
    then('brain is looked up by unique ref')
    then('the skill executes with that brain')
      sothat('callers can select from allowlisted brains by ref')

  when('they call actor.act({ brain: BrainRepl, skill: { ... } })')
    then('brain is used directly with custom config')
    then('the skill executes with that brain')
      sothat('callers can pass custom brain configurations')

  when('the brain is not in the actor allowlist')
    then('error is thrown: brain not in allowlist')
      sothat('security is enforced: roles only allow allowlisted brains')

  when('the skill is not found')
    then('error is thrown: skill not found')
      sothat('users know which skills are available')


## usecase.3 = sdk `.run()` invocation (solid route)

given('an sdk user invokes actor.run()')
  when('they call actor.run({ skill: { ... } })')
    then('the shell skill executes via spawn')
    then('no brain is involved')
    then('result is returned to the caller')
      sothat('deterministic shell execution is supported')


## usecase.4 = sdk `.ask()` invocation (fluid route)

given('an sdk user invokes actor.ask()')
  when('they call actor.ask({ prompt: "..." })')
    then('a fluid conversation with the actor begins')
    then('brain decides the path')
    then('response is returned to the caller')
      sothat('open-ended exploration is supported')


## usecase.5 = cli `act` command (rigid route)

given('a cli user with linked roles')
  when('they run `npx rhachet act --role <role> --skill <skill>`')
    then('the skill executes under that actor')
    then('all args after the command are passed through to the skill')
    then('skill output is emitted to stdout')

  when('they run `npx rhachet act ... --brain <repo/slug>`')
    then('brain is looked up by repo/slug')
    then('the skill executes with that brain')
      sothat('callers can select from allowlisted brains via cli')

  when('--brain is not in the actor allowlist')
    then('error is thrown: brain not in allowlist')

  when('--role is omitted but skill is unique across all roles')
    then('the unique skill is found and executed')
      sothat('convenience is provided for unambiguous cases')

  when('--role is omitted and skill is ambiguous')
    then('error lists matching roles')
      sothat('users can disambiguate')

  when('--repo is provided')
    then('skill search is filtered to that repo')

  when('--attempts <n> is provided with --output <path>')
    then('skill runs <n> times independently')
    then('each attempt writes to output path with attempt suffix')
      sothat('multi-attempt consensus workflows are supported')

  when('--concurrency <n> is provided with --attempts')
    then('at most <n> attempts run in parallel')

  when('hooks are configured')
    then('input is transformed via onInvokeActInput hooks')
      sothat('custom preprocessing is supported')


## usecase.6 = cli `run` command (solid route)

given('a cli user executing shell skills')
  when('they run `npx rhachet run --skill <skill>`')
    then('skill is discovered from .agent/ skill dirs')
    then('all args are passed through to the skill executable')
    then('no brain is involved')
      sothat('deterministic shell execution is supported')

  when('they run `npx rhachet run --role <role> --skill <skill>`')
    then('skill is scoped to that role')


## usecase.7 = cli `ask` command (fluid route)

given('a cli user wanting to converse with an actor')
  when('they run `npx rhachet ask --role <role>`')
    then('a fluid conversation with the actor begins')
    then('brain decides the path')
      sothat('open-ended exploration is supported')

  when('they run `npx rhachet ask --role <role> --ask <prompt>`')
    then('the prompt is sent to the actor')
    then('response is emitted to stdout')


## usecase.8 = skill resolution from multiple sources

given('skills defined in both role.skills and .agent/ dirs')
  when('`act` is invoked with --skill <slug>')
    then('skill is searched in role.skills.rigid first')
    then('skill is searched in .agent/ skill dirs second')
      sothat('both skill definition patterns are supported')

  when('skill exists in both locations')
    then('role.skills takes precedence')
      sothat('explicit registration overrides filesystem discovery')


## usecase.9 = actor-role uniqueness

given('one actor registered per role+repo')
  when('--repo is omitted and --role is unique across all repos')
    then('the actor for that role is selected')
      sothat('--repo can be omitted for convenience')

  when('--repo is omitted and --role exists in multiple repos')
    then('error lists matching repos')
      sothat('users can disambiguate')


## usecase.10 = error boundaries

given('invalid invocation')
  when('`npx rhachet ask --repo <repo>` (no role)')
    then('error: you cant talk to a repo, only to actors')

  when('`npx rhachet ask --repo <repo> --skill <skill>`')
    then('error: you cant talk to a skill, only to actors')
      sothat('conceptual boundaries are enforced')

  when('required args are missing')
    then('helpful error shows required args and available options')


## usecase.11 = output handling

given('skill execution with output')
  when('--output <path> is provided')
    then('result is written to the specified path')

  when('--output is not provided')
    then('result is emitted to stdout')
      sothat('default behavior is convenient for piping')

  when('--attempts is used without --output')
    then('error: --attempts requires --output')


## usecase.12 = type-safe skill invocation

given('an sdk user invokes skills on an actor')
  when('skill is registered in role.skills.solid with zod schema')
    then('actor.run() provides type inference for skill name and args')

  when('skill is registered in role.skills.rigid with zod schema')
    then('actor.act() provides type inference for skill name and args')

  when('skill name is not registered')
    then('type error at compile time')
      sothat('invalid skill invocations are caught early')


## usecase.13 = brain allowlist in genActor

given('a roles package author defines an actor')
  when('they call genActor({ role, brains: [...] })')
    then('the brains array defines the allowlist')
    then('the first brain is the default')
      sothat('actors declare which brains they support')

  when('brains array is empty or omitted')
    then('error: actor must have at least one brain')
