# research.patterns.v1.i1

## wish summary

support `BrainAtom` in `actor.ask()` in addition to `BrainRepl`, since both share `.ask()` interface.

---

## pattern 1: Actor domain object

**[EXTEND]**

### description

the Actor domain object composes a Role with an allowlist of brains, exposing `.act()`, `.run()`, and `.ask()` methods.

### citations

[1] `src/domain.objects/Actor.ts:69-98`
```ts
export interface Actor<TRole extends Role = Role> {
  /**
   * .what = the role this actor assumes
   */
  role: TRole;

  /**
   * .what = the brains this actor is allowed to use
   * .note = first brain is the default
   */
  brains: BrainRepl[];

  /**
   * .what = invokes a rigid skill with brain
   * .why = deterministic harness with probabilistic brain operations
   */
  act: ActorActOp<TRole>;

  /**
   * .what = invokes a solid skill via spawn
   * .why = deterministic shell execution, no brain
   */
  run: ActorRunOp<TRole>;

  /**
   * .what = starts a fluid conversation with the default brain
   * .why = open-ended exploration, brain decides path
   */
  ask: ActorAskOp;
}
```

[2] `src/domain.objects/Actor.ts:63-67`
```ts
 * .note = Actor = BrainRepl + Role composition
 *   - first brain in allowlist is the default
 *   - .act() invokes rigid skills (deterministic harness, brain operations)
 *   - .run() invokes solid skills (deterministic, no brain)
 *   - .ask() starts fluid conversation with default brain
```

### relation to wish

currently `brains: BrainRepl[]` only supports BrainRepl. need to extend to support BrainAtom for `.ask()` operations.

---

## pattern 2: ActorAskOp type

**[REUSE]**

### description

the ActorAskOp type defines the simple contract for `.ask()` - takes prompt, returns response string.

### citations

[3] `src/domain.objects/Actor.ts:48-54`
```ts
/**
 * .what = type for actor.ask() method
 * .why = enables fluid conversation with brain
 */
export type ActorAskOp = (input: {
  prompt: string;
}) => Promise<{ response: string }>;
```

### relation to wish

this contract is compatible with both BrainRepl and BrainAtom since both expose `.ask()` that can return `{ response: string }`. no changes needed.

---

## pattern 3: genActor factory

**[EXTEND]**

### description

factory function that creates an Actor from a role and brain allowlist. currently only accepts BrainRepl.

### citations

[4] `src/domain.operations/actor/genActor.ts:25-28`
```ts
export const genActor = <TRole extends Role>(input: {
  role: TRole;
  brains: BrainRepl[];
}): Actor<TRole> => {
```

[5] `src/domain.operations/actor/genActor.ts:97-107`
```ts
  // create bound .ask() method
  const ask = async (askInput: {
    prompt: string;
  }): Promise<{ response: string }> => {
    // delegate to actorAsk with default brain
    return actorAsk({
      role: input.role,
      brain: defaultBrain,
      prompt: askInput.prompt,
    });
  };
```

### relation to wish

need to extend input signature to accept both BrainRepl and BrainAtom. the `.ask()` method delegates to `actorAsk` which uses `brain.ask()` - works for both brain types.

---

## pattern 4: actorAsk operation

**[EXTEND]**

### description

operation that executes a fluid conversation with a brain. loads role briefs and calls `brain.ask()`.

### citations

[6] `src/domain.operations/actor/actorAsk.ts:13-17`
```ts
export const actorAsk = async (input: {
  role: Role;
  brain: BrainRepl;
  prompt: string;
}): Promise<{ response: string }> => {
```

[7] `src/domain.operations/actor/actorAsk.ts:26-34`
```ts
  // execute fluid conversation with brain
  // note: openai requires object schema, so wrap response in object
  const result = await input.brain.ask({
    role: { briefs },
    prompt: input.prompt,
    schema: {
      output: z.object({ response: z.string() }),
    },
  });
```

### relation to wish

need to change `brain: BrainRepl` to `brain: BrainRepl | BrainAtom` since both have identical `.ask()` signatures.

---

## pattern 5: BrainRepl domain object

**[REUSE]**

### description

interface for agentic REPL-style brains with tool use. has both `.ask()` and `.act()` methods.

### citations

[8] `src/domain.objects/BrainRepl.ts:10-18`
```ts
/**
 * .what = a brain.atom operating behind a REPL (read-execute-print-loop)
 * .why =
 *   - enables registration of pluggable agentic repls (e.g., claude-code, codex)
 *   - provides a standardized contract for agentic tool-using inference
 *   - enables dynamic swapping of agentic systems at runtime
 *
 * .note = repls differ from atoms in that they execute iterative agentic loops
 *   with tool use, rather than single-turn inference
 */
```

[9] `src/domain.objects/BrainRepl.ts:47-55`
```ts
  ask: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
```

### relation to wish

the `.ask()` signature is compatible with BrainAtom. will reuse as-is.

---

## pattern 6: BrainAtom domain object

**[REUSE]**

### description

interface for single-turn inference brains without tool use. has only `.ask()` method.

### citations

[10] `src/domain.objects/BrainAtom.ts:9-15`
```ts
/**
 * .what = an LLM inference endpoint capable of creative language imagination
 * .why =
 *   - enables registration of pluggable LLM atoms (e.g., claude, gpt, llama)
 *   - provides a standardized contract for single-turn or multi-turn inference
 *   - enables dynamic swapping of models at runtime
 */
```

[11] `src/domain.objects/BrainAtom.ts:46-54`
```ts
  ask: <TOutput>(
    input: {
      plugs?: BrainAtomPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
```

### relation to wish

`.ask()` signature is identical to BrainRepl (aside from plugs type). this is the type we want to add support for.

---

## pattern 7: brain plugin package structure (openai example)

**[REUSE]**

### description

brain plugins follow a standard structure: index.ts exports `getBrainAtoms*()` and `getBrainRepls*()` plus factory functions.

### citations

[12] `src/_topublish/rhachet-brain-openai/src/index.ts:7-21`
```ts
/**
 * .what = returns all brain atoms provided by openai
 * .why = enables consumers to register openai atoms with genContextBrain
 */
export const getBrainAtomsByOpenAI = (): BrainAtom[] => {
  return [genBrainAtom({ slug: 'openai/gpt-4o' })];
};

/**
 * .what = returns all brain repls provided by openai
 * .why = enables consumers to register openai repls with genContextBrain
 */
export const getBrainReplsByOpenAI = (): BrainRepl[] => {
  return [genBrainRepl({ slug: 'openai/codex' })];
};
```

[13] `src/_topublish/rhachet-brain-openai/src/index.ts:23-25`
```ts
// re-export factories for direct access
export { genBrainAtom } from './atoms/genBrainAtom';
export { genBrainRepl } from './repls/genBrainRepl';
```

### relation to wish

will reuse this exact pattern for the new xai/grok brain plugin.

---

## pattern 8: genBrainAtom factory (slug-to-config mapping)

**[REUSE]**

### description

factory function that creates BrainAtom instances. uses slug-to-config mapping for model resolution.

### citations

[14] `src/_topublish/rhachet-brain-openai/src/atoms/genBrainAtom.ts:14-20`
```ts
type OpenAIAtomSlug =
  | 'openai/gpt-4o'
  | 'openai/gpt-4o-mini'
  | 'openai/gpt-4-turbo'
  | 'openai/o1'
  | 'openai/o1-mini'
  | 'openai/o1-preview';
```

[15] `src/_topublish/rhachet-brain-openai/src/atoms/genBrainAtom.ts:65-68`
```ts
export const genBrainAtom = (input: { slug: OpenAIAtomSlug }): BrainAtom => {
  const config = CONFIG_BY_SLUG[input.slug];

  return new BrainAtom({
```

[16] `src/_topublish/rhachet-brain-openai/src/atoms/genBrainAtom.ts:86-112`
```ts
      // compose system prompt from briefs
      const systemPrompt = askInput.role.briefs
        ? await castBriefsToPrompt({ briefs: askInput.role.briefs })
        : undefined;

      // get openai client from context or create new one
      const openai =
        (context?.openai as OpenAI | undefined) ??
        new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

      // build messages array
      const messages: OpenAI.ChatCompletionMessageParam[] = [];
      if (systemPrompt) {
        messages.push({ role: 'system', content: systemPrompt });
      }
      messages.push({ role: 'user', content: askInput.prompt });

      // call openai api
      const response = await openai.chat.completions.create({
        model: config.model,
        messages,
      });

      // extract content from response
      const content = response.choices[0]?.message?.content ?? '';

      // parse output via schema
      return askInput.schema.output.parse({ content });
```

### relation to wish

will reuse this exact pattern for `rhachet-brain-xai` with xai/grok slugs and xai SDK client.

---

## pattern 9: integration test pattern for brain atoms

**[REUSE]**

### description

integration tests use given/when/then structure, test atom properties and `.ask()` with/without briefs.

### citations

[17] `src/_topublish/rhachet-brain-openai/src/atoms/genBrainAtom.integration.test.ts:19-40`
```ts
describe('genBrainAtom.integration', () => {
  jest.setTimeout(30000);

  // use gpt-4o-mini for fast integration tests
  const brainAtom = genBrainAtom({ slug: 'openai/gpt-4o-mini' });

  given('[case1] genBrainAtom({ slug: "openai/gpt-4o-mini" })', () => {
    when('[t0] inspecting the atom', () => {
      then('repo is "openai"', () => {
        expect(brainAtom.repo).toEqual('openai');
      });

      then('slug is "openai/gpt-4o-mini"', () => {
        expect(brainAtom.slug).toEqual('openai/gpt-4o-mini');
      });

      then('description is defined', () => {
        expect(brainAtom.description).toBeDefined();
        expect(brainAtom.description.length).toBeGreaterThan(0);
      });
    });
  });
```

[18] `src/_topublish/rhachet-brain-openai/src/atoms/genBrainAtom.integration.test.ts:42-72`
```ts
  given('[case2] ask is called', () => {
    when('[t0] with simple prompt', () => {
      then('it returns a substantive response', async () => {
        const result = await brainAtom.ask({
          role: {},
          prompt: 'respond with exactly: hello world',
          schema: { output: outputSchema },
        });
        expect(result.content).toBeDefined();
        expect(result.content.length).toBeGreaterThan(0);
        expect(result.content.toLowerCase()).toContain('hello');
      });
    });

    when('[t1] with briefs', () => {
      then('response leverages knowledge from brief', async () => {
        const briefs = [
          genArtifactGitFile({
            uri: path.join(BRIEFS_DIR, 'secret-code.brief.md'),
          }),
        ];
        const result = await brainAtom.ask({
          role: { briefs },
          prompt: 'say hello',
          schema: { output: outputSchema },
        });
        expect(result.content).toBeDefined();
        expect(result.content).toContain('ZEBRA42');
      });
    });
  });
```

### relation to wish

will reuse this pattern for `rhachet-brain-xai` integration tests.

---

## pattern 10: anthropic brain plugin (reference implementation)

**[REUSE]**

### description

anthropic implementation follows same structure as openai, with provider-specific SDK usage.

### citations

[19] `src/_topublish/rhachet-brain-anthropic/src/atoms/genBrainAtom.ts:14-23`
```ts
type ClaudeAtomSlug =
  | 'claude/haiku'
  | 'claude/haiku/v3.5'
  | 'claude/haiku/v4.5'
  | 'claude/sonnet'
  | 'claude/sonnet/v4'
  | 'claude/sonnet/v4.5'
  | 'claude/opus'
  | 'claude/opus/v4'
  | 'claude/opus/v4.5';
```

[20] `src/_topublish/rhachet-brain-anthropic/src/atoms/genBrainAtom.ts:105-116`
```ts
      // get anthropic client from context or create new one
      const anthropic =
        (context?.anthropic as Anthropic | undefined) ??
        new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

      // call anthropic api
      const response = await anthropic.messages.create({
        model: config.model,
        max_tokens: 16384,
        system: systemPrompt,
        messages: [{ role: 'user', content: askInput.prompt }],
      });
```

### relation to wish

will follow this pattern for xai, adapting for xai SDK specifics.

---

## summary

| pattern | status | rationale |
|---------|--------|-----------|
| Actor domain object | **[EXTEND]** | add support for BrainAtom in brains allowlist |
| ActorAskOp type | **[REUSE]** | contract already compatible with both brain types |
| genActor factory | **[EXTEND]** | accept BrainAtom in addition to BrainRepl |
| actorAsk operation | **[EXTEND]** | type signature to accept BrainAtom |
| BrainRepl domain object | **[REUSE]** | unchanged, still used for `.act()` |
| BrainAtom domain object | **[REUSE]** | already exists, matches needed interface |
| brain plugin structure | **[REUSE]** | follow for rhachet-brain-xai |
| genBrainAtom factory | **[REUSE]** | pattern for xai implementation |
| integration test pattern | **[REUSE]** | pattern for xai tests |
| anthropic brain plugin | **[REUSE]** | reference for xai implementation |

### key insight

BrainRepl and BrainAtom have **identical `.ask()` signatures** (citations [9], [11]). the only difference is:
- BrainRepl has additional `.act()` method for tool-using operations
- BrainAtom has only `.ask()` for single-turn inference

this makes the extension straightforward: anywhere that only uses `.ask()` can accept `BrainRepl | BrainAtom`.
