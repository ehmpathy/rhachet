# research: production code patterns for `--prep` flag

## pattern.1: commander.js flag definition [REUSE]

the cli uses commander.js for argument parsing with typed options.

**citation [1]**: `src/contract/cli/invokeInit.ts:17-27`
```typescript
.option('--roles <roles...>', 'role specifiers to initialize')
.option(
  '--hooks [brains...]',
  'apply brain hooks (auto-detect brains if no args)',
)
.option('--config', 'generate rhachet.use.ts config (legacy behavior)')
.option(
  '--mode <mode>',
  'findsert (default) preserves prior, upsert overwrites',
  'findsert',
)
```

**relation to wish**: `--prep` flag follows same pattern. variadic optional `[...]` syntax enables `--prep` alone (boolean) or `--prep brains...` (array).

---

## pattern.2: options type in action handler [EXTEND]

action handler receives typed options object.

**citation [2]**: `src/contract/cli/invokeInit.ts:28-34`
```typescript
.action(
  async (options: {
    roles?: string[];
    hooks?: boolean | string[];
    config?: boolean;
    mode: 'findsert' | 'upsert';
  }) => {
```

**relation to wish**: extend options type to include `prep?: boolean`. new flag.

---

## pattern.3: flag routing via undefined checks [REUSE]

command routes based on which flags are provided via undefined checks.

**citation [3]**: `src/contract/cli/invokeInit.ts:39-82`
```typescript
// if --roles specified, initialize from packages
if (options.roles !== undefined && options.roles.length > 0) {
  // ... init roles logic
}

// if --hooks alone (without --roles), just reapply hooks
if (
  options.hooks !== undefined &&
  (options.roles === undefined || options.roles.length === 0)
) {
  // ... sync hooks logic
}

// if --config specified, generate rhachet.use.ts
if (options.config) {
  // ... generate config logic
}
```

**relation to wish**: add routing for `--prep` flag with same pattern.

---

## pattern.4: package.json read [REUSE]

package.json read via fs.readFileSync + JSON.parse.

**citation [4]**: `src/domain.operations/init/discoverRolePackages.ts:1-10`
```typescript
export const discoverRolePackages = async (
  context: ContextCli,
): Promise<string[]> => {
  const root = await getGitRepoRoot({ from: context.cwd });
  const pkgPath = resolve(root, 'package.json');
  const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
  return Object.keys(allDeps).filter((name) =>
    name.startsWith('rhachet-roles-'),
  );
};
```

**relation to wish**: same pattern for read. need new write pattern for scripts mutation.

---

## pattern.5: upsertFile for overwrites [REUSE]

upsert pattern for file writes that overwrite extant content.

**citation [5]**: `src/infra/upsertFile.ts:1-27`
```typescript
export const upsertFile = (input: {
  cwd: string;
  path: string;
  content?: string;
}): { effect: 'UPDATED' | 'CREATED' } => {
  const existed = existsSync(input.path);

  // create file or directory
  if (input.content !== undefined)
    writeFileSync(input.path, input.content, 'utf8');
  else mkdirSync(input.path, { recursive: true });

  if (existed) {
    console.log(`  â†» [updated] ${relative(input.cwd, input.path)}`);
    return { effect: 'UPDATED' };
  }

  console.log(`  + [created] ${relative(input.cwd, input.path)}`);
  return { effect: 'CREATED' };
};
```

**relation to wish**: prepare:rhachet entry uses upsert semantics (overwrite). may reference this pattern.

---

## pattern.6: findsertFile for preserve-if-extant [REUSE]

findsert pattern for file writes that preserve extant content.

**citation [6]**: `src/infra/findsertFile.ts:1-25`
```typescript
export const findsertFile = (input: {
  cwd: string;
  path: string;
  content?: string;
}): { effect: 'FOUND' | 'CREATED' } => {
  // check if already exists
  if (existsSync(input.path)) {
    console.log(`  â—‹ [found] ${relative(input.cwd, input.path)}`);
    return { effect: 'FOUND' };
  }

  // create file or directory
  if (input.content !== undefined)
    writeFileSync(input.path, input.content, 'utf8');
  else mkdirSync(input.path, { recursive: true });
  console.log(`  + [created] ${relative(input.cwd, input.path)}`);
  return { effect: 'CREATED' };
};
```

**relation to wish**: prepare entry findsert logic is more nuanced (append if extant, don't duplicate). this pattern is file-level, not json-property-level. will need NEW pattern for json property findsert.

---

## pattern.7: mode-based persist function selection [REUSE]

select persist function based on mode flag.

**citation [7]**: `src/domain.operations/init/generateRhachetUseTs.ts:43-50`
```typescript
  // select persist function based on mode
  const persistFile = input.mode === 'upsert' ? upsertFile : findsertFile;

  console.log(``);
  console.log(`âœ¨ ${input.mode} rhachet resources...`);

  // persist rhachet.use.ts (upsert or findsert based on mode)
  const configPath = resolve(context.gitroot, 'rhachet.use.ts');
```

**relation to wish**: similar pattern could apply if `--prep` had mode variants. for now, simpler: prepare:rhachet always upsert, prepare entry always findsert-append.

---

## pattern.8: hook sync flow [REUSE]

hooks sync after role init via syncHooksForLinkedRoles.

**citation [8]**: `src/contract/cli/invokeInit.ts:45-57`
```typescript
  // if --hooks also specified, apply hooks after init
  let hookErrors: Array<{ source: string; error: Error }> = [];
  if (options.hooks !== undefined) {
    const brains =
      Array.isArray(options.hooks) && options.hooks.length > 0
        ? options.hooks
        : undefined;
    const hookResult = await syncHooksForLinkedRoles(
      { brains },
      context,
    );
    hookErrors = hookResult.errors;
  }
```

**relation to wish**: `--hooks` presence determines if `--hooks` appears in persisted command. logic already extant for hook detection.

---

## pattern.9: context with gitroot [REUSE]

context object carries cwd and gitroot for path derivation.

**citation [9]**: `src/domain.objects/ContextCli.ts:8-18`
```typescript
export interface ContextCli {
  cwd: string;        // current work directory
  gitroot: string;    // git repository root path
}

export const genContextCli = async (input: {
  cwd: string;
}): Promise<ContextCli> => {
  const gitroot = await getGitRepoRoot({ from: input.cwd });
  return new ContextCli({ cwd: input.cwd, gitroot });
};
```

**relation to wish**: use `context.gitroot` to locate package.json.

---

## pattern.10: console output symbols [REUSE]

consistent symbols for operation feedback.

**citation [10]**: various files
```
  + [created]   â€” new resource
  â†» [updated]   â€” overwrote extant
  â—‹ [found]     â€” extant preserved
  âœ¨            â€” operation header
  ðŸ”­            â€” search/discover
  ðŸ’ª            â€” execute action
```

**relation to wish**: use same symbols for prepare entry mutations.

---

## summary: pattern disposition

| pattern | disposition | rationale |
|---------|-------------|-----------|
| commander.js flags | [REUSE] | add `--prep` with same syntax |
| options type | [EXTEND] | add `prep?: boolean` |
| flag routing | [REUSE] | add `--prep` route |
| package.json read | [REUSE] | same fs pattern |
| upsertFile | [REUSE] | reference for semantics |
| findsertFile | [REUSE] | reference for semantics |
| mode-based selection | [REUSE] | may apply to `--prep` |
| hook sync flow | [REUSE] | detect `--hooks` presence |
| context gitroot | [REUSE] | locate package.json |
| console symbols | [REUSE] | consistent feedback |

---

## gaps: new patterns needed

### gap.1: package.json scripts mutation

no extant pattern for mutate-and-write package.json. need:
- read package.json
- parse json
- mutate scripts object
- serialize with formatting preserved (or standardized)
- write back

### gap.2: findsert-append for json properties

findsertFile is file-level. need property-level:
- if prepare entry absent â†’ create
- if prepare entry extant but lacks rhachet â†’ append `&& npm run prepare:rhachet`
- if prepare entry extant and has rhachet â†’ no-op

### gap.3: command reconstruction

need to reconstruct init command from current flags:
- base: `npx rhachet init`
- add `--hooks` if `options.hooks !== undefined`
- add `--roles` with current role specifiers
- serialize to string for prepare:rhachet value
