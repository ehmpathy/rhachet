# vision: `--prep` flag for `rhachet init`

## the outcome world

### before

```sh
# developer sets up rhachet in a repo
npx rhachet init --hooks --roles mechanic,behaver

# ... time passes, teammate clones the repo ...

npm install
# no rhachet setup occurs
# teammate has no idea rhachet was ever used here
# hooks aren't configured, roles aren't linked
# they have to discover rhachet exists, then manually run init
```

the knowledge of "this repo uses rhachet" lives only in the developer's head. every new clone is a blank slate.

### after

```sh
# developer sets up rhachet with --prep
npx rhachet init --hooks --prep --roles mechanic,behaver

# package.json now has:
# "prepare:rhachet": "npx rhachet init --hooks --roles mechanic,behaver"
# "prepare": "... && npm run prepare:rhachet"

# ... time passes, teammate clones the repo ...

npm install
# prepare command runs automatically
# rhachet init runs, hooks configured, roles linked
# teammate is ready to work with full agent support
```

the knowledge propagates. the repo is self-configuring.

### the "aha" moment

> "wait, i just cloned and npm installed, and claude already has the briefs loaded? the hooks are already set up? i didn't have to do anything?"

the value clicks when onboarding becomes invisible. the repo teaches itself to new developers.

## user experience

### usecase 1: initial setup

**goal**: set up rhachet in a repo and ensure future developers get the same setup

**timeline**:
1. developer runs `npx rhachet init --hooks --prep --roles mechanic,behaver`
2. rhachet:
   - links roles into `.agent/`
   - configures hooks (if `--hooks` passed)
   - upserts `prepare:rhachet` entry into package.json
   - findserts `npm run prepare:rhachet` into `prepare` entry
3. developer commits package.json changes
4. done - future clones are self-configuring

**contract inputs**:
```sh
npx rhachet init --hooks --prep --roles mechanic,behaver
#                 ^^^^^^  ^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^
#                 |       |      roles to link
#                 |       persist setup to prepare entry
#                 configure hooks
```

**contract outputs** (package.json):
```json
{
  "scripts": {
    "prepare:rhachet": "npx rhachet init --hooks --roles mechanic,behaver",
    "prepare": "husky install && npm run prepare:rhachet"
  }
}
```

### usecase 2: updating roles

**goal**: add or change roles and ensure teammates get the update

**timeline**:
1. developer runs `npx rhachet init --hooks --prep --roles mechanic,behaver,designer`
2. rhachet updates `prepare:rhachet` entry with new roles list
3. developer commits
4. teammates run `npm install` after pull
5. prepare command runs, new roles linked

### usecase 3: no hooks variant

**goal**: link roles but skip hook configuration

```sh
npx rhachet init --prep --roles mechanic
```

**outputs**:
```json
{
  "scripts": {
    "prepare:rhachet": "npx rhachet init --roles mechanic"
  }
}
```

note: `--hooks` omitted from persisted command because it wasn't passed at `--prep` time.

## mental model

### how users describe it

> "it's like a package.json postinstall for agent setup"

> "rhachet --prep makes the repo remember its agent configuration"

> "it's the prepare pattern, but for ai tooling"

### analogies

| extant pattern | rhachet equivalent |
|------------------|-------------------|
| `husky install` in prepare | `rhachet init` in prepare |
| `.nvmrc` + nvm auto-use | `.agent/` + prepare auto-init |
| `prisma generate` in postinstall | `rhachet init` in prepare |

### terminology

| user might say | we call it |
|----------------|-----------|
| "auto-setup" | `--prep` flag |
| "remember my config" | persisted init command |
| "runs on install" | prepare integration |

## evaluation

### how well does it solve the goals?

| goal | solved? |
|------|---------|
| new clones auto-configure | yes - prepare runs on npm install |
| teammates get same setup | yes - command is in version control |
| roles stay current | yes - re-running init updates links |
| hooks stay configured | yes - if `--hooks` was passed |

### pros

- zero-friction onboarding for teammates
- declarative: config lives in package.json, not developer memory
- idempotent: safe to run multiple times
- composable: works alongside extant prepare entries

### cons

- requires npm install to trigger (not on clone alone)
- adds ~300ms to npm install (rhachet init time)
- prepare entry can get cluttered with multiple tools

### edgecases and pit of success

| edgecase | handling |
|----------|----------|
| prepare entry already extant | findsert: append `&& npm run prepare:rhachet` if not already present |
| prepare:rhachet already extant | upsert: overwrite with new config |
| no prepare entry yet | create one: `"prepare": "npm run prepare:rhachet"` |
| prepare already has rhachet | idempotent: no duplicate `&& npm run prepare:rhachet` |
| user passes `--hooks` later | update persisted command to include `--hooks` |
| user omits `--hooks` later | update persisted command to omit `--hooks` |

### awkward bits discovered

1. **flag name**: `--prep` vs `--persist` vs `--save`?
   - `--prep` aligns with npm's `prepare` naming
   - `--persist` clearer semantically but longer
   - recommendation: `--prep` (short, memorable, echoes "prepare")

2. **order of flags**: does flag order matter?
   - `--prep --roles x` vs `--roles x --prep`
   - recommendation: order-independent parsing

3. **removing --prep setup**: no `--unprep` flag?
   - for now: manual removal from package.json
   - could add later if needed

4. **monorepos**: which package.json?
   - uses closest package.json to cwd
   - behavior is intuitive for most cases
