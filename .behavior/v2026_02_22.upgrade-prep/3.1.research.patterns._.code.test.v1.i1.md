# research: test code patterns for `--prep` flag

## pattern.1: test file naming conventions [REUSE]

two-tier organization: unit tests vs integration tests.

**citation [1]**: file naming
- `*.test.ts` — unit tests, collocated with implementation
- `*.integration.test.ts` — integration tests, collocated with implementation
- example: `src/contract/cli/invokeInit.integration.test.ts`

**relation to wish**: follow same convention. add integration tests to `invokeInit.integration.test.ts`.

---

## pattern.2: test infra directory [REUSE]

shared test helpers live in `src/.test/infra/`.

**citation [2]**: `src/.test/infra/index.ts`
```
genTestTempDir.ts
setTestTempAsset.ts
invokeRhachetCli.ts
runRhachetCli.ts
withTempHome.ts
withTestSshAgent.ts
```

**relation to wish**: use extant helpers. may add new helper for package.json mutation setup.

---

## pattern.3: BDD structure with test-fns [REUSE]

tests use `given/when/then` from `test-fns` for readable organization.

**citation [3]**: `src/contract/cli/invokeInit.integration.test.ts:15-52`
```typescript
describe('invokeInit (integration)', () => {
  given('a CLI program with invokeInit registered', () => {
    const testDir = join(__dirname, './.temp/invokeInit');
    const originalCwd = process.cwd();

    beforeAll(() => {
      mkdirSync(testDir, { recursive: true });
      try {
        execSync('git init', { cwd: testDir, stdio: 'pipe' });
      } catch {
        // already a git repo
      }
    });

    afterAll(() => {
      process.chdir(originalCwd);
    });

    const program = new Command('rhachet');
    const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

    beforeEach(() => {
      logSpy.mockClear();
      process.chdir(testDir);
    });

    invokeInit({ program });

    when('invoked with --config and package.json...', () => {
      beforeEach(() => {
        writeFileSync(
          join(testDir, 'package.json'),
          JSON.stringify({...}),
        );
      });

      then('it should create rhachet.use.ts', async () => {
        await program.parseAsync(['init', '--config'], { from: 'user' });
        expect(existsSync(configPath)).toBe(true);
      });
    });
  });
});
```

**relation to wish**: follow exact same pattern for `--prep` tests.

---

## pattern.4: useBeforeAll for computed context [REUSE]

`useBeforeAll` from test-fns for lazy computed fixtures.

**citation [4]**: `src/domain.operations/init/showInitUsageInstructions.integration.test.ts:8-13`
```typescript
given('[case1] current repo with rhachet-roles-* packages', () => {
  const context = useBeforeAll(() => genContextCli({ cwd: process.cwd() }));

  when('[t0] showInitUsageInstructions is called', () => {
    then('output contains usage header', async () => {
      const result = await showInitUsageInstructions(context);
      expect(result.output).toContain('usage: npx rhachet init --roles');
    });
  });
});
```

**relation to wish**: use for async setup like temp directory creation.

---

## pattern.5: genTestTempDir helper [REUSE]

factory for isolated temp directories with setup/teardown.

**citation [5]**: `src/.test/infra/genTestTempDir.ts:8-43`
```typescript
export const genTestTempDir = (input: {
  base: string;
  name: string;
}): {
  path: string;
  setup: () => void;
  teardown: () => void;
  rm: (relativePath: string) => void;
} => {
  const testDir = join(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,

    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },

    teardown: () => {
      process.chdir(originalCwd);
    },

    rm: (relativePath: string) => {
      rmSync(join(testDir, relativePath), { force: true, recursive: true });
    },
  };
};
```

**relation to wish**: use for isolated test repos with package.json.

---

## pattern.6: setTestTempAsset helper [REUSE]

creates test assets with safety guards.

**citation [6]**: `src/.test/infra/setTestTempAsset.ts:8-25`
```typescript
export const setTestTempAsset = (input: {
  dir: string;
  name: string;
  content: string;
  executable?: boolean;
}): { path: string } => {
  // guard: ensure we're under .temp for safety
  if (!input.dir.includes('.temp'))
    throw new Error(
      `setTestTempAsset: dir must be under .temp for safety, got: ${input.dir}`,
    );

  const assetPath = join(input.dir, input.name);
  mkdirSync(dirname(assetPath), { recursive: true });
  writeFileSync(assetPath, input.content);

  const shouldExecute = input.executable ?? input.name.endsWith('.sh');
  if (shouldExecute) chmodSync(assetPath, '755');

  return { path: assetPath };
};
```

**relation to wish**: use for creating test package.json files.

---

## pattern.7: commander.js program setup [REUSE]

create program instance, register command, invoke with parseAsync.

**citation [7]**: `src/contract/cli/invokeInit.integration.test.ts:36-51`
```typescript
const program = new Command('rhachet');
const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

beforeEach(() => {
  logSpy.mockClear();
  process.chdir(testDir);
});

invokeInit({ program });

// in test:
await program.parseAsync(['init', '--config'], { from: 'user' });
```

**relation to wish**: same pattern for `--prep` flag invocation.

---

## pattern.8: program.exitOverride() for error tests [REUSE]

prevent process.exit in error paths.

**citation [8]**: `src/contract/cli/invokeAct.integration.test.ts:43-44`
```typescript
const program = new Command();
program.exitOverride(); // prevent process.exit in tests
```

**relation to wish**: use for error boundary tests (no package.json, invalid json).

---

## pattern.9: console.log spy for output assertions [REUSE]

spy on console.log to verify command output.

**citation [9]**: `src/contract/cli/invokeInit.integration.test.ts:215-217`
```typescript
expect(logSpy).toHaveBeenCalledWith(
  expect.stringContaining('○ [found]'),
);
```

**relation to wish**: verify `[created]`, `[updated]`, `[found]` output for prepare entries.

---

## pattern.10: getError for error assertions [REUSE]

capture thrown errors for assertion.

**citation [10]**: `src/contract/cli/invokeAct.integration.test.ts:67-71`
```typescript
const error = await getError(() =>
  program.parseAsync(args, { from: 'user' }),
);
expect(error?.message).toContain('no brains available');
```

**relation to wish**: use for error boundary tests.

---

## pattern.11: package.json read/write in tests [REUSE]

create and verify package.json content.

**citation [11]**: `src/contract/cli/invokeInit.integration.test.ts:57-67`
```typescript
beforeEach(() => {
  writeFileSync(
    join(testDir, 'package.json'),
    JSON.stringify({
      name: 'test-project',
      dependencies: {
        'rhachet-roles-ehmpathy': '1.0.0',
      },
    }),
  );
});
```

**citation [12]**: `src/domain.operations/npm/execNpmInstall.integration.test.ts:32-44`
```typescript
then('npm install succeeds and package is added', () => {
  execNpmInstall({ packages: ['is-odd'] }, context);

  const pkg = JSON.parse(readFileSync('package.json', 'utf8'));
  expect(pkg.dependencies['is-odd']).toBeDefined();
});
```

**relation to wish**: same pattern for asserting scripts mutations.

---

## pattern.12: findsert status assertions [REUSE]

verify idempotent operation effects.

**citation [13]**: `src/domain.operations/link/findsertRepoGitignore.integration.test.ts:41-50`
```typescript
then('creates file with correct content, status=created', () => {
  const result = findsertRepoGitignore({ repoDir });

  expect(result.status).toEqual('created');

  const content = readFileSync(join(repoDir, '.gitignore'), 'utf8');
  expect(content).toContain('.what = tells git to ignore this dir');
});
```

**relation to wish**: verify prepare entry findsert returns correct status.

---

## pattern.13: mode flag test differentiation [REUSE]

test different behavior for findsert vs upsert modes.

**citation [14]**: `src/contract/cli/invokeInit.integration.test.ts:254-290`
```typescript
when(
  'rhachet.use.ts already exists and --config --mode upsert is used',
  () => {
    beforeEach(() => {
      writeFileSync(join(testDir, 'package.json'), JSON.stringify({...}));
      writeFileSync(join(testDir, 'rhachet.use.ts'), '// prior config');
    });

    then(
      'it should report [updated] and overwrite prior content',
      async () => {
        await program.parseAsync(['init', '--config', '--mode', 'upsert'], {
          from: 'user',
        });

        const content = readFileSync(configPath, 'utf8');
        expect(content).not.toBe('// prior config');
        expect(logSpy).toHaveBeenCalledWith(
          expect.stringContaining('↻ [updated]'),
        );
      },
    );
  },
);
```

**relation to wish**: similar pattern for testing prepare:rhachet upsert vs prepare findsert-append.

---

## summary: pattern disposition

| pattern | disposition | rationale |
|---------|-------------|-----------|
| file naming | [REUSE] | add to `invokeInit.integration.test.ts` |
| test infra dir | [REUSE] | use extant helpers |
| BDD given/when/then | [REUSE] | same structure |
| useBeforeAll | [REUSE] | async fixtures |
| genTestTempDir | [REUSE] | isolated test repos |
| setTestTempAsset | [REUSE] | create test files |
| commander program | [REUSE] | same invocation pattern |
| exitOverride | [REUSE] | error tests |
| console.log spy | [REUSE] | output verification |
| getError | [REUSE] | error assertions |
| package.json read/write | [REUSE] | verify scripts |
| findsert status | [REUSE] | verify idempotency |
| mode flag tests | [REUSE] | upsert vs findsert |

---

## test structure for `--prep` flag

```typescript
describe('invokeInit (integration)', () => {
  given('--prep flag behavior', () => {
    // setup temp dir with git init
    // setup package.json with rhachet-roles-* dep

    when('[t0] --prep --roles mechanic (no prepare entry extant)', () => {
      then('prepare:rhachet entry created')
      then('prepare entry created with npm run prepare:rhachet')
    });

    when('[t1] --prep --hooks --roles mechanic (no prepare entry extant)', () => {
      then('prepare:rhachet entry includes --hooks')
    });

    when('[t2] --prep --roles mechanic (prepare entry extant)', () => {
      then('prepare entry appended with && npm run prepare:rhachet')
      then('prepare entry not duplicated on re-run')
    });

    when('[t3] --prep --roles mechanic (prepare:rhachet extant)', () => {
      then('prepare:rhachet entry updated with new roles')
      then('prepare entry unchanged')
    });

    when('[t4] --prep without --roles', () => {
      then('error surfaced: --prep requires --roles')
    });
  });
});
```
