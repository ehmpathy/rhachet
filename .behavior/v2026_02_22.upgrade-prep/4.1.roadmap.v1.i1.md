# roadmap: `--prep` flag for `rhachet init`

## phase.0: preparation

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/3.3.blueprint.v1.i1.md` â€” blueprint
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.prod.v1.i1.md` â€” prod patterns

**checklist**:
- [ ] confirm all dependencies extant (test-fns, commander, etc)
- [ ] confirm test suite passes: `npm run test`

**acceptance**:
- `npm run test` exits 0

---

## phase.1: genInitCommand (pure function)

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.test.v1.i1.md` â€” test patterns
- `.behavior/v2026_02_22.upgrade-prep/3.3.blueprint.v1.i1.md` â€” contract.3

**depends on**: phase.0

**checklist**:
- [ ] create `src/domain.operations/pkg/genInitCommand.ts`
- [ ] implement: `genInitCommand({ hooks, roles }) => string`
- [ ] create `src/domain.operations/pkg/genInitCommand.test.ts`
- [ ] test: hooks=true, roles=['mechanic'] â†’ `npx rhachet init --hooks --roles mechanic`
- [ ] test: hooks=false, roles=['a','b'] â†’ `npx rhachet init --roles a,b`
- [ ] test: hooks=true, roles=['a','b','c'] â†’ `npx rhachet init --hooks --roles a,b,c`

**acceptance**:
- `npm run test:unit -- genInitCommand` exits 0
- all cases from contract.3 examples pass

**verify**:
```sh
npm run test:unit -- genInitCommand
```

---

## phase.2: upsertPackageJsonEntry (pure function)

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.test.v1.i1.md` â€” test patterns
- `.behavior/v2026_02_22.upgrade-prep/3.3.blueprint.v1.i1.md` â€” contract.4

**depends on**: phase.0

**checklist**:
- [ ] create `src/domain.operations/pkg/upsertPackageJsonEntry.ts`
- [ ] implement: `upsertPackageJsonEntry({ pkg, key, value }) => { pkg, effect }`
- [ ] create `src/domain.operations/pkg/upsertPackageJsonEntry.test.ts`
- [ ] test: key absent â†’ effect='CREATED', pkg.scripts[key] set
- [ ] test: key extant â†’ effect='UPDATED', pkg.scripts[key] overwritten

**acceptance**:
- `npm run test:unit -- upsertPackageJsonEntry` exits 0
- CREATED and UPDATED effects verified

**verify**:
```sh
npm run test:unit -- upsertPackageJsonEntry
```

---

## phase.3: findsertAppendPackageJsonEntry (pure function)

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.test.v1.i1.md` â€” test patterns
- `.behavior/v2026_02_22.upgrade-prep/3.3.blueprint.v1.i1.md` â€” contract.5
- `.behavior/v2026_02_22.upgrade-prep/2.2.criteria.blackbox.matrix.md` â€” matrix.1

**depends on**: phase.0

**checklist**:
- [ ] create `src/domain.operations/pkg/findsertAppendPackageJsonEntry.ts`
- [ ] implement: `findsertAppendPackageJsonEntry({ pkg, key, append, separator }) => { pkg, effect }`
- [ ] create `src/domain.operations/pkg/findsertAppendPackageJsonEntry.test.ts`
- [ ] test: key absent â†’ effect='CREATED', pkg.scripts[key] = append
- [ ] test: key extant, lacks append â†’ effect='APPENDED', pkg.scripts[key] = prior + separator + append
- [ ] test: key extant, has append â†’ effect='FOUND', pkg.scripts[key] unchanged
- [ ] test: default separator is ' && '

**acceptance**:
- `npm run test:unit -- findsertAppendPackageJsonEntry` exits 0
- CREATED, APPENDED, and FOUND effects verified
- idempotency verified (FOUND on re-run)

**verify**:
```sh
npm run test:unit -- findsertAppendPackageJsonEntry
```

---

## phase.4: persistPrepareEntries (orchestrator)

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.prod.v1.i1.md` â€” prod patterns (package.json read)
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.test.v1.i1.md` â€” test patterns (genTestTempDir)
- `.behavior/v2026_02_22.upgrade-prep/3.3.blueprint.v1.i1.md` â€” contract.2

**depends on**: phase.1, phase.2, phase.3

**checklist**:
- [ ] create `src/domain.operations/init/persistPrepareEntries.ts`
- [ ] implement: read package.json â†’ genInitCommand â†’ upsert prepare:rhachet â†’ findsert-append prepare â†’ write package.json
- [ ] add console output: `ðŸ“¦ persist prepare entries...` with effect symbols
- [ ] create `src/domain.operations/init/persistPrepareEntries.integration.test.ts`
- [ ] test: no prepare entries â†’ both CREATED
- [ ] test: prepare extant â†’ prepare:rhachet CREATED, prepare APPENDED
- [ ] test: both extant with rhachet â†’ prepare:rhachet UPDATED, prepare FOUND
- [ ] test: hooks=true reflected in prepare:rhachet value
- [ ] test: hooks=false reflected in prepare:rhachet value

**acceptance**:
- `npm run test:integration -- persistPrepareEntries` exits 0
- package.json correctly mutated in temp directory
- console output shows correct effect symbols

**verify**:
```sh
npm run test:integration -- persistPrepareEntries
```

---

## phase.5: invokeInit --prep flag

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.prod.v1.i1.md` â€” prod patterns (commander.js, flag route)
- `.behavior/v2026_02_22.upgrade-prep/3.3.blueprint.v1.i1.md` â€” contract.1

**depends on**: phase.4

**checklist**:
- [ ] update `src/contract/cli/invokeInit.ts`: add `.option('--prep', ...)`
- [ ] update options type: add `prep?: boolean`
- [ ] add validation: if `--prep` without `--roles` â†’ BadRequestError
- [ ] add route: if `options.prep` after roles init â†’ call `persistPrepareEntries`
- [ ] pass `{ hooks: options.hooks !== undefined, roles: options.roles }` to persistPrepareEntries

**acceptance**:
- `npx tsx ./bin/run init --prep --roles mechanic` mutates package.json
- `npx tsx ./bin/run init --prep` (no --roles) shows error

**verify**:
```sh
# in a temp directory with package.json
npx tsx ./bin/run init --prep --roles mechanic
cat package.json | jq '.scripts'
```

---

## phase.6: invokeInit integration tests

**read before start**:
- `.behavior/v2026_02_22.upgrade-prep/2.1.criteria.blackbox.md` â€” blackbox criteria
- `.behavior/v2026_02_22.upgrade-prep/2.2.criteria.blackbox.matrix.md` â€” coverage matrix
- `.behavior/v2026_02_22.upgrade-prep/3.1.research.patterns._.code.test.v1.i1.md` â€” test patterns

**depends on**: phase.5

**checklist**:
- [ ] update `src/contract/cli/invokeInit.integration.test.ts`
- [ ] add given('--prep flag behavior', () => { ... })
- [ ] test [t0]: --prep --hooks --roles (no prepare entries) â†’ both created, --hooks in command
- [ ] test [t1]: --prep --roles (no --hooks) â†’ prepare:rhachet without --hooks
- [ ] test [t2]: --prep --roles (prepare:rhachet extant) â†’ updated, prepare unchanged
- [ ] test [t3]: --prep --hooks (extant without hooks) â†’ --hooks added
- [ ] test [t4]: --prep (extant with hooks) â†’ --hooks removed
- [ ] test [t5]: --prep (prepare = husky install) â†’ appended
- [ ] test [t6]: --prep (prepare already has rhachet) â†’ idempotent
- [ ] test [t7]: --prep without --roles â†’ error
- [ ] test [t8]: --prep (no package.json) â†’ error

**acceptance**:
- `npm run test:integration -- invokeInit` exits 0
- all 9 test cases from blackbox criteria pass

**verify**:
```sh
npm run test:integration -- invokeInit
```

---

## phase.7: full test suite

**read before start**: none (verification only)

**depends on**: phase.6

**checklist**:
- [ ] run `npm run test:types`
- [ ] run `npm run test:lint`
- [ ] run `npm run test:unit`
- [ ] run `npm run test:integration`
- [ ] run `npm run test` (all)

**acceptance**:
- all test commands exit 0
- no type errors
- no lint errors

**verify**:
```sh
npm run test
```

---

## summary

| phase | deliverable | depends on | verify command |
|-------|-------------|------------|----------------|
| 0 | preparation | â€” | `npm run test` |
| 1 | genInitCommand | 0 | `npm run test:unit -- genInitCommand` |
| 2 | upsertPackageJsonEntry | 0 | `npm run test:unit -- upsertPackageJsonEntry` |
| 3 | findsertAppendPackageJsonEntry | 0 | `npm run test:unit -- findsertAppendPackageJsonEntry` |
| 4 | persistPrepareEntries | 1,2,3 | `npm run test:integration -- persistPrepareEntries` |
| 5 | invokeInit --prep flag | 4 | manual verification |
| 6 | invokeInit integration tests | 5 | `npm run test:integration -- invokeInit` |
| 7 | full test suite | 6 | `npm run test` |

**parallel opportunities**: phases 1, 2, 3 can execute in parallel (no dependencies between them)
