# research: test code patterns

## pattern.1 = acceptance test fixture infrastructure

**[EXTEND]** — add fixtures for keyrack extends scenarios

### citation [1]: blackbox/.test/infra/genTestTempRepo.ts:67-122

```ts
export const genTestTempRepo = async (input: {
  /** fixture template to use */
  fixture: TestRepoFixture;
  /** optional unique suffix for the repo name */
  suffix?: string;
  /** run pnpm install after copy (for fixtures with package.json) */
  install?: boolean;
}): Promise<{
  /** absolute path to the test repo */
  path: string;
}> => {
  // gen unique temp directory path
  const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const suffix = input.suffix ? `-${input.suffix}` : '';
  const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${suffix}`);

  // fail fast if fixture dne
  const fixturePath = join(ASSETS_DIR, input.fixture);
  if (!existsSync(fixturePath))
    throw new Error(`fixture not found: ${input.fixture} (${fixturePath})`);

  // copy fixture assets into temp repo
  cpSync(fixturePath, repoPath, { recursive: true });
```

### relation to wish

need to create new fixtures for keyrack extends test scenarios:
- `with-keyrack-extends` — root keyrack with extends array
- `with-role-keyrack` — role that declares keyrack in its definition

---

## pattern.2 = acceptance test CLI invocation

**[REUSE]** — use invokeRhachetCliBinary for CLI tests

### citation [2]: blackbox/.test/infra/invokeRhachetCliBinary.ts:36-67

```ts
export const invokeRhachetCliBinary = (input: {
  /** which binary to invoke (default: 'rhachet') */
  binary?: 'rhachet' | 'rhx';
  /** CLI args after the binary name (e.g., ['run', '--skill', 'foo'] for rhachet, ['foo'] for rhx) */
  args: string[];
  /** cwd for the command */
  cwd: string;
  /** optional stdin data to pipe */
  stdin?: string;
  /** whether to log output on failure (default: true) */
  logOnError?: boolean;
  /** optional env vars to merge with process.env */
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const binPath = input.binary === 'rhx' ? RHX_BIN : RHACHET_BIN;
  const result = spawnSync(binPath, input.args, {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
    env: { ...process.env, ...input.env },
  });
```

### relation to wish

reuse directly for:
- `roles link` acceptance tests
- `keyrack get` acceptance tests
- `keyrack init --at` acceptance tests
- `repo introspect` acceptance tests

---

## pattern.3 = roles link acceptance tests

**[EXTEND]** — add tests for boot.yml and keyrack.yml symlinks

### citation [3]: blackbox/cli/roles.link.acceptance.test.ts:49-70

```ts
      then('repo readme is a symlink to source file', () => {
        const readmePath = expand(repo.path, '.agent/repo=test-repo/readme.md');
        const stats = lstatSync(readmePath);
        expect(stats.isSymbolicLink()).toBe(true);

        // verify symlink points to the correct source
        const linkTarget = readlinkSync(readmePath);
        expect(linkTarget).toContain('.source/repo-readme.md');
      });

      then('role readme is a symlink to source file', () => {
        const readmePath = expand(
          repo.path,
          '.agent/repo=test-repo/role=tester/readme.md',
        );
        const stats = lstatSync(readmePath);
        expect(stats.isSymbolicLink()).toBe(true);

        // verify symlink points to the correct source
        const linkTarget = readlinkSync(readmePath);
        expect(linkTarget).toContain('.source/role-readme.md');
      });
```

### relation to wish

extend with similar assertions for:
- `.agent/repo=$slug/role=$role/boot.yml` symlink created
- `.agent/repo=$slug/role=$role/keyrack.yml` symlink created
- symlinks point to correct sources in node_modules

---

## pattern.4 = repo introspect acceptance tests

**[EXTEND]** — add tests for boot and keyrack in rhachet.repo.yml

### citation [4]: blackbox/cli/repo.introspect.acceptance.test.ts:37-47

```ts
      then('yml contains role slug', () => {
        const manifestPath = expand(repo.path, 'rhachet.repo.yml');
        const content = readFileSync(manifestPath, 'utf-8');
        expect(content).toContain('slug:');
      });

      then('yml contains roles array', () => {
        const manifestPath = expand(repo.path, 'rhachet.repo.yml');
        const content = readFileSync(manifestPath, 'utf-8');
        expect(content).toContain('roles:');
      });
```

### relation to wish

extend with assertions for:
- yml contains `boot:` when role declares boot
- yml contains `keyrack:` when role declares keyrack
- boot and keyrack paths are relative to package root

---

## pattern.5 = keyrack init acceptance tests

**[EXTEND]** — add tests for `keyrack init --at $path`

### citation [5]: blackbox/cli/keyrack.init.acceptance.test.ts:20-53

```ts
  given('[case1] keyrack init with default ssh key (fresh repo)', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'minimal' }),
    );

    when('[t0] init (json output)', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['keyrack', 'init', '--json'],
          cwd: repo.path,
          env: { HOME: repo.path },
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('response contains owner null for default', () => {
        const parsed = JSON.parse(result.stdout);
        expect(parsed.host.owner).toBeNull();
      });
```

### relation to wish

extend with new test cases:
- `keyrack init --at $path` for role-level keyrack.yml
- valid schema exits 0
- invalid schema exits non-zero with helpful error
- key spec lacks description → error message

---

## pattern.6 = daoKeyrackRepoManifest integration tests

**[EXTEND]** — add tests for `extends` field parsing

### citation [6]: src/access/daos/daoKeyrackRepoManifest/index.integration.test.ts:33-49

```ts
  given('[case2] valid keyrack.yml exists', () => {
    beforeEach(() => {
      const agentDir = join(testDir, '.agent');
      mkdirSync(agentDir, { recursive: true });
      writeFileSync(
        join(agentDir, 'keyrack.yml'),
        `org: testorg

env.all:
  - XAI_API_KEY: encrypted
  - GITHUB_TOKEN
  - AWS_PROFILE: ephemeral

env.test: []
`,
      );
    });

    when('[t0] get called', () => {
      then('returns parsed manifest', async () => {
        const result = await daoKeyrackRepoManifest.get({ gitroot: testDir });

        expect(result).not.toBeNull();
        // 3 keys in env.all expanded to env.test = 3 keys total
        expect(Object.keys(result!.keys)).toHaveLength(3);
      });
```

### relation to wish

extend with test cases:
- keyrack.yml with `extends: [path]` → loads extended manifest
- keys from extended manifest are merged
- root keys override extended keys
- invalid extends path → error message
- circular extends → error message

---

## pattern.7 = fixture .agent/ directory structure

**[USE .agent/ ONLY]** — consumer repo fixtures need only the .agent/ directory

### relation to wish

consumer repo test fixtures simulate post-link state:
- no rhachet.use.ts (deprecated, for role suppliers only)
- no rhachet.repo.yml (for role suppliers only)
- just .agent/ directory with linked roles

```
with-role-boot-keyrack/
  .agent/
    repo=test-repo/
      role=tester/
        readme.md
        boot.yml
        keyrack.yml
        briefs/
        skills/
```

for role supplier tests (repo introspect), use separate fixtures with rhachet.repo.yml.

---

## pattern.8 = integration test temp directory

**[REUSE]** — use genTestTempDir for integration tests

### citation [8]: src/.test/infra/genTestTempDir.ts:8-43

```ts
export const genTestTempDir = (input: {
  /** base directory (typically __dirname) */
  base: string;
  /** subdirectory name under .temp */
  name: string;
}): {
  /** absolute path to the test directory */
  path: string;
  /** call in beforeAll to setup directory and switch cwd */
  setup: () => void;
  /** call in afterAll to restore original cwd */
  teardown: () => void;
  /** call to remove a file or directory within the test dir */
  rm: (relativePath: string) => void;
} => {
  const testDir = expand(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,

    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },
```

### relation to wish

reuse directly for daoKeyrackRepoManifest integration tests that test extends parsing.

---

## pattern.9 = execRoleLink integration tests

**[EXTEND]** — add tests for boot.yml and keyrack.yml linking

### citation [9]: src/domain.operations/invoke/link/execRoleLink.integration.test.ts:61-93

```ts
      then('stdout matches snapshot', () => {
        const role: RoleManifest = {
          slug: 'mechanic',
          readme: { uri: 'role-readme.md' },
          briefs: { dirs: [{ uri: 'test-briefs' }] },
          skills: { dirs: [{ uri: 'test-skills' }] },
          inits: { dirs: [{ uri: 'test-inits' }] },
        };

        const repo: RoleRegistryManifest = {
          slug: 'ehmpathy',
          readme: { uri: 'readme.md' },
          roles: [role],
        };

        const context = new ContextCli({
          cwd: testDir.path,
          gitroot: testDir.path,
        });

        // capture stdout
        const logs: string[] = [];
        const originalLog = console.log;
        console.log = (...args: string[]) => logs.push(args.join(' '));

        try {
          execRoleLink({ role, repo }, context);
        } finally {
          console.log = originalLog;
        }

        const output = logs.join('\n');
        expect(output).toMatchSnapshot();
      });
```

### relation to wish

extend with:
- add `boot: { uri: 'boot.yml' }` to role fixture
- add `keyrack: { uri: 'keyrack.yml' }` to role fixture
- create boot.yml and keyrack.yml in test temp dir
- assert symlinks are created
- assert snapshot includes boot.yml and keyrack.yml in output

---

## pattern.10 = keyrack manifest fixture structure

**[EXTEND]** — add fixtures with extends arrays

### citation [10]: blackbox/.test/assets/with-keyrack-manifest/.agent/keyrack.yml

```yaml
org: testorg

env.test:
  - XAI_API_KEY
  - GITHUB_APP_CREDS
```

### relation to wish

create new fixture `with-keyrack-extends`:
```yaml
org: testorg
extends:
  - .agent/repo=test-repo/role=tester/keyrack.yml
env.test:
  - LOCAL_KEY
```

and corresponding extended keyrack in `.agent/repo=test-repo/role=tester/keyrack.yml`:
```yaml
org: testorg
env.test:
  - ROLE_KEY
```

---

## summary

| pattern | file | action | change |
|---------|------|--------|--------|
| genTestTempRepo | blackbox/.test/infra/genTestTempRepo.ts | EXTEND | add fixtures for keyrack extends |
| invokeRhachetCliBinary | blackbox/.test/infra/invokeRhachetCliBinary.ts | REUSE | use for CLI acceptance tests |
| roles link tests | blackbox/cli/roles.link.acceptance.test.ts | EXTEND | add boot.yml + keyrack.yml symlink assertions |
| repo introspect tests | blackbox/cli/repo.introspect.acceptance.test.ts | EXTEND | add boot + keyrack in yml assertions |
| keyrack init tests | blackbox/cli/keyrack.init.acceptance.test.ts | EXTEND | add `--at $path` tests |
| daoKeyrackRepoManifest tests | src/access/daos/daoKeyrackRepoManifest/index.integration.test.ts | EXTEND | add extends parsing tests |
| fixture .agent/ structure | blackbox/.test/assets/*/.agent/ | USE | consumer fixtures use .agent/ only (post-link state) |
| genTestTempDir | src/.test/infra/genTestTempDir.ts | REUSE | use for integration tests |
| execRoleLink tests | src/domain.operations/invoke/link/execRoleLink.integration.test.ts | EXTEND | add boot + keyrack linking |
| keyrack fixture | blackbox/.test/assets/with-keyrack-manifest/.agent/keyrack.yml | EXTEND | add extends field fixtures |

## new fixtures needed

all fixtures simulate consumer repos (post-link state) — `.agent/` directory only.

| fixture | purpose | contents |
|---------|---------|----------|
| `with-keyrack-extends` | test extends chain lookup | .agent/keyrack.yml with extends, .agent/repo=*/role=*/keyrack.yml |
| `with-role-boot-keyrack` | test boot + keyrack in linked role | .agent/repo=*/role=*/boot.yml + keyrack.yml |
| `with-circular-extends` | test circular detection | keyrack A extends B, B extends A |
| `with-recursive-extends` | test recursive lookup | root extends A, A extends B, B has deep key |
