# research: production code patterns

## pattern.1 = Role type definition

**[EXTEND]** — add `boot` and `keyrack` optional properties

### citation [1]: src/domain.objects/Role.ts:110-134

```ts
  briefs: { dirs: { uri: string } | { uri: string }[] };

  /**
   * .what = initialization resources and commands for this role
   * .why = declares setup actions that should run once when instantiating a role
   * .how =
   *   - dirs: directory-based init scripts for linking (same pattern as briefs/skills)
   *     - single { uri: string }: symlinks this dir as the full inits dir
   *     - array { uri: string }[]: symlinks each dir within the inits dir
   *   - exec: commands to execute when `npx rhachet roles init` is run
   */
  inits?: {
    dirs?: { uri: string } | { uri: string }[];
    exec?: { cmd: string }[];
  };

  /**
   * .what = hooks declared by this role
   * .why = enables role authors to register hooks for dispatch and brain events
   * .how =
   *   - onDispatch: middleware over rhachet dispatch actions (ask/act input transformation)
   *   - onBrain: hooks applied to brain repl configs (boot, tool, stop events)
   */
  hooks?: RoleHooks;
```

### relation to wish

Role type lacks `boot` and `keyrack` properties. need to add:
- `boot?: { uri: string }` — path to boot.yml
- `keyrack?: { uri: string }` — path to keyrack.yml

follows same pattern as `readme: { uri: string }`.

---

## pattern.2 = RoleManifest type definition

**[EXTEND]** — add `keyrack` property (boot already present)

### citation [2]: src/domain.objects/RoleManifest.ts:9-19

```ts
export interface RoleManifest {
  slug: string;
  readme: { uri: string };
  briefs: { dirs: { uri: string } | { uri: string }[] };
  skills: { dirs: { uri: string } | { uri: string }[] };
  inits?: {
    dirs?: { uri: string } | { uri: string }[];
    exec?: { cmd: string }[];
  };
  boot?: { uri: string };
}
```

### relation to wish

RoleManifest has `boot?: { uri: string }` but lacks `keyrack`. need to add:
- `keyrack?: { uri: string }` — path to keyrack.yml

---

## pattern.3 = castIntoRoleRegistryManifest (repo introspect)

**[EXTEND]** — add boot and keyrack to RoleManifestSerializable and serialization

### citation [3]: src/domain.operations/manifest/castIntoRoleRegistryManifest.ts:11-20

```ts
interface RoleManifestSerializable {
  slug: string;
  readme: string;
  briefs: { dirs: string | string[] };
  skills: { dirs: string | string[] };
  inits?: {
    dirs?: string | string[];
    exec?: string[];
  };
}
```

### citation [4]: src/domain.operations/manifest/castIntoRoleRegistryManifest.ts:82-91

```ts
  // build base manifest
  const manifest: RoleManifestSerializable = {
    slug: role.slug,
    readme: makeRelative({ absolutePath: role.readme.uri, packageRoot }),
    briefs: {
      dirs: briefsDirs.length === 1 ? briefsDirs[0]! : briefsDirs,
    },
    skills: {
      dirs: skillsDirs.length === 1 ? skillsDirs[0]! : skillsDirs,
    },
  };
```

### relation to wish

RoleManifestSerializable lacks `boot` and `keyrack`. need to add:
- `boot?: string` — relative path to boot.yml
- `keyrack?: string` — relative path to keyrack.yml

serialization should include both if present on Role.

---

## pattern.4 = execRoleLink (roles link)

**[EXTEND]** — add symlink for boot.yml and keyrack.yml

### citation [5]: src/domain.operations/invoke/link/execRoleLink.ts:103-112

```ts
  // symlink .agent/repo=$repo/role=$role/readme.md
  if (input.role.readme?.uri) {
    const targetPath = expand(repoRoleDir, 'readme.md');
    const relativeTargetPath = relative(process.cwd(), targetPath);
    const { status } = symlinkReadme({
      sourcePath: input.role.readme.uri,
      targetPath,
    });
    linkResults.push({ path: relativeTargetPath, status });
  }
```

### citation [6]: src/domain.operations/invoke/link/execRoleLink.ts:136-147

```ts
  // link inits if configured
  const inits = input.role.inits?.dirs
    ? symlinkResourceDirectories(
        {
          sourceDirs: input.role.inits.dirs,
          targetDir: expand(repoRoleDir, 'inits'),
          resourceName: 'inits',
        },
        context,
      )
    : { fileCount: 0, results: [] };
  linkResults.push(...inits.results);
```

### relation to wish

execRoleLink symlinks readme.md for roles but not boot.yml or keyrack.yml. need to add:
- symlink boot.yml if `role.boot?.uri` present
- symlink keyrack.yml if `role.keyrack?.uri` present

use symlinkFile pattern (single file symlink).

---

## pattern.5 = symlinkFile (single file symlink)

**[RENAME + REUSE]** — rename symlinkReadme → symlinkFile, use for boot.yml and keyrack.yml symlinks

### citation [7]: src/domain.operations/invoke/link/symlinkReadme.ts:8-43

```ts
// rename to symlinkFile — more accurate name for generic single-file symlink
export const symlinkFile = (input: {
  sourcePath: string;
  targetPath: string;
}): { status: 'created' | 'updated' } => {
  const { sourcePath, targetPath } = input;

  // expand to absolute paths
  const sourceAbsolute = expand(process.cwd(), sourcePath);
  const targetAbsolute = expand(process.cwd(), targetPath);

  // check if target already present (lstatSync detects broken symlinks, existsSync does not)
  const hadTargetBefore = (() => {
    try {
      lstatSync(targetAbsolute);
      return true;
    } catch {
      return false;
    }
  })();

  // remove prior target if present (handles both files and broken symlinks)
  if (hadTargetBefore) {
    try {
      unlinkSync(targetAbsolute);
    } catch {
      rmSync(targetAbsolute, { force: true });
    }
  }

  // create relative symlink from target directory to source file
  const targetDir = expand(targetAbsolute, '..');
  const relativeSource = relative(targetDir, sourceAbsolute);
  symlinkSync(relativeSource, targetAbsolute, 'file');

  return { status: hadTargetBefore ? 'updated' : 'created' };
};
```

### relation to wish

symlinkReadme is a generic single-file symlink utility with an inaccurate name. rename to symlinkFile for accuracy, then reuse for boot.yml and keyrack.yml.

---

## pattern.6 = daoKeyrackRepoManifest (keyrack.yml parsing)

**[EXTEND]** — add `extends` field to schema and hydration

### citation [8]: src/access/daos/daoKeyrackRepoManifest/schema.ts:18-50

```ts
export const schemaKeyrackRepoManifest = z
  .object({
    org: z.string(),
  })
  .catchall(z.unknown())
  .refine(
    (data) => {
      // reject flat keys: format
      if ('keys' in data) return false;
      return true;
    },
    {
      message:
        'flat keys: format is no longer supported; use org + env.* sections instead',
    },
  )
  // note: env.* sections are optional — a fresh manifest may only have org
  // env.* sections are added as keys are set (except sudo which never appears here)
  .refine(
    (data) => {
      // env.all requires at least one env-specific section
      const hasEnvAll = 'env.all' in data;
      const envSpecific = Object.keys(data).filter(
        (k) => k.startsWith('env.') && k !== 'env.all',
      );
      if (hasEnvAll && envSpecific.length === 0) return false;
      return true;
    },
    {
      message:
        'env.all requires at least one env-specific section (e.g., env.prod)',
    },
  );
```

### citation [9]: src/access/daos/daoKeyrackRepoManifest/index.ts:101-106

```ts
    // hydrate domain objects from env-scoped sections
    const org = result.data.org;
    const envSections = Object.keys(result.data)
      .filter((k) => k.startsWith('env.') && k !== 'env.all')
      .map((k) => k.slice(4));
    const keys: Record<string, KeyrackKeySpec> = {};
```

### relation to wish

schema lacks `extends` field. need to add:
- `extends?: string[]` — array of paths to extended keyrack.yml files

hydration needs to:
1. parse `extends` array
2. load each extended keyrack.yml
3. merge keys (later extends override earlier, root overrides all)
4. detect circular extends

---

## pattern.7 = getKeyrackKeyGrant (key lookup)

**[EXTEND]** — key lookup should use merged manifest from extends

### citation [10]: src/domain.operations/keyrack/getKeyrackKeyGrant.ts:158-175

```ts
export async function getKeyrackKeyGrant(
  input: { for: { repo: true }; env?: string; slugs: string[] },
  context: ContextKeyrackGrantGet,
): Promise<KeyrackGrantAttempt[]>;
export async function getKeyrackKeyGrant(
  input: { for: { key: string } },
  context: ContextKeyrackGrantGet,
): Promise<KeyrackGrantAttempt>;
export async function getKeyrackKeyGrant(
  input:
    | { for: { repo: true }; env?: string; slugs: string[] }
    | { for: { key: string } },
  context: ContextKeyrackGrantGet,
): Promise<KeyrackGrantAttempt | KeyrackGrantAttempt[]> {
  // handle single key grant
  if ('key' in input.for) {
    return attemptGrantKey({ slug: input.for.key }, context);
  }
```

### relation to wish

key grant lookup uses slug directly. the slug lookup should work against the merged manifest (including extended keyracks).

---

## pattern.8 = KeyrackRepoManifest domain object

**[EXTEND]** — may need to track extends chain for debugging

### citation [11]: src/domain.objects/keyrack/KeyrackRepoManifest.ts:11-31

```ts
export interface KeyrackRepoManifest {
  /**
   * .what = org name that owns this keyrack
   * .why = org prefix in slugs isolates credentials across orgs
   * .example = 'ehmpathy', 'ahbode'
   */
  org: string;

  /**
   * .what = declared env names derived from env.* sections (except env.all)
   * .why = enables --env validation and error messages that list available envs
   * .example = ['prod', 'prep']
   */
  envs: string[];

  /**
   * .what = map of key slug ($org.$env.$key) to key spec
   * .why = enables lookup by slug for grant operations
   */
  keys: Record<string, KeyrackKeySpec>;
}
```

### relation to wish

KeyrackRepoManifest tracks `org`, `envs`, and `keys`. may need to add:
- `extends?: string[]` — for debugging/error messages about which extended keyrack a key came from

---

## summary

| pattern | file | action | change |
|---------|------|--------|--------|
| Role type | Role.ts | EXTEND | add `boot?: { uri }`, `keyrack?: { uri }` |
| RoleManifest type | RoleManifest.ts | EXTEND | add `keyrack?: { uri }` |
| castIntoRoleRegistryManifest | castIntoRoleRegistryManifest.ts | EXTEND | serialize boot + keyrack |
| execRoleLink | execRoleLink.ts | EXTEND | symlink boot.yml + keyrack.yml |
| symlinkFile | symlinkReadme.ts → symlinkFile.ts | RENAME + REUSE | rename, use for boot/keyrack symlinks |
| keyrack schema | daoKeyrackRepoManifest/schema.ts | EXTEND | add `extends?: string[]` |
| keyrack dao | daoKeyrackRepoManifest/index.ts | EXTEND | load + merge extends chain |
| getKeyrackKeyGrant | getKeyrackKeyGrant.ts | REUSE | already uses merged manifest |
| KeyrackRepoManifest | KeyrackRepoManifest.ts | EXTEND | optional `extends` for debug |
