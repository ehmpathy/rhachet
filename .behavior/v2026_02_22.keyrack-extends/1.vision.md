# vision: keyrack extends

## the outcome world

### before

a mechanic skill needs `EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN` to push commits and open prs.

**today's reality:**
- every repo that uses `mechanic` must manually declare that key in its `.agent/keyrack.yml`
- repo maintainers don't know which keys the role needs until skills fail
- key specs are copy-pasted across repos, drift happens, trust is implicit

```yaml
# .agent/keyrack.yml (every repo, manually maintained)
org: myorg
env.prod:
  - EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN  # how did i know to add this?
```

### after

roles declare their key requirements. repos explicitly extend them.

```yaml
# .agent/repo=ehmpathy/role=mechanic/keyrack.yml (linked from role)
keys:
  EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN:
    description: github token for seaturtle[bot] pr operations
    source: 1password
    vault: ehmpathy-prod
    item: seaturtle-bot-github-token
```

```yaml
# .agent/keyrack.yml (repo root)
org: myorg
extends:
  - .agent/repo=ehmpathy/role=mechanic/keyrack.yml
env.prod:
  - MY_REPO_SPECIFIC_KEY
```

**the aha moment:** run `rhachet keyrack get --key EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN` and it just works — found via the extended role keyrack. no manual declaration, no copy-paste, no drift.

### day-in-the-life

**role author (ehmpathy):**
1. runs `rhachet keyrack init --at src/domain.roles/mechanic/keyrack.yml` to create role keyrack
2. adds keys via `rhachet keyrack set --key GITHUB_TOKEN --vault os.secure --at src/domain.roles/mechanic/keyrack.yml`
3. publishes role — keyrack.yml gets built to dist, symlinked on `roles link`

**repo maintainer (consumer):**
1. runs `rhachet init --roles mechanic` or `rhachet roles link --role mechanic`
2. `.agent/repo=ehmpathy/role=mechanic/keyrack.yml` appears (symlinked)
3. adds `extends:` to root keyrack — explicit opt-in to trust that role's keys
4. skills that need those keys now find them automatically

**developer using skills:**
1. invokes `git.commit.push` skill
2. skill calls `rhachet keyrack get --key EHMPATHY_SEATURTLE_PROD_GITHUB_TOKEN`
3. keyrack looks up extends chain → finds spec in role keyrack → unlocks from vault
4. skill succeeds

---

## user experience

### usecases

| actor | goal | contract |
|-------|------|----------|
| role author | create keyrack for my role | `keyrack init --at $path` |
| role author | add key to role keyrack | `keyrack set --key $KEY --at $path` |
| role author | publish keyrack with role | `Role.keyrack: { uri: string }` in definition |
| repo maintainer | trust a role's key declarations | `extends:` in root keyrack.yml |
| developer | fetch a key declared by role | `keyrack get --key $KEY` |

### contract inputs & outputs

#### role definition (role author)

```ts
// src/domain.roles/mechanic/index.ts
export const mechanic = Role.typed({
  slug: 'mechanic',
  // ... current fields ...
  boot: { uri: 'src/domain.roles/mechanic/boot.yml' },        // NEW (add to Role type)
  keyrack: { uri: 'src/domain.roles/mechanic/keyrack.yml' },  // NEW (add to Role type)
});
```

#### repo introspect (role author)

both `boot` and `keyrack` are published in `rhachet.repo.yml`:

```yaml
# rhachet.repo.yml (generated by repo introspect)
slug: ehmpathy
readme: readme.md
roles:
  - slug: mechanic
    readme: src/domain.roles/mechanic/readme.md
    briefs:
      dirs: src/domain.roles/mechanic/briefs
    skills:
      dirs: src/domain.roles/mechanic/skills
    boot: src/domain.roles/mechanic/boot.yml      # NEW
    keyrack: src/domain.roles/mechanic/keyrack.yml # NEW
```

this enables `roles link` to symlink both files into `.agent/`.

#### keyrack init (role author)

```bash
# create role keyrack at specified path
rhachet keyrack init --at src/domain.roles/mechanic/keyrack.yml
```

creates keyrack.yml at the specified path (same as default init, different location).

#### keyrack set --at (role author)

```bash
# add key to role keyrack at specified path
rhachet keyrack set --key GITHUB_TOKEN --vault os.secure --at src/domain.roles/mechanic/keyrack.yml
```

adds key declaration to the keyrack at the specified path. enables role authors to populate role keyracks without manual yaml edits.

#### keyrack.yml extends (repo maintainer)

```yaml
# .agent/keyrack.yml
org: myorg
extends:
  - .agent/repo=ehmpathy/role=mechanic/keyrack.yml
  - .agent/repo=bhuild/role=behaver/keyrack.yml
env.prod:
  - MY_LOCAL_KEY
```

semantics:
- extends paths are computed relative to repo root
- keys from extended keyracks are merged into this manifest
- local keys override extended keys (same slug)
- order matters for conflict handling (last wins)

#### roles link (automatic)

```bash
rhachet roles link --role mechanic
```

creates symlink:
```
.agent/repo=ehmpathy/role=mechanic/keyrack.yml → node_modules/rhachet-roles-ehmpathy/dist/roles/mechanic/keyrack.yml
```

### timeline

```
role author                              repo maintainer                        developer
-----------                              ---------------                        ---------
create keyrack.yml in role

keyrack init --at ...
  ✓ validates schema
  ✓ prepares for build

publish role package
                                         npm install rhachet-roles-ehmpathy

                                         rhachet init --roles mechanic
                                           → links keyrack.yml

                                         add extends: to root keyrack
                                           → explicit trust grant
                                                                                invoke skill
                                                                                  → keyrack get finds key
                                                                                  → key unlocked
                                                                                  → skill succeeds
```

---

## mental model

### how users describe it to a friend

> "roles can declare what keys their skills need. when you use a role, you add its keyrack to your extends list, and those keys become available. it's like... roles bring their own key requirements, and you opt-in to trusting them."

### analogies

| analogy | maps to |
|---------|---------|
| npm peer dependencies | roles declare key requirements, consumers satisfy them |
| terraform providers | roles provide key specs, consumers configure credentials |
| class inheritance | child keyrack extends parent keyracks, adds local keys |
| css cascade | extended keyracks merge, local definitions override |

### terms

| user term | our term | meaning |
|-----------|----------|---------|
| "role keyrack" | role keyrack manifest | keyrack.yml bundled with a role |
| "repo keyrack" | root keyrack manifest | .agent/keyrack.yml at repo root |
| "extends" | keyrack extends | inheritance chain from root to role keyracks |
| "key requirement" | KeyrackKeySpec | declaration of a key a role needs |

---

## evaluation

### how well does it satisfy the goals?

| goal | solution | effectiveness |
|------|----------|---------------|
| roles declare key needs | `Role.keyrack` + role keyrack.yml | ✓ explicit, versioned |
| keys linked on `roles link` | symlink like boot.yml | ✓ consistent pattern |
| explicit trust model | `extends:` in root keyrack | ✓ opt-in, auditable |
| key lookup | merge extended + local | ✓ predictable |

### pros

- **explicit trust**: repo owner decides which role keyracks to trust
- **declarative**: roles declare requirements, repos satisfy them
- **composable**: multiple roles' keyracks can be extended
- **consistent**: follows current patterns (boot.yml, briefs/skills linking)
- **auditable**: extends list shows exactly what's trusted
- **versionable**: role keyrack updates ship with role package updates

### cons

- **indirection**: key lookup requires traversing extends chain
- **merge complexity**: conflict handling rules need clear docs
- **circular extends**: need to detect and error on circular extends

### edge cases & pit of success

| edge case | pit of success approach |
|-----------|------------------------|
| circular extends | detect at parse time, fail fast with clear error |
| absent extended file | fail fast: "extended keyrack not found: $path" |
| key slug conflict | last-wins: "key $slug overridden by $path" |
| extends non-extant role | roles link fails first, so extends path won't exist |
| org mismatch | root org is authoritative, ignore extended org |
| recursive extends depth | closer extends override deeper; root wins over all |
| deep extends chain | reasonable max depth (e.g., 10 levels) to prevent runaway |

### open questions

1. **should extends support globs?** e.g., `.agent/repo=*/role=*/keyrack.yml`
   - no: explicit paths are more auditable

2. **should keyrack.yml be optional for roles?**
   - yes: many roles don't need keys; Role.keyrack is optional

3. **should extends be recursive?** role keyrack A extends B?
   - yes: role keyracks may extend shared base keyracks
   - merge semantics: closer extends override deeper extends; root wins over all
   - circular detection required: fail fast with clear error

---

---

## implementation scope

### changes required

| component | change |
|-----------|--------|
| `Role` type | add `boot?: { uri: string }` and `keyrack?: { uri: string }` |
| `RoleManifest` type | add `keyrack?: { uri: string }` (boot already present) |
| `castIntoRoleRegistryManifest` | include `boot` and `keyrack` in yaml output |
| `execRoleLink` | symlink `boot.yml` and `keyrack.yml` if declared |
| keyrack yaml schema | add `extends: string[]` field |
| keyrack get | traverse extends chain to find key specs |
| `keyrack init --at` | validate role-level keyrack.yml schema |
| `keyrack set --at` | write key to keyrack at custom path |

### acceptance tests

- `roles link` symlinks `keyrack.yml` from role
- `keyrack get` finds keys from extended role keyracks
- `keyrack init --at` validates role keyrack schema
- `keyrack set --at` writes key to keyrack at custom path
- `repo introspect` includes boot and keyrack in manifest

---

## summary

keyrack extends enables:
- role authors declare key requirements alongside skills
- repo maintainers explicitly opt-in to trust role keyracks
- developers use skills without manual key declaration

the pattern mirrors current conventions:
- `Role.boot: { uri }` and `Role.keyrack: { uri }` alongside `Role.briefs`, `Role.skills`
- both symlinked on `roles link`
- both published via `repo introspect`
- keyrack looked up through extends chain like css cascade

explicit trust via extends ensures repo owners control which keys are available.
