# blueprint: keyrack extends

## overview

enable roles to declare key requirements via `Role.keyrack: { uri }` and `Role.boot: { uri }`, symlink them on `roles link`, publish them via `repo introspect`, support `extends:` in keyrack.yml for inheritance chains, and support `keyrack set --at` to add keys to role-level keyracks.

---

## filediff treestruct

```
src/
  domain.objects/
    [~] Role.ts                                    # add boot?: { uri }, keyrack?: { uri }
    [~] RoleManifest.ts                            # add keyrack?: { uri }
    [~] keyrack/KeyrackRepoManifest.ts             # add extends?: string[] for debug
  domain.operations/
    manifest/
      [~] castIntoRoleRegistryManifest.ts          # serialize boot + keyrack paths
    invoke/link/
      [~] execRoleLink.ts                          # symlink boot.yml + keyrack.yml
      [R] symlinkReadme.ts → symlinkFile.ts        # rename: generic single-file symlink
    keyrack/
      [~] init.ts                                  # add --at $path support
      [+] init.integration.test.ts                 # integration tests: --at $path creates file
      [~] setKeyrackKey.ts                         # add at?: string for custom keyrack path
      [~] setKeyrackKeyHost.ts                     # pass at to dao for custom keyrack write
  contract/cli/
    [~] invokeKeyrack.ts                           # add --at option to set command
  access/daos/
    daoKeyrackRepoManifest/
      [~] schema.ts                                # add extends?: string[] to schema
      [~] index.ts                                 # delegate to hydrate; add at?: to findsertKeyToEnv
      [~] index.integration.test.ts                # test extends parse; test --at path
      hydrate/                                     # NEW: hydration subdirectory
        [+] hydrateKeyrackRepoManifest.ts          # main hydration logic
        [+] hydrateKeyrackRepoManifest.test.ts     # unit tests for hydration + merge
        [+] loadManifestHydrated.ts                # recursive load with extends resolution
        [+] loadManifestHydrated.test.ts           # unit tests for hydrated load
        [+] loadManifestExplicit.ts                # raw load without extends resolution
        [+] loadManifestExplicit.test.ts           # unit tests for explicit load

blackbox/
  .test/
    assets/
      [+] with-keyrack-extends/                    # root keyrack with extends
      [+] with-role-keyrack/                       # role with keyrack declaration
      [+] with-role-boot-keyrack/                  # role with both boot + keyrack
      [+] with-circular-extends/                   # circular extends for error test
      [+] with-recursive-extends/                  # deep extends chain
  cli/
    [~] roles.link.acceptance.test.ts              # add boot.yml + keyrack.yml tests
    [~] repo.introspect.acceptance.test.ts         # add boot + keyrack in yml tests
    [+] keyrack.extends.acceptance.test.ts         # extends chain acceptance tests
    [+] keyrack.init.acceptance.test.ts            # keyrack init --at acceptance tests
    [~] keyrack.set.acceptance.test.ts             # add --at tests for custom keyrack path
```

---

## codepath treestruct

### domain.objects

```
Role
  [○] slug: string
  [○] readme: { uri: string }
  [○] briefs: { dirs: ... }
  [○] skills: { dirs: ..., refs: ... }
  [○] inits?: { dirs?: ..., exec?: ... }
  [○] hooks?: RoleHooks
  [+] boot?: { uri: string }                       # NEW: path to boot.yml
  [+] keyrack?: { uri: string }                    # NEW: path to keyrack.yml

RoleManifest
  [○] slug: string
  [○] readme: { uri: string }
  [○] briefs: { dirs: ... }
  [○] skills: { dirs: ... }
  [○] inits?: { dirs?: ..., exec?: ... }
  [○] boot?: { uri: string }                       # already present
  [+] keyrack?: { uri: string }                    # NEW: add keyrack

KeyrackRepoManifest
  [○] org: string
  [○] envs: string[]
  [○] keys: Record<string, KeyrackKeySpec>
  [+] extends?: string[]                           # NEW: for debug/error context
```

### domain.operations/manifest

```
castIntoRoleRegistryManifest
  [○] build base manifest with slug, readme, briefs, skills
  [○] add inits if present
  [+] add boot if present                          # NEW: serialize boot path
  [+] add keyrack if present                       # NEW: serialize keyrack path

RoleManifestSerializable (internal interface)
  [○] slug, readme, briefs, skills, inits
  [+] boot?: string                                # NEW
  [+] keyrack?: string                             # NEW
```

### domain.operations/invoke/link

```
execRoleLink
  [○] symlink briefs directories
  [○] symlink skills directories
  [○] symlink inits directories
  [○] symlink readme.md via symlinkFile
  [+] symlink boot.yml if role.boot?.uri           # NEW: use symlinkFile
  [+] symlink keyrack.yml if role.keyrack?.uri     # NEW: use symlinkFile

symlinkFile (renamed from symlinkReadme)
  [R] rename symlinkReadme.ts → symlinkFile.ts     # more accurate name
  [←] reuse for readme.md, boot.yml, keyrack.yml   # generic single-file symlink
```

### domain.operations/keyrack

```
init (extend for --at)
  [○] init keyrack at default path
  [~] add --at $path option for role-level keyracks
  [+] create keyrack file at specified path

setKeyrackKey (extend for --at)
  [○] compute target slugs based on env
  [○] delegate to setKeyrackKeyHost for each slug
  [~] pass at?: string to setKeyrackKeyHost

setKeyrackKeyHost (extend for --at)
  [○] expand org from manifest
  [○] store secret in vault
  [○] update host manifest
  [~] write to custom keyrack path if at provided
  [~] read org from custom keyrack if at provided
```

### contract/cli

```
invokeKeyrack (keyrack set --at)
  [○] keyrack set command with --key, --vault, --env, --org
  [+] add --at option for custom keyrack path
  [~] pass at to setKeyrackKey
  [~] read org from custom keyrack when --at provided
```

### access/daos/daoKeyrackRepoManifest

```
schema.ts
  [○] org: z.string()
  [○] .catchall(z.unknown())
  [○] .refine() validators
  [+] extends?: z.array(z.string()).optional()     # NEW: add extends field

index.ts
  [○] getPath, init, get, set, del
  [~] get: delegate to hydrate/ after yaml parse + schema validate
  [~] set.findsertKeyToEnv: add at?: string for custom keyrack path

hydrate/ (NEW — subdirectory for hydration logic)
  hydrateKeyrackRepoManifest.ts
    [+] input: { parsed, manifestPath, visited? }, context: { gitroot }
    [+] parse org from parsed data
    [+] extract env sections
    [+] build keys record
    [+] if extends present:
    [+]   load each extended manifest via loadManifestHydrated
    [+]   detect circular extends via visited set
    [+]   merge keys (last wins, root wins)
    [+] return KeyrackRepoManifest with extends for debug context

  loadManifestHydrated.ts
    [+] input: { path, visited }, context: { gitroot }
    [+] read yaml file at path
    [+] parse with schema
    [+] call hydrateKeyrackRepoManifest recursively
    [+] returns fully hydrated manifest (extends resolved)

  loadManifestExplicit.ts
    [+] input: { path }, context: { gitroot }
    [+] read yaml file at path
    [+] parse with schema
    [+] return raw parsed manifest (no extends resolution)
    [+] use for: validation, inspection, keyrack init --at
```

---

## contracts

### Role type extension

```ts
// src/domain.objects/Role.ts
export interface Role {
  // ... prior fields ...

  /**
   * .what = boot configuration for this role
   * .why = enables role authors to declare boot.yml for brain initialization
   */
  boot?: { uri: string };

  /**
   * .what = keyrack manifest for this role
   * .why = enables role authors to declare key requirements for skills
   */
  keyrack?: { uri: string };
}
```

### keyrack.yml extends schema

```yaml
# .agent/keyrack.yml
org: myorg
extends:
  - .agent/repo=ehmpathy/role=mechanic/keyrack.yml
  - .agent/repo=bhuild/role=behaver/keyrack.yml
env.prod:
  - MY_LOCAL_KEY
```

### hydrate contract

```ts
// src/access/daos/daoKeyrackRepoManifest/hydrate/hydrateKeyrackRepoManifest.ts

/**
 * .what = hydrates KeyrackRepoManifest from parsed schema, with extends resolution
 * .why = centralizes hydration logic with recursive extends traversal
 */
export const hydrateKeyrackRepoManifest = async (
  input: {
    parsed: SchemaOutput;
    manifestPath: string;
    visited?: Set<string>;  // for circular detection
  },
  context: {
    gitroot: string;
  },
): Promise<KeyrackRepoManifest> => {
  // parse org, env sections, keys from parsed data
  // if extends present:
  //   check for circular reference (fail if manifestPath in visited)
  //   for each path in extends:
  //     load extended manifest via loadManifestHydrated
  //     merge keys (later wins)
  //   apply root keys last (root wins over all)
  // return merged manifest with extends for debug
};
```

```ts
// src/access/daos/daoKeyrackRepoManifest/hydrate/loadManifestHydrated.ts

/**
 * .what = loads keyrack manifest from file path with full extends resolution
 * .why = entry point for recursive extends loading; wraps file I/O + hydration
 */
export const loadManifestHydrated = async (
  input: { path: string; visited: Set<string> },
  context: { gitroot: string },
): Promise<KeyrackRepoManifest> => {
  // read yaml file at input.path
  // parse with schema
  // call hydrateKeyrackRepoManifest with parsed data
};
```

```ts
// src/access/daos/daoKeyrackRepoManifest/hydrate/loadManifestExplicit.ts

/**
 * .what = loads keyrack manifest from file path without extends resolution
 * .why = raw access for validation, inspection, keyrack init --at
 */
export const loadManifestExplicit = async (
  input: { path: string },
  context: { gitroot: string },
): Promise<KeyrackRepoManifestExplicit> => {
  // read yaml file at input.path
  // parse with schema
  // return raw parsed manifest (no extends traversal)
};
```

### keyrack set --at contract

```ts
// src/contract/cli/invokeKeyrack.ts (keyrack set command)
keyrack
  .command('set')
  // ... prior options ...
  .option(
    '--at <path>',
    'custom keyrack.yml path (for role-level keyracks)',
  )
```

```ts
// src/domain.operations/keyrack/setKeyrackKey.ts
export const setKeyrackKey = async (
  input: {
    // ... prior fields ...
    at?: string;  // NEW: custom keyrack path
  },
  context: KeyrackHostContext,
): Promise<{ results: KeyrackKeyHost[] }>;
```

```ts
// src/access/daos/daoKeyrackRepoManifest/index.ts
set: {
  findsertKeyToEnv: async (input: {
    gitroot: string;
    key: string;
    env: string;
    at?: string;  // NEW: custom keyrack path (overrides default .agent/keyrack.yml)
  }): Promise<void>;
}
```

### merge semantics

| scenario | result |
|----------|--------|
| key in root only | use root |
| key in extended only | use extended |
| key in root + extended | root wins |
| key in pathA + pathB | pathB wins (last-wins) |
| recursive: root → A → B | closer wins (A over B), root wins over all |

---

## test coverage

### unit tests

| file | coverage |
|------|----------|
| `daoKeyrackRepoManifest/hydrate/hydrateKeyrackRepoManifest.test.ts` | hydration, merge logic, circular detection |
| `daoKeyrackRepoManifest/hydrate/loadManifestHydrated.test.ts` | recursive load with extends resolution |
| `daoKeyrackRepoManifest/hydrate/loadManifestExplicit.test.ts` | raw load without extends resolution |

### integration tests

| file | coverage |
|------|----------|
| `daoKeyrackRepoManifest/index.integration.test.ts` | extends field parse, key merge, recursive load, --at path |
| `execRoleLink.integration.test.ts` | boot.yml + keyrack.yml symlinks |
| `keyrack/init.integration.test.ts` | keyrack init --at creates file at specified path |
| `keyrack/setKeyrackKeyHost.integration.test.ts` | keyrack set --at writes to custom path |

### acceptance tests

| file | coverage |
|------|----------|
| `roles.link.acceptance.test.ts` | usecase.2, usecase.5 |
| `repo.introspect.acceptance.test.ts` | usecase.1, usecase.5 |
| `keyrack.extends.acceptance.test.ts` | usecase.3, usecase.4, usecase.7-10 |
| `keyrack.init.acceptance.test.ts` | usecase.6 (--at creates keyrack at path) |
| `keyrack.set.acceptance.test.ts` | usecase.11 (--at writes key to custom path) |

### usecase → test map

| usecase | test file | scenarios |
|---------|-----------|-----------|
| usecase.1 = role author publishes role with keyrack | repo.introspect.acceptance.test.ts | keyrack in yml |
| usecase.2 = repo maintainer links role keyrack | roles.link.acceptance.test.ts | keyrack.yml symlink |
| usecase.3 = repo maintainer extends role keyrack | keyrack.extends.acceptance.test.ts | key lookup via extends |
| usecase.4 = extends path validation | keyrack.extends.acceptance.test.ts | invalid path error |
| usecase.5 = role author links boot.yml | roles.link.acceptance.test.ts | boot.yml symlink |
| usecase.6 = keyrack init --at | keyrack.init.acceptance.test.ts | --at creates file at specified path |
| usecase.7 = extends merges key specs | keyrack.extends.acceptance.test.ts | full spec inheritance |
| usecase.8 = extends order semantics | keyrack.extends.acceptance.test.ts | last-wins, root wins |
| usecase.9 = circular extends detection | keyrack.extends.acceptance.test.ts | error message |
| usecase.10 = recursive extends support | keyrack.extends.acceptance.test.ts | deep key lookup |
| usecase.11 = keyrack set --at | keyrack.set.acceptance.test.ts | --at writes to custom keyrack |

---

## fixtures

### with-role-keyrack

simulates a consumer repo after `roles link` with a role that declares keyrack only (no boot).

```
with-role-keyrack/
  .agent/
    repo=test-repo/
      role=tester/
        readme.md
        keyrack.yml                # role keyrack manifest (no boot)
        briefs/
          sample-brief.md
        skills/
          say-hello.sh
```

**role keyrack.yml:**
```yaml
org: testorg
env.test:
  - ROLE_ONLY_KEY
```

### with-role-boot-keyrack

simulates a consumer repo after `roles link` with a role that declares both boot and keyrack.

```
with-role-boot-keyrack/
  .agent/
    repo=test-repo/
      role=tester/
        readme.md
        boot.yml                   # role boot config
        keyrack.yml                # role keyrack manifest
        briefs/
          sample-brief.md
        skills/
          say-hello.sh
```

**note:** no rhachet.use.ts or rhachet.repo.yml — those are for role suppliers, not consumers. test fixtures simulate post-link state.

### with-keyrack-extends

```
with-keyrack-extends/
  .agent/
    keyrack.yml                  # root with extends
    repo=test-repo/
      role=tester/
        keyrack.yml              # role keyrack to extend
```

**root keyrack.yml:**
```yaml
org: testorg
extends:
  - .agent/repo=test-repo/role=tester/keyrack.yml
env.test:
  - LOCAL_KEY
```

**role keyrack.yml:**
```yaml
org: testorg
env.test:
  - ROLE_KEY
```

### with-circular-extends

```
with-circular-extends/
  .agent/
    keyrack.yml                  # extends pathA
    pathA/
      keyrack.yml                # extends pathB
    pathB/
      keyrack.yml                # extends pathA (circular!)
```

### with-recursive-extends

```
with-recursive-extends/
  .agent/
    keyrack.yml                  # extends pathA
    pathA/
      keyrack.yml                # extends pathB
    pathB/
      keyrack.yml                # has DEEP_KEY
```

---

## execution phases

### phase 1: domain.objects updates
1. extend Role type with `boot?: { uri }` and `keyrack?: { uri }`
2. extend RoleManifest type with `keyrack?: { uri }`
3. extend KeyrackRepoManifest with `extends?: string[]`

### phase 2: repo introspect (castIntoRoleRegistryManifest)
1. extend RoleManifestSerializable with boot and keyrack
2. serialize boot path if present
3. serialize keyrack path if present
4. add acceptance tests for boot + keyrack in yml

### phase 3: roles link (execRoleLink)
1. rename symlinkReadme.ts → symlinkFile.ts (more accurate name)
2. update execRoleLink imports to use symlinkFile
3. symlink boot.yml if role.boot?.uri present
4. symlink keyrack.yml if role.keyrack?.uri present
5. add integration + acceptance tests

### phase 4: keyrack extends (daoKeyrackRepoManifest)
1. add extends field to keyrack schema
2. extract hydrate.ts from index.ts
3. implement extends load in hydrate.ts with recursive traversal
4. implement merge logic (last-wins, root-wins)
5. implement circular detection via visited set
6. update index.ts get to use hydrate
7. add unit + integration + acceptance tests

### phase 5: keyrack init --at
1. update keyrack init to accept --at $path
2. create keyrack file at specified path (same as default init, different location)
3. add acceptance tests for --at flag

### phase 6: keyrack set --at
1. add --at option to `keyrack set` CLI command
2. update `daoKeyrackRepoManifest.set.findsertKeyToEnv` to accept `at?: string`
3. update `setKeyrackKeyHost` to pass `at` to dao
4. update `setKeyrackKey` to pass `at` through
5. read org from custom keyrack when --at provided
6. add integration + acceptance tests

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| circular extends infinite loop | track visited paths, fail fast on cycle |
| deep extends chain performance | reasonable depth (e.g., max 10 levels) |
| extends path not found | clear error: "extended keyrack not found: $path" |
| org mismatch in extended keyrack | root org is authoritative, ignore extended org |
| merge order confusion | document: last-wins for extends array, root wins over all |
