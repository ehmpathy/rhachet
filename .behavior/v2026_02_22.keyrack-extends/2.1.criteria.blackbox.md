# blackbox criteria: keyrack extends

## usecase.1 = role author publishes role with keyrack

```
given(role author has a role with key requirements)
  when(role definition includes keyrack: { uri })
    then(repo introspect includes keyrack path in rhachet.repo.yml)
      sothat(consumers can link the keyrack on roles link)

given(role author wants keyrack for their role)
  when(keyrack init --at src/domain.roles/mechanic/keyrack.yml)
    then(creates keyrack.yml at specified path)
      sothat(role author can add key specs for role's skills)
```

## usecase.2 = repo maintainer links role keyrack

```
given(consumer repo with rhachet-roles-* package installed)
  given(role declares keyrack: { uri } in its definition)
    when(rhachet roles link --role mechanic)
      then(.agent/repo=$slug/role=$role/keyrack.yml symlink is created)
      then(symlink points to node_modules/.../keyrack.yml)
        sothat(repo can extend the role keyrack)

given(consumer repo with rhachet-roles-* package installed)
  given(role does NOT declare keyrack)
    when(rhachet roles link --role mechanic)
      then(no keyrack.yml symlink is created)
      then(link operation still succeeds)
        sothat(keyrack is optional for roles)
```

## usecase.3 = repo maintainer extends role keyrack

```
given(root keyrack.yml with extends: [.agent/repo=ehmpathy/role=mechanic/keyrack.yml])
  given(extended keyrack.yml declares key ROLE_KEY)
    when(keyrack get --key ROLE_KEY)
      then(returns key spec from extended keyrack)
        sothat(keys from role keyracks are available)

given(root keyrack.yml with extends: [...])
  given(root keyrack also declares key LOCAL_KEY)
    when(keyrack get --key LOCAL_KEY)
      then(returns key spec from root keyrack)
        sothat(local keys still work)

given(root keyrack.yml with extends: [...])
  given(both root and extended keyrack declare same key SHARED_KEY)
    when(keyrack get --key SHARED_KEY)
      then(returns key spec from root keyrack)
        sothat(local keys override extended keys)
```

## usecase.4 = extends path validation

```
given(root keyrack.yml with extends: [.agent/repo=foo/role=bar/keyrack.yml])
  given(extended path does not exist)
    when(keyrack get --key ANY_KEY)
      then(exits non-zero)
      then(error message includes "extended keyrack not found: $path")
        sothat(user knows which extends path is broken)

given(root keyrack.yml with extends: [pathA, pathB])
  given(pathA declares KEY_A, pathB declares KEY_B)
    when(keyrack get --key KEY_A)
      then(returns key spec from pathA)
    when(keyrack get --key KEY_B)
      then(returns key spec from pathB)
        sothat(multiple extends paths are supported)
```

## usecase.5 = role author links boot.yml (parity)

```
given(role definition includes boot: { uri })
  when(repo introspect)
    then(rhachet.repo.yml includes boot path for that role)
      sothat(boot.yml is published alongside keyrack.yml)

given(consumer repo with role that declares boot: { uri })
  when(rhachet roles link --role mechanic)
    then(.agent/repo=$slug/role=$role/boot.yml symlink is created)
      sothat(boot.yml is linked like keyrack.yml)
```

## usecase.6 = keyrack init --at

```
given(no keyrack exists at target path)
  when(keyrack init --at src/domain.roles/mechanic/keyrack.yml)
    then(creates keyrack.yml at specified path)
    then(same behavior as default init, different location)
      sothat(role author can create role-level keyracks)
```

## usecase.7 = extends merges key specs

```
given(extended keyrack has keys: { GITHUB_TOKEN: { source: 1password, vault: prod, item: bot-token } })
  when(root keyrack extends it)
    when(keyrack get --key GITHUB_TOKEN --json)
      then(output includes source, vault, item from extended spec)
        sothat(full key spec is inherited)

given(extended keyrack has org: ehmpathy)
  given(root keyrack has org: myorg)
    when(keyrack get --key EXTENDED_KEY)
      then(key slug uses root org prefix)
        sothat(org is not inherited from extended keyrack)
```

## usecase.8 = extends order semantics

```
given(root keyrack with extends: [pathA, pathB])
  given(pathA declares KEY_X)
  given(pathB declares KEY_X)
    when(keyrack get --key KEY_X)
      then(returns key spec from pathB)
        sothat(later extends override earlier extends â€” last wins)

given(root keyrack with extends: [pathA, pathB])
  given(root keyrack declares KEY_X)
  given(pathB declares KEY_X)
    when(keyrack get --key KEY_X)
      then(returns key spec from root)
        sothat(root always wins over any extended)
```

## usecase.9 = circular extends detection

```
given(root keyrack with extends: [pathA])
  given(pathA has extends: [pathB])
  given(pathB has extends: [pathA])
    when(keyrack get --key ANY_KEY)
      then(exits non-zero)
      then(error message includes "circular extends detected")
        sothat(user knows the extends chain is invalid)

given(root keyrack with extends: [pathA])
  given(pathA has extends: [root keyrack path])
    when(keyrack get --key ANY_KEY)
      then(exits non-zero)
      then(error message includes "circular extends detected")
        sothat(self-referential extends are caught)
```

## usecase.10 = recursive extends support

```
given(root keyrack with extends: [pathA])
  given(pathA has extends: [pathB])
  given(pathB declares KEY_DEEP)
    when(keyrack get --key KEY_DEEP)
      then(returns key spec from pathB)
        sothat(extends chains are followed recursively)

given(root keyrack with extends: [pathA])
  given(pathA has extends: [pathB])
  given(pathA declares KEY_A)
  given(pathB declares KEY_A)
    when(keyrack get --key KEY_A)
      then(returns key spec from pathA)
        sothat(closer extends override deeper extends)
```

## usecase.11 = keyrack set --at

```
given(keyrack.yml exists at custom path)
  when(keyrack set --key MY_KEY --vault os.secure --env prod --at $custom_path)
    then(key is added to env.prod section of keyrack at $custom_path)
    then(root .agent/keyrack.yml is NOT modified)
      sothat(role authors can add keys to role keyracks)

given(keyrack.yml does not exist at custom path)
  when(keyrack set --key MY_KEY --vault os.secure --at $custom_path)
    then(exits non-zero)
    then(error message indicates keyrack not found at path)
      sothat(user knows to run keyrack init --at first)

given(keyrack.yml exists at custom path with org: testorg)
  when(keyrack set --key MY_KEY --vault os.secure --env prod --at $custom_path)
    then(key slug uses org from custom keyrack)
      sothat(org context is read from target keyrack)
```
