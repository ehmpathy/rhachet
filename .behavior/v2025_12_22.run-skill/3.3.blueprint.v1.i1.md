# blueprint: `npx rhachet run --skill $skill`

## summary

implement a `run` command that discovers and executes skills from linked role directories

## domain model

```
RoleSkillExecutable
  â”œâ”€â”€ slug: string              // e.g., "init.bhuild", "git.worktree"
  â”œâ”€â”€ path: string              // absolute path to executable file
  â”œâ”€â”€ repoSlug: string          // e.g., "ehmpathy", ".this"
  â””â”€â”€ roleSlug: string          // e.g., "mechanic", "designer"
```

## directory structure (already exists)

```
.agent/
  â”œâ”€â”€ repo=$repo/
  â”‚   â””â”€â”€ role=$role/
  â”‚       â””â”€â”€ skills/
  â”‚           â””â”€â”€ .skills/           # symlinked from role package
  â”‚               â”œâ”€â”€ init.bhuild.sh
  â”‚               â”œâ”€â”€ git.worktree.sh
  â”‚               â””â”€â”€ claude.hooks/
  â”‚                   â””â”€â”€ *.sh
```

## implementation plan

### 1. create domain operation: `discoverSkillExecutables.ts`

**path**: `src/domain.operations/invoke/discoverSkillExecutables.ts`

**contract**:
```ts
export const discoverSkillExecutables = (input: {
  repoSlug?: string;   // filter by repo
  roleSlug?: string;   // filter by role
  skillSlug?: string;  // filter by skill name
}): RoleSkillExecutable[]
```

**behavior**:
- scans `.agent/repo=*/role=*/skills/` directories
- if `repoSlug` specified, only scan that repo
- if `roleSlug` specified, only scan that role
- for each skills dir, recursively find executable files
- extract skill slug from filename:
  - `init.bhuild.sh` â†’ `init.bhuild`
  - `git.worktree` â†’ `git.worktree`
- if `skillSlug` specified, filter to matches
- return list of `RoleSkillExecutable`

**pattern reference**: follows `bootRoleResources.ts` pattern for directory traversal

### 2. create domain operation: `findUniqueSkillExecutable.ts`

**path**: `src/domain.operations/invoke/findUniqueSkillExecutable.ts`

**contract**:
```ts
export const findUniqueSkillExecutable = (input: {
  repoSlug?: string;
  roleSlug?: string;
  skillSlug: string;
}): RoleSkillExecutable
```

**behavior**:
- calls `discoverSkillExecutables` with filters
- if zero matches â†’ `BadRequestError.throw('no skill found with slug "$slug"')`
- if multiple matches â†’ `BadRequestError.throw('multiple skills found...')` with disambiguation hints
- if exactly one â†’ return it

### 3. create domain operation: `executeSkill.ts`

**path**: `src/domain.operations/invoke/executeSkill.ts`

**contract**:
```ts
export const executeSkill = async (input: {
  skill: RoleSkillExecutable;
  args: string[];
}): Promise<void>
```

**behavior**:
- uses `execSync` with `stdio: 'inherit'` (same as `invokeRolesInit.ts`)
- passes all args through to the skill script
- sets cwd to git root (consistent with other commands)

### 4. create CLI command: `invokeRun.ts`

**path**: `src/contract/cli/invokeRun.ts`

**contract**:
```ts
export const invokeRun = ({
  program,
  registries,
}: {
  program: Command;
  registries: RoleRegistry[];
}): void
```

**cli interface**:
```
rhachet run --skill <slug> [--repo <repo>] [--role <role>] [<extra-args...>]
```

**options** (used by rhachet to find the skill):
- `-s, --skill <slug>` (required) - the skill to execute
- `--repo <slug>` (optional) - filter to specific repo
- `--role <slug>` (optional) - filter to specific role

**passthrough**: ALL args after `run` pass to the skill (options above included)

**examples**:
```sh
npx rhachet run --skill init.behavior --name my-feature
# â†’ executes: init.behavior.sh --skill init.behavior --name my-feature

npx rhachet run --skill git.worktree set feature-branch --open
# â†’ executes: git.worktree.sh --skill git.worktree set feature-branch --open

npx rhachet run --role mechanic --skill init.claude
# â†’ executes: init.claude.sh --role mechanic --skill init.claude
```

**note**: all args pass through to the skill, with `--skill`, `--repo`, `--role` included. skills can use these for self-awareness (e.g., log which skill runs) or ignore them.

**behavior**:
1. validate `--skill` is provided
2. call `findUniqueSkillExecutable({ repoSlug, roleSlug, skillSlug })`
3. collect ALL args after `run` (with `--skill`, `--repo`, `--role` included)
4. log which skill will run: `ðŸŒŠ skill "$slug" from repo=$repo role=$role`
5. call `executeSkill({ skill, args })` with full arg passthrough

**implementation note**:
use commander's `.allowUnknownOption()` and `.passThroughOptions()` to capture all args. pass `process.argv` (after `run` command) directly to the skill - rhachet only extracts enough to find the skill, then passes everything through unchanged.

### 5. wire into main CLI

**modify**: `src/contract/cli/invoke.ts`

- import `invokeRun`
- add `invokeRun({ program, registries })` after `invokeRoles`

## file changes summary

| file | action |
|------|--------|
| `src/domain.objects/RoleSkillExecutable.ts` | create |
| `src/domain.operations/invoke/discoverSkillExecutables.ts` | create |
| `src/domain.operations/invoke/discoverSkillExecutables.test.ts` | create |
| `src/domain.operations/invoke/findUniqueSkillExecutable.ts` | create |
| `src/domain.operations/invoke/findUniqueSkillExecutable.test.ts` | create |
| `src/domain.operations/invoke/executeSkill.ts` | create |
| `src/contract/cli/invokeRun.ts` | create |
| `src/contract/cli/invokeRun.integration.test.ts` | create |
| `src/contract/cli/invoke.ts` | modify |
| `.agent/repo=.this/role=any/skills/say-hello.sh` | create (test fixture) |

## edge cases

1. **no `.agent/` directory** â†’ error with hint to run `rhachet roles link` first
2. **skill in subdirectory** â†’ support `claude.hooks/pretooluse.check-permissions` style paths
3. **multiple matches** â†’ list all matches with repo/role for disambiguation
4. **skill not executable** â†’ warn but attempt execution anyway (shell handles permissions)
5. **passthrough includes rhachet flags** â†’ rhachet extracts `--skill`, `--repo`, `--role` to find the skill, but ALL args (those flags included) pass through to the skill (e.g., `--skill foo --name bar` â†’ skill receives `--skill foo --name bar`)

## test scenarios

```ts
given('[case1] skill exists in one role only', () => {
  when('[t0] run --skill init.bhuild', () => {
    then('executes the skill successfully')
  })
})

given('[case2] skill exists in multiple roles', () => {
  when('[t0] run --skill init.bhuild', () => {
    then('throws error with list of all matches')
  })
  when('[t1] run --skill init.bhuild --role mechanic', () => {
    then('executes the skill from mechanic role')
  })
})

given('[case3] skill does not exist', () => {
  when('[t0] run --skill nonexistent', () => {
    then('throws error with helpful message')
  })
})

given('[case4] skill with extra args', () => {
  when('[t0] run --skill git.worktree set feature-branch', () => {
    then('passes positional args through to skill script')
  })
  when('[t1] run --skill init.behavior --name xyz', () => {
    then('passes flag args through to skill script')
  })
  when('[t2] run --skill init.behavior --name xyz --verbose', () => {
    then('passes multiple flag args through to skill script')
  })
})

given('[case5] skill in repo=.this', () => {
  // uses .agent/repo=.this/role=any/skills/say-hello.sh as test fixture
  when('[t0] run --skill say-hello', () => {
    then('discovers and executes skill from .this repo')
  })
  when('[t1] run --skill say-hello --repo .this', () => {
    then('executes skill when repo explicitly specified')
  })
  when('[t2] run --skill say-hello --repo .this --role any', () => {
    then('executes skill when both repo and role specified')
  })
  when('[t3] run --skill say-hello --name world', () => {
    then('passes args through to .this skill')
  })
})
```

## test fixtures

create `.agent/repo=.this/role=any/skills/say-hello.sh` for integration tests:
```sh
#!/usr/bin/env bash
# test fixture skill for integration tests
echo "hello ${1:-stranger}"
```

## alternative approaches considered

### a. use programmatic RoleSkill refs instead of file discovery

**rejected because**: the wish explicitly asks for directory-based skill discovery (`Role.skills.dirs/*`), not programmatic refs. directory-based skills are the primary mechanism for shell-based tools.

### b. add `run` as subcommand of `roles`

**rejected because**: `run` is a top-level action, not a role management action. `roles boot|link|init|cost` manage role resources; `run` executes skills.

## dependencies

- uses: `commander`, `helpful-errors`, `node:fs`, `node:path`, `node:child_process`
- no new dependencies required

## compatibility

- fully backwards compatible (new command, no changes to prior behavior)
- follows patterns from `invokeRolesBoot.ts`, `invokeRolesInit.ts`
