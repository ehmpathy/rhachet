# research: production codepath patterns

> patterns in this repo relevant to keyrack implementation

---

## summary table

| pattern area | file path | mark | keyrack usage |
|---|---|---|---|
| command registration | `src/contract/cli/invoke.ts` | [REUSE] | `invokeKeyrack()` with sub-commands |
| config path discovery | `src/domain.operations/config/genContextConfigOfUsage.ts` | [EXTEND] | discover `~/.rhachet/keyrack.config.json` + `@gitroot/.agent/keyrack.yml` |
| just-in-time load | `src/domain.operations/config/ContextConfigOfUsage.ts` | [REUSE] | lazy-load vault adapters and manifest |
| memoization | `src/domain.operations/config/genContextConfigOfUsage.ts` | [REUSE] | avoid multiple config reads |
| domain context | `src/domain.objects/ContextCli.ts` | [REUSE] | use ContextCli for gitroot resolution |
| error handler | `src/contract/cli/invoke.ts` | [REUSE] | use `BadRequestError` from helpful-errors |
| custom errors | `src/domain.operations/invoke/executeSkill.ts` | [EXTEND] | define `VaultAccessError`, `KeyrackConfigError` |
| file upsert | `src/infra/upsertFile.ts` | [REUSE] | write config files with effect tracker |
| file findsert | `src/infra/findsertFile.ts` | [REUSE] | idempotent keyrack initialization |
| schema validation | `src/domain.operations/manifest/getRoleRegistryManifest.ts` | [EXTEND] | validate keyrack.yml with Zod |
| env var declaration | `src/domain.objects/RoleSkillArgGetter.ts` | [REUSE] | declare mechanism adapter env vars |
| lookup with dedup | `src/domain.operations/invoke/assureFindRole.ts` | [EXTEND] | find vault adapters, ensure no duplicates |
| sub-command impl | `src/contract/cli/invokeAct.ts` | [REUSE] | follow pattern for get/set/del commands |
| shell execution | `src/domain.operations/invoke/executeSkill.ts` | [REFERENCE] | age encryption commands for os.secure |

---

## pattern 1: command registration

**file:** `src/contract/cli/invoke.ts:27-81`

```typescript
const _invoke = async (input: { args: string[] }): Promise<void> => {
  const cwd = process.cwd();
  const context = await genContextConfigOfUsage({ args: input.args, cwd });
  const program = new Command();
  program.name('rhachet').description('...');

  invokeInit({ program });
  invokeAct({ program }, context);
  invokeAsk({ program }, context);

  await program.parseAsync(input.args, { from: 'user' }).catch((error) => {
    if (error instanceof BadRequestError) {
      console.error(`⛈️ ${error.message}`);
      process.exit(1);
    }
    throw error;
  });
};
```

**mark:** [REUSE]

keyrack should follow this pattern with `invokeKeyrack()` that registers sub-commands for get, set, del.

---

## pattern 2: config path discovery

**file:** `src/domain.operations/config/genContextConfigOfUsage.ts:29-62`

```typescript
const extractConfigPathFromArgs = (input: { args: string[] }): string | null => {
  const configIndex = input.args.findIndex((a) => a === '--config' || a === '-c');
  if (configIndex === -1) return null;
  const configPath = input.args[configIndex + 1];
  if (!configPath || configPath.startsWith('-')) return null;
  return configPath;
};

const resolveExplicitConfigPath = (
  input: { args: string[] },
  context: ContextCli,
): string | null => {
  const configPathFromArgs = extractConfigPathFromArgs({ args: input.args });
  if (configPathFromArgs) {
    const resolved = path.resolve(context.cwd, configPathFromArgs);
    if (fs.existsSync(resolved)) return resolved;
    return null;
  }
  const configPathFromGitRoot = path.join(context.gitroot, 'rhachet.use.ts');
  if (fs.existsSync(configPathFromGitRoot)) return configPathFromGitRoot;
  return null;
};
```

**mark:** [EXTEND]

keyrack adapts this pattern:
- user config: `~/.rhachet/keyrack.config.json`
- repo manifest: `@gitroot/.agent/keyrack.yml`

---

## pattern 3: just-in-time load with memoization

**file:** `src/domain.operations/config/ContextConfigOfUsage.ts:19-89`

```typescript
export interface ContextConfigOfUsage {
  config: {
    usage: {
      isExplicit: () => boolean;
      getExplicitPath: () => string;
      get: {
        registries: {
          explicit: () => Promise<{ registries: RoleRegistry[] }>;
          implicit: () => Promise<{ manifests: HasPackageRoot<...>[] }>;
        };
        brains: { explicit: () => Promise<BrainRepl[]> };
        hooks: { explicit: () => Promise<RoleHooksOnDispatch | null> };
      };
    };
  };
}
```

**file:** `src/domain.operations/config/genContextConfigOfUsage.ts:68-74`

```typescript
const memoize = <T>(fn: () => Promise<T>): (() => Promise<T>) => {
  let cached: Promise<T> | null = null;
  return () => {
    if (cached === null) cached = fn();
    return cached;
  };
};
```

**mark:** [REUSE]

keyrack uses this pattern for lazy credential vault access — load config only when needed, cache result.

---

## pattern 4: domain context

**file:** `src/domain.objects/ContextCli.ts:8-26`

```typescript
export interface ContextCli {
  cwd: string;
  gitroot: string;
}

export class ContextCli extends DomainLiteral<ContextCli> implements ContextCli {
  public static unique = ['cwd'] as const;
}

export const genContextCli = async (input: { cwd: string }): Promise<ContextCli> => {
  const gitroot = await getGitRepoRoot({ from: input.cwd });
  return new ContextCli({ cwd: input.cwd, gitroot });
};
```

**mark:** [REUSE]

keyrack uses ContextCli directly for gitroot resolution to find `.agent/keyrack.yml`.

---

## pattern 5: error handler

**file:** `src/contract/cli/invoke.ts:70-80`

```typescript
await program.parseAsync(input.args, { from: 'user' }).catch((error) => {
  if (error instanceof BadRequestError) {
    console.error(``);
    console.error(`⛈️ ${error.message}`);
    console.error(``);
    console.error(`[args] ${input.args}`);
    console.error(``);
    process.exit(1);
  }
  throw error;
});
```

**mark:** [REUSE]

keyrack uses `BadRequestError` for validation errors (invalid manifest, invalid mech, etc).

---

## pattern 6: custom error classes

**file:** `src/domain.operations/invoke/executeSkill.ts:12-26`

```typescript
export class SkillExecutionError extends HelpfulError {
  public readonly exitCode: number;

  constructor(
    message: string,
    metadata: { skill: string; path: string; exitCode: number | null },
  ) {
    super(message, metadata);
    this.exitCode = metadata.exitCode ?? 1;
  }
}
```

**mark:** [EXTEND]

keyrack defines:
- `VaultAccessError` — vault locked, sso expired, etc
- `KeyrackConfigError` — invalid manifest, invalid mechanism

---

## pattern 7: file upsert

**file:** `src/infra/upsertFile.ts:8-27`

```typescript
export const upsertFile = (input: {
  cwd: string;
  path: string;
  content?: string;
}): { effect: 'UPDATED' | 'CREATED' } => {
  const existed = existsSync(input.path);
  if (input.content !== undefined)
    writeFileSync(input.path, input.content, 'utf8');
  else mkdirSync(input.path, { recursive: true });

  if (existed) {
    console.log(`  ↻ [updated] ${relative(input.cwd, input.path)}`);
    return { effect: 'UPDATED' };
  }
  console.log(`  + [created] ${relative(input.cwd, input.path)}`);
  return { effect: 'CREATED' };
};
```

**mark:** [REUSE]

keyrack uses this to write `keyrack.config.json` updates.

---

## pattern 8: file findsert

**file:** `src/infra/findsertFile.ts:8-25`

```typescript
export const findsertFile = (input: {
  cwd: string;
  path: string;
  content?: string;
}): { effect: 'FOUND' | 'CREATED' } => {
  if (existsSync(input.path)) {
    console.log(`  ○ [found] ${relative(input.cwd, input.path)}`);
    return { effect: 'FOUND' };
  }
  if (input.content !== undefined)
    writeFileSync(input.path, input.content, 'utf8');
  else mkdirSync(input.path, { recursive: true });
  console.log(`  + [created] ${relative(input.cwd, input.path)}`);
  return { effect: 'CREATED' };
};
```

**mark:** [REUSE]

keyrack uses this for idempotent initialization of `~/.rhachet/` directory.

---

## pattern 9: schema validation

**file:** `src/domain.operations/manifest/getRoleRegistryManifest.ts:15-133`

```typescript
const schemaRoleManifestRaw = z.object({
  slug: z.string(),
  readme: z.string(),
  briefs: z.object({ dirs: z.union([z.string(), z.array(z.string())]) }),
  skills: z.object({ dirs: z.union([z.string(), z.array(z.string())]) }),
});

// read and parse YAML
let content: string;
try {
  content = readFileSync(manifestPath, 'utf8');
} catch (error) {
  const nodeError = error as NodeJS.ErrnoException;
  if (nodeError.code === 'ENOENT')
    throw new BadRequestError('rhachet.repo.yml not found', { ... });
  throw error;
}

// parse YAML
let parsed: unknown;
try {
  parsed = parseYaml(content);
} catch (error) {
  throw new BadRequestError('rhachet.repo.yml has invalid yaml', { ... });
}

// validate schema
const result = schemaRoleManifestRaw.safeParse(parsed);
if (!result.success)
  throw new BadRequestError('rhachet.repo.yml has invalid schema', { ... });
```

**mark:** [EXTEND]

keyrack validates `keyrack.yml` manifest with Zod schema:
```typescript
const schemaKeyrackManifest = z.object({
  keys: z.array(z.object({
    name: z.string(),
    mech: z.enum(['REPLICA', 'GITHUB_APP', 'AWS_SSO']).optional(),
  })),
});
```

---

## pattern 10: env var declaration

**file:** `src/domain.objects/RoleSkillArgGetter.ts:28-50`

```typescript
export interface RoleSkillArgGetter<TOutput, TVariables> {
  lookup: {
    [K in keyof Omit<TVariables, 'ask'>]:
      | {
          source: 'process.env';
          desc: string;
          envar: string;
          type: WithOptionPrefix<'string'>;
        }
      | {
          source: 'process.argv';
          desc: string;
          char?: string;
          type: WithOptionPrefix<'string'>;
        };
  };
  assess: (input: any) => input is TVariables;
  instantiate: (input: TVariables) => Promise<TOutput> | TOutput;
};
```

**mark:** [REUSE]

keyrack mechanism adapters (GITHUB_APP, AWS_SSO) can use this pattern to declare expected env var shapes.

---

## pattern 11: lookup with deduplication

**file:** `src/domain.operations/invoke/assureFindRole.ts:10-30`

```typescript
export const assureFindRole = ({
  registries,
  slug,
}: {
  registries: RoleRegistry[];
  slug: string;
}): Role => {
  const matches = registries
    .flatMap((r) => r.roles)
    .filter((r) => r.slug === slug);
  if (matches.length === 0)
    BadRequestError.throw(`no role named "${slug}" found in any registry`, { slug });
  if (matches.length > 1)
    BadRequestError.throw(
      `multiple roles named "${slug}" found across registries`,
      { slug },
    );
  return matches[0]!;
};
```

**mark:** [EXTEND]

keyrack uses similar pattern to find vault adapters and ensure no duplicate mechanism definitions.

---

## pattern 12: sub-command implementation

**file:** `src/contract/cli/invokeAct.ts:170-237`

```typescript
export const invokeAct = (
  { program }: { program: Command },
  context: ContextConfigOfUsage,
): void => {
  const actCommand = program
    .command('act')
    .description('invoke a rigid skill with brain')
    .requiredOption('-r, --role <slug>', 'role to invoke')
    .requiredOption('-s, --skill <slug>', 'skill to invoke')
    .option('-b, --brain <ref>', 'brain to use (format: repo/slug)')
    .option('-i, --input <json>', 'input JSON for the skill')
    .option('-o, --output <path>', 'output file path')
    .allowUnknownOption(true)
    .allowExcessArguments(true);

  actCommand.action(async (opts: {...}) => {
    // load resources just-in-time
    const registries = (await context.config.usage.get.registries.explicit()).registries;
    const brains = await context.config.usage.get.brains.explicit();
    const hooks = await context.config.usage.get.hooks.explicit();
    const configPath = context.config.usage.getExplicitPath();

    // determine mode and branch logic
    const useIsolatedThreads = opts.attempts !== undefined;
    if (useIsolatedThreads) {
      return await performActViaIsolatedThreads({...});
    }
    return await performActInCurrentThread({...});
  });
};
```

**mark:** [REUSE]

keyrack commands follow this pattern:
```typescript
export const invokeKeyrack = (
  { program }: { program: Command },
  context: ContextConfigOfUsage,
): void => {
  const keyrackCommand = program.command('keyrack').description('credential management');

  keyrackCommand
    .command('get')
    .option('--for <scope>', 'repo or key name')
    .option('--key <name>', 'specific key')
    .action(async (opts) => { ... });

  keyrackCommand
    .command('set')
    .requiredOption('--key <name>', 'key to set')
    .option('--mech <type>', 'mechanism: REPLICA, GITHUB_APP, AWS_SSO')
    .action(async (opts) => { ... });

  keyrackCommand
    .command('del')
    .requiredOption('--key <name>', 'key to delete')
    .action(async (opts) => { ... });
};
```

---

## pattern 13: shell execution

**file:** `src/domain.operations/invoke/executeSkill.ts:39-89`

```typescript
export const executeSkill = <TOutput = unknown>(input: {
  skill: RoleSkillExecutable;
  args: string[];
  stream?: boolean;
  schema?: { output: z.ZodSchema<TOutput> };
}): TOutput => {
  const stream = input.stream ?? true;
  const command = [input.skill.path, ...input.args]
    .map((arg) => (arg.includes(' ') ? `"${arg}"` : arg))
    .join(' ');

  const result = spawnSync(command, [], {
    cwd: process.cwd(),
    shell: '/bin/bash',
    utf-8: true,
    stdio: stream
      ? [process.stdin, process.stdout, process.stderr]
      : ['inherit', 'pipe', 'inherit'],
  });

  if (result.status !== 0)
    throw new SkillExecutionError('skill execution failed', {...});

  if (stream) return undefined as TOutput;

  const stdout = ((result.stdout as string) ?? '').trim();
  if (!stdout) return undefined as TOutput;

  let parsed: unknown;
  try {
    parsed = JSON.parse(stdout);
  } catch {
    parsed = stdout;
  }

  if (input.schema) return input.schema.output.parse(parsed);
  return parsed as TOutput;
};
```

**mark:** [REFERENCE]

keyrack may use similar pattern for:
- age encryption/decryption commands (os.secure vault)
- github app token generation
- aws sso session refresh

---

## key insights

1. **config management:** rhachet uses two-tier config:
   - explicit: `rhachet.use.ts` (runtime config via TypeScript import)
   - implicit: `rhachet.repo.yml` manifests (via YAML)
   - keyrack follows: explicit `~/.rhachet/keyrack.config.json` + implicit `@gitroot/.agent/keyrack.yml`

2. **just-in-time load:** commands declare dependencies, config loads only when needed via memoized getters. critical for cli responsiveness.

3. **error management:** all validation uses `BadRequestError` with helpful metadata. custom errors extend `HelpfulError`.

4. **file i/o:** two patterns:
   - `upsertFile`: overwrites (for config updates)
   - `findsertFile`: idempotent creation (for initial setup)

5. **shell integration:** skills execute via `spawnSync` with stdin passthrough, support stream and capture modes.
