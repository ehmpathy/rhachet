# vision: rhachet/keyrack â€” the hotel front desk for credentials

> raw credentials stay locked in the vault. only keycards are handed to agents. ğŸ”

---

## the outcome world

### before: credential chaos

casey adds a new integration test that needs an aws credential and a github app token. the dance begins:

1. hunt for the api key in slack dms, 1password, or a `.env.local` someone shared months ago
2. paste it raw into `~/.config/rhachet/keyrack.env` alongside six other keys, some of which expired last week
3. `source use.apikeys.sh` â€” which loads all values as raw env vars. long-lived keys, private keys, expired tokens â€” all dumped into the session for any child process to see
4. tests pass locally. push to ci. ci needs the same keys but stored differently. set them as github secrets, pass them via `env:` blocks. the raw private key now lives in the ci step's env
5. github flags a pat as a bot. ci turns red. nobody remembers where the key came from or who owns it
6. a new developer joins. they spend 45 minutes on "where do i get the XAI_API_KEY?" and "how do i set up aws access?" â€” because the answer is different on every machine

the pattern: credentials are scattered, unmanaged, and leak into every process that runs. long-lived keys sit in plaintext on disk. expired keys cause mysterious failures. onboard is a scavenger hunt.

### after: credential firewall via `rhachet/keyrack`

casey adds a new integration test. the repo has a `.agent/keyrack.yml` that declares what credentials the repo needs:

```yaml
# .agent/keyrack.yml
keys:
  BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN:
    mech: GITHUB_APP
  EHMPATHY_AWS_SSO_PREP:
    mech: AWS_SSO
  XAI_API_KEY: # mech defaults to REPLICA â€” no spec needed
```

casey runs:

```sh
rhx keyrack get --for repo
```

the keyrack reads the manifest, checks each key against the global config at `~/.rhachet/keyrack.config.json`, and reports:

```
ğŸ” rhachet/keyrack
â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
â”‚  â”œâ”€ vault: 1password
â”‚  â”œâ”€ mech: GITHUB_APP
â”‚  â””â”€ status: ğŸ”‘ granted (github app â†’ 1h token)
â”œâ”€ EHMPATHY_AWS_SSO_PREP
â”‚  â”œâ”€ vault: os.secure
â”‚  â”œâ”€ mech: AWS_SSO
â”‚  â””â”€ status: ğŸ”‘ granted (sso session valid for 3h)
â”œâ”€ XAI_API_KEY
â”‚  â”œâ”€ vault: os.direct
â”‚  â”œâ”€ mech: REPLICA
â”‚  â””â”€ status: ğŸ”‘ granted
â””â”€ done. 3 granted, 0 blocked.
```

the raw credentials never reach the session. only the granted, short-lived values are exported. tests run. tokens expire. private keys stay locked.

a new developer joins. they run `rhx keyrack get --for repo`. the keyrack reads the manifest, checks their machine, and says:

```
ğŸ” rhachet/keyrack
â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
â”‚  â””â”€ status: ğŸ«§ unfound
â”‚     â””â”€ fix: rhx keyrack set --key BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN --mech GITHUB_APP
â”œâ”€ EHMPATHY_AWS_SSO_PREP
â”‚  â””â”€ status: ğŸ«§ unfound
â”‚     â””â”€ fix: rhx keyrack set --key EHMPATHY_AWS_SSO_PREP --mech AWS_SSO
â”œâ”€ XAI_API_KEY
â”‚  â””â”€ status: ğŸ«§ unfound
â”‚     â””â”€ fix: rhx keyrack set --key XAI_API_KEY
â””â”€ done. 0 granted, 3 not found.
```

no guesswork. no scavenger hunt. the keyrack tells them exactly what to do.

### the "aha" moment

> "the keyrack is the front desk at a hotel. raw credentials stay locked in the vault behind the counter. agents (guests) never touch them. when they need access, the front desk staff (mechanism adapters) mint short-lived keycards and hang them on the rack. agents grab keycards, do their work, and leave. the raw credentials never leave the vault."

### why keyrack: a pit of success for credential distribution

the hotel front desk isn't just a nice metaphor â€” it's a **pit of success**. the architecture makes secure credential distribution the default, not the exception.

**hotels solved this problem centuries ago.** guests don't get master keys. they get keycards. keycards expire. keycards are scoped to specific rooms. if a keycard is lost, the damage is bounded. the guest never touches the master key, never knows where it's stored, never has the opportunity to copy it.

this is the pit of success: **the easy path is the safe path.**

| hotel practice | keyrack practice | pit of success property |
|----------------|------------------|-------------------------|
| guests get keycards, never master keys | agents get grants, never raw credentials | **default is safe** |
| keycards expire at checkout | grants are short-lived (1h github, 8h sso) | **damage is bounded** |
| keycards only open assigned rooms | grants are scoped to declared mechanisms | **access is scoped** |
| lost keycard? front desk mints a new one | expired grant? keyrack mints a fresh one | **recovery is easy** |
| master key stays in the vault | private keys stay in the vault | **secrets don't travel** |
| front desk verifies identity first | keyrack validates mechanism constraints | **contraband is blocked** |
| no keycard without a reservation | no grant without a manifest declaration | **access is explicit** |
| guest can't request room 999 if not on their reservation | keyrack refuses keys not in `.agent/keyrack.yml` | **allowlist is enforced** |
| all rooms or no rooms (group reservation) | all keys or no keys (all-or-none mount) | **partial access is forbidden** |

**why "keyrack" and not "keyring"?**

a keyring is a bundle of keys jangled together â€” grab the ring, jangle through, find the one you need. unstructured. undifferentiated. the keys are all the same type.

a keyrack is the board at the hotel front desk with **numbered slots**. each slot holds one keycard. each keycard is scoped, labeled, and ready for pickup. the structure enforces organization. you don't jangle â€” you **reach into a slot and grab exactly what you need**.

```
keyring (bundle)           keyrack (slots)
    ğŸ”‘                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   ğŸ”‘ğŸ”‘ğŸ”‘                   â”‚  ğŸ”‘  ğŸ”‘  ğŸ”‘  ğŸ”‘  ğŸ”‘  ğŸ”‘  â”‚
  ğŸ”‘ğŸ”‘ğŸ”‘ğŸ”‘ğŸ”‘                 â”‚ 101 102 103 104 105 106 â”‚
   (jangle)                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  (structured)
```

the keyrack metaphor reinforces:
- **indexed access** â€” each credential has a named slot
- **visual organization** â€” you can see what's available at a glance
- **structured pickup** â€” grab from a slot, not from a pile
- **front desk control** â€” someone else minted these; you just take what's yours

**the pit of success in practice:**

1. **hard to leak raw credentials** â€” agents never see them; they're consumed and discarded at resolution time
2. **hard to use long-lived tokens** â€” mechanism constraints block `ghp_...` pats where `GITHUB_APP` is declared
3. **hard to run with partial access** â€” all-or-none mount means no "well, 2 of 3 keys worked" scenarios
4. **hard to enumerate credentials** â€” the `.agent/keyrack.yml` allowlist bounds what keyrack will even look for
5. **easy to onboard** â€” `rhx keyrack get --for repo` tells you exactly what to run for every absent key
6. **easy to recover** â€” expired grants just need a fresh `get`; the vault handles the rest

**the allowlist security model:**

`.agent/keyrack.yml` is the **allowlist** â€” the repo's declaration of exactly which credentials it needs. this is the primary protection against rogue actors who might try to search for credentials on the host:

- **keyrack refuses to get keys not in the manifest** â€” if a key is not declared in `.agent/keyrack.yml`, keyrack will not look for it, period. it immediately returns "absent" without a check of the host manifest or any vault.
- **the manifest is the contract** â€” the repo author explicitly declares what credentials are needed. this bounds the scope of credential access.
- **no enumeration expeditions** â€” a rogue process cannot use keyrack to enumerate what credentials exist on the host. keyrack only responds to keys that the repo has explicitly allowlisted.

this is why the hotel analogy holds: a guest cannot request room 999 if room 999 isn't on their reservation. the reservation (manifest) is the allowlist. the front desk (keyrack) enforces it.

the hotel solved credential distribution. the keyrack brings that solution to software.

---

## user experience

### usecase 1: developer sets up credentials for the first time

**goal**: new developer sets up all credentials a repo needs, securely, in under 5 minutes

**timeline**:

1. clone the repo, run `rhx keyrack get --for repo`
2. keyrack reads `.agent/keyrack.yml`, finds 3 keys not configured
3. keyrack prints the `rhx keyrack set` commands to run for each key, with the `--mech` prescribed by the manifest
4. developer runs each `set` command:

```sh
# guided setup: keyrack walks through each step

# api key â€” simplest case (default mech = REPLICA)
rhx keyrack set --key XAI_API_KEY
# â†’ prompts: "which vault?" â†’ os.direct | os.secure | 1password
# â†’ (user picks os.direct)
# â†’ prompts: "paste your XAI_API_KEY value:"
# â†’ stores in ~/.rhachet/keyrack.direct.json
# â†’ done

# aws sso â€” mechanism adapter guides the auth flow
rhx keyrack set --key EHMPATHY_AWS_SSO_PREP --mech AWS_SSO
# â†’ prompts: "which vault?" â†’ os.direct | os.secure | 1password
# â†’ (user picks os.secure)
# â†’ prompts: "which aws profile?" â†’ "ehmpathy.dev"
# â†’ runs: aws sso login --profile ehmpathy.dev
# â†’ stores profile reference in ~/.rhachet/keyrack.config.json
# â†’ encrypts session ref in ~/.rhachet/keyrack.secure.{hash}.age
# â†’ done

# github app â€” mechanism adapter guides the app credential setup
rhx keyrack set --key BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN --mech GITHUB_APP
# â†’ prompts: "which vault?" â†’ os.direct | os.secure | 1password
# â†’ (user picks 1password)
# â†’ prompts: "which 1password item holds the github app credentials?"
# â†’ links to 1password item reference in ~/.rhachet/keyrack.config.json
# â†’ done (1password retrieves the actual value at get-time)
```

5. run `rhx keyrack get --for repo` again â€” all 3 keys resolve. tests run.

**contract**:

```
input:  rhx keyrack set --key $KEY [--mech $MECH]
         â†’ prompts for vault choice (os.direct | os.secure | 1password)
         â†’ guides through vault-specific setup
output: key stored in vault, reference persisted in ~/.rhachet/keyrack.config.json
```

### usecase 2: keyrack embedded in test commands (findsert semantics)

**goal**: no separate `keyrack get` step to remember â€” it's baked into `npm run test:integration` with findsert semantics. one linear path for local and ci.

**findsert logic** (for each key declared in `.agent/keyrack.yml`):

1. key already in env AND safe â†’ pass through (no-op)
2. key already in env AND not safe (e.g., `ghp_...` where `GITHUB_APP` is required) â†’ fail fast
3. key not in env â†’ load from keyrack

**on local** â€” human or robot just runs tests. keyrack loads credentials automatically:

```sh
npm run test:integration -- syncPhoneFromWhodis.integration.test.ts

# rhx keyrack get --for repo runs automatically via test setup
# ğŸ” rhachet/keyrack (findsert)
# â”œâ”€ EHMPATHY_AWS_SSO_PREP Â·Â·Â· ğŸ«§ not in env â†’ ğŸ”‘ granted (sso session valid for 8h)
# â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN Â·Â·Â· ğŸ«§ not in env â†’ ğŸ”‘ granted (github app â†’ 1h token)
# â”œâ”€ XAI_API_KEY Â·Â·Â· ğŸ«§ not in env â†’ ğŸ”‘ granted
# â””â”€ done. 3 granted, 0 blocked.
```

**on ci** â€” env vars are already injected by the `rhachet/keyrack@v1` action step. findsert detects them, validates safety, passes through:

```sh
# env vars already present from github action step
# ğŸ” rhachet/keyrack (findsert)
# â”œâ”€ EHMPATHY_AWS_SSO_PREP Â·Â·Â· ğŸ”‘ already in env, safe â†’ pass through
# â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN Â·Â·Â· ğŸ”‘ already in env, safe â†’ pass through
# â”œâ”€ XAI_API_KEY Â·Â·Â· ğŸ”‘ already in env, safe â†’ pass through
# â””â”€ done. 3 granted, 0 blocked.
```

**on ci with a leaked pat** â€” findsert catches it:

```sh
# ğŸ” rhachet/keyrack (findsert)
# â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN Â·Â·Â· ğŸš« already in env, NOT safe (ghp_... but mech requires GITHUB_APP)
# â””â”€ fail. 1 blocked.
```

this eliminates the "remember to run keyrack before tests" problem. agents (human and robot) just run tests. the keyrack is the gate that fires on every run â€” and on ci where env vars are pre-granted, it's a no-op.

if a vault is locked (e.g., os.secure key expired):

```
# ğŸ” rhachet/keyrack
# â”œâ”€ EHMPATHY_AWS_SSO_PREP
# â”‚  â””â”€ status: ğŸ”’ locked (sso session expired)
# â”‚     â””â”€ fix: rhx keyrack unlock --key EHMPATHY_AWS_SSO_PREP
# â””â”€ fail. 1 key locked. no keys mounted (all-or-none).
```

the keyrack refuses to mount any keys if any required key is unavailable. no risk of partial-privilege escalation.

### usecase 3: ci resolves credentials via firewall step

**goal**: ci passes raw secrets to keyrack step, keyrack resolves and sanitizes, test steps see only short-lived tokens

**timeline**:

1. github repo stores `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` as a json blob secret (app id + private key)
2. test workflow passes raw secret only to the `rhachet/keyrack` step
3. keyrack resolves â†’ writes short-lived token to `$GITHUB_ENV`
4. subsequent test steps see only the granted token â€” original secret never in their env
5. tests run with fresh 1-hour token

```yaml
# .test.yml â€” per test job

# step 1: keyrack resolves credentials
# raw secret is ONLY visible to this step
- name: resolve credentials
  uses: rhachet/keyrack@v1
  env:
    BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN: ${{ secrets.BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN }}
  # detects JSON app creds â†’ mints short-lived token
  # writes: echo "BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN=ghs_..." >> $GITHUB_ENV
  # original secret stays in this step only

# step 2: tests see only the granted token
- name: test:integration
  run: npm run test:integration
  # value is ghs_... (short-lived), not the JSON blob
```

the raw secret (json with private key) is only in the keyrack step's `env:`. it never appears in `$GITHUB_ENV`. only the granted short-lived token does.

### usecase 4: developer unlocks a vault

**goal**: developer unlocks a vault so `get` can retrieve credentials from it

**timeline**:

1. `rhx keyrack get --for repo` reports a key is locked
2. `rhx keyrack unlock --key EHMPATHY_AWS_SSO_PREP`
3. keyrack detects the vault backend and triggers its auth flow
4. `rhx keyrack get --for repo` now grants the key

```sh
rhx keyrack unlock --key EHMPATHY_AWS_SSO_PREP
# ğŸ”“ unlock EHMPATHY_AWS_SSO_PREP
# â”œâ”€ vault: os.secure
# â””â”€ âœ¨ unlocked (via age passphrase)

rhx keyrack unlock --key BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
# ğŸ”“ unlock BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
# â”œâ”€ vault: 1password
# â””â”€ âœ¨ unlocked (via op signin)
```

`unlock` is a thin wrapper that triggers the vault's own auth flow. the user doesn't need to remember whether they chose `os.secure` (age passphrase) or `1password` (op signin) â€” `unlock` guides them through the right flow for their configured vault.

**what rhachet controls vs what it doesn't**:

rhachet **never** retains vault keys. it triggers the vault's auth, retrieves the credential, and discards the vault key immediately. how long the vault stays unlocked is governed entirely by the vault backend (1password session duration, age passphrase entry, etc.) â€” not by rhachet.

rhachet also does **not** control the **credential's own lifetime**. once a credential is granted and exported to env, rhachet can't revoke it. the credential lives and dies by its own policy:

| credential type | lifetime governed by | what happens on expiry |
|---|---|---|
| github app token | github (1h) | next `get` mints a fresh one (if vault still unlocked) |
| aws sso session | aws (session-scoped) | next `get` fails â†’ user must re-auth via `unlock` |
| longlived api key | the provider (indefinite) | stays valid until the provider revokes it |

if a credential expires mid-session, `rhx keyrack get` detects it and tells the human to re-authenticate. rhachet grants credentials â€” it does not revoke them. revocation is the credential provider's responsibility.

### usecase 5: keyrack blocks a long-lived pat

**goal**: prevent accidental use of long-lived credentials that should have been replaced

```sh
rhx keyrack get --for repo
# ğŸ” rhachet/keyrack
# â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
# â”‚  â””â”€ status: ğŸš« blocked (detected ghp_... long-lived pat)
# â”‚     â””â”€ this repo requires mech: GITHUB_APP
# â”‚     â””â”€ fix: rhx keyrack set --key BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN --mech GITHUB_APP
# â””â”€ fail. 1 key blocked. no keys mounted.
```

the manifest declares the required mechanism. if someone has a raw `ghp_...` pat configured for a key that requires `GITHUB_APP`, the keyrack refuses to export it. forces the safe path.

---

## mental model

### how developers describe it to a friend

> "we have a tool called `rhachet keyrack`. think of it like a hotel front desk. raw credentials stay locked in the vault â€” some in 1password, some encrypted on disk. when you run `rhx keyrack get`, the front desk mints short-lived keycards and hangs them on the rack. your tests grab keycards, never the raw credentials. same front desk locally and in ci."

### the front desk flow

```
guest arrives (agent needs credentials)
       â†“
front desk checks vault (resolve from storage backend)
       â†“
mints keycard (mechanism adapter â†’ short-lived grant)
       â†“
hangs on keyrack (ready for pickup)
       â†“
guest takes keycard (agent receives grant)
       â†“
raw credentials never leave the vault
```

### analogies

**the hotel front desk** (primary metaphor):

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      keyrack                            â”‚
â”‚                   (the front desk)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚   vaults              mechanism            keycards     â”‚
â”‚   (storage)    â†’      adapters      â†’      (grants)     â”‚
â”‚                       (mint)                            â”‚
â”‚   os.direct           REPLICA            api key      â”‚
â”‚   os.secure           GITHUB_APP           ghs_... 1h   â”‚
â”‚   1password           AWS_SSO              session 8h   â”‚
â”‚                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚   raw credentials never leave the vault                 â”‚
â”‚   only keycards are handed to agents                    â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| hotel concept | keyrack concept |
|---------------|-----------------|
| hotel vault (behind the counter) | vault backends (1password, os.secure, os.direct) |
| front desk staff | mechanism adapters (mint keycards from raw credentials) |
| keyrack with slots | keyrack (holds granted keycards ready for pickup) |
| hotel guests | agents (human or robot, receive keycards) |
| keycard with room number | granted token (scoped, expires, used directly) |
| master key in vault | app private key (proves identity, never handed out) |
| guest reservation | `.agent/keyrack.yml` (declares what credentials the repo needs) |
| concierge setup | keyrack `set` command (guides through credential setup) |

### terms: developer vs system

| developer says | system says |
|---|---|
| "load my keys" | `rhx keyrack get --for repo` |
| "set up a key" | `rhx keyrack set --key $KEY [--mech $MECH]` â†’ prompts for vault |
| "get one key" | `rhx keyrack get --key $KEY` |
| "unlock the vault" | `rhx keyrack unlock --key $KEY` |
| "what keys does this repo need?" | reads `.agent/keyrack.yml` |
| "where are my keys stored?" | reads `~/.rhachet/keyrack.config.json` |
| "the github token" | `BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN` |
| "resolve credentials" | `rhachet/keyrack@v1` github action step |
| "mint a token" | mechanism adapter translates raw creds â†’ short-lived token |
| "block that pat" | keyrack detects `ghp_...` â†’ fail fast |

---

## architecture

### the three layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  .agent/keyrack.yml            â”‚  per-repo manifest
â”‚  (declares keys + mechanisms)   â”‚  (what this repo needs)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ~/.rhachet/keyrack.config.jsonâ”‚  per-machine config
â”‚  (maps keys â†’ vaults)          â”‚  (where keys are stored)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  vault backends                 â”‚  per-vault storage
â”‚  os.direct | os.secure | 1pass  â”‚  (how keys are persisted)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### vault adapters (`rhachet-vaults-*`)

vault adapters abstract away the details of credential storage and retrieval. same supplier pattern as `rhachet-roles-*` and `rhachet-brains-*`:

- **today**: collocated in rhachet core
- **eventually**: discovered as `rhachet-vaults-*` packages, same as roles and brains

vaults are a peer supplier to roles and brains because vaults are what unlock delegated agency. brains supply the capacity to think. roles supply the knowledge and skills. vaults supply the authorizations â€” the credentials that grant access to external systems. roles can then narrow those authorizations further (e.g., a mechanic role only needs read access to ci logs, not admin access to production).

eventually, vaults should also:
- **sanitize**: flag when a credential grants more access than the role needs â€” verify credentials are not over-authorized for the declared scope
- **provision**: walk users through credential creation with the right scope from scratch â€” not just how to store a key, but how to create it in the first place

each vault adapter implements: `get`, `set`, `unlock`, `status` â€” so the keyrack can delegate without awareness of the vault's internals.

**initial release:**
- `os.direct` â€” plaintext json, immediate access, no auth
- `os.secure` â€” age-encrypted, passphrase-gated, works identically on all platforms
- `1password` â€” 1password vault via `op` cli

**future work** (platform-specific vaults):
- `mac.keychain` â€” macOS Keychain integration for users who prefer native credential storage
- `linux.secret-service` â€” GNOME Keyring / KWallet for users who prefer d-bus secret service

| vault | security | access | storage |
|-------|----------|--------|---------|
| `os.direct` | none (plaintext) | immediate, no auth | `~/.rhachet/keyrack.direct.json` |
| `os.secure` | age-encrypted (scrypt + ChaCha20-Poly1305) | requires passphrase | `~/.rhachet/keyrack.secure.{hash}.age` |
| `1password` | 1password vault | requires 1pass auth (via `op` cli) | 1password item reference |

**why age for `os.secure`?**

platform-specific secret storage is fragmented: macOS Keychain has its own API, Linux has GNOME Keyring vs KWallet vs nothing in headless, Windows has Credential Manager. rather than maintain platform-specific code paths, `os.secure` uses [age encryption](https://github.com/FiloSottile/age) â€” which works the same way everywhere:

- **one code path** â€” no `if (macos) { ... } else if (linux) { ... }` branching
- **zero dependencies** â€” no d-bus, no daemon, no os-specific api, no native bindings
- **correct crypto defaults** â€” scrypt kdf + ChaCha20-Poly1305 AEAD, zero config
- **official TypeScript library** â€” `age-encryption` on npm, maintained by the author
- **portable secrets** â€” `~/.rhachet/keyrack.secure.{hash}.age` files can be copied between machines

the passphrase unlocks the age-encrypted file. the passphrase is consumed and discarded â€” never retained by rhachet. this is the pit of success: one encryption backend that Just Worksâ„¢ on linux, macos, windows, ci, docker, ssh â€” anywhere node runs.

### mechanism adapters

| mechanism | what it does | short-lived result |
|-----------|-------------|-------------------|
| `REPLICA` (default) | pass through (no translation possible) | same value, noted as non-translatable |
| `GITHUB_APP` | json blob with appId + privateKey â†’ installation token | `ghs_...` (1 hour) |
| `AWS_SSO` | sso profile â†’ session credentials | temporary aws credentials (session-scoped) |

extensible via the adapter pattern: each mechanism is a separate adapter that knows how to translate its raw credential into the shortest-lived form.

### supplier taxonomy

| supplier type | package pattern | what it supplies | examples |
|---|---|---|---|
| roles | `rhachet-roles-*` | briefs + skills | `rhachet-roles-ehmpathy` |
| brains | `rhachet-brains-*` | brain repls + atoms | `rhachet-brains-anthropic` |
| vaults | `rhachet-vaults-*` | credential storage + retrirhachet completion --setup+ unlock | `rhachet-vaults-1password`, `rhachet-vaults-os` |

### global config shape

```json
// ~/.rhachet/keyrack.config.json
{
  "XAI_API_KEY": {
    "vault": "os.direct",
    "createdAt": "2026-02-05T10:00:00Z",
    "updatedAt": "2026-02-05T10:00:00Z"
  },
  "EHMPATHY_AWS_SSO_PREP": {
    "vault": "os.secure",
    "createdAt": "2026-02-05T10:00:00Z",
    "updatedAt": "2026-02-05T10:00:00Z"
  },
  "BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN": {
    "vault": "1password",
    "vault_ref": "op://Dev/bhuild-beaver-app-creds",
    "createdAt": "2026-02-05T10:00:00Z",
    "updatedAt": "2026-02-05T10:00:00Z"
  }
}
```

### per-repo manifest shape

```yaml
# .agent/keyrack.yml
keys:
  BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN:
    mech: GITHUB_APP
  EHMPATHY_AWS_SSO_PREP:
    mech: AWS_SSO
  XAI_API_KEY: # mech defaults to REPLICA â€” no spec needed
```

the manifest prescribes the mechanism when non-default. the vault is the developer's choice (set at `keyrack set` time). the mechanism determines what resolution logic the firewall applies.

---

## evaluation

### how well does it solve the goals?

| goal | solution | score |
|------|----------|-------|
| pit of success | manifest declares what's needed; `set` guides setup; `get` resolves or tells you how to fix | âœ… excellent |
| portable | same manifest, same cli, same logic â€” local, ci, any machine | âœ… excellent |
| secure | vault backends protect raw credentials; firewall resolves to short-lived; blocks long-lived where translatable | âœ… excellent |
| onboard speed | new developer runs `get --for repo`, gets exact `set` commands for every key not found | âœ… excellent |
| credential firewall | blocks pats, resolves app creds, passes api keys, all-or-none mount | âœ… excellent |
| extensible mechanisms | adapter pattern for GITHUB_APP, AWS_SSO, future mechanisms | âœ… excellent |
| vault flexibility | os.direct for convenience, os.secure for safety, 1password for teams | âœ… excellent |
| session-scoped unlock | os.secure keys unlockable for session or N hours; vault password never cached | âœ… excellent |
| ci parity | `rhachet/keyrack@v1` action applies same firewall logic as local cli | âœ… excellent |

### pros

- **universal firewall**: one gate between raw credentials and downstream processes, every environment
- **manifest-driven**: repos declare what they need; developers choose where to store it
- **guided setup**: `set` walks developers through each credential type, mechanism-aware
- **all-or-none mount**: if any key is not available, no keys are mounted â€” prevents partial-privilege scenarios
- **vault-agnostic**: same cli whether keys live in 1password, encrypted on disk, or plaintext
- **mechanism-extensible**: new credential types (e.g., OIDC, service accounts) are added as adapters
- **no credential leakage**: granted values are exported; raw credentials, vault passwords, and private keys are consumed and discarded
- **ci-native**: github action step applies the same resolution logic
- **forward-compatible**: vault backends and mechanisms can be added without alteration to the manifest or cli contract

### cons

- **new component to build**: cli commands, vault backends, mechanism adapters, github action
- **one-time setup per developer**: each developer configures their vaults once via `set`
- **vault backend complexity**: os.secure requires encryption logic; 1password requires `op` cli
- **all-or-none can block**: if one key expires, the developer can't run any tests until all keys resolve â€” correct behavior, but can cause friction in the moment

### edgecases and pit of success

| edgecase | pit of success design |
|----------|----------------------|
| key not found in vault | clear error with exact `rhx keyrack set` command to run |
| vault locked (os.secure key expired) | clear error with `rhx keyrack unlock` command; vault password consumed and discarded |
| long-lived pat configured for GITHUB_APP key | blocked with clear error; forces the safe path |
| 1password not authenticated | clear error: "run `op signin` first" |
| aws sso session expired | clear error: "run `rhx keyrack unlock --key $KEY` to re-authenticate" |
| `.agent/keyrack.yml` not found | fail fast: "this repo does not declare keyrack requirements" |
| partial key availability | all-or-none: no keys mounted until all resolve |
| token expires mid-test | 1h github tokens are 6x longer than typical test suites (~10 min); sso sessions last hours |
| private key in child process env | keyrack resolves and discards before children start â€” private key never leaks |
| developer spawns terminal from unlocked session | session-scoped unlock ideally does not propagate (best effort via terminal-specific env) |
| new mechanism type needed | add adapter, declare in manifest â€” no changes to cli or vault contracts |

---

## summary

`rhachet/keyrack` is the hotel front desk for credentials. repos declare what credentials they need in `.agent/keyrack.yml` â€” like a guest reservation. developers configure where their raw credentials are stored via `rhx keyrack set` â€” in 1password, encrypted on disk, or plaintext (the vaults behind the counter). when they run `rhx keyrack get --for repo`, the front desk mints short-lived keycards via mechanism adapters, hangs them on the rack, and agents pick them up. raw credentials never leave the vault. all-or-none: if any key is not available, none are handed out.

same front desk in ci via `rhachet/keyrack@v1`. same reservation, same logic, different vault backend.

the result: no long-lived credential ever reaches a downstream process. no scavenger hunt for new developers. no expired keys in shared env files. no private keys in child process environments.

> raw credentials stay locked in the vault. only keycards are handed to agents. ğŸ”
