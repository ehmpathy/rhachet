# blackbox criteria: rhachet/keyrack

> what experience must be delivered â€” no mechanism or implementation details

---

# usecase.1 = get credentials for a repo

given('a repo with `.agent/keyrack.yml` that declares 3 keys')
  given('all 3 keys are configured on this machine and vaults are unlocked')
    when('`rhx keyrack get --for repo`')
      then('each key reports status: ğŸ”‘ granted')
        sothat('the developer knows all credentials resolved')
      then('only the granted short-lived values are exported to the env')
        sothat('downstream processes never see raw credentials')
      then('raw credentials, private keys, and vault passwords are not in the env')
        sothat('no credential leakage to child processes')
      then('summary reads "3 granted, 0 blocked"')
        sothat('the developer can confirm at a glance')

  given('none of the 3 keys are configured on this machine')
    when('`rhx keyrack get --for repo`')
      then('each key reports status: ğŸ«§ unfound')
        sothat('the developer knows which keys are absent')
      then('each not-found key prints a fix command: `rhx keyrack set --key $KEY [--mech $MECH]`')
        sothat('the developer knows exactly what to run')
      then('the --mech in the fix command matches the manifest declaration')
        sothat('the developer does not need to look up the mechanism')
      then('no keys are mounted')
        sothat('partial-privilege scenarios are prevented')
      then('summary reads "0 granted, 3 not found"')

  given('2 of 3 keys are configured and granted, 1 is not found')
    when('`rhx keyrack get --for repo`')
      then('the 2 available keys report ğŸ”‘ granted')
      then('the 1 absent key reports ğŸ«§ unfound with a fix command')
      then('no keys are mounted â€” even the 2 that resolved')
        sothat('all-or-none policy prevents partial privilege')

  given('1 key has a locked vault (e.g., sso session expired)')
    when('`rhx keyrack get --for repo`')
      then('the locked key reports status: ğŸ”’ locked')
      then('the locked key prints a fix command: `rhx keyrack unlock --key $KEY`')
      then('no keys are mounted')
        sothat('all-or-none policy holds for locked vaults too')

  given('a key is configured with a value that violates its declared mechanism')
    when('`rhx keyrack get --for repo`')
      then('the key reports status: ğŸš« blocked')
      then('the block message names the violation (e.g., "ghp_... but mech requires GITHUB_APP")')
        sothat('the developer knows what is wrong and why')
      then('a fix command is printed')
      then('no keys are mounted')

given('a repo without `.agent/keyrack.yml`')
  when('`rhx keyrack get --for repo`')
    then('fail fast with a clear message: this repo does not declare keyrack requirements')
      sothat('the developer knows the manifest is absent, not that keys are absent')

---

# usecase.2 = get a single credential

given('a key that is configured and its vault is unlocked')
  when('`rhx keyrack get --key $KEY`')
    then('the granted value is exported to env')
    then('the key reports status: ğŸ”‘ granted')

given('a key that is not configured on this machine')
  when('`rhx keyrack get --key $KEY`')
    then('the key reports status: ğŸ«§ unfound')
    then('a fix command is printed: `rhx keyrack set --key $KEY`')
    then('the key is not exported to env')

given('a key whose vault is locked')
  when('`rhx keyrack get --key $KEY`')
    then('the key reports status: ğŸ”’ locked')
    then('a fix command is printed: `rhx keyrack unlock --key $KEY`')
    then('the key is not exported to env')

given('a key whose value violates the declared mechanism')
  when('`rhx keyrack get --key $KEY`')
    then('the key reports status: ğŸš« blocked')
    then('the block message names the violation')
    then('a fix command is printed')
    then('the key is not exported to env')

---

# usecase.3 = set up a credential

given('a key name with no --mech (defaults to REPLICA)')
  when('`rhx keyrack set --key $KEY`')
    then('prompted to choose a vault: os.direct | os.secure | 1password')
      sothat('the developer chooses their preferred storage backend')
    then('guided through vault-specific setup for the chosen vault')
      sothat('the developer does not need to know vault internals')
    then('on completion, the key reference is persisted in `~/.rhachet/keyrack.config.json`')
      sothat('subsequent `get` calls can find it')
    then('confirmation message reports success')

given('a key name with --mech GITHUB_APP')
  when('`rhx keyrack set --key $KEY --mech GITHUB_APP`')
    then('prompted to choose a vault')
    then('guided through github app credential setup specific to the chosen vault')
      sothat('the developer is walked through app id, private key, etc.')

given('a key name with --mech AWS_SSO')
  when('`rhx keyrack set --key $KEY --mech AWS_SSO`')
    then('prompted to choose a vault')
    then('guided through aws sso profile setup specific to the chosen vault')
      sothat('the developer is walked through profile name, sso auth, etc.')

given('a key that is already configured')
  when('`rhx keyrack set --key $KEY`')
    then('warned that this key already has a configuration')
    then('prompted to confirm overwrite or cancel')
      sothat('accidental overwrite of vault references is prevented')

---

# usecase.4 = unlock a vault

given('a key with an os.secure vault that is locked')
  when('`rhx keyrack unlock --key $KEY`')
    then('the age passphrase prompt is triggered')
      sothat('the developer provides their encryption passphrase')
    then('on success, reports "unlocked"')
    then('passphrase is consumed and discarded â€” never retained by rhachet')
      sothat('vault credentials are not a leakage vector')
    then('the unlock flow is identical on linux, macos, windows, ci, and docker')
      sothat('one code path works everywhere node runs')

given('a key with a 1password vault that is locked')
  when('`rhx keyrack unlock --key $KEY`')
    then('the 1password auth flow is triggered (via `op` cli)')
    then('on success, reports "unlocked"')
    then('vault key is consumed and discarded')

given('a key with an os.direct vault')
  when('`rhx keyrack unlock --key $KEY`')
    then('reports that os.direct does not require unlock â€” already accessible')
      sothat('no confusion about why unlock is a no-op for plaintext vaults')

given('a key that is not configured on this machine')
  when('`rhx keyrack unlock --key $KEY`')
    then('fail fast: key not configured, run `rhx keyrack set` first')
      sothat('the developer knows unlock requires prior setup')

---

# usecase.5 = findsert semantics (embedded in test commands)

given('keyrack is embedded in `npm run test:integration` setup')
  given('all declared keys are already in env AND safe')
    when('test command runs')
      then('each key reports: already in env, safe â†’ pass through')
      then('no vault access occurs')
        sothat('ci where env vars are pre-granted is a no-op')
      then('tests proceed')

  given('a declared key is in env but violates the declared mechanism')
    when('test command runs')
      then('the key reports: ğŸš« already in env, NOT safe')
      then('the block message names the violation')
      then('tests do not proceed')
        sothat('leaked long-lived pats in ci are caught before tests run')

  given('declared keys are not in env, vaults are unlocked')
    when('test command runs')
      then('each key is loaded from the keyrack')
      then('each key reports: ğŸ«§ not in env â†’ ğŸ”‘ granted')
      then('tests proceed with granted values')
        sothat('local developers just run tests without a separate keyrack step')

  given('declared keys are not in env, one vault is locked')
    when('test command runs')
      then('the locked key reports ğŸ”’ locked with fix command')
      then('a clear stderr message is emitted')
        sothat('robots (ci agents, claude code, etc.) know to ask a human to unlock')
        sothat('humans know exactly what command to run')
      then('no keys are mounted')
      then('tests do not proceed')

  given('declared keys are not in env, one key is not configured')
    when('test command runs')
      then('the not-found key reports ğŸ«§ unfound with set command')
      then('no keys are mounted')
      then('tests do not proceed')

---

# usecase.6 = firewall behavior (credential type detection)

given('a key declared with mech: GITHUB_APP')
  given('the raw value is a json blob with appId + privateKey')
    when('the key is resolved')
      then('a short-lived installation token (ghs_...) is granted')
      then('the json blob with the private key is not in the env')
        sothat('private keys never reach downstream processes')

  given('the raw value is a ghp_... long-lived pat')
    when('the key is resolved')
      then('the key is ğŸš« blocked')
      then('the message states that GITHUB_APP requires app credentials, not a pat')
        sothat('the developer knows the pat must be replaced')

  given('the raw value is a ghs_... short-lived token')
    when('the key is resolved')
      then('the token is passed through as ğŸ”‘ granted')
        sothat('already-short-lived tokens are not re-resolved')

given('a key declared with mech: AWS_SSO')
  given('the sso session is valid')
    when('the key is resolved')
      then('temporary aws credentials are granted')
      then('the sso profile reference is not in the env')

  given('the sso session has expired')
    when('the key is resolved')
      then('the key reports ğŸ”’ locked (sso session expired)')
      then('a fix command is printed: `rhx keyrack unlock --key $KEY`')

given('a key declared with mech: GITHUB_APP')
  given('the raw value is an unrecognized format (not json, not ghp_, not ghs_)')
    when('the key is resolved')
      then('the key is ğŸš« blocked')
      then('the message states that GITHUB_APP requires app credentials (json blob) or a short-lived token (ghs_)')
        sothat('the developer knows what format is expected')

  given('the raw value is json but does not match the expected schema (e.g., no appId or no privateKey)')
    when('the key is resolved')
      then('the key is ğŸš« blocked')
      then('the message states which required fields are absent')
        sothat('the developer knows exactly what to fix in the json blob')

given('a key with default mech (REPLICA)')
  given('the raw value is an api key (e.g., sk-..., tvly-...)')
    when('the key is resolved')
      then('the value is passed through as ğŸ”‘ granted')
        sothat('api keys with no short-lived alternative are still usable')

  given('the raw value is a ghp_... long-lived pat')
    when('the key is resolved')
      then('the key is ğŸš« blocked')
      then('the message states that long-lived github pats are forbidden â€” create a github app instead')
        sothat('ghp_ pats are never accepted regardless of declared mechanism')

---

# usecase.7 = ci action step

given('a github actions workflow with `rhachet/keyrack@v1` step')
  given('raw secrets passed via `env:` to the keyrack step')
    when('the keyrack step runs')
      then('short-lived granted tokens are written to `$GITHUB_ENV`')
        sothat('subsequent steps see only the short-lived values')
      then('the raw secrets are NOT written to `$GITHUB_ENV`')
        sothat('private keys and raw credentials stay in the keyrack step only')

  given('a raw secret that is a long-lived pat for a GITHUB_APP key')
    when('the keyrack step runs')
      then('the step fails with ğŸš« blocked')
      then('no values are written to `$GITHUB_ENV`')
        sothat('long-lived pats never reach test steps')

---

# usecase.8 = all-or-none mount policy

given('a repo with N declared keys')
  given('N-1 keys resolve, 1 key does not (not found, locked, or blocked)')
    when('`rhx keyrack get --for repo`')
      then('status for all N keys is reported')
        sothat('the developer sees the full picture, not just the first failure')
      then('no keys are mounted â€” even the N-1 that resolved')
        sothat('no downstream process runs with partial credentials')
      then('the summary names the count of each status category')

  given('all N keys resolve')
    when('`rhx keyrack get --for repo`')
      then('all N keys are mounted')
      then('summary reads "N granted, 0 blocked"')

---

# usecase.9 = human vs robot error guidance

given('a vault is locked when `keyrack get` or findsert runs')
  when('the locked status is reported')
    then('stderr includes guidance for robots: "ask a human to unlock this vault"')
      sothat('ci agents and ai tools know they cannot self-resolve vault auth')
    then('stderr includes guidance for humans: the exact `rhx keyrack unlock` command to run')
      sothat('humans can fix it without guesswork')
    then('stderr includes the vault type (e.g., os.secure, 1password)')
      sothat('the human knows what auth flow to expect')

given('a key is not found when `keyrack get` or findsert runs')
  when('the not-found status is reported')
    then('stderr includes guidance for robots: "ask a human to set up this key"')
      sothat('ci agents and ai tools know they cannot self-resolve credential setup')
    then('stderr includes guidance for humans: the exact `rhx keyrack set` command to run')
      sothat('humans can fix it without guesswork')

---

# usecase.10 = credential lifetime and expiry

given('a granted credential has its own lifetime policy')
  given('github app token (1h lifetime)')
    when('token expires mid-session')
      then('next `get` mints a fresh token if vault is still unlocked')
      then('next `get` reports ğŸ”’ locked if vault lock has expired')
        sothat('the developer knows to re-authenticate')

  given('aws sso session (session-scoped lifetime)')
    when('sso session expires')
      then('next `get` reports ğŸ”’ locked (sso session expired)')
      then('a fix command is printed: `rhx keyrack unlock --key $KEY`')
        sothat('the developer knows to re-authenticate via sso')

  given('replica api key (indefinite lifetime)')
    when('the credential provider revokes the key externally')
      then('keyrack still reports ğŸ”‘ granted')
        sothat('keyrack grants credentials â€” it does not validate them against the provider')
      then('downstream process receives the revoked key and fails')
        sothat('revocation is the provider responsibility, not keyrack')

given('rhachet is asked about credential lifetimes')
  when('credential is exported to env')
    then('rhachet does not track or revoke the credential')
      sothat('credential lifecycle is the provider responsibility')
    then('rhachet cannot un-export a credential from an active process')
      sothat('no false sense of control over credential revocation')

---

# usecase.11 = output format

given('`rhx keyrack get --for repo` runs')
  when('status is reported')
    then('output uses tree structure with unicode box characters')
      sothat('hierarchical status is visually clear')
    then('each key shows: name, vault, mech, status')
      sothat('the developer sees the full picture for each key')
    then('status icons are: ğŸ”‘ granted, ğŸ«§ unfound, ğŸ”’ locked, ğŸš« blocked')
      sothat('status is scannable at a glance')
    then('summary line shows counts per status category')
      sothat('the overall result is immediately clear')

given('output example')
  when('3 keys, all granted')
    then('output resembles:')
      ```
      ğŸ” rhachet/keyrack
      â”œâ”€ BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN
      â”‚  â”œâ”€ vault: 1password
      â”‚  â”œâ”€ mech: GITHUB_APP
      â”‚  â””â”€ status: ğŸ”‘ granted (github app â†’ 1h token)
      â”œâ”€ EHMPATHY_AWS_SSO_PREP
      â”‚  â”œâ”€ vault: os.secure
      â”‚  â”œâ”€ mech: AWS_SSO
      â”‚  â””â”€ status: ğŸ”‘ granted (sso session valid for 3h)
      â”œâ”€ XAI_API_KEY
      â”‚  â”œâ”€ vault: os.direct
      â”‚  â”œâ”€ mech: REPLICA
      â”‚  â””â”€ status: ğŸ”‘ granted
      â””â”€ done. 3 granted, 0 blocked.
      ```

  when('1 key not found')
    then('output includes fix command:')
      ```
      â”œâ”€ XAI_API_KEY
      â”‚  â””â”€ status: ğŸ«§ unfound
      â”‚     â””â”€ fix: rhx keyrack set --key XAI_API_KEY
      ```

  when('1 key locked')
    then('output includes fix command and vault type:')
      ```
      â”œâ”€ EHMPATHY_AWS_SSO_PREP
      â”‚  â””â”€ status: ğŸ”’ locked (sso session expired)
      â”‚     â””â”€ fix: rhx keyrack unlock --key EHMPATHY_AWS_SSO_PREP
      ```

---

# usecase.12 = vault-specific setup guidance

given('developer chooses os.direct vault via `set`')
  when('guided through setup')
    then('prompted to paste the raw credential value')
    then('value is stored in `~/.rhachet/keyrack.direct.json`')
    then('warned that os.direct stores credentials in plaintext')
      sothat('developer makes an informed security tradeoff')

given('developer chooses os.secure vault via `set`')
  when('guided through setup')
    then('prompted to paste the raw credential value')
    then('prompted to enter an age passphrase')
    then('value is encrypted with age and stored in `~/.rhachet/keyrack.secure.{hash}.age`')
    then('passphrase is consumed and discarded â€” never stored')
      sothat('passphrase must be re-entered on each unlock')
    then('setup flow is identical on linux, macos, windows')
      sothat('developer experience is consistent across platforms')

given('developer chooses 1password vault via `set`')
  when('guided through setup')
    then('prompted to specify which 1password item holds the credential')
    then('item reference is stored in `~/.rhachet/keyrack.config.json`')
    then('actual credential is retrieved from 1password at `get` time')
      sothat('credential value is never stored locally by keyrack')

---

# usecase.13 = list configured keys

given('developer wants to see all configured keys')
  when('`rhx keyrack list`')
    then('lists all keys in `~/.rhachet/keyrack.config.json`')
    then('shows vault type for each key')
    then('shows when each key was configured (createdAt)')
    then('does NOT show credential values')
      sothat('list is safe to run in shared contexts')

given('no keys are configured')
  when('`rhx keyrack list`')
    then('reports "no keys configured"')
    then('suggests `rhx keyrack set --key $KEY` to configure keys')

---

# usecase.14 = remove a configured key

given('developer wants to remove a key configuration')
  when('`rhx keyrack del --key $KEY`')
    then('prompted to confirm removal')
    then('on confirm, key is removed from `~/.rhachet/keyrack.config.json`')
    then('if vault is os.direct, value is removed from `~/.rhachet/keyrack.direct.json`')
    then('if vault is os.secure, the `.age` file is deleted')
    then('if vault is 1password, only the reference is removed (1password item is untouched)')
      sothat('del only affects keyrack config, not the external vault')

given('key is not configured')
  when('`rhx keyrack del --key $KEY`')
    then('fail fast: key not configured')

---

# usecase.15 = allowlist enforcement (repo manifest as security boundary)

given('a repo with `.agent/keyrack.yml` that declares keys A, B, C')
  given('a key D that is NOT declared in the manifest')
    given('key D IS configured on this machine with a valid vault')
      when('`rhx keyrack get --key D`')
        then('the key reports status: ğŸ«§ absent')
          sothat('keyrack refuses to look up keys not in the allowlist')
        then('the message states "key not found in repo manifest"')
          sothat('the developer knows the key must be added to keyrack.yml first')
        then('keyrack does NOT check the host manifest for key D')
          sothat('no credential enumeration via brute-force key guesses')
        then('keyrack does NOT check any vault for key D')
          sothat('vault access is scoped to the allowlist only')

    given('key D is NOT configured on this machine')
      when('`rhx keyrack get --key D`')
        then('the key reports status: ğŸ«§ absent')
        then('the message states "key not found in repo manifest"')
          sothat('the error is about allowlist, not about host setup')
        then('the fix command suggests to add key D to keyrack.yml')
          sothat('the developer knows the manifest is the gate, not the host config')

given('a rogue actor attempts to enumerate host credentials via keyrack')
  when('rogue actor calls `keyrack get --key SECRET_KEY_1` for a key not in manifest')
    then('keyrack returns "absent" immediately')
      sothat('keyrack does not reveal whether the key exists on the host')
  when('rogue actor calls `keyrack get --key SECRET_KEY_2` for another key not in manifest')
    then('keyrack returns "absent" immediately')
      sothat('no information is leaked about host credential inventory')
  when('rogue actor loops through many key names not in manifest')
    then('every attempt returns "absent" with the same message')
      sothat('there is no time or message difference that leaks information')

given('keyrack get is called with --for repo')
  when('the repo manifest declares keys A, B, C')
    then('only keys A, B, C are resolved')
      sothat('the manifest bounds the scope of credential resolution')
    then('no other keys from the host manifest are exposed')
      sothat('keyrack.yml is the allowlist that protects the host')

given('ci environment has many credentials in process.env')
  given('repo manifest only declares 2 of those credentials')
    when('keyrack get --for repo runs')
      then('only the 2 declared keys are checked')
        sothat('ci secrets not in the manifest are not touched')
      then('the other ci secrets remain invisible to keyrack')
        sothat('manifest is the allowlist even in credential-rich environments')
