wish =

take a look at the vision that a caller of rhachet had for what they want to exist, here

.behavior/v2026_02_05.keyrack/.refs/caller.vision.md


we want to support that vision

we want to support it via

- an export of rhachet/keyrack for programatic sdk usage
- a command in rhachet cli, `rhachet keyrack`
- an override in `rhx` as `rhx keyrack`

we want to be able to say 

`rhx keyrack use`

and itll look at the @gitroot/keyrack.yml 

check for the list of the ENV_VAR keys that the repo has declared need to be mounted in order for the tests or whatnot to run

and then use it 


---

we also want to allow users to say


rhx keyrack use --key XAI_API_KEY 

or 

rhx keyrack use --key EHMPATHY_AWS_SSO_PREP

---

we want this to be backed by a global store on the caller's machine, similar to how use.apikeys.sh works today

except we also need to be able to say 

rhx keyrack set --key EHMPATHY_AWS_SSO_PREP --mech AWS_SSO --vault 1password

which will guide the user through how to set that in their local env securely, against their 1password persistence backend

----

we also want to be able to let users not have a remote persisted backend

e.g.,


rhx keyrack set --key XAI_API_KEY --vault os.secure (which uses a secure encryption vault on that os)

or 

rhx keyrack set --key XAI_API_KEY --vault os.plaintext (which sets the key directly as plaintext)


---

we'll need to support different mechanisms for api key translation

default = 
- REPLICA (long lived tokens that have no alternatives)

other mechs include
- AWS_SSO (uses the sso procedure to authenticate the current user; see ehmpathy/declastruct-aws github repo's provision dir steps for examples)

- GITHUB_APP (uses the github app procedure to authenticate the current user; see ehmpathy/declastruct-github github repo's provision dir steps for examples)

we'll want this to be extensible, so use the adapter pattern so we can easily dispatch to the right adapter to translate the inputs && request the required inputs from the user 

---

we'll want different --vaults available

i.e., 

--vault os.secure (noted above); requires a key to access
--vault os.direct (rather than plaintext, lets use direct); no key requierd, direct access for any actor on the machine

--vault 1password (uses the 1pass shell; requires user to have authed into 1pass already, we'll just chain the shell commands for them as desired)

---

all of the records of where to find these keys should be persisted inside the global ~/.rhachet/keyrack dir on the device

specifically, within ~/.rhachet/keyrack.config.json 

that's the user's keyrack config

in there, we'll serialize via .json where to find each key

if its direct access, then it'll be in ~/.rhachet/keyrack.direct.json 

if its secure access, then it'll be in its own SECURED location; and if the os.secure mechanism requires a location for that secure file, it'll be in ~/.rhachet.keyrack.secure.$hashOfKeyName.sha ; and the .config.json will say { $keyname: { vault: $vault, createdAt, updatedAt } } 

and that'll be enough to know where to find it 

same for 1password

---

that way, it doesn't matter where the caller chooses to store the keys on their machine, all callers can store them in differnet locations, and the keyrack will be able to find them - or failfast and tell them how to safely and easily add them

---

and, specifically

we'll expect that 

rhx keyrack get --for repo  (forget the `keyrack use` idea, we'll stick with get/set

will look for a `@gitroot/.agent/keyrack.yml` and failfast if not found

and we'll expect that  if found, it'll run, internally `rhx keyrack get --key $key` for each key listed

rhx keyrack get --key $key  being the operation which tries to get the key from the keyrack based on the keyrack.config 

and tells the user 
- key not found, add it - here's how (probably, the keyrack.yml should prescribe the --mech of the key, which will guide the install)
- key is locked, unlock it the vault that the key is in - here's how 
- key is added, feel free to use it

for each key

and failsfast and doesn't mount any keys if any of the keys are not available. that way, there's no risk of the user to get into a privs escalation hazard


---

overall, we want this to be a firewall, like mentioned in that consumer vision

if we see any longlived key examples, block them and tell them how to replace 

robots shouldn't have access to long lived keys; neither should test envs. its now trivial to get proper keys (e.g., via declastruct-aws and declastruct-github), and rhachet/keyrack will guide users through it


---

the goal is
- pit of success; keeps users safe without them needing to know how, and makes it easy to use. guides them through everything
- portable; cicd, local, your machine, my machine - it just works 
- secure; uses proven extant password vaults and mechanisms to secure your data 

---

e.g.,

- AWS_SSO_PROD_ADMIN ? vault that behind 1pass

- AWS_SSO_PREP_MECHANIC ? vault that on os.secure is fine  

- XAI_API_KEY ? vault that on os.direct is fine ; but, if wanted, can make it os.secure, too


---


and the os.secure is an important case 

we basically want to say that it can be unlocked for a period of N hours 

meaning, subsequent calls to `rhx keyrack get --for repo | --key $key` will all pass for up to N hours 

or, for a full session


so when someone runs the `rhx keyrack unlock --for repo | --key $key`, it should ask them --uptill session-end or 5hrs

where session-end identifies this specific terminal session (maybe via env var; hopefully in a way that doesn't propogate if someone spawns a new terminal from this terminal, but not the end of the world if not)

---

e.g.,

unlock the vault of their ssh key (for os.secure)

or 

unlock the vault of their 1pass (for 1password)

---

and rhachet should be crazy careful with those creds; those are the most important of all. never save them, treat where those are set in the resultant env var crazy careful (and hopefully, we can just consume those creds and not even expose them in the session again)

and maybe yeah, if the key itself expires, then they'll need to unlock their vault again - which is correct

we should't 'cache' their vualt key ever - and we shouldn't set it in the session either

if their key expires, that policy is there for a reason, and they'll need to ask a human to auth again to unlock the vault to get a new key.

---




also, we need to guarantee that `keyrack get` will forbid to get any keys that arent explicitly allowlisted in the
  keyrack.yml for that gitrepo; this must be added to the vision and the criteria and implemented; and covered with
  extensive acceptance tests; this is the main protection against rogue actors who want to search your creds; the
  keyrack.yml is the allowlist that limits the scope that keyrack exposes you to. (it will flatout refuse to check the
  keyrack host unless keyrack.yml has explicitly allowlisted it)

