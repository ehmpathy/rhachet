# research: test codepath patterns

> patterns in this repo relevant to keyrack test implementation

---

## summary table

| pattern | file location | use case | mark |
|---------|--------------|----------|------|
| given/when/then | `invokeAct.test.ts` | cli command unit tests | [REUSE] |
| mock context | `genMockContextConfigOfUsage.ts` | context fixture | [EXTEND] |
| temp dir | `genTestTempDir.ts` | filesystem isolation | [REUSE] |
| temp assets | `setTestTempAsset.ts` | file creation | [EXTEND] |
| cli unit test | `invokeAct.test.ts` | command handlers | [REUSE] |
| cli integration | `invokeAct.integration.test.ts` | domain logic with fixtures | [REUSE] |
| config file i/o | `getRoleRegistryManifest.integration.test.ts` | yaml/json read/write | [EXTEND] |
| file system | `findsertRepoGitignore.integration.test.ts` | file presence/state | [EXTEND] |
| acceptance bbox | `act.acceptance.test.ts` | binary invocation | [REUSE] |
| temp repo fixture | `genTestTempRepo.ts` | fixture generation | [EXTEND] |
| cli binary invoke | `invokeRhachetCliBinary.ts` | black-box execution | [EXTEND] |
| useBeforeAll | `rhx.acceptance.test.ts` | async setup/cache | [REUSE] |
| error assert | `getSkillContext.test.ts` | error assertions | [REUSE] |
| type safety | `Template.test.ts` | type validation | [EXTEND] |
| jest mocks | `invokeAct.test.ts` | dependency mock | [EXTEND] |
| spies/clear | `invokeAct.test.ts` | interaction verification | [REUSE] |

---

## pattern 1: given/when/then structure

**file:** `src/contract/cli/invokeAct.test.ts:25-220`

```typescript
import { getError, given, then, when } from 'test-fns';

describe('invokeAct', () => {
  given('invokeAct is registered on a CLI program', () => {
    let program: Command;

    beforeEach(() => {
      program = new Command();
      program.exitOverride();
    });

    when('act command is called with valid args', () => {
      then('executes the skill with brain', async () => {
        await program.parseAsync([...], { from: 'user' });
        expect(mockBrain.act).toHaveBeenCalled();
      });
    });
  });
});
```

**mark:** [REUSE]

ideal for keyrack cli tests (`rhx keyrack get/set/del`).

---

## pattern 2: mock context configuration

**file:** `src/.test/genMockContextConfigOfUsage.ts:14-56`

```typescript
export const genMockContextConfigOfUsage = (input?: {
  isExplicit?: boolean;
  explicitPath?: string;
  registries?: RoleRegistry[];
  brains?: BrainRepl[];
  hooks?: RoleHooksOnDispatch | null;
}): ContextConfigOfUsage => {
  return {
    config: {
      usage: {
        isExplicit: () => isExplicit,
        getExplicitPath: () => explicitPath,
        get: {
          registries: { explicit: async () => ({ registries }) },
          brains: { explicit: async () => brains },
          hooks: { explicit: async () => hooks },
        },
      },
    },
  };
};
```

**mark:** [EXTEND]

create similar helper `genMockKeyrackConfig` for credential vault state.

---

## pattern 3: temp directory management

**file:** `src/.test/infra/genTestTempDir.ts:8-43`

```typescript
export const genTestTempDir = (input: {
  base: string;
  name: string;
}): {
  path: string;
  setup: () => void;
  teardown: () => void;
  rm: (relativePath: string) => void;
} => {
  const testDir = resolve(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,
    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },
    teardown: () => {
      process.chdir(originalCwd);
    },
    rm: (relativePath: string) => {
      rmSync(resolve(testDir, relativePath), { force: true, recursive: true });
    },
  };
};
```

**mark:** [REUSE]

perfect for test `~/.rhachet/keyrack.config.json` read/write/delete operations.

---

## pattern 4: temp asset creation

**file:** `src/.test/infra/setTestTempAsset.ts:8-40`

```typescript
export const setTestTempAsset = (input: {
  dir: string;
  name: string;
  content: string;
  executable?: boolean;
}): { path: string; } => {
  // guard: ensure we write to a temp directory
  if (!input.dir.includes('.temp'))
    throw new Error(`dir must be under .temp for safety`);

  const assetPath = resolve(input.dir, input.name);
  mkdirSync(dirname(assetPath), { recursive: true });
  writeFileSync(assetPath, input.content);

  const shouldExecute = input.executable ?? input.name.endsWith('.sh');
  if (shouldExecute) chmodSync(assetPath, '755');

  return { path: assetPath };
};
```

**mark:** [EXTEND]

adapt for test keyrack.config.json files with specific vault configurations.

---

## pattern 5: cli unit test with mocks

**file:** `src/contract/cli/invokeAct.test.ts:1-220`

```typescript
jest.mock('@src/domain.operations/invoke/discoverSkillExecutables', () => ({
  discoverSkillExecutables: jest.fn()
    .mockReturnValue([{ path: '/fake/.agent/skills/summarize.sh', name: 'summarize.sh' }]),
}));

describe('invokeAct', () => {
  const testRole = new Role({
    slug: 'tester',
    name: 'Tester',
    purpose: 'test role for CLI tests',
  });

  const mockBrain = {
    repo: 'anthropic',
    slug: 'anthropic/claude',
    act: jest.fn().mockResolvedValue({ summary: 'test summary' }),
  } as unknown as BrainRepl;

  given('invokeAct is registered on a CLI program', () => {
    let program: Command;
    let logSpy: jest.SpyInstance;

    beforeEach(() => {
      program = new Command();
      program.exitOverride();
      logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      jest.clearAllMocks();

      const mockContext = genMockContextConfigOfUsage({
        isExplicit: true,
        explicitPath: '/fake/rhachet.use.ts',
        registries: [mockRegistry],
        brains: [mockBrain],
      });
      invokeAct({ program }, mockContext);
    });

    when('act command is called with valid args', () => {
      then('executes the skill with brain', async () => {
        await program.parseAsync(['act', '--role', 'tester', '--skill', 'summarize'],
          { from: 'user' });
        expect(mockBrain.act).toHaveBeenCalled();
      });
    });
  });
});
```

**mark:** [REUSE]

ideal pattern for unit tests of `rhx keyrack get`, `set`, `del` commands.

---

## pattern 6: config file test with temp repo

**file:** `src/domain.operations/manifest/getRoleRegistryManifest.integration.test.ts:11-99`

```typescript
import { given, then, useBeforeAll, when } from 'test-fns';
import { mkdirSync, writeFileSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

describe('getRoleRegistryManifest', () => {
  given('[case1] a package with valid rhachet.repo.yml', () => {
    const scene = useBeforeAll(async () => {
      const packageRoot = join(tmpdir(), `rhachet-test-manifest-${Date.now()}`);
      mkdirSync(packageRoot, { recursive: true });

      const validManifest = `
slug: test-repo
readme: readme.md
roles:
  - slug: mechanic
    readme: roles/mechanic/readme.md
    briefs:
      dirs: roles/mechanic/briefs
    skills:
      dirs: roles/mechanic/skills
`;
      writeFileSync(join(packageRoot, 'rhachet.repo.yml'), validManifest);
      return { packageRoot };
    });

    when('[t0] getRoleRegistryManifest is called', () => {
      then('returns a RoleRegistryManifest instance', () => {
        const result = getRoleRegistryManifest({ packageRoot: scene.packageRoot });
        expect(result).toBeInstanceOf(RoleRegistryManifest);
      });
    });
  });

  given('[case2] a package without rhachet.repo.yml', () => {
    const scene = useBeforeAll(async () => {
      const packageRoot = join(tmpdir(), `rhachet-test-no-manifest-${Date.now()}`);
      mkdirSync(packageRoot, { recursive: true });
      return { packageRoot };
    });

    when('[t0] getRoleRegistryManifest is called', () => {
      then('throws BadRequestError', async () => {
        const error = await getError(() =>
          getRoleRegistryManifest({ packageRoot: scene.packageRoot })
        );
        expect(error).toBeInstanceOf(BadRequestError);
        expect(error.message).toContain('rhachet.repo.yml');
      });
    });
  });
});
```

**mark:** [EXTEND]

adapt for test `~/.rhachet/keyrack.config.json` parse and validation with different vault types.

---

## pattern 7: file system isolation

**file:** `src/domain.operations/invoke/link/findsertRepoGitignore.integration.test.ts:16-95`

```typescript
describe('findsertRepoGitignore', () => {
  const testDir = resolve(__dirname, './.temp/findsertRepoGitignore');
  const repoDir = resolve(testDir, '.agent/repo=test');
  const originalCwd = process.cwd();

  beforeAll(() => {
    rmSync(testDir, { recursive: true, force: true });
    mkdirSync(repoDir, { recursive: true });
    process.chdir(testDir);
  });

  afterAll(() => {
    process.chdir(originalCwd);
    rmSync(testDir, { recursive: true, force: true });
  });

  beforeEach(() => {
    const gitignorePath = resolve(repoDir, '.gitignore');
    if (existsSync(gitignorePath)) {
      rmSync(gitignorePath);
    }
  });

  given('[case1] directory exists, no .gitignore', () => {
    when('[t0] findsertRepoGitignore called', () => {
      then('creates file with correct content, status=created', () => {
        const result = findsertRepoGitignore({ repoDir });
        expect(result.status).toEqual('created');

        const content = readFileSync(resolve(repoDir, '.gitignore'), 'utf8');
        expect(content).toContain('.what = tells git to ignore this dir');
      });
    });
  });
});
```

**mark:** [EXTEND]

use for keyrack config file presence, creation, and update scenarios.

---

## pattern 8: acceptance test with temp repo

**file:** `accept.blackbox/cli/act.acceptance.test.ts:1-122`

```typescript
import { given, then, useBeforeAll, when } from 'test-fns';
import { genTestTempRepo } from '@/blackbox/.test/infra/genTestTempRepo';
import { invokeRhachetCliBinary } from '@/blackbox/.test/infra/invokeRhachetCliBinary';

describe('rhachet act', () => {
  given('[case1] repo with registry but no brains', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-registry' })
    );

    when('[t0] act --role any --skill say-hello', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['act', '--role', 'any', '--skill', 'say-hello'],
          cwd: repo.path,
          logOnError: false,
        })
      );

      then('exits with non-zero status', () => {
        expect(result.status).not.toEqual(0);
      });

      then('stderr contains error about no brains', () => {
        expect(result.stderr).toContain('no brains available');
      });
    });
  });
});
```

**mark:** [REUSE]

ideal for blackbox tests of keyrack cli commands.

---

## pattern 9: temp repo fixture generation

**file:** `accept.blackbox/.test/infra/genTestTempRepo.ts:46-91`

```typescript
export type TestRepoFixture =
  | 'minimal'
  | 'with-skills'
  | 'with-registry'
  | 'with-inits'

export const genTestTempRepo = (input: {
  fixture: TestRepoFixture;
  suffix?: string;
  install?: boolean;
}): { path: string; } => {
  // gen unique temp directory path
  const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${input.suffix ? `-${input.suffix}` : ''}`);

  // copy fixture assets into temp repo
  const fixturePath = join(ASSETS_DIR, input.fixture);
  cpSync(fixturePath, repoPath, { recursive: true });

  // make shell skills executable
  setSkillsExecutable({ dir: repoPath });

  // init git repo (required for rhachet)
  execSync('git init', { cwd: repoPath, stdio: 'ignore' });
  execSync('git config user.email "test@example.com"', { cwd: repoPath, stdio: 'ignore' });
  execSync('git config user.name "Test User"', { cwd: repoPath, stdio: 'ignore' });

  // install dependencies if requested
  if (input.install && existsSync(join(repoPath, 'package.json'))) {
    execSync('bun install', { cwd: repoPath, stdio: 'inherit', timeout: 120000 });
  }

  return { path: repoPath };
};
```

**mark:** [EXTEND]

create keyrack-specific fixtures:
- `with-keyrack-config`
- `with-vault-os-direct`
- `with-vault-os-secure`
- `with-vault-1password`

---

## pattern 10: cli binary invocation

**file:** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:15-46`

```typescript
const RHACHET_BIN = resolve(__dirname, '../../../bin/run');
const RHX_BIN = resolve(__dirname, '../../../bin/rhx');

export const invokeRhachetCliBinary = (input: {
  binary?: 'rhachet' | 'rhx';
  args: string[];
  cwd: string;
  stdin?: string;
  logOnError?: boolean;
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const binPath = input.binary === 'rhx' ? RHX_BIN : RHACHET_BIN;
  const result = spawnSync(binPath, input.args, {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
    env: input.env ? { ...process.env, ...input.env } : undefined,
  });

  const shouldLog = input.logOnError ?? true;
  if (shouldLog && result.status !== 0) {
    console.error('stderr:', result.stderr);
    console.error('stdout:', result.stdout);
  }

  return result;
};
```

**mark:** [EXTEND]

reuse with `binary: 'rhx'` and `args: ['keyrack', 'get', ...]` for keyrack acceptance tests.

---

## pattern 11: error assertion

**file:** `src/domain.operations/invoke/getSkillContext.test.ts:30-114`

```typescript
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';
import { getError, given, then, when } from 'test-fns';

describe('getSkillContext', () => {
  given('a valid context getter that requires OPENAI_API_KEY', () => {
    const getter = getterExample.clone();

    when('called with passin: { wrongKey: "oops" }', () => {
      then('it should throw BadRequestError', async () => {
        const error = await getError(async () =>
          getSkillContext({
            getter,
            from: { passin: { wrongKey: 'oops' } as any },
          })
        );

        expect(error).toBeInstanceOf(BadRequestError);
      });
    });

    when('called with env: {} (key absent)', () => {
      then('it should throw BadRequestError', async () => {
        const error = await getError(async () =>
          getSkillContext({
            getter,
            from: { lookup: { env: {} } },
          })
        );

        expect(error).toBeInstanceOf(BadRequestError);
      });
    });
  });
});
```

**mark:** [REUSE]

use for error scenarios in keyrack (vault config absent, invalid credentials, etc).

---

## pattern 12: config read/write test

**file:** `src/_topublish/rhachet-brains-anthropic/src/hooks/config.dao.test.ts:8-141`

```typescript
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { given, then, useBeforeAll, when } from 'test-fns';

describe('config.dao', () => {
  describe('readClaudeCodeSettings', () => {
    given('[case1] empty repo (no .claude/settings.json)', () => {
      const repo = useBeforeAll(async () => {
        const dir = path.join(os.tmpdir(), `claude-config-test-${Date.now()}`);
        await fs.mkdir(dir, { recursive: true });
        return { path: dir };
      });

      when('[t0] read is called', () => {
        const scene = useBeforeAll(async () => {
          const settings = await readClaudeCodeSettings({ from: repo.path });
          return { settings };
        });

        then('returns empty object', () => {
          expect(scene.settings).toEqual({});
        });
      });
    });

    given('[case2] repo with settings.json', () => {
      const repo = useBeforeAll(async () => {
        const dir = path.join(os.tmpdir(), `claude-config-test-${Date.now()}`);
        await fs.mkdir(path.join(dir, '.claude'), { recursive: true });
        await fs.writeFile(
          path.join(dir, '.claude', 'settings.json'),
          JSON.stringify({ hooks: { SessionStart: [...] } }),
          'utf-8',
        );
        return { path: dir };
      });

      when('[t0] read is called', () => {
        const scene = useBeforeAll(async () => {
          const settings = await readClaudeCodeSettings({ from: repo.path });
          return { settings };
        });

        then('returns parsed settings', () => {
          expect(scene.settings.hooks).toBeDefined();
        });
      });
    });
  });
});
```

**mark:** [REUSE]

perfect pattern for keyrack config read/write/merge operations.

---

## pattern 13: spy and clear

**file:** `src/contract/cli/invokeAct.test.ts:62-86`

```typescript
given('invokeAct is registered on a CLI program', () => {
  let program: Command;
  let logSpy: jest.SpyInstance;

  beforeEach(() => {
    program = new Command();
    program.exitOverride();
    logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    jest.clearAllMocks();

    const mockContext = genMockContextConfigOfUsage({...});
    invokeAct({ program }, mockContext);
  });

  afterEach(() => {
    logSpy.mockRestore();
  });

  when('act command is called with valid args', () => {
    then('executes the skill with brain', async () => {
      await program.parseAsync([...], { from: 'user' });
      expect(mockBrain.act).toHaveBeenCalled();
      expect(logSpy).toHaveBeenCalledWith(
        expect.stringContains('act rigid skill')
      );
    });
  });
});
```

**mark:** [REUSE]

use to verify keyrack vault access calls and console output.

---

## keyrack test recommendations

### unit tests

- use `given/when/then` with mocked vault access functions
- mock filesystem for `~/.rhachet/keyrack.config.json`
- test each command: get, set, del

### integration tests

- extend file i/o patterns for keyrack.config.json
- test vault type resolution (os.direct, os.secure, 1password)
- test mechanism adapters (REPLICA, GITHUB_APP, AWS_SSO)

### acceptance tests

- use black-box pattern with compiled binary
- create fixtures:
  - `with-keyrack-manifest` — repo with `.agent/keyrack.yml`
  - `with-keyrack-config` — user home with `~/.rhachet/keyrack.config.json`
  - `with-vault-os-direct` — plaintext vault
  - `with-vault-os-secure` — age-encrypted vault

### error scenarios

- vault not configured
- vault locked
- mechanism violation (ghp_ blocked)
- manifest absent
- key unfound
