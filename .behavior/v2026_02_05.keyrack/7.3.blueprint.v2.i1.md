# blueprint v2: keyrack ci action as firewall via os.envvar vault

> refined implementation blueprint for the ci action rewrite as a firewall, via `os.envvar` as a first-check vault in the current grant flow

---

## 0. context

### the core requirement: idempotency

the wish and criteria prescribe a **core idempotency requirement**: `rhx keyrack get` must be safe to call redundantly. the same command may execute multiple times in the same session:

1. **ci action calls it** â†’ writes safe grants to `$GITHUB_ENV`
2. **test command calls it again** (embedded in test setup) â†’ must not fail or conflict
3. **developer calls it locally** â†’ then runs tests that also call it â†’ must passthrough

without idempotency, the github action cannot work. the action writes grants to `$GITHUB_ENV`, and subsequent steps inherit those env vars. if a test command internally calls `rhx keyrack get`, it must recognize the already-granted values and passthrough â€” not fail because "no host manifest entry found".

### the blocker

the current implementation lacks this idempotency. it always looks up the host manifest (`~/.rhachet/keyrack.manifest.json`) to find where a key is stored. this fails when:
- **ci runners** have no host manifest (and shouldn't need one)
- **local env** already has a granted value in the environment
- **embedded calls** re-run after a prior grant

### the solution: os.envvar as a first-class vault

add `os.envvar` as a **first-class vault** â€” a full `KeyrackHostVaultAdapter` implementation just like `os.direct`, `os.secure`, and `1password`. the only difference: os.envvar is **always checked first** in the grant flow.

```
vault adapters (all first-class):
â”œâ”€â”€ os.envvar   â†’ reads process.env[slug], always checked first
â”œâ”€â”€ os.direct   â†’ reads ~/.rhachet/keyrack.direct.json
â”œâ”€â”€ os.secure   â†’ reads encrypted files via age
â””â”€â”€ 1password   â†’ reads via op cli
```

```
grant flow priority:
1. check os.envvar vault first
   â†’ if present: validate via mechanism, grant
   â†’ if absent: fall through to host manifest vault
2. check host manifest â†’ lookup configured vault (os.direct, os.secure, 1password)
```

this means:
- **ci**: secrets arrive via `env:` block â†’ os.envvar finds them â†’ mechanism validates â†’ grant
- **local**: env var absent â†’ falls through to configured vault â†’ normal flow
- **re-grant**: already-granted value in env â†’ os.envvar finds it â†’ passthrough

the same `rhx keyrack get --for repo` command becomes the firewall when env vars are set. no new domain operation needed. no new cli command needed. the mechanism validation IS the firewall â€” already built into the grant flow.

### the vision: firewall

the vision (usecase 3, usecase 7 in criteria) prescribes the ci action as a **firewall**:
- github secrets come in as env vars
- keyrack.yml prescribes the mechanism for each key
- the action applies the mechanism (validate + translate)
- safe (short-lived) grants come out to `$GITHUB_ENV`
- raw secrets never reach subsequent steps

---

## 1. filediffs treestruct

**legend:**
- `[+]` create â€” file to create
- `[~]` update â€” file to update

```
src/
â”œâ”€â”€ domain.objects/keyrack/
â”‚   â””â”€â”€ [~] KeyrackHostVault.ts                            # add 'os.envvar' to union
â”‚
â”œâ”€â”€ domain.operations/keyrack/
â”‚   â”œâ”€â”€ [~] getKeyrackKeyGrant.ts                          # check os.envvar first in attemptGrantKey
â”‚   â”œâ”€â”€ [~] genKeyrackGrantContext.ts                      # add os.envvar adapter to vault adapters
â”‚   â””â”€â”€ adapters/vaults/
â”‚       â”œâ”€â”€ [+] vaultAdapterOsEnvvar.ts                    # new: reads process.env[slug]
â”‚       â”œâ”€â”€ [+] vaultAdapterOsEnvvar.test.ts               # unit tests
â”‚       â””â”€â”€ [~] index.ts                                   # export vaultAdapterOsEnvvar

.github/actions/keyrack/
â””â”€â”€ [~] action.yml                                         # full rewrite as firewall
```

---

## 2. codepaths treestruct

**legend:**
- `[+]` create
- `[~]` update
- `[â—‹]` retain

```
grant flow (attemptGrantKey)
â”œâ”€â”€ [â—‹] find keySpec in repoManifest
â”œâ”€â”€ [+] check os.envvar vault first
â”‚   â”œâ”€â”€ [+] process.env[slug] â†’ value found?
â”‚   â”‚   â”œâ”€â”€ yes â†’ skip host manifest lookup, skip vault unlock
â”‚   â”‚   â”‚   â”œâ”€â”€ [â—‹] mechAdapter.validate({ value })
â”‚   â”‚   â”‚   â”œâ”€â”€ [â—‹] mechAdapter.translate({ value })
â”‚   â”‚   â”‚   â””â”€â”€ [â—‹] construct KeyrackKeyGrant with source.vault = 'os.envvar'
â”‚   â”‚   â””â”€â”€ no â†’ fall through to host manifest vault
â”‚   â”‚       â””â”€â”€ [â—‹] prior flow (keyHost lookup â†’ vault adapter â†’ mechanism)
â”œâ”€â”€ [â—‹] find keyHost in hostManifest
â”œâ”€â”€ [â—‹] vault adapter get/unlock/validate
â””â”€â”€ [â—‹] mechanism validate + translate

vault adapter: os.envvar
â”œâ”€â”€ [+] isUnlocked() â†’ true (always)
â”œâ”€â”€ [+] get({ slug }) â†’ process.env[slug] ?? null
â”œâ”€â”€ [+] set() â†’ throw UnexpectedCodePathError (read-only vault)
â”œâ”€â”€ [+] del() â†’ throw UnexpectedCodePathError (read-only vault)
â””â”€â”€ [+] unlock() â†’ no-op (always unlocked)

ci action
â”œâ”€â”€ [~] setup step â†’ install rhachet
â”œâ”€â”€ [~] grant step â†’ rhx keyrack get --for repo --json
â”‚   â”œâ”€â”€ [+] for each granted key: write to $GITHUB_ENV + ::add-mask::
â”‚   â”œâ”€â”€ [+] if any key fails: exit 1, write zero
â”‚   â””â”€â”€ [+] outputs: granted (json array), failed (json array)
â””â”€â”€ [-] unlock step â†’ removed (not applicable for os.envvar)
```

---

## 3. contracts

### 3.1 updated KeyrackHostVault

```typescript
type KeyrackHostVault = 'os.direct' | 'os.secure' | '1password' | 'os.envvar';
```

`os.envvar` is a read-only vault â€” it reads from `process.env[slug]`. no storage, no unlock, no set. it's the "vault" for values that are already in the environment (ci secrets, local exports, etc.).

### 3.2 vaultAdapterOsEnvvar

```typescript
/**
 * .what = vault adapter that reads from process.env
 * .why = passthrough for env vars (ci secrets, local exports)
 *
 * .note = read-only vault â€” set and del throw UnexpectedCodePathError
 * .note = always unlocked â€” no authentication required
 */
export const vaultAdapterOsEnvvar: KeyrackHostVaultAdapter = {
  isUnlocked: async () => true,
  unlock: async () => {},
  get: async (input: { slug: string }) => process.env[input.slug] ?? null,
  set: async () => { throw new UnexpectedCodePathError('os.envvar is read-only'); },
  del: async () => { throw new UnexpectedCodePathError('os.envvar is read-only'); },
};
```

### 3.3 updated attemptGrantKey flow

```typescript
const attemptGrantKey = async (input, context) => {
  const { slug } = input;

  // find key spec in repo manifest
  const keySpec = context.repoManifest?.keys[slug];
  if (!keySpec) return { status: 'absent', ... };

  // check os.envvar first â€” passthrough for ci and local env
  const envValue = await context.vaultAdapters['os.envvar'].get({ exid: null, slug });
  if (envValue !== null) {
    // value found in env â€” skip host manifest, skip vault unlock
    // apply mechanism validation (this is the firewall)
    const mechAdapter = context.mechAdapters[keySpec.mech];
    const validation = mechAdapter.validate({ value: envValue });
    if (!validation.valid) return { status: 'blocked', slug, message: validation.reason, ... };

    const translatedValue = await mechAdapter.translate({ value: envValue });
    return { status: 'granted', grant: new KeyrackKeyGrant({
      slug, value: translatedValue, source: { vault: 'os.envvar', mech: keySpec.mech },
    })};
  }

  // fall through to host manifest vault (prior flow)
  const keyHost = context.hostManifest.hosts[slug];
  if (!keyHost) return { status: 'absent', ... };
  // ... rest of prior flow unchanged
};
```

the key behavior: **if env var is present, skip host manifest entirely**. this means:
- ci runners don't need a host manifest â€” env vars from `env:` block are sufficient
- locally, if you `export XAI_API_KEY=sk-abc`, it gets picked up and validated
- if env var is absent, the prior vault-based flow kicks in

### 3.4 ci action contract

```yaml
# usage in workflow
- name: resolve credentials
  uses: ./.github/actions/keyrack
  env:
    XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
    BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN: ${{ secrets.BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN }}

# subsequent steps see only safe (validated + translated) values
- name: test
  run: npm run test:integration
```

**inputs:** none â€” the action reads `.agent/keyrack.yml` and grants all declared keys.

**on failure:** the action exits with code 1 and fails the job. logs show which keys failed and why.

---

## 4. action.yml rewrite

```yaml
name: keyrack
description: resolve credentials via rhachet keyrack â€” short-lived tokens only

runs:
  using: "composite"
  steps:
    - name: ensure rhachet available
      shell: bash
      run: |
        set -euo pipefail
        if command -v rhx &> /dev/null; then
          echo "ðŸ”­ rhachet already available"
        else
          echo "ðŸ”­ install rhachet..."
          npm install -g rhachet
        fi

    - name: firewall
      id: grant
      shell: bash
      run: |
        set -euo pipefail
        echo "ðŸ”¥ keyrack firewall"

        # verify keyrack.yml is present
        if [ ! -f ".agent/keyrack.yml" ]; then
          echo "â›ˆï¸ .agent/keyrack.yml not found"
          exit 1
        fi

        # resolve credentials via the grant flow
        # os.envvar vault checks process.env first â€” env: block secrets land here
        RESULT=$(rhx keyrack get --for repo --json)

        # check for any failures first (all-or-none)
        FAILED_COUNT=$(echo "$RESULT" | jq '[.[] | select(.status != "granted")] | length')
        if [ "$FAILED_COUNT" -gt 0 ]; then
          echo "â›ˆï¸ $FAILED_COUNT key(s) failed:"
          echo "$RESULT" | jq -r '.[] | select(.status != "granted") | "   â”œâ”€â”€ â›ˆï¸ \(.slug): \(.status) â€” \(.message // "unknown")"'
          echo "::error::$FAILED_COUNT key(s) failed the keyrack firewall"
          exit 1
        fi

        # all keys granted â€” mask + export each value
        GRANTED_SLUGS=$(echo "$RESULT" | jq '[.[] | .grant.slug]')
        echo "$RESULT" | jq -c '.[]' | while IFS= read -r attempt; do
          SLUG=$(echo "$attempt" | jq -r '.grant.slug')
          VALUE=$(echo "$attempt" | jq -r '.grant.value')
          echo "::add-mask::${VALUE}"
          echo "${SLUG}=${VALUE}" >> $GITHUB_ENV
          echo "   â”œâ”€â”€ ðŸ”‘ $SLUG granted"
        done

        GRANTED_COUNT=$(echo "$GRANTED_SLUGS" | jq 'length')
        echo "   â””â”€â”€ $GRANTED_COUNT granted"

        echo "granted=$GRANTED_SLUGS" >> $GITHUB_OUTPUT
```

---

## 5. test coverage

### 5.1 unit tests

**vaultAdapterOsEnvvar.test.ts:**
```
given('[case1] vault is always unlocked', () => {
  when('[t0] isUnlocked called', () => {
    then('returns true', ...);
  });
});

given('[case2] env var is present', () => {
  when('[t0] get called with slug', () => {
    then('returns env value', ...);
  });
});

given('[case3] env var is absent', () => {
  when('[t0] get called with slug', () => {
    then('returns null', ...);
  });
});

given('[case4] write operation attempted', () => {
  when('[t0] set called', () => {
    then('throws UnexpectedCodePathError', ...);
  });
  when('[t1] del called', () => {
    then('throws UnexpectedCodePathError', ...);
  });
});
```

**getKeyrackKeyGrant.test.ts (extended):**
```
given('[caseN] key is present in process.env', () => {
  when('[t0] get called for that key', () => {
    then('grants from os.envvar vault', ...);
    then('skips host manifest lookup', ...);
    then('applies mechanism validation', ...);
  });
});

given('[caseN+1] key is present in both env and host manifest', () => {
  when('[t0] get called for that key', () => {
    then('env takes precedence (os.envvar wins)', ...);
  });
});

given('[caseN+2] key in env fails mechanism validation', () => {
  when('[t0] get called for that key', () => {
    then('returns blocked status', ...);
    then('does not fall through to host manifest', ...);
  });
});
```

### 5.2 integration tests

**vaultAdapterOsEnvvar.integration.test.ts:**
```
given('[case1] real process.env interaction', () => {
  beforeEach(() => {
    process.env['TEST_KEY'] = 'test-value';
  });
  afterEach(() => {
    delete process.env['TEST_KEY'];
  });

  when('[t0] get called for present key', () => {
    then('returns the env value', ...);
  });

  when('[t1] get called for absent key', () => {
    then('returns null', ...);
  });
});
```

**getKeyrackKeyGrant.integration.test.ts (extended):**
```
given('[caseN] env var with REPLICA mechanism', () => {
  beforeEach(() => {
    process.env['XAI_API_KEY'] = 'sk-valid-key';
  });

  when('[t0] keyrack get called', () => {
    then('grants with value from env', ...);
    then('source.vault is os.envvar', ...);
  });
});

given('[caseN+1] env var with GITHUB_APP mechanism', () => {
  beforeEach(() => {
    process.env['GITHUB_TOKEN'] = 'ghs_short-lived-token';
  });

  when('[t0] keyrack get called', () => {
    then('grants with translated value', ...);
  });
});

given('[caseN+2] env var fails firewall (long-lived token)', () => {
  beforeEach(() => {
    process.env['GITHUB_TOKEN'] = 'ghp_long-lived-pat';
  });

  when('[t0] keyrack get called', () => {
    then('returns blocked status', ...);
    then('message explains why blocked', ...);
  });
});
```

### 5.3 acceptance tests

**keyrack.acceptance.test.ts (extended):**
```
given('[caseN] CI firewall scenario', () => {
  const tempRepo = setupTempRepoWithKeyrackYml({
    keys: [{ slug: 'TEST_KEY', mech: 'REPLICA' }],
  });

  when('[t0] key is in env and valid', () => {
    const result = execSync('rhx keyrack get --for repo --json', {
      env: { ...process.env, TEST_KEY: 'sk-valid' },
      cwd: tempRepo,
    });

    then('grants the key', () => {
      const parsed = JSON.parse(result.toString());
      expect(parsed[0].status).toEqual('granted');
      expect(parsed[0].grant.source.vault).toEqual('os.envvar');
    });
  });

  when('[t1] key is in env but invalid (blocked by mech)', () => {
    const result = execSync('rhx keyrack get --for repo --json', {
      env: { ...process.env, TEST_KEY: 'ghp_long-lived' },
      cwd: tempRepo,
    });

    then('blocks the key', () => {
      const parsed = JSON.parse(result.toString());
      expect(parsed[0].status).toEqual('blocked');
    });
  });
});
```

---

## 6. key design decisions

### 6.1 os.envvar is always checked first

the grant flow checks `process.env[slug]` before the host manifest lookup. this means:
- **ci**: secrets arrive via `env:` block â†’ os.envvar finds them â†’ mechanism validates â†’ grant
- **local**: env var absent â†’ falls through to configured vault â†’ normal flow
- **local override**: `export KEY=val && rhx keyrack get --key KEY` â†’ os.envvar wins

this priority is intentional: if a value is already in the environment, use it. the environment is the most immediate source of truth.

### 6.2 no host manifest required when env var is present

if `process.env[slug]` has a value, the host manifest entry for that key is skipped entirely. this means:
- ci runners don't need `~/.rhachet/keyrack.manifest.json`
- a key can be granted even if it has no host manifest entry
- the only requirement is: key must be declared in `.agent/keyrack.yml` (repo manifest)

### 6.3 mechanism validation IS the firewall

no separate "firewall" operation. the current mechanism adapters enforce the firewall:
- `mechAdapterReplica.validate()` rejects long-lived patterns (ghp_*, AKIA*, etc.)
- `mechAdapterGithubApp.validate()` requires valid json or ghs_ token
- `mechAdapterAwsSso.validate()` requires valid sso profile format

the ci action delegates to the same adapters used locally. identical firewall logic everywhere.

### 6.4 action reads keyrack.yml directly

the action has no inputs â€” it reads `.agent/keyrack.yml` and grants all declared keys. the caller passes secrets via the `env:` block so os.envvar can find them.

### 6.5 os.envvar is read-only

`set` and `del` throw `UnexpectedCodePathError`. you can't write to process.env via keyrack â€” env vars are set by the caller (ci workflow, shell export, etc.). keyrack only reads them.

### 6.6 idempotent passthrough â€” safe to call redundantly

`rhx keyrack get` is idempotent. it can be called any number of times on the same env, and the outcome is identical. this is critical because the same `rhx keyrack get --for repo` call may execute in multiple contexts for the same process:

**scenario 1: local developer runs twice**
```sh
rhx keyrack get --for repo          # grants from vault, exports to env
rhx keyrack get --for repo          # os.envvar finds the prior grants â†’ passthrough (or re-translate to safety)
```

second call sees the granted values already in env via os.envvar. mechanism validation re-runs â€” if the value is already safe (e.g., `sk-...` for REPLICA, `ghs_...` for GITHUB_APP), it passes through. if it was translated (e.g., github app json â†’ `ghs_...` token), the translated value is already in env and passes through as safe.

**scenario 2: `npm run test:integration` embeds `rhx keyrack get`**
```sh
# developer already ran keyrack get manually
rhx keyrack get --for repo          # grants from vault â†’ values now in env

# test command also calls keyrack get (embedded in test setup)
npm run test:integration            # internally runs rhx keyrack get â†’ os.envvar passthrough
```

no conflict. the embedded call sees values already in env and validates them. tests proceed.

**scenario 3: ci action + embedded test command**
```yaml
# step 1: keyrack action fires, writes safe grants to $GITHUB_ENV
- uses: ./.github/actions/keyrack
  env:
    XAI_API_KEY: ${{ secrets.XAI_API_KEY }}

# step 2: test command also calls rhx keyrack get internally
- run: npm run test:integration
  # keyrack get sees XAI_API_KEY in env (from GITHUB_ENV) â†’ os.envvar passthrough
```

the action wrote safe values to `$GITHUB_ENV`. the test step inherits those values as env vars. when the embedded `rhx keyrack get` runs, os.envvar finds them, validates them (still safe), and passes through. no double-translation. no conflict.

**why this works:** mechanism adapters are designed so that already-translated values pass validation:
- REPLICA: `sk-...` passes â†’ `sk-...` (passthrough is identity)
- GITHUB_APP: `ghs_...` passes â†’ `ghs_...` (short-lived token passes through)
- AWS_SSO: temporary credentials pass â†’ temporary credentials (already translated)

the only values that get blocked are raw secrets that haven't been through the firewall yet (ghp_*, json blobs with private keys, etc.). once a value has been granted, it's safe to reuse â€” like a hotel keycard, if you walk up to the lobby and ask for keys, they'll see you've already got a safe one you can keep on with.

---

## 7. verification

```sh
# types
npm run test:types

# build
npm run build

# manual test: local with env var override
XAI_API_KEY=sk-test123 npx tsx ./bin/run keyrack get --key XAI_API_KEY --json

# manual test: local without env var (falls through to vault)
npx tsx ./bin/run keyrack get --key XAI_API_KEY --json
```

---

## 8. criteria coverage

this blueprint covers:
- **usecase 5** (findsert / passthrough): os.envvar is the "already in env" check from matrix C. idempotent â€” safe to embed `rhx keyrack get` in test commands that also run after a manual keyrack get or after the ci action
- **usecase 7** (ci action step): env vars from `env:` block â†’ os.envvar â†’ mechanism firewall â†’ safe grants to `$GITHUB_ENV`
- **matrix I** (ci action step): all 6 rows covered by current mechanism adapters + os.envvar vault
- **matrix C** (findsert): env check = os.envvar vault check; cascade = fall through to configured vault. idempotent â€” re-granted values pass through because already-translated values pass mechanism validation
