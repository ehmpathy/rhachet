# blueprint: keyrack ci action as firewall via os.envvar vault

> implementation blueprint for the ci action rewrite as a firewall, via `os.envvar` as a first-check vault in the current grant flow

---

## 0. context

the current `.github/actions/keyrack/action.yml` treats ci like a local machine â€” installs rhachet, uses vault backends (os.direct, os.secure, 1password), accepts passphrase inputs. this misses the core purpose.

the vision (usecase 3, usecase 7 in criteria) prescribes the action as a **firewall**:
- github secrets come in as env vars
- keyrack.yml prescribes the mechanism for each key
- the action applies the mechanism (validate + translate)
- safe (short-lived) grants come out to `$GITHUB_ENV`
- raw secrets never reach subsequent steps

### the insight

instead of a separate `firewallKeyrackKeys` operation, we add `os.envvar` as a vault that's **always checked first** in the current `attemptGrantKey` flow. this means:
- locally: env var absent â†’ falls through to configured vault (os.direct, os.secure, 1password)
- ci: env var present (from `env:` block) â†’ os.envvar finds it â†’ mechanism validates (firewall!) â†’ safe grant out
- the current `rhx keyrack get --for repo` becomes the firewall when env vars are set

no new domain operation needed. no new cli command needed. the mechanism validation IS the firewall â€” it's already built into the grant flow.

---

## 1. filediffs treestruct

**legend:**
- `[+]` create â€” file to create
- `[~]` update â€” file to update

```
src/
â”œâ”€â”€ domain.objects/keyrack/
â”‚   â””â”€â”€ [~] KeyrackHostVault.ts                            # add 'os.envvar' to union
â”‚
â”œâ”€â”€ domain.operations/keyrack/
â”‚   â”œâ”€â”€ [~] getKeyrackKeyGrant.ts                          # check os.envvar first in attemptGrantKey
â”‚   â”œâ”€â”€ [~] genKeyrackGrantContext.ts                      # add os.envvar adapter to vault adapters
â”‚   â””â”€â”€ adapters/vaults/
â”‚       â”œâ”€â”€ [+] vaultAdapterOsEnvvar.ts                    # new: reads process.env[slug]
â”‚       â””â”€â”€ [~] index.ts                                   # export vaultAdapterOsEnvvar

.github/actions/keyrack/
â””â”€â”€ [~] action.yml                                         # full rewrite as firewall
```

---

## 2. codepaths treestruct

**legend:**
- `[+]` create
- `[~]` update
- `[â—‹]` retain

```
grant flow (attemptGrantKey)
â”œâ”€â”€ [â—‹] find keySpec in repoManifest
â”œâ”€â”€ [+] check os.envvar vault first
â”‚   â”œâ”€â”€ [+] process.env[slug] â†’ value found?
â”‚   â”‚   â”œâ”€â”€ yes â†’ skip host manifest lookup, skip vault unlock
â”‚   â”‚   â”‚   â”œâ”€â”€ [â—‹] mechAdapter.validate({ value })
â”‚   â”‚   â”‚   â”œâ”€â”€ [â—‹] mechAdapter.translate({ value })
â”‚   â”‚   â”‚   â””â”€â”€ [â—‹] construct KeyrackKeyGrant with source.vault = 'os.envvar'
â”‚   â”‚   â””â”€â”€ no â†’ fall through to host manifest vault
â”‚   â”‚       â””â”€â”€ [â—‹] prior flow (keyHost lookup â†’ vault adapter â†’ mechanism)
â”œâ”€â”€ [â—‹] find keyHost in hostManifest
â”œâ”€â”€ [â—‹] vault adapter get/unlock/validate
â””â”€â”€ [â—‹] mechanism validate + translate

vault adapter: os.envvar
â”œâ”€â”€ [+] isUnlocked() â†’ true (always)
â”œâ”€â”€ [+] get({ slug }) â†’ process.env[slug] ?? null
â”œâ”€â”€ [+] set() â†’ throw UnexpectedCodePathError (read-only vault)
â”œâ”€â”€ [+] del() â†’ throw UnexpectedCodePathError (read-only vault)
â””â”€â”€ [+] unlock() â†’ no-op (always unlocked)

ci action
â”œâ”€â”€ [~] setup step â†’ install rhachet
â”œâ”€â”€ [~] grant step â†’ rhx keyrack get --for repo --json
â”‚   â”œâ”€â”€ [+] for each granted key: write to $GITHUB_ENV + ::add-mask::
â”‚   â”œâ”€â”€ [+] if any key fails: exit 1, write zero
â”‚   â””â”€â”€ [+] outputs: granted (json array), failed (json array)
â””â”€â”€ [-] unlock step â†’ removed (not applicable for os.envvar)
```

---

## 3. contracts

### 3.1 updated KeyrackHostVault

```typescript
type KeyrackHostVault = 'os.direct' | 'os.secure' | '1password' | 'os.envvar';
```

`os.envvar` is a read-only vault â€” it reads from `process.env[slug]`. no storage, no unlock, no set. it's the "vault" for values that are already in the environment (ci secrets, local exports, etc.).

### 3.2 vaultAdapterOsEnvvar

```typescript
/**
 * .what = vault adapter that reads from process.env
 * .why = enables passthrough for env vars (ci secrets, local exports)
 *
 * .note = read-only vault â€” set and del throw UnexpectedCodePathError
 * .note = always unlocked â€” no authentication required
 */
export const vaultAdapterOsEnvvar: KeyrackHostVaultAdapter = {
  isUnlocked: async () => true,
  unlock: async () => {},
  get: async (input: { slug: string }) => process.env[input.slug] ?? null,
  set: async () => { throw new UnexpectedCodePathError('os.envvar is read-only'); },
  del: async () => { throw new UnexpectedCodePathError('os.envvar is read-only'); },
};
```

### 3.3 updated attemptGrantKey flow

```typescript
const attemptGrantKey = async (input, context) => {
  const { slug } = input;

  // find key spec in repo manifest
  const keySpec = context.repoManifest?.keys[slug];
  if (!keySpec) return { status: 'absent', ... };

  // check os.envvar first â€” passthrough for ci and local env
  const envValue = await context.vaultAdapters['os.envvar'].get({ exid: null, slug });
  if (envValue !== null) {
    // value found in env â€” skip host manifest, skip vault unlock
    // apply mechanism validation (this is the firewall)
    const mechAdapter = context.mechAdapters[keySpec.mech];
    const validation = mechAdapter.validate({ value: envValue });
    if (!validation.valid) return { status: 'blocked', slug, message: validation.reason, ... };

    const translatedValue = await mechAdapter.translate({ value: envValue });
    return { status: 'granted', grant: new KeyrackKeyGrant({
      slug, value: translatedValue, source: { vault: 'os.envvar', mech: keySpec.mech },
    })};
  }

  // fall through to host manifest vault (prior flow)
  const keyHost = context.hostManifest.hosts[slug];
  if (!keyHost) return { status: 'absent', ... };
  // ... rest of prior flow unchanged
};
```

the key behavior: **if env var is present, skip host manifest entirely**. this means:
- ci runners don't need a host manifest â€” env vars from `env:` block are sufficient
- locally, if you `export XAI_API_KEY=sk-abc`, it gets picked up and validated
- if env var is absent, the prior vault-based flow kicks in

### 3.4 ci action contract

```yaml
# usage in workflow
- name: resolve credentials
  uses: ./.github/actions/keyrack
  with:
    keys: 'XAI_API_KEY BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN'
  env:
    XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
    BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN: ${{ secrets.BHUILD_DEMO_REPO_ACCESS_GITHUB_TOKEN }}

# subsequent steps see only safe (validated + translated) values
- name: test
  run: npm run test:integration
```

**inputs:**
- `keys` (optional): space-separated list of key slugs. if empty, grant all keys from repo manifest.

**outputs:**
- `granted`: json array of granted key slugs
- `failed`: json array of failed key slugs with reasons

---

## 4. action.yml rewrite

```yaml
name: keyrack
description: resolve credentials via rhachet keyrack â€” short-lived tokens only

inputs:
  keys:
    description: |
      space-separated list of key slugs to grant
      leave empty to grant all keys from repo manifest
    required: false
    default: ''

outputs:
  granted:
    description: json array of granted key slugs
    value: ${{ steps.grant.outputs.granted }}
  failed:
    description: json array of failed key slugs with reasons
    value: ${{ steps.grant.outputs.failed }}

runs:
  using: "composite"
  steps:
    - name: ensure rhachet available
      shell: bash
      run: |
        set -euo pipefail
        if command -v rhx &> /dev/null; then
          echo "ðŸ”­ rhachet already available"
        else
          echo "ðŸ”­ install rhachet..."
          npm install -g rhachet
        fi

    - name: firewall
      id: grant
      shell: bash
      run: |
        set -euo pipefail
        echo "ðŸ”­ keyrack firewall"

        # verify keyrack.yml is present
        if [ ! -f ".agent/keyrack.yml" ]; then
          echo "â›ˆï¸ .agent/keyrack.yml not found"
          exit 1
        fi

        # resolve credentials via the grant flow
        # os.envvar vault checks process.env first â€” env: block secrets land here
        KEYS="${{ inputs.keys }}"
        if [ -z "$KEYS" ]; then
          RESULT=$(rhx keyrack get --for repo --json)
        else
          RESULT="[]"
          for key in $KEYS; do
            KEY_RESULT=$(rhx keyrack get --key "$key" --json)
            RESULT=$(echo "$RESULT" | jq --argjson r "$KEY_RESULT" '. + [$r]')
          done
        fi

        GRANTED_SLUGS="[]"
        FAILED_SLUGS="[]"

        # parse results, mask + export granted values
        echo "$RESULT" | jq -c '.[]' | while IFS= read -r attempt; do
          STATUS=$(echo "$attempt" | jq -r '.status')

          if [ "$STATUS" = "granted" ]; then
            SLUG=$(echo "$attempt" | jq -r '.grant.slug')
            VALUE=$(echo "$attempt" | jq -r '.grant.value')
            echo "::add-mask::${VALUE}"
            echo "${SLUG}=${VALUE}" >> $GITHUB_ENV
            echo "   â”œâ”€â”€ âœ¨ $SLUG granted"
            GRANTED_SLUGS=$(echo "$GRANTED_SLUGS" | jq --arg k "$SLUG" '. + [$k]')
          else
            SLUG=$(echo "$attempt" | jq -r '.slug')
            MESSAGE=$(echo "$attempt" | jq -r '.message // "unknown error"')
            echo "   â”œâ”€â”€ â›ˆï¸ $SLUG: $STATUS â€” $MESSAGE"
            FAILED_SLUGS=$(echo "$FAILED_SLUGS" | jq --arg k "$SLUG" --arg m "$MESSAGE" '. + [{slug: $k, reason: $m}]')
          fi
        done

        GRANTED_COUNT=$(echo "$GRANTED_SLUGS" | jq 'length')
        FAILED_COUNT=$(echo "$FAILED_SLUGS" | jq 'length')
        echo "   â””â”€â”€ $GRANTED_COUNT granted, $FAILED_COUNT failed"

        echo "granted=$GRANTED_SLUGS" >> $GITHUB_OUTPUT
        echo "failed=$FAILED_SLUGS" >> $GITHUB_OUTPUT

        # all-or-none: if any key failed, exit 1
        if [ "$FAILED_COUNT" -gt 0 ]; then
          echo "::error::$FAILED_COUNT key(s) failed the keyrack firewall"
          exit 1
        fi
```

---

## 5. key design decisions

### 5.1 os.envvar is always checked first

the grant flow checks `process.env[slug]` before the host manifest lookup. this means:
- **ci**: secrets arrive via `env:` block â†’ os.envvar finds them â†’ mechanism validates â†’ grant
- **local**: env var absent â†’ falls through to configured vault â†’ normal flow
- **local override**: `export KEY=val && rhx keyrack get --key KEY` â†’ os.envvar wins

this priority is intentional: if a value is already in the environment, use it. the environment is the most immediate source of truth.

### 5.2 no host manifest required when env var is present

if `process.env[slug]` has a value, the host manifest entry for that key is skipped entirely. this means:
- ci runners don't need `~/.rhachet/keyrack.manifest.json`
- a key can be granted even if it has no host manifest entry
- the only requirement is: key must be declared in `.agent/keyrack.yml` (repo manifest)

### 5.3 mechanism validation IS the firewall

no separate "firewall" operation. the current mechanism adapters enforce the firewall:
- `mechAdapterReplica.validate()` rejects long-lived patterns (ghp_*, AKIA*, etc.)
- `mechAdapterGithubApp.validate()` requires valid json or ghs_ token
- `mechAdapterAwsSso.validate()` requires valid sso profile format

the ci action delegates to the same adapters used locally. identical firewall logic everywhere.

### 5.4 keys input is optional on the action

if `keys` is empty, the action grants all keys from `.agent/keyrack.yml`. if `keys` is provided, only those specific keys are granted. either way, the env vars must be passed via the `env:` block.

### 5.5 os.envvar is read-only

`set` and `del` throw `UnexpectedCodePathError`. you can't write to process.env via keyrack â€” env vars are set by the caller (ci workflow, shell export, etc.). keyrack only reads them.

### 5.6 idempotent passthrough â€” safe to call redundantly

`rhx keyrack get` is idempotent. it can be called any number of times on the same env, and the outcome is identical. this is critical because the same `rhx keyrack get --for repo` call may execute in multiple contexts for the same process:

**scenario 1: local developer runs twice**
```sh
rhx keyrack get --for repo          # grants from vault, exports to env
rhx keyrack get --for repo          # os.envvar finds the prior grants â†’ passthrough (or re-translate to safety)
```

second call sees the granted values already in env via os.envvar. mechanism validation re-runs â€” if the value is already safe (e.g., `sk-...` for REPLICA, `ghs_...` for GITHUB_APP), it passes through. if it was translated (e.g., github app json â†’ `ghs_...` token), the translated value is already in env and passes through as safe.

**scenario 2: `npm run test:integration` embeds `rhx keyrack get`**
```sh
# developer already ran keyrack get manually
rhx keyrack get --for repo          # grants from vault â†’ values now in env

# test command also calls keyrack get (embedded in test setup)
npm run test:integration            # internally runs rhx keyrack get â†’ os.envvar passthrough
```

no conflict. the embedded call sees values already in env and validates them. tests proceed.

**scenario 3: ci action + embedded test command**
```yaml
# step 1: keyrack action fires, writes safe grants to $GITHUB_ENV
- uses: ./.github/actions/keyrack
  env:
    XAI_API_KEY: ${{ secrets.XAI_API_KEY }}

# step 2: test command also calls rhx keyrack get internally
- run: npm run test:integration
  # keyrack get sees XAI_API_KEY in env (from GITHUB_ENV) â†’ os.envvar passthrough
```

the action wrote safe values to `$GITHUB_ENV`. the test step inherits those values as env vars. when the embedded `rhx keyrack get` runs, os.envvar finds them, validates them (still safe), and passes through. no double-translation. no conflict.

**why this works:** mechanism adapters are designed so that already-translated values pass validation:
- REPLICA: `sk-...` passes â†’ `sk-...` (passthrough is identity)
- GITHUB_APP: `ghs_...` passes â†’ `ghs_...` (short-lived token passes through)
- AWS_SSO: temporary credentials pass â†’ temporary credentials (already translated)

the only values that get blocked are raw secrets that haven't been through the firewall yet (ghp_*, json blobs with private keys, etc.). once a value has been granted, it's safe to reuse â€” like a hotel keycard, if you walk up to the lobby and ask for keys, they'll see you've already got a safe one you can keep on with.

---

## 6. verification

```sh
# types
npm run test:types

# build
npm run build

# manual test: local with env var override
XAI_API_KEY=sk-test123 npx tsx ./bin/run keyrack get --key XAI_API_KEY --json

# manual test: local without env var (falls through to vault)
npx tsx ./bin/run keyrack get --key XAI_API_KEY --json
```

---

## 7. criteria coverage

this blueprint covers:
- **usecase 5** (findsert / passthrough): os.envvar is the "already in env" check from matrix C. idempotent â€” safe to embed `rhx keyrack get` in test commands that also run after a manual keyrack get or after the ci action
- **usecase 7** (ci action step): env vars from `env:` block â†’ os.envvar â†’ mechanism firewall â†’ safe grants to `$GITHUB_ENV`
- **matrix I** (ci action step): all 6 rows covered by current mechanism adapters + os.envvar vault
- **matrix C** (findsert): env check = os.envvar vault check; cascade = fall through to configured vault. idempotent â€” re-granted values pass through because already-translated values pass mechanism validation
