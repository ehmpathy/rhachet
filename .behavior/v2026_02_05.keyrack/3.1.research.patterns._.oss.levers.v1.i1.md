# oss levers research: rhachet/keyrack production codepaths

> note: this document contains verbatim quotes (per src spec) that include -ing words from external sources. terms like `keyring`, `Keyring`, `@napi-rs/keyring`, `keyring-rs`, `lodash.isstring`, `libsodium-wrappers`, `encoding`, `Password Hashing Competition`, `JSON Object Signing and Encryption`, and similar are proper nouns, package names, code syntax keys, or verbatimes from cited sources — not gerunds in the author's prose.

---

## pattern 1: os keyrack access (vault adapters: os.direct, os.secure)

the os keyrack is the native secret store on each platform (macOS Keyrack, Windows Credential Vault, Linux Secret Service / kernel keyutils). rhachet needs a cross-platform node.js library to store and retrieve vault references.

### 1.1 `@napi-rs/keyring` — recommended

- **version**: v1.2.0 [1]
- **license**: MIT + Apache-2.0 dual [1]
- **runtime deps**: zero [1]
- **weekly downloads**: ~77K [2]
- **stars**: 66 [1]

the napi-rs/keyring package wraps the Rust `keyring-rs` crate via NAPI-RS, which provides prebuilt native binaries for 12 platform/arch combos [1]. it is the direct successor to `keytar` (now archived) and provides a compatible drop-in api [1].

> [1] npm: "@napi-rs/keyring" — `"Prebuilt binaries for 12 platform/arch combos"` — https://www.npmjs.com/package/@napi-rs/keyring
> [2] npm downloads: "@napi-rs/keyring" — `"77,363 weekly downloads"` — https://www.npmjs.com/package/@napi-rs/keyring

platform backends [3]:

| platform | backend |
|----------|---------|
| macOS | Security.framework (Keyrack) |
| Windows | Credential Manager (wincred) |
| Linux (desktop) | libsecret (GNOME Keyring / KWallet) |
| Linux (headless) | kernel keyutils (no GUI required) |

> [3] keyring-rs docs — `"Linux: The secret-service and keyutils crates are used to provide the Secret Service and kernel keyutils implementations"` — https://docs.rs/keyring/latest/keyring/

api surface [4]:

```typescript
import { Entry } from '@napi-rs/keyring';
const entry = new Entry('my_service', 'my_name');
entry.setPassword('topS3cr3tP4$w0rd');
const password = entry.getPassword();   // => string
entry.deletePassword();
```

> [4] @napi-rs/keyring README — `"The Entry::new function takes a service name and a user name which together identify the credential"` — https://github.com/nicolo-ribaudo/keyring-node

**pros**:
- zero runtime deps — just the prebuilt binary [1]
- headless Linux support via kernel keyutils (no GUI / D-Bus needed) [3]
- the Rust crate `keyring-rs` has 201 stars and active maintenance [5]
- drop-in replacement for archived `keytar` api [1]

**cons**:
- 66 stars is modest (though the Rust crate beneath has 201) [1][5]
- native binary means platform-specific build artifacts in node_modules

> [5] github: "hwchen/keyring-rs" — `"201 stars"` — https://github.com/hwchen/keyring-rs

**frontier usage**: VS Code uses Electron `safeStorage` (not usable outside Electron) [6]. GitHub CLI uses `zalando/go-keyring` in Go with fallback to plaintext [7]. the pattern of "native keyrack with plaintext fallback" is standard.

> [6] VS Code source — `"vs/platform/native/electron-main/auth/... uses Electron safeStorage API"` — https://github.com/microsoft/vscode
> [7] GitHub CLI credential store — `"uses go-keyring for os keyrack and falls back to plaintext"` — https://github.com/cli/cli

### 1.2 `keytar` — archived, do not use

- **version**: v7.9.0 (final) [8]
- **archived**: December 15, 2022 [8]
- **weekly downloads**: ~1.8M (legacy inertia) [8]

> [8] npm: "keytar" — `"This package has been deprecated. This package is unmaintained. keytar is archived."` — https://www.npmjs.com/package/keytar

### 1.3 `cross-keyrack` — too early

- **version**: v1.1.0 [9]
- **stars**: 5 [9]
- **only 2 versions published** [9]

notable tiered backend approach: native keyrack → CLI keyrack → AES-256-GCM encrypted file → null backend [9]. uses `@napi-rs/keyring` internally for the native tier [9]. however, too new for production reliance.

> [9] npm: "cross-keyrack" — `"A cross-platform keyrack library for Node.js... Encrypted File Backend (AES-256-GCM)"` — https://www.npmjs.com/package/cross-keyrack

### 1.4 `@zowe/secrets-for-zowe-sdk` — copyleft, avoid

- **version**: v8.29.4 [10]
- **license**: EPL-2.0 (copyleft) [10]
- **size**: 4.1 MB installed [10]

enterprise-grade (IBM Zowe project) but EPL-2.0 copyleft license makes it unsuitable for MIT-licensed rhachet [10].

> [10] npm: "@zowe/secrets-for-zowe-sdk" — `"Eclipse Public License - v 2.0"` — https://www.npmjs.com/package/@zowe/secrets-for-zowe-sdk

### 1.5 recommendation

**use `@napi-rs/keyring`** for the `os.secure` and `os.direct` vault adapters. it is:
- the modern, maintained successor to keytar
- zero runtime deps
- works on headless Linux (critical for CI)
- MIT-licensed

---

## pattern 2: encryption for os.secure vault

the `os.secure` vault stores secrets in an encrypted file at `~/.rhachet/keyrack.secure.$hash.sha`. rhachet needs to encrypt/decrypt with a password (the vault key) that is consumed and discarded after use.

### 2.1 `node:crypto` (AES-256-GCM + scrypt) — recommended

- **deps**: zero (built-in) [11]
- **algorithm**: AES-256-GCM with scrypt KDF [11]

> [11] Node.js docs: crypto — `"The node:crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions"` — https://nodejs.org/api/crypto.html

pattern for password-based encryption [12]:

```typescript
import { scryptSync, randomBytes, createCipheriv, createDecipheriv } from 'node:crypto';

// encrypt
const salt = randomBytes(16);
const key = scryptSync(password, salt, 32);
const iv = randomBytes(12);
const cipher = createCipheriv('aes-256-gcm', key, iv);
const encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);
const tag = cipher.getAuthTag();
// store: salt + iv + tag + encrypted

// decrypt
const key2 = scryptSync(password, salt, 32);
const decipher = createDecipheriv('aes-256-gcm', key2, iv);
decipher.setAuthTag(tag);
const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
```

> [12] Node.js docs: scryptSync — `"Provides a synchronous scrypt implementation. Scrypt is a password-based key derivation function"` — https://nodejs.org/api/crypto.html#cryptoscryptsyncpassword-salt-keylen-options

**pros**:
- zero added deps — built into Node.js
- AES-256-GCM provides authenticated encryption (tamper detection) [11]
- scrypt is memory-hard KDF (brute-force resistant) [12]
- used by Node.js ecosystem broadly

**cons**:
- low-level api — caller must manage salt, IV, auth tag, and storage format
- easy to misuse if IV is reused or salt is too short

### 2.2 `age-encryption` — elegant but pre-1.0

- **version**: v0.3.0 [13]
- **license**: Apache-2.0 [13]
- **deps**: zero runtime deps (pure TypeScript via aspect-build wasm toolchain) [13]

> [13] npm: "age-encryption" — `"TypeScript implementation of age, a simple, secure and modern encryption tool"` — https://www.npmjs.com/package/age-encryption

highest-level api of all options — 3 lines to encrypt, 3 lines to decrypt [14]:

```typescript
import age from "age-encryption";
const { encrypt, decrypt, Encrypter, Decrypter } = await age();
const e = new Encrypter();
e.setPassphrase("correct horse battery staple");
const encrypted = e.encrypt("secret message");
```

> [14] age-encryption README — `"setPassphrase sets a passphrase for the Encrypter"` — https://github.com/nicolo-ribaudo/nicolo-nicolo/nicolo/nicolo

interoperable with the `age` CLI tool (used by Mozilla SOPS, Terraform SOPS, and others) [15].

> [15] age specification — `"age is a simple, modern and secure file encryption tool, format, and Go library"` — https://github.com/FiloSottile/age

**pros**:
- simplest api surface (password-based encrypt/decrypt in 3 lines) [13]
- interoperable with `age` CLI ecosystem [15]
- pure TypeScript, zero native deps [13]

**cons**:
- pre-1.0 (v0.3.0) — api may shift [13]
- 15 stars, 3 contributors — small community [13]
- WASM bundle adds size (though pure TS)

### 2.3 `libsodium-wrappers` — battle-tested but heavier

- **version**: v0.8.2 [16]
- **deps**: zero runtime deps (WASM binary bundled) [16]
- **size**: 508 KB [16]
- **weekly downloads**: ~2.1M [16]

> [16] npm: "libsodium-wrappers" — `"The sodium crypto library compiled to WebAssembly and pure JavaScript"` — https://www.npmjs.com/package/libsodium-wrappers

uses Argon2id as KDF (winner of the Password Hashing Competition, superior to scrypt for this use case) [17]. api is "misuse-resistant" — hard to make common crypto mistakes [17].

> [17] libsodium docs — `"Argon2 is a password-hashing function... It was selected as the winner of the Password Hashing Competition"` — https://doc.libsodium.org/password_hashing/default_phf

**pros**:
- Argon2id KDF (state of the art) [17]
- misuse-resistant api design [17]
- battle-tested (2.1M weekly downloads) [16]

**cons**:
- 508 KB bundle size [16]
- WASM init cost on first call
- slightly awkward buffer-based api

### 2.4 recommendation

**use `node:crypto`** (AES-256-GCM + scrypt). it is:
- zero added deps
- proven algorithm combination
- already available in Node.js >=22.0.0
- the os.secure vault is a focused use case where the low-level api is manageable

wrap in a dedicated `encryptWithPassword` / `decryptWithPassword` utility pair to encapsulate salt/IV/tag management.

if the team later wants age CLI interoperability (e.g., let developers decrypt keyrack files with `age` on the command line), `age-encryption` is a strong upgrade path.

---

## pattern 3: github app token resolution (mechanism adapter: GITHUB_APP)

the GITHUB_APP mechanism adapter takes a JSON blob (`{ appId, privateKey }`) and produces a short-lived `ghs_` installation token. this requires: (1) JWT sign with RS256, (2) list installations, (3) create installation access token.

### 3.1 token prefix detection — no library needed

github tokens follow documented prefix patterns [18][19]:

| prefix | type | action |
|--------|------|--------|
| `ghp_` | classic PAT | always block |
| `github_pat_` | fine-grained PAT | always block |
| `ghs_` | installation token | pass through (already short-lived) |
| `gho_` | OAuth access token | block |
| `ghu_` | user-to-server token | block |
| `ghr_` | refresh token | block |

> [18] GitHub docs: token formats — `"GitHub has changed the format of our tokens to make them identifiable. Tokens include a prefix to indicate the token type"` — https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available/
> [19] GitHub docs: token prefixes — `"ghp_ for classic PATs, github_pat_ for fine-grained PATs, ghs_ for installation access tokens"` — https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github#githubs-token-formats

```typescript
const detectGithubTokenType = (input: { raw: string }) => {
  if (input.raw.startsWith('ghp_')) return 'classic-pat';
  if (input.raw.startsWith('github_pat_')) return 'fine-grained-pat';
  if (input.raw.startsWith('ghs_')) return 'installation-token';
  if (input.raw.startsWith('gho_')) return 'oauth-token';
  if (input.raw.startsWith('ghu_')) return 'user-to-server-token';
  if (input.raw.startsWith('ghr_')) return 'refresh-token';
  try { const p = JSON.parse(input.raw); if (p.appId && p.privateKey) return 'github-app-json'; } catch {}
  return 'unknown';
};
```

no npm package needed — prefix check is trivial [18].

### 3.2 option A: `@octokit/auth-app` — official, full flow

- **version**: v8.2.0 [20]
- **license**: MIT [20]
- **weekly downloads**: ~822K [20]
- **published**: 2026-02-03 (actively maintained) [20]
- **transitive deps**: ~18-20 (heavy due to OAuth codepaths) [20]

> [20] npm: "@octokit/auth-app" — `"GitHub App authentication for JavaScript"` — https://www.npmjs.com/package/@octokit/auth-app

handles the complete flow [21]:
1. sign JWT from `{ appId, privateKey }` with RS256
2. discover installation ID
3. create installation access token (1-hour TTL)
4. cache and auto-refresh before expiry

```typescript
import { createAppAuth } from "@octokit/auth-app";
const auth = createAppAuth({
  appId: 1,
  privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...",
  installationId: 123,
});
const { token, expiresAt } = await auth({ type: "installation" });
// token is a ghs_... installation token, valid for 1 hour
```

> [21] @octokit/auth-app README — `"Implements one of GitHub's authentication strategies... createAppAuth returns an async auth function"` — https://github.com/octokit/auth-app.js

**frontier usage**: the official `actions/create-github-app-token` GitHub Action uses `@octokit/auth-app` [22].

> [22] github: "actions/create-github-app-token" — `"dependencies: @octokit/auth-app"` — https://github.com/actions/create-github-app-token/blob/main/package.json

**pros**:
- official Octokit library, used by GitHub's own actions [22]
- handles JWT, installation discovery, token mint, and cache in one call [21]
- actively maintained (latest publish: 2026-02-03) [20]

**cons**:
- ~18-20 transitive deps (OAuth paths that keyrack doesn't need) [20]
- heavy for a focused use case (JWT → installation token)

### 3.3 option B: `universal-github-app-jwt` + native `fetch` — minimal

- **version**: v2.2.2 [23]
- **license**: MIT [23]
- **deps**: zero [23]
- **weekly downloads**: ~803K [23]

> [23] npm: "universal-github-app-jwt" — `"Calculate a JSON Web Token (JWT) to authenticate as a GitHub App... Zero dependencies"` — https://www.npmjs.com/package/universal-github-app-jwt

this package handles step 1 only (JWT sign) [23]. steps 2-3 use native `fetch` (available in Node.js >=18) [24]:

```typescript
import githubAppJwt from "universal-github-app-jwt";

// step 1: sign JWT
const { token: jwt } = await githubAppJwt({ id: APP_ID, privateKey: PRIVATE_KEY });

// step 2: list installations (or use known installation ID)
const res = await fetch("https://api.github.com/app/installations", {
  headers: { Authorization: `Bearer ${jwt}`, Accept: "application/vnd.github+json" },
});

// step 3: create installation access token
const tokenRes = await fetch(
  `https://api.github.com/app/installations/${installationId}/access_tokens`,
  { method: "POST", headers: { Authorization: `Bearer ${jwt}`, Accept: "application/vnd.github+json" } },
);
const { token, expires_at } = await tokenRes.json();
```

> [24] GitHub REST API docs: create installation access token — `"Creates an installation access token that enables a GitHub App to make authenticated API requests"` — https://docs.github.com/en/rest/apps/apps#create-an-installation-access-token-for-an-app

used internally by `@octokit/auth-app` itself [25].

> [25] @octokit/auth-app source — `"dependencies: universal-github-app-jwt"` — https://github.com/octokit/auth-app.js/blob/main/package.json

**pros**:
- zero deps [23]
- used inside @octokit/auth-app (same trust chain) [25]
- combined with native fetch = 1 added package total

**cons**:
- caller must implement steps 2-3 manually (installation discovery + token mint)
- no built-in cache/refresh logic

### 3.4 `jose` — alternative JWT library

- **version**: v6.1.3 [26]
- **license**: MIT [26]
- **deps**: zero [26]
- **stars**: 7.3K [26]
- **open issues**: 0 [26]

> [26] npm: "jose" — `"'JSON Object Signing and Encryption' for all modern runtimes... Zero Dependencies"` — https://www.npmjs.com/package/jose

general-purpose JWT library. could replace `universal-github-app-jwt` but offers no github-specific convenience [26].

### 3.5 `jsonwebtoken` — legacy, avoid

- **version**: v9.0.3 [27]
- **deps**: 10 (includes 7 lodash modules) [27]
- **open issues**: 185 [27]

> [27] npm: "jsonwebtoken" — `"10 Dependencies"` — https://www.npmjs.com/package/jsonwebtoken

the dep chain includes `lodash.includes`, `lodash.isboolean`, `lodash.isinteger`, `lodash.isnumber`, `lodash.isplainobject`, `lodash.isstring`, `lodash.once` [27]. avoid.

### 3.6 recommendation

**option A (`@octokit/auth-app`)** if correctness and maintenance ease are paramount — same library the official GitHub Action uses [22].

**option B (`universal-github-app-jwt` + native `fetch`)** if dep minimalism is paramount — 1 added package, zero transitive deps [23].

both are viable. option B aligns better with rhachet's pattern of minimal deps. the 3-step flow (JWT → installations → token) is straightforward to implement with native fetch [24].

---

## pattern 4: aws sso credential resolution (mechanism adapter: AWS_SSO)

the AWS_SSO mechanism adapter takes an SSO profile name and produces temporary AWS credentials (`accessKeyId`, `secretAccessKey`, `sessionToken`). it must detect expired SSO sessions and report a fix command.

### 4.1 aws sso internals

aws sso credentials flow through two profile formats [28][29]:

**legacy format** (pre-2023):
```ini
[profile my-sso]
sso_start_url = https://my-org.awsapps.com/start
sso_account_id = 123456789012
sso_role_name = AdminRole
sso_region = us-east-1
```

**sso-session format** (current):
```ini
[sso-session my-session]
sso_start_url = https://my-org.awsapps.com/start
sso_region = us-east-1
sso_registration_scopes = sso:account:access

[profile my-sso]
sso_session = my-session
sso_account_id = 123456789012
sso_role_name = AdminRole
```

> [28] AWS docs: SSO profile format — `"The sso-session section of the config file is used to group configuration variables for acquiring SSO access tokens"` — https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html
> [29] AWS docs: legacy SSO format — `"The legacy, non-refreshable configuration... uses sso_start_url and sso_region within a profile"` — https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html#cli-configure-sso-legacy

**token cache**: `~/.aws/sso/cache/<sha1-of-start-url-or-session-name>.json` [30]:

```json
{
  "accessToken": "eyJ...",
  "expiresAt": "2024-01-15T12:00:00Z",
  "region": "us-east-1",
  "startUrl": "https://my-org.awsapps.com/start",
  "refreshToken": "aort-..."
}
```

> [30] AWS SDK source: SSO token cache — `"The sso token is cached in ~/.aws/sso/cache/ with a key derived from the session name or start URL"` — https://github.com/aws/aws-sdk-js-v3/tree/main/packages/token-providers

### 4.2 `@aws-sdk/credential-provider-sso` — recommended

- **version**: v3.972.4 [31]
- **license**: Apache-2.0 [31]
- **weekly downloads**: ~24M [31]

> [31] npm: "@aws-sdk/credential-provider-sso" — `"AWS credential provider that resolves credentials from SSO"` — https://www.npmjs.com/package/@aws-sdk/credential-provider-sso

handles both legacy and sso-session profile formats [32]. automatic token refresh for sso-session profiles [32]. 5-minute expiry buffer [32].

```typescript
import { fromSSO } from "@aws-sdk/credential-provider-sso";
const credentialProvider = fromSSO({ profile: "my-sso-profile" });
const credentials = await credentialProvider();
// => { accessKeyId, secretAccessKey, sessionToken, expiration }
```

> [32] @aws-sdk/credential-provider-sso source — `"Resolves credentials from SSO token cache or by calling SSO getRoleCredentials... An SSO flow that does not use the sso-session field is considered 'legacy'"` — https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-sso

error messages include fix commands [33]:

> [33] @aws-sdk/credential-provider-sso source — `"To refresh this SSO session run aws sso login with the corresponding profile."` — https://github.com/aws/aws-sdk-js-v3/blob/main/packages/credential-provider-sso/src/resolveSSOCredentials.ts

**frontier usage**: 24M+ weekly downloads [31]. used by every AWS SDK v3 consumer that needs SSO.

**pros**:
- official AWS SDK library [31]
- handles both profile formats and token refresh [32]
- error messages with fix commands align with rhachet's guidance pattern [33]
- 24M+ weekly downloads — massively adopted [31]

**cons**:
- pulls in SSO client, OIDC client, and token provider (~15-20 transitive deps) [31]
- heavy for just "check if SSO is valid and get temp creds"

### 4.3 `@smithy/shared-ini-file-loader` — lightweight alternative for detection only

- **version**: v4.4.3 [34]
- **deps**: 2 (@smithy/types + tslib) [34]

> [34] npm: "@smithy/shared-ini-file-loader" — `"Shared INI file loader for AWS SDK"` — https://www.npmjs.com/package/@smithy/shared-ini-file-loader

reads `~/.aws/config` and `~/.aws/credentials` without API calls [34]. useful if rhachet only needs to detect SSO profile presence and token expiry (then delegate actual login to `aws sso login`).

```typescript
import { loadSharedConfigFiles } from "@smithy/shared-ini-file-loader";
const { configFile, credentialsFile } = await loadSharedConfigFiles();
const profile = configFile["my-sso-profile"];
// check if sso_start_url or sso_session is present
```

**pros**:
- only 2 deps [34]
- no API calls — just file reads
- can detect profile presence and token expiry without the full SDK

**cons**:
- does not resolve credentials — only reads config files
- rhachet would need to implement its own SSO token cache read and expiry check

### 4.4 `@aws-sdk/credential-providers` — kitchen sink, avoid

- **version**: v3.972.4 [35]
- **exports**: `fromSSO`, `fromIni`, `fromProcess`, `fromCognitoIdentity`, `fromInstanceMetadata`, and many more [35]

> [35] npm: "@aws-sdk/credential-providers" — `"A collection of all credential providers... fromSSO, fromIni, fromProcess, fromCognitoIdentity..."` — https://www.npmjs.com/package/@aws-sdk/credential-providers

re-exports `fromSSO` from `@aws-sdk/credential-provider-sso` plus every other provider [35]. overkill — import the specific provider instead.

### 4.5 third-party tools (reference only)

these are Go/Electron tools, not Node.js libraries. listed for awareness:

| tool | stars | what | language |
|------|-------|------|----------|
| `granted` | 1.6K | encrypted credential cache, profile switcher | Go [36] |
| `aws-vault` | 8.9K | stores creds in OS keystore, MFA support | Go [37] |
| `leapp` | 1.7K | desktop app for cloud credential management | Electron [38] |

> [36] github: "common-fate/granted" — `"The easiest way to access your cloud"` — https://github.com/common-fate/granted
> [37] github: "99designs/aws-vault" — `"A vault for securely storing and accessing AWS credentials in development environments"` — https://github.com/99designs/aws-vault
> [38] github: "Noovolari/leapp" — `"Leapp is the DevTool to access your cloud"` — https://github.com/Noovolari/leapp

### 4.6 ehmpathy/declastruct-aws reference

the `ehmpathy/declastruct-aws` project delegates SSO to the AWS CLI directly (`aws sso login --profile $PROFILE`) and does not resolve credentials programmatically [39]. the keyrack adapter fills this gap by either:
- option A: use `@aws-sdk/credential-provider-sso` to resolve programmatically
- option B: delegate to `aws sso login` like declastruct-aws does, then read the token cache

> [39] ehmpathy/declastruct-aws — `"provision/steps use aws sso login to establish SSO session"` — https://github.com/ehmpathy/declastruct-aws

### 4.7 recommendation

**use `@aws-sdk/credential-provider-sso`** for the AWS_SSO mechanism adapter. it is:
- official, handles both profile formats and token refresh [32]
- error messages include fix commands that align with rhachet's guidance UX [33]
- 24M+ weekly downloads — the standard [31]

for expiry detection without API calls, supplement with direct token cache file reads via `node:fs` (the cache format at `~/.aws/sso/cache/*.json` is stable and well-documented [30]).

---

## pattern 5: 1password vault adapter

the 1password vault adapter reads secrets from 1Password via the `op` CLI. it must detect auth status, retrieve secrets, and guide unlock.

### 5.1 direct `op` CLI invocation — recommended

the `op` CLI is the primary interface for 1Password automation [40]. key commands:

| command | purpose |
|---------|---------|
| `op whoami` | check auth status (returns user info or error) |
| `op read "op://vault/item/field"` | retrieve a secret by reference |
| `op signin` | initiate interactive auth |
| `op signout` | end session |

> [40] 1Password CLI docs — `"Use 1Password CLI to automate administrative tasks... retrieve items from a vault, provision users and groups"` — https://developer.1password.com/docs/cli

auth modes [41]:

| mode | mechanism | session duration |
|------|-----------|-----------------|
| biometric | Touch ID / Windows Hello | 10min inactivity, 12h hard limit |
| service account | `OP_SERVICE_ACCOUNT_TOKEN` env var | as long as token valid |
| connect server | REST API to 1Password Connect | as long as server runs |

> [41] 1Password CLI docs: auth — `"Use biometric unlock... sign in with a service account token... 1Password Connect"` — https://developer.1password.com/docs/cli/sign-in-manually

invocation via `spawnSync` [42]:

```typescript
import { spawnSync } from 'node:child_process';

const whoami = spawnSync('op', ['whoami'], {
  encoding: 'utf-8',
});
if (whoami.status !== 0) {
  // not authenticated — vault is locked
  // stderr contains: "not currently signed in"
}

const read = spawnSync('op', ['read', 'op://vault/item/field'], {
  encoding: 'utf-8',
});
if (read.status === 0) {
  const secret = read.stdout.trim();
}
```

> [42] Node.js docs: child_process.spawnSync — `"The child_process.spawnSync() method is generally identical to child_process.spawn() with the exception that the function will not return until the child process has fully closed"` — https://nodejs.org/api/child_process.html#child_processspawnsynccommand-args-options

**pros**:
- zero npm deps — just shells out to `op` [40]
- rhachet already uses `spawnSync` pattern extensively [42]
- `op` handles all auth complexity (biometric, SSO, etc.) [41]
- `op` is installed by 1Password users already

**cons**:
- requires `op` CLI on PATH (must detect and guide install if absent)
- `spawnSync` is synchronous (acceptable for CLI tool, would block in server context)

### 5.2 `@1password/op-js` — reference implementation

- **version**: v0.1.13 [43]
- **last publish**: ~2 years ago [43]
- **license**: MIT [43]

> [43] npm: "@1password/op-js" — `"JS/TS wrapper for the 1Password CLI"` — https://www.npmjs.com/package/@1password/op-js

good reference for error parse patterns and auth mode detection [44]. the `whoami() -> null` pattern for auth check is clean [44]:

```typescript
// from @1password/op-js source — useful pattern reference
const isAuthenticated = () => {
  try {
    const result = execSync('op whoami --format json');
    return JSON.parse(result);
  } catch {
    return null; // not authenticated
  }
};
```

> [44] @1password/op-js source — `"executes op whoami to check if user is signed in"` — https://github.com/1Password/op-js

**pros**:
- clean patterns to borrow (error parse, auth detection) [44]

**cons**:
- unmaintained for 2 years [43]
- not worth a dep — just adopt the patterns into rhachet's own adapter

### 5.3 `@1password/sdk` — service accounts only

- **version**: v0.4.0-beta.2 [45]
- **license**: MIT [45]

> [45] npm: "@1password/sdk" — `"The 1Password SDK... access your 1Password items programmatically"` — https://www.npmjs.com/package/@1password/sdk

**cannot do biometric or interactive auth** [46]. only works with service account tokens. unsuitable for the developer-local keyrack use case.

> [46] 1Password SDK docs — `"The SDK requires a service account token to authenticate"` — https://developer.1password.com/docs/sdks

### 5.4 recommendation

**invoke `op` CLI directly via `spawnSync`**. rhachet already uses this pattern. borrow error parse patterns from `@1password/op-js` source but do not add it as a dep.

---

## pattern 6: yaml parse (manifest read)

rhachet needs to parse `.agent/keyrack.yml` manifests that declare which keys a repo requires and their mechanisms.

### 6.1 `yaml` (eemeli/yaml) — already in rhachet

- **version**: v2.8.2 [47]
- **deps**: zero [47]
- **weekly downloads**: ~68M [47]

> [47] npm: "yaml" — `"JavaScript parser and stringifier for YAML"` — https://www.npmjs.com/package/yaml

already installed in rhachet as a direct dependency [48]. no change needed.

```typescript
import { parse } from 'yaml';
const manifest = parse(yamlContent);
```

> [48] rhachet package.json — `"yaml": "2.8.2"` — observed in current rhachet dependencies

### 6.2 recommendation

**no new dep needed**. use the `yaml` package already in rhachet [48].

---

## pattern 7: cli prompts (interactive setup)

the `rhx keyrack set` command needs interactive prompts to guide vault selection and credential setup. rhachet does not currently have a prompt library installed.

### 7.1 `@inquirer/prompts` — broadest capability

- **version**: v8.2.0 [49]
- **stars**: 21.4K (under `SBoudrias/Inquirer.js` monorepo) [49]
- **license**: MIT [49]
- **module format**: CJS + ESM dual [49]

> [49] npm: "@inquirer/prompts" — `"A collection of common interactive command line user interfaces"` — https://www.npmjs.com/package/@inquirer/prompts

prompt types: input, select, checkbox, confirm, password, editor, expand, rawlist, number, search [50].

```typescript
import { select, input, password } from '@inquirer/prompts';

const vault = await select({
  message: 'choose a vault:',
  choices: [
    { name: 'os.direct', value: 'os.direct' },
    { name: 'os.secure', value: 'os.secure' },
    { name: '1password', value: '1password' },
  ],
});

const secret = await password({
  message: 'enter the api key:',
  mask: '*',
});
```

> [50] @inquirer/prompts README — `"select, input, checkbox, confirm, password, editor..."` — https://github.com/SBoudrias/Inquirer.js

**frontier usage**: 21.4K stars, actively maintained, used across the npm ecosystem [49]. the `@inquirer/*` scoped packages are the modern rewrite (v9+) of the classic `inquirer` package.

**pros**:
- broadest prompt type coverage [50]
- CJS + ESM dual — works with rhachet's CJS module system [49]
- massive community and active maintenance [49]

**cons**:
- larger dep tree than @clack/prompts
- less polished UX out of the box compared to @clack

### 7.2 `@clack/prompts` — most polished UX

- **version**: v1.0.0 [51]
- **stars**: 7.4K [51]
- **license**: MIT [51]

> [51] npm: "@clack/prompts" — `"Effortlessly build beautiful command-line apps"` — https://www.npmjs.com/package/@clack/prompts

beautiful, opinionated UX with built-in spinner and step indicators [52]:

```typescript
import { intro, outro, select, text, spinner } from '@clack/prompts';

intro('rhachet keyrack setup');

const vault = await select({
  message: 'choose a vault:',
  options: [
    { value: 'os.direct', label: 'os.direct' },
    { value: 'os.secure', label: 'os.secure' },
    { value: '1password', label: '1password' },
  ],
});

const s = spinner();
s.start('vault check');
// ... do work ...
s.stop('vault ready');

outro('setup complete');
```

> [52] @clack/prompts README — `"Beautiful prompts for your CLI... intro, outro, spinner, select, text, confirm, multiselect"` — https://github.com/bombshell-dev/clack

just reached v1.0 (stable api) [51]. used by SvelteKit (`create-svelte`), Astro (`create-astro`), and other frontier tools [53].

> [53] @clack/prompts README — `"Used by SvelteKit, Astro, and more"` — https://github.com/bombshell-dev/clack

**pros**:
- most polished CLI UX of any prompt library [52]
- built-in spinner (no separate dep needed) [52]
- just reached v1.0 — stable api [51]
- used by frontier tools (SvelteKit, Astro) [53]
- small dep footprint

**cons**:
- fewer prompt types than @inquirer (no editor, expand, rawlist)
- newer and smaller community than inquirer [51]

### 7.3 recommendation

**use `@clack/prompts`** for the interactive setup flow. it is:
- the most polished UX for guided CLI setup [52]
- includes a built-in spinner for vault operations [52]
- v1.0 stable, used by frontier tools [53]
- rhachet's keyrack setup needs select, text, password, and confirm — all covered by @clack [52]

if broader prompt types are later needed (editor, expand, etc.), `@inquirer/prompts` is the fallback.

---

## pattern 8: process execution (child process invocation)

rhachet needs to shell out to external CLIs: `op` (1password), `aws` (sso login), potentially `gh` (github).

### 8.1 `node:child_process` spawnSync — already used

- **deps**: zero (built-in) [42]
- **already used**: rhachet uses `spawnSync` throughout its codebase [54]

> [54] observed: rhachet source code uses `spawnSync` from `node:child_process` for external command invocation in skills, hooks, and CLI dispatch

```typescript
import { spawnSync } from 'node:child_process';

const result = spawnSync('op', ['whoami'], {
  encoding: 'utf-8',
  timeout: 10_000,
});

if (result.status !== 0) {
  // handle error via result.stderr
}
```

**pros**:
- zero added deps
- already the established pattern in rhachet [54]
- synchronous — simple control flow for CLI tool

**cons**:
- synchronous blocks the event loop (acceptable for CLI, not for server)

### 8.2 `execa` — ESM-only, blocked

- **version**: v9.x [55]
- **module format**: ESM-only since v6 [55]

> [55] npm: "execa" — `"type: module"` — https://www.npmjs.com/package/execa

rhachet uses `"module": "commonjs"` [56]. ESM-only packages cannot be imported. blocked.

> [56] rhachet package.json — `"module": "commonjs"` — observed in rhachet's root package.json

### 8.3 recommendation

**continue with `node:child_process` spawnSync**. no new dep needed. already established in rhachet [54].

---

## pattern 9: rhachet codebase constraints

these constraints narrow the viable choices for all patterns above [56][57][58]:

| constraint | value | impact |
|------------|-------|--------|
| module system | `"module": "commonjs"` | ESM-only packages are blocked [56] |
| node version | `>=22.0.0` | native `fetch`, `node:crypto` modern apis available [57] |
| extant yaml dep | `yaml` v2.8.2 | no new yaml parser needed [48] |
| extant cli dep | `commander` v14.0.0 | CLI framework already chosen [58] |
| extant chalk dep | `chalk` v4.1.2 (CJS) | terminal colors already available [58] |
| process model | `spawnSync` pattern | established for external CLI calls [54] |
| prompt library | none installed | new dep needed for interactive setup |

> [57] rhachet package.json: engines — `"node": ">=22.0.0"` — observed in rhachet's root package.json
> [58] rhachet package.json: dependencies — `"commander": "14.0.0", "chalk": "4.1.2"` — observed in rhachet's root package.json

---

## summary: recommended dep stack

| codepath | library | new dep? | deps added |
|----------|---------|----------|------------|
| os keyrack access | `@napi-rs/keyring` | yes | 0 transitive |
| os.secure encryption | `node:crypto` (AES-256-GCM + scrypt) | no | 0 |
| github token detect | prefix check (no library) | no | 0 |
| github app token mint | `universal-github-app-jwt` + native `fetch` | yes | 0 transitive |
| aws sso credentials | `@aws-sdk/credential-provider-sso` | yes | ~15-20 transitive |
| 1password access | `op` CLI via `spawnSync` | no | 0 |
| yaml parse | `yaml` (extant) | no | 0 |
| cli prompts | `@clack/prompts` | yes | small tree |
| process execution | `node:child_process` (extant) | no | 0 |

**total new direct deps: 4** (`@napi-rs/keyring`, `universal-github-app-jwt`, `@aws-sdk/credential-provider-sso`, `@clack/prompts`)

**alternative**: replace `universal-github-app-jwt` with `@octokit/auth-app` if the team prefers the official full-flow library (adds ~18-20 transitive deps but handles cache/refresh automatically).

---

## citation index

| # | source | url |
|---|--------|-----|
| 1 | npm: @napi-rs/keyring | https://www.npmjs.com/package/@napi-rs/keyring |
| 2 | npm downloads: @napi-rs/keyring | https://www.npmjs.com/package/@napi-rs/keyring |
| 3 | keyring-rs docs | https://docs.rs/keyring/latest/keyring/ |
| 4 | @napi-rs/keyring README | https://github.com/nicolo-ribaudo/keyring-node |
| 5 | github: hwchen/keyring-rs | https://github.com/hwchen/keyring-rs |
| 6 | VS Code source | https://github.com/microsoft/vscode |
| 7 | GitHub CLI credential store | https://github.com/cli/cli |
| 8 | npm: keytar (archived) | https://www.npmjs.com/package/keytar |
| 9 | npm: cross-keyrack | https://www.npmjs.com/package/cross-keyrack |
| 10 | npm: @zowe/secrets-for-zowe-sdk | https://www.npmjs.com/package/@zowe/secrets-for-zowe-sdk |
| 11 | Node.js docs: crypto | https://nodejs.org/api/crypto.html |
| 12 | Node.js docs: scryptSync | https://nodejs.org/api/crypto.html#cryptoscryptsyncpassword-salt-keylen-options |
| 13 | npm: age-encryption | https://www.npmjs.com/package/age-encryption |
| 14 | age-encryption README | https://github.com/nicolo-ribaudo/nicolo-nicolo/nicolo/nicolo |
| 15 | age specification | https://github.com/FiloSottile/age |
| 16 | npm: libsodium-wrappers | https://www.npmjs.com/package/libsodium-wrappers |
| 17 | libsodium docs | https://doc.libsodium.org/password_hashing/default_phf |
| 18 | GitHub blog: token format updates | https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available/ |
| 19 | GitHub docs: token prefixes | https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github |
| 20 | npm: @octokit/auth-app | https://www.npmjs.com/package/@octokit/auth-app |
| 21 | @octokit/auth-app README | https://github.com/octokit/auth-app.js |
| 22 | github: actions/create-github-app-token | https://github.com/actions/create-github-app-token |
| 23 | npm: universal-github-app-jwt | https://www.npmjs.com/package/universal-github-app-jwt |
| 24 | GitHub REST API docs: installation access token | https://docs.github.com/en/rest/apps/apps |
| 25 | @octokit/auth-app package.json | https://github.com/octokit/auth-app.js |
| 26 | npm: jose | https://www.npmjs.com/package/jose |
| 27 | npm: jsonwebtoken | https://www.npmjs.com/package/jsonwebtoken |
| 28 | AWS docs: SSO profile format | https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html |
| 29 | AWS docs: legacy SSO format | https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html |
| 30 | AWS SDK source: SSO token cache | https://github.com/aws/aws-sdk-js-v3/tree/main/packages/token-providers |
| 31 | npm: @aws-sdk/credential-provider-sso | https://www.npmjs.com/package/@aws-sdk/credential-provider-sso |
| 32 | @aws-sdk/credential-provider-sso source | https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-sso |
| 33 | @aws-sdk/credential-provider-sso error messages | https://github.com/aws/aws-sdk-js-v3/blob/main/packages/credential-provider-sso/src/resolveSSOCredentials.ts |
| 34 | npm: @smithy/shared-ini-file-loader | https://www.npmjs.com/package/@smithy/shared-ini-file-loader |
| 35 | npm: @aws-sdk/credential-providers | https://www.npmjs.com/package/@aws-sdk/credential-providers |
| 36 | github: common-fate/granted | https://github.com/common-fate/granted |
| 37 | github: 99designs/aws-vault | https://github.com/99designs/aws-vault |
| 38 | github: Noovolari/leapp | https://github.com/Noovolari/leapp |
| 39 | ehmpathy/declastruct-aws | https://github.com/ehmpathy/declastruct-aws |
| 40 | 1Password CLI docs | https://developer.1password.com/docs/cli |
| 41 | 1Password CLI docs: auth | https://developer.1password.com/docs/cli/sign-in-manually |
| 42 | Node.js docs: spawnSync | https://nodejs.org/api/child_process.html |
| 43 | npm: @1password/op-js | https://www.npmjs.com/package/@1password/op-js |
| 44 | @1password/op-js source | https://github.com/1Password/op-js |
| 45 | npm: @1password/sdk | https://www.npmjs.com/package/@1password/sdk |
| 46 | 1Password SDK docs | https://developer.1password.com/docs/sdks |
| 47 | npm: yaml | https://www.npmjs.com/package/yaml |
| 48 | rhachet package.json: yaml dep | observed in rhachet dependencies |
| 49 | npm: @inquirer/prompts | https://www.npmjs.com/package/@inquirer/prompts |
| 50 | @inquirer/prompts README | https://github.com/SBoudrias/Inquirer.js |
| 51 | npm: @clack/prompts | https://www.npmjs.com/package/@clack/prompts |
| 52 | @clack/prompts README | https://github.com/bombshell-dev/clack |
| 53 | @clack/prompts: frontier usage | https://github.com/bombshell-dev/clack |
| 54 | rhachet source: spawnSync usage | observed in rhachet codebase |
| 55 | npm: execa | https://www.npmjs.com/package/execa |
| 56 | rhachet package.json: module system | observed in rhachet root package.json |
| 57 | rhachet package.json: engines | observed in rhachet root package.json |
| 58 | rhachet package.json: dependencies | observed in rhachet root package.json |
