# blackbox criteria: coverage matrix

> distilled from `2.1.criteria.blackbox.md` â€” all combinations, gaps flagged

---

## matrix A: single key resolution (pipeline)

the core resolution cascade. each key passes through this pipeline top-to-bottom; the first match determines the outcome.

| ind: configured? | ind: vault accessible? | ind: value vs declared mech | dep: status | dep: exported? | dep: fix command |
|---|---|---|---|---|---|
| no | â€” | â€” | ðŸ«§ unfound | no | `set --key $KEY [--mech $MECH]` |
| yes | locked | â€” | ðŸ”’ locked | no | `unlock --key $KEY` |
| yes | unlocked | violates mech | ðŸš« blocked | no | `set --key $KEY --mech $MECH` |
| yes | unlocked | matches mech | ðŸ”‘ granted | yes | â€” |

4 rows, 0 gaps. this is the complete pipeline â€” every key lands in exactly one row.

---

## matrix B: firewall resolution per mechanism

how the "value vs declared mech" check works, per mechanism type.

| ind: declared mech | ind: raw value shape | dep: status | dep: granted value | dep: raw value in env? |
|---|---|---|---|---|
| REPLICA (default) | api key (sk-..., tvly-..., etc.) | ðŸ”‘ granted | same value (pass through) | yes (no translation possible) |
| REPLICA (default) | ghp_... (long-lived pat) | ðŸš« blocked | â€” | no â€” ghp_ pats are forbidden globally |
| GITHUB_APP | json blob (appId + privateKey) | ðŸ”‘ granted | ghs_... (short-lived, ~1h) | no (json blob discarded) |
| GITHUB_APP | ghp_... (long-lived pat) | ðŸš« blocked | â€” | no |
| GITHUB_APP | ghs_... (short-lived token) | ðŸ”‘ granted | same value (pass through) | yes (already short-lived) |
| GITHUB_APP | json but invalid schema (e.g., no appId or no privateKey) | ðŸš« blocked | â€” | no â€” names which required fields are absent |
| GITHUB_APP | unrecognized format (not json, not ghp_, not ghs_) | ðŸš« blocked | â€” | no â€” requires json blob or ghs_ token |
| AWS_SSO | sso session valid | ðŸ”‘ granted | temporary aws credentials | no (profile ref discarded) |
| AWS_SSO | sso session expired | ðŸ”’ locked | â€” | no |

9 rows, 0 gaps.

note: `ghp_...` long-lived pats are blocked **regardless of declared mechanism**. the keyrack treats ghp_ pats as contraband â€” create a github app instead.

---

## matrix C: findsert semantics

how the keyrack behaves when embedded in test commands (e.g., `npm run test:integration`).

| ind: key in env? | ind: value safe? (vs declared mech) | dep: action | dep: tests proceed? |
|---|---|---|---|
| yes | safe | pass through (no-op) | yes |
| yes | not safe (violates mech) | ðŸš« blocked | no |
| no | â€” | load from keyrack â†’ cascade to matrix A | depends on matrix A outcome |

3 rows, 0 gaps. the "no, load from keyrack" case cascades into matrix A for the full resolution pipeline.

---

## matrix D: multi-key mount policy (get --for repo)

how the all-or-none policy applies across N declared keys.

| ind: worst key status across all N keys | dep: any keys mounted? | dep: summary format |
|---|---|---|
| all ðŸ”‘ granted | yes | "N granted, 0 blocked" |
| any ðŸ«§ unfound | no | counts per status category |
| any ðŸ”’ locked | no | counts per status category |
| any ðŸš« blocked | no | counts per status category |
| mix of unfound + locked + blocked | no | counts per status category |

5 rows, 0 gaps. the rule is simple: if any key is not ðŸ”‘ granted, no keys are mounted.

note: status for ALL N keys is always reported regardless of mount outcome. the developer sees the full picture.

---

## matrix E: set up a credential

| ind: --mech arg | ind: key already configured? | dep: vault prompt? | dep: setup guidance type | dep: warn overwrite? |
|---|---|---|---|---|
| (none) â†’ REPLICA | no | yes | paste raw value | no |
| GITHUB_APP | no | yes | github app credential walkthrough | no |
| AWS_SSO | no | yes | aws sso profile walkthrough | no |
| any | yes | â€” (halted before) | â€” | yes â†’ confirm overwrite or cancel |

4 rows, 0 gaps.

---

## matrix F: unlock a vault

| ind: vault type | ind: key configured? | ind: platform | dep: auth flow triggered | dep: outcome |
|---|---|---|---|---|
| os.secure | yes | linux | age passphrase prompt | unlocked; passphrase discarded |
| os.secure | yes | macos | age passphrase prompt | unlocked; passphrase discarded |
| os.secure | yes | windows | age passphrase prompt | unlocked; passphrase discarded |
| os.secure | yes | ci/docker | age passphrase prompt | unlocked; passphrase discarded |
| 1password | yes | any | `op` cli auth | unlocked; vault key discarded |
| os.direct | yes | any | none | reports: no unlock needed |
| any | no | any | none | fail fast: key not configured |

7 rows, 0 gaps.

note: os.secure uses age encryption on ALL platforms â€” identical behavior everywhere node runs. no platform-specific secret storage (keychain, secret service, etc.) in initial release.

---

## matrix G: error guidance (human vs robot)

| ind: error type | dep: robot stderr guidance | dep: human stderr guidance |
|---|---|---|
| ðŸ”’ locked | "ask a human to unlock this vault" | exact `unlock --key` command + vault type |
| ðŸ«§ unfound | "ask a human to set up this key" | exact `set --key` command + mech if declared |
| ðŸš« blocked | "ask a human to reconfigure this key" | exact `set --key` command + violation message |

3 rows, 0 gaps.

---

## matrix H: manifest presence

| ind: `.agent/keyrack.yml` present? | dep: outcome |
|---|---|
| yes, with keys declared | proceed to resolution (matrix A per key) |
| no | fail fast: "this repo does not declare keyrack requirements" |

2 rows, 0 gaps.

---

## matrix I: ci action step

| ind: raw secret shape | ind: declared mech | dep: written to `$GITHUB_ENV`? | dep: step outcome |
|---|---|---|---|
| json blob (appId + privateKey) | GITHUB_APP | yes (ghs_... short-lived token) | success |
| ghp_... (long-lived pat) | GITHUB_APP | no | ðŸš« blocked, step fails |
| ghs_... (short-lived token) | GITHUB_APP | yes (same value, pass through) | success |
| api key (sk-..., etc.) | REPLICA | yes (same value) | success |
| sso profile | AWS_SSO | yes (temporary credentials) | success |
| sso profile (expired session) | AWS_SSO | no | ðŸ”’ locked, step fails |

6 rows, 0 gaps. the ci action step applies the same resolution logic as local cli (matrix B).

---

## decomposition notes

all matrices have â‰¤ 3 independent dimensions. no decomposition needed.

the key design insight: **single key resolution (matrix A) is the atomic unit**. all other matrices compose on top of it:
- matrix D (multi-key) = matrix A applied per key + all-or-none policy
- matrix C (findsert) = env check + cascade to matrix A
- matrix I (ci action) = matrix B applied per secret + `$GITHUB_ENV` output

this compositional structure keeps each matrix narrow and testable.

---

## matrix J: credential lifetime and expiry

| ind: credential type | ind: lifetime governed by | ind: expiry event | dep: next `get` behavior |
|---|---|---|---|
| github app token | github (1h) | token expires | mints fresh token if vault unlocked |
| github app token | github (1h) | token expires + vault locked | ðŸ”’ locked, fix command printed |
| aws sso session | aws (session-scoped) | sso session expires | ðŸ”’ locked (sso session expired) |
| replica api key | provider (indefinite) | provider revokes externally | ðŸ”‘ granted (keyrack does not validate) |

4 rows, 0 gaps.

note: keyrack grants credentials â€” it does not revoke them. revocation is the credential provider's responsibility. keyrack cannot un-export a credential from an active process.

---

## matrix K: list keys

| ind: keys configured? | dep: output |
|---|---|
| yes, N keys | lists all N keys with vault type and createdAt (no values shown) |
| no | "no keys configured" + suggests `set --key $KEY` |

2 rows, 0 gaps.

---

## matrix L: remove key

| ind: key configured? | ind: vault type | dep: config removal | dep: value removal |
|---|---|---|---|
| yes | os.direct | removed from keyrack.config.json | removed from keyrack.direct.json |
| yes | os.secure | removed from keyrack.config.json | `.age` file deleted |
| yes | 1password | removed from keyrack.config.json | 1password item untouched |
| no | â€” | fail fast: key not configured | â€” |

4 rows, 0 gaps.

note: `del` only affects keyrack config, not the external vault for 1password.

---

## matrix M: vault-specific setup

| ind: vault choice | dep: value storage | dep: security | dep: platform behavior |
|---|---|---|---|
| os.direct | `~/.rhachet/keyrack.direct.json` | plaintext (warned) | identical everywhere |
| os.secure | `~/.rhachet/keyrack.secure.{hash}.age` | age-encrypted | identical everywhere |
| 1password | reference in keyrack.config.json | 1password vault | depends on `op` cli |

3 rows, 0 gaps.

---

## decomposition notes

all matrices have â‰¤ 3 independent dimensions. no decomposition needed.

the key design insight: **single key resolution (matrix A) is the atomic unit**. all other matrices compose on top of it:
- matrix D (multi-key) = matrix A applied per key + all-or-none policy
- matrix C (findsert) = env check + cascade to matrix A
- matrix I (ci action) = matrix B applied per secret + `$GITHUB_ENV` output
- matrix J (lifetime) = external provider governs expiry, keyrack re-resolves on next get
- matrix M (vault setup) = vault choice determines storage location and encryption

this compositional structure keeps each matrix narrow and testable.

---

## gap summary

all gaps resolved. 0 open gaps across all matrices.
