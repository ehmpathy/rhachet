# research: domain terms for rhachet/keyrack

> what should we call the domain objects?

---

## 1. prior art: how extant systems name their concepts

### 1.1 macos keyrack (apple)

| concept | apple's term |
|---------|-------------|
| the store | **Keyrack** (encrypted database, `SecKeyrack`) |
| a credential | **Keyrack Item** (`SecKeyrackItem`) |
| item categories | **Item Class** (internet password, generic password, certificate, key) |
| search mechanism | **Search Attributes** |

> [1] "Keyrack Services consists of two main parts: an encrypted database (represented by the SecKeyrack class) and items inserted into the database (represented by the SecKeyrackItem class)." â€” [Apple Developer: Keyrack Services](https://developer.apple.com/documentation/security/keyrack-services)

> [2] "macOS supports two different keyrack implementations, the file-based keyrack and the iOS-style database keyrack. The latter is also called data protection keyrack." â€” [Apple TN3137](https://developer.apple.com/documentation/technotes/tn3137-on-mac-keyracks)

### 1.2 windows credential manager

| concept | windows's term |
|---------|---------------|
| the store | **Credential Manager** / **Credential Store** |
| a credential | **Credential** (`CREDENTIAL` struct) |
| subtypes | **Type** (`CRED_TYPE_GENERIC`, `CRED_TYPE_DOMAIN_PASSWORD`, `CRED_TYPE_DOMAIN_CERTIFICATE`) |
| the secret value | **CredentialBlob** |
| the identifier | **TargetName** |

> [3] "Generic credentials are defined and authenticated by applications that manage authorization and security directly instead of to delegate these tasks to the OS." â€” [Microsoft Learn: Kinds of Credentials](https://learn.microsoft.com/en-us/windows/win32/secauthn/kinds-of-credentials)

> [4] the `CREDENTIAL` struct contains fields `Type`, `TargetName`, `CredentialBlob`, `UserName`. â€” [Microsoft Learn: CREDENTIALA](https://learn.microsoft.com/en-us/windows/win32/api/wincred/ns-wincred-credentiala)

### 1.3 linux libsecret / gnome keyring

| concept | libsecret's term |
|---------|-----------------|
| the store | **Collection** (was "keyring" in old api) |
| a credential | **Secret Item** / **Item** |
| item type definition | **Schema** (`SecretSchema`) |
| item metadata | **Attributes** (string key-value pairs, unencrypted) |
| the secret value | **Secret** (the encrypted part) |

> [5] "Keyrings are called 'collections' in libsecret. This is the same lingo as the Secret Service DBus API." â€” [Jan-Piet Mens](https://jpmens.net/2024/10/24/notes-to-self-gnome-keyring-and-libsecret/)

> [6] "The libsecret API is focused on schemas, and encourages users to define a SecretSchema for their password storage." â€” [GNOME libsecret Migration Guide](https://gnome.pages.gitlab.gnome.org/libsecret/migrating-libgnome-keyring.html)

### 1.4 1password cli (`op`)

| concept | 1password's term |
|---------|-----------------|
| a group of credentials | **Vault** |
| a credential | **Item** |
| a field within a credential | **Field** |
| a group of fields | **Section** |
| uri reference format | `op://<vault>/<item>/<section>/<field>` |

> [7] "A secret reference URI includes the names (or unique identifiers) of the vault, item, section, and field where a secret is stored in your 1Password account." â€” [1Password: Secret References](https://developer.1password.com/docs/cli/secret-references/)

> [8] "Items are the objects you perform CRUD operations on in the 1Password vaults." â€” [1Password CLI: item](https://developer.1password.com/docs/cli/reference/management-commands/item/)

### 1.5 hashicorp vault

| concept | vault's term |
|---------|-------------|
| credential store | **Vault** (the system) |
| storage backend plugin | **Secrets Engine** |
| where an engine is enabled | **Mount** / **Mount Path** |
| a credential | **Secret** |
| time-limited credential | **Lease** (with `lease_id`, `lease_duration`) |
| validity period | **TTL** (time to live) |
| extendable? | **Renewable** (boolean) |
| token handle for management | **Accessor** |
| access control declaration | **Policy** (declarative, deny-by-default) |
| policy actions | **Capabilities** (create, read, update, delete, list, deny, sudo) |
| dynamic vs static | **Dynamic Secret** vs **Static Secret** |

> [9] "A Secrets Engine is a plugin-style component in Vault that you enable at a specific mount path... To the user, secrets engines behave similar to a virtual filesystem." â€” [HashiCorp: Secrets Engines](https://developer.hashicorp.com/vault/docs/secrets)

> [10] "All dynamic secrets in Vault are required to have a lease. Even if the data is meant to be valid for eternity, a lease is required to force the consumer to check in routinely." â€” [HashiCorp: Lease, Renew, and Revoke](https://developer.hashicorp.com/vault/docs/concepts/lease)

> [11] "Policies provide a declarative way to grant or forbid access to certain paths and operations in Vault." â€” [HashiCorp: Policies](https://developer.hashicorp.com/vault/docs/concepts/policies)

> [12] "Vault promises that the data will be valid for the given duration, or Time To Live (TTL)." â€” [HashiCorp: Tune the Lease TTL](https://developer.hashicorp.com/vault/docs/troubleshoot/tune-lease-ttl)

### 1.6 aws secrets manager / ssm parameter store

| concept | aws's term |
|---------|-----------|
| a credential | **Secret** (secrets manager) / **Parameter** (ssm) |
| the secret payload | **Secret Value** / **SecretString** |
| version labels | **Version** with **Labels** (`AWSCURRENT`, `AWSPENDING`, `AWSPREVIOUS`) |
| auto-refresh | **Rotation** |

> [13] "A secret has versions that hold copies of the encrypted secret value. Secrets Manager doesn't store a linear history of secrets with versions. Instead, it keeps track of three specific versions via labels." â€” [AWS: What's in a secret?](https://docs.aws.amazon.com/secretsmanager/latest/userguide/whats-in-a-secret.html)

### 1.7 kubernetes / external secrets operator

| concept | k8s term |
|---------|---------|
| a credential | **Secret** (Kind=Secret) |
| external source reference | **ExternalSecret** (eso) |
| backend config | **SecretStore** / **ClusterSecretStore** (eso) |
| backend system | **Provider** (eso) |

> [14] "A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key." â€” [Kubernetes: Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)

> [15] "A SecretStore defines how to fetch the data. It defines the provider, such as Vault, its server address, the path for secrets, and its authentication method." â€” [External Secrets Operator](https://external-secrets.io/latest/provider/kubernetes/)

> [16] "The ExternalSecret describes what data should be fetched, how the data should be transformed and saved as a Kind=Secret." â€” [External Secrets Operator: ExternalSecret](https://external-secrets.io/v0.4.4/api-externalsecret/)

### 1.8 docker secrets

| concept | docker's term |
|---------|-------------|
| a credential | **Secret** |
| delivery mechanism | **Mount** (in-memory filesystem at `/run/secrets/<secret_name>`) |
| access control | **Granted access** (services must be "granted explicit access") |

> [17] "A given secret is only accessible to those services which have been granted explicit access to it, and only while those service tasks run." â€” [Docker Docs: Manage sensitive data with Docker secrets](https://docs.docker.com/engine/swarm/secrets/)

> [18] "When a container task stops, the decrypted secrets shared to it are unmounted from the in-memory filesystem for that container and flushed from the node's memory." â€” [Docker Docs](https://docs.docker.com/engine/swarm/secrets/)

### 1.9 pass (unix password manager)

| concept | pass's term |
|---------|------------|
| the store | **Password Store** (`~/.password-store`) |
| a credential | **Password Entry** (a gpg-encrypted file) |
| organization | **Folder hierarchy** (freeform directory tree) |

> [19] "Pass keeps passwords inside gpg2 encrypted files inside a simple directory tree at ~/.password-store." â€” [passwordstore.org](https://www.passwordstore.org/)

### 1.10 age / sops

| concept | age/sops term |
|---------|-------------|
| public key | **Recipient** |
| private key | **Identity** |
| key file | **Identity File** (`keys.txt`) |

> [20] "Files can be encrypted to multiple recipients via -r/--recipient, and every recipient will be able to decrypt the file." â€” [GitHub: FiloSottile/age](https://github.com/FiloSottile/age)

### 1.11 oauth2 / oidc

| concept | oauth/oidc term |
|---------|----------------|
| permission type | **Grant** (authorization code grant, client credentials grant) |
| short-lived credential | **Access Token** |
| refresh mechanism | **Refresh Token** |
| identity proof | **ID Token** |
| permission scope | **Scope** |
| data within token | **Claim** |
| the issuer | **Authorization Server** |

> [21] "Client credentials can be used as an authorization grant when the authorization scope is limited to the protected resources under the control of the client." â€” [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

> [22] "Access tokens are credentials used to access protected resources. An access token is a string that represents an authorization issued to the client." â€” [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

> [23] "In OAuth 2.0, a dedicated authorization server takes care of token mint and policy enforcement." â€” [connect2id: OAuth 2.1 explained](https://connect2id.com/learn/oauth-2-1)

### 1.12 github app installation tokens

| concept | github term |
|---------|-----------|
| long-lived secret | **Private Key** (.pem file) |
| intermediate token | **JWT** (10-minute ttl) |
| short-lived output | **Installation Access Token** (1-hour ttl) |

> [24] "A GitHub App Installation Token is a short-lived access token that allows a GitHub App to interact with specific repositories or organizations where it has been installed. The installation access token will expire after 1 hour." â€” [DevOpsSchool](https://www.devopsschool.com/blog/what-is-github-app-installation-token/)

---

## 2. cross-system concept comparison

### 2.1 the container that holds credentials

| system | term |
|--------|------|
| macos | **Keyrack** |
| windows | **Credential Manager** |
| gnome/linux | **Collection** (formerly "keyring") |
| 1password | **Vault** |
| hashicorp | **Vault** |
| aws | **Secrets Manager** / **Parameter Store** |
| kubernetes | **Secret** (object) |
| docker | **Secret** (swarm-managed) |
| pass | **Password Store** |

### 2.2 a single credential entry

| system | term |
|--------|------|
| macos | **Keyrack Item** |
| windows | **Credential** |
| gnome/linux | **Secret Item** / **Item** |
| 1password | **Item** |
| hashicorp vault | **Secret** |
| aws | **Secret** / **Parameter** |
| kubernetes | **Secret** |
| docker | **Secret** |
| pass | **Entry** (a file) |
| oauth2 | **Token** / **Grant** |

### 2.3 the act of resolve/translate credentials

| system | term |
|--------|------|
| hashicorp vault | **Lease** (dynamic generation with ttl) |
| oauth2 | **Grant** / **Issue** |
| github apps | **Mint** (jwt) then **Generate** (installation token) |
| aws | **Rotate** |
| microsoft identity | **Mint** ("authorization server takes care of token mint") |
| general | **Resolve**, **Exchange**, **Derive** |

### 2.4 storage backend

| system | term |
|--------|------|
| hashicorp vault | **Secrets Engine** (mounted at a path) |
| k8s external secrets | **Provider** (in a SecretStore) |
| 1password | **Vault** (the container) |
| general | **Backend**, **Store**, **Provider** |

### 2.5 translation/resolution mechanism

| system | term |
|--------|------|
| hashicorp vault | **Secrets Engine** (dynamic engine generates on read) |
| oauth2 | **Grant Type** (the mechanism via which tokens are obtained) |
| github apps | **Auth flow** (private key -> jwt -> installation token) |
| general | **Resolver**, **Adapter**, **Engine** |

### 2.6 status of a credential

| system | term |
|--------|------|
| hashicorp vault | **Lease states**: active, expired, revoked |
| aws secrets manager | **Labels**: AWSCURRENT, AWSPREVIOUS |
| oauth2 | token is: valid, expired, revoked |
| docker | **Granted** (service has explicit access) or not |

### 2.7 manifest/declaration of required credentials

| system | term |
|--------|------|
| hashicorp vault | **Policy** (declarative, deny-by-default, path-based) |
| k8s external secrets | **ExternalSecret** (spec that declares what to fetch) |
| docker compose | **secrets** key in `docker-compose.yml` |
| general | **Manifest**, **Declaration**, **Requirements**, **Spec** |

---

## 3. parallel domain terminology

### 3.1 physical keyrack

| physical term | potential map |
|---------------|-------------|
| **Keyrack** | the system itself (collection of keys) |
| **Key** | a single credential |
| **Fob** | an attached identifier/decorator for a key |
| **Retractable Reel** | extend access temporarily, then retract |
| **Carabiner** | quick-attach/detach mount point |

> [25] "A keyrack (also key ring) is a small ring or chain of metal to which several keys, or fobs can be attached." â€” [Wikipedia: Keyrack](https://en.wikipedia.org/wiki/Keyrack)

### 3.2 locksmith terminology

| locksmith term | definition | potential map |
|----------------|------------|--------------|
| **Key Blank** | an uncut key used as a start point | a raw credential (unresolved) |
| **Bitt** | the cut pattern on a key that makes it unique | the specific credential value |
| **Keyway** | the shape of the hole that accepts a key | the mechanism/adapter type |
| **Master Key** | a key that opens many locks | a broad-scope credential |
| **Ward** | metal obstruction inside a lock that blocks wrong keys | a credential blocker/firewall rule |
| **Cylinder** | the main body that houses the lock mechanism | the vault/backend |
| **Plug** | the part that the key turns | the resolver/adapter |
| **Escutcheon** | the plate that covers the keyhole | the interface/api surface |
| **Shackle** | the u-shaped loop on a padlock | the exported handle |

> [26] "Key Blank: A basic, uncut key that locksmiths use to create a new key via the necessary grooves and notches." â€” [Mr Locksmith Glossary](https://www.mrlocksmithtraining.com/glossary/)

> [27] "Ward: Formed pieces of concentric metal are affixed around the inside of the keyhole... The bitted key passes over these wards to operate the bolt." â€” [Locksmiths.co.uk Terminology](https://www.locksmiths.co.uk/locksmith-terminology-parts-of-locks/)

> [28] "Bitting: The number(s) that represent(s) the dimensions of the key cuts... The bitting instructs a locksmith how to cut a certain key." â€” [Mr Locksmith Glossary](https://www.mrlocksmithtraining.com/glossary/)

> [29] "Escutcheon: The cover for the keyhole of a mortice or similar lock." â€” [Locksmiths.co.uk](https://www.locksmiths.co.uk/locksmith-terminology-parts-of-locks/)

### 3.3 bank / safe deposit box

| bank term | definition | potential map |
|-----------|------------|--------------|
| **Vault** | the secure room that houses deposit boxes | the overall secret storage system |
| **Safe Deposit Box** | individual locked container within vault | a single vault entry |
| **Guard Key** | bank's key (one of two required) | system-side credential |
| **Renter Key** | customer's key (one of two required) | user-side credential |
| **Dual Control** | two parties required to open | two-factor / dual-authorization |

> [30] "The bank keeps a second key, called the 'guard key,' in case an authorized employee needs to access the box." â€” [NerdWallet: Safe Deposit Box](https://www.nerdwallet.com/article/banking/what-is-safe-deposit-box)

> [31] "When the safe deposit account is opened, all persons authorized to access the box sign a signature card. The bank allows only those individuals to open the box." â€” [PNC: Safe Deposit Box](https://www.pnc.com/insights/personal-finance/protect/what-is-a-safe-deposit-box.html)

### 3.4 airport security

| airport term | definition | potential map |
|-------------|------------|--------------|
| **Checkpoint** | the gate where all passengers are screened | the credential firewall |
| **Screen** (verb) | to inspect and validate | credential validation/resolution |
| **Board Pass** | the issued, time-limited access document | the resolved grant (short-lived token) |
| **Clearance** | permission to proceed | credential status: granted |
| **PreCheck** | pre-verified trusted traveler | pre-authorized mechanism |

> [32] "Security checkpoints are typically located before gates... where passengers must present a valid pass and comply with security rules." â€” [TripGain: Security Checkpoint](https://tripgain.com/glossary/security-checkpoint)

### 3.5 military / government clearance

| military term | definition | potential map |
|-------------|------------|--------------|
| **Clearance** | authorization level (confidential, secret, top secret) | credential access level |
| **Compartment** | isolated information set, identified via code word | scoped credential group |
| **Need-to-Know** | access only if required for role | minimum-privilege principle |

> [33] "Compartments of information are identified by code words, and this is one means by which the 'need to know' principle is formally and automatically enforced." â€” [Wikipedia: U.S. Security Clearance Terms](https://en.wikipedia.org/wiki/List_of_U.S._security_clearance_terms)

### 3.6 healthcare / pharmacy

| healthcare term | definition | potential map |
|----------------|------------|--------------|
| **Prescription** | a doctor's written order for a specific medication | a declared credential requirement (manifest entry) |
| **Formulary** | the approved list of medications | the manifest of allowed credentials |
| **Dispensary / Pharmacy** | the place that fulfills prescriptions | the resolver/adapter |
| **Schedule** (i-v) | classification of controlled substance risk | credential risk level (longlived=high, short-lived=low) |
| **Controlled Substance** | drugs with abuse potential, that require special care | long-lived / high-risk credentials |

> [34] "Drugs, substances, and certain chemicals used to make drugs are classified into five (5) distinct categories or schedules based on the drug's acceptable medical use and the drug's abuse or dependency potential." â€” [DEA: Drug Schedule](https://www.dea.gov/drug-information/drug-scheduling)

### 3.7 hotel keycard system

| hotel term | definition | potential map |
|-----------|------------|--------------|
| **Keycard** | the time-limited access credential given at check-in | the resolved short-lived grant |
| **Card Encoder** | the machine that programs keycards | the credential resolver |
| **Front Desk** | where keycards are issued | the credential firewall/gateway |
| **Check-In** | the process of identity verification and card issuance | the mount/resolution process |
| **Checkout Date** | encoded expiry on the card | ttl / lease expiry |
| **Blank Keycard** | unprogrammed card stock | raw/unresolved credential |

> [35] "When a guest checks in, the front desk assigns a room and programs the key card to grant access to the room door for the duration of the stay." â€” [Kisi: How Hotel Key Cards Work](https://www.getkisi.com/blog/how-do-hotel-key-cards-work)

> [36] "Personnel at the hotel desk will imprint the user information at check-in and usually set a time limit for its use until checkout." â€” [Kisi](https://www.getkisi.com/blog/how-do-hotel-key-cards-work)

---

## 4. domain object term proposals

for each domain object, options are scored on:
- **specificity** â€” eliminates ambiguity, minimizes confusion
- **intuition** â€” eliminates friction, maximizes adoption
- **precedent** â€” alignment with established systems

### 4.1 the system itself

already decided: **Keyrack**. aligns with apple's macos keyrack (the most direct precedent for a credential manager on a developer machine). "keyrack" is physical, intuitive, and well-known.

### 4.2 per-repo manifest (`.agent/keyrack.yml`)

what it is: a declarative file that says "this repo needs these keys, resolved via these mechanisms"

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **KeyManifest** | k8s externalsecret, docker-compose secrets | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | "manifest" is the standard term for declarative requirements files |
| **KeyPolicy** | hashicorp vault policy | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜†â˜† | "policy" implies enforcement â€” accurate but feels more like access control than requirements |
| **KeyFormulary** | healthcare formulary | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜†â˜†â˜† | precise but unfamiliar to most developers |
| **KeySpec** | k8s resource specs | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | "spec" is well-known from k8s, terraform |

**recommendation**: **KeyManifest** or **KeySpec**

- "manifest" wins on precedent (package.json, docker-compose, k8s manifests are all declarative requirements)
- "spec" wins on brevity

### 4.3 per-machine config (`~/.rhachet/keyrack.config.json`)

what it is: maps each key name to its vault backend + metadata on this specific machine

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **KeyrackConfig** | general config pattern | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜… | simple and obvious, aligns with convention |
| **SecretStore** | k8s external secrets operator | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | "store" maps well â€” it defines where secrets are stored per-machine |
| **VaultMap** | general | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜†â˜† | "map" implies the keyâ†’vault relation |

**recommendation**: **KeyrackConfig**

- simplest, most obvious, no ambiguity
- the file is literally the keyrack's config for this machine

### 4.4 a single entry in the manifest (declares name + mechanism)

what it is: one key declared in `keyrack.yml` â€” says "this repo needs THIS_KEY resolved via THIS_MECH"

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **KeyRequirement** | general requirements pattern | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | explicitly declares a requirement |
| **KeyDeclaration** | declarative patterns | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | the manifest declares what is needed |
| **KeyPrescription** | healthcare | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜†â˜† | beautiful metaphor â€” a prescription declares what medication (key) via which mechanism (dispensary) â€” but unfamiliar in software |
| **KeyEntry** | general | â˜…â˜…â˜…â˜†â˜† | â˜…â˜…â˜…â˜…â˜… | simple but vague â€” "entry" could mean too many things |

**recommendation**: **KeyRequirement**

- most precise: the manifest entry is literally a requirement
- aligns with npm peer dependencies, docker requirements, etc.

### 4.5 a single entry in the config (declares vault + metadata)

what it is: one key's vault bind on this machine â€” says "THIS_KEY is stored in THIS_VAULT"

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **KeyBind** | general bind pattern | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | it binds a key name to a vault location |
| **KeySource** | general | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | where the key comes from |
| **VaultEntry** | 1password vault entries | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜†â˜† | specific but puts vault first |
| **KeyProvision** | general | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜†â˜† | how the key is provisioned on this machine |

**recommendation**: **KeyBind**

- precise: it binds a key name to a vault + metadata
- clean pair: manifest has **KeyRequirement**, config has **KeyBind**
- "bind" is well-understood (env var bind, port bind, etc.)

### 4.6 vault backends (os.direct, os.secure, 1password)

what it is: the storage backend where raw credentials live

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **Vault** | hashicorp, 1password | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜… | the established term. already used in the vision: `--vault os.direct` |
| **Store** | general, k8s secretstore | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | clear but generic |
| **Backend** | hashicorp, general | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜†â˜† | technical, less intuitive |
| **Locker** | physical metaphor | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | strong physical metaphor (gym locker, school locker) |

**recommendation**: **Vault**

- already established in the wish/vision (`--vault os.direct`, `--vault 1password`)
- strongest precedent (hashicorp vault, 1password vault)
- most intuitive to developers

### 4.7 mechanism adapters (REPLICA, GITHUB_APP, AWS_SSO)

what it is: the translation logic that resolves raw credentials into their shortest-lived form

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **Mechanism** | already used in wish: `--mech` | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | established in the vision, generic enough |
| **GrantType** | oauth2 grant types | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | strongest software precedent â€” oauth2's "grant type" determines how tokens are obtained |
| **Keyway** | locksmith | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜†â˜† | beautiful metaphor â€” the keyway shape determines which key fits â€” but unfamiliar |
| **Resolver** | general | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | describes what it does â€” resolves raw â†’ short-lived |
| **Engine** | hashicorp vault secrets engine | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜†â˜† | precise but overloaded |
| **Minter** | oauth2 token mint | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | describes the action well |

**recommendation**: **Mechanism** (keep as-is) or **GrantType**

- "mechanism" is already established in the wish (`--mech GITHUB_APP`)
- "grant type" is the strongest software precedent (rfc 6749) and maps perfectly: the mechanism determines *how* a credential grant is obtained
- either works; "mechanism" is simpler, "grant type" is more precise

### 4.8 credential status (granted, not found, locked, blocked)

what it is: the state of a credential when the keyrack evaluates it

| status | emoji | precedent | notes |
|--------|-------|-----------|-------|
| **granted** | ðŸ”‘ | docker ("granted explicit access"), oauth2 | the key resolved and is available |
| **absent** | ðŸ«§ | general | the key is not configured on this machine |
| **locked** | ðŸ”’ | general, locksmith | the vault requires auth to unlock |
| **blocked** | ðŸš« | general, airport security | the key violates the declared mechanism |

**recommendation**: **granted / absent / locked / blocked**

- these four cover all cases from the criteria
- "absent" > "not found" â€” "not found" implies a search that failed; "absent" states a fact: the key is not here
- "granted" from oauth2/docker precedent
- "locked" from physical metaphor (vault is locked, need to unlock)
- "blocked" from firewall/airport metaphor (contraband detected, refused)

### 4.9 the resolution result (output of one key resolved)

what it is: the bundle returned when a key is evaluated: status + value (if granted) + metadata

| option | precedent | specificity | intuition | notes |
|--------|-----------|-------------|-----------|-------|
| **KeyGrant** | oauth2 grant | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜… | the output is literally a "grant" â€” access was granted, here's the token |
| **KeyLease** | hashicorp vault lease | â˜…â˜…â˜…â˜…â˜… | â˜…â˜…â˜…â˜…â˜† | "lease" implies ttl + renewability â€” accurate for resolution output |
| **KeyResult** | general | â˜…â˜…â˜…â˜†â˜† | â˜…â˜…â˜…â˜…â˜… | simple but vague |
| **KeyResolution** | general | â˜…â˜…â˜…â˜…â˜† | â˜…â˜…â˜…â˜…â˜† | describes the process output |

**recommendation**: **KeyGrant**

- oauth2 precedent: a "grant" is a resolved, scoped, time-limited authorization [21][22]
- aligns with the vision metaphor: "credentials go in. only keycards come out." â€” the keycard IS the grant
- aligns with docker: "granted explicit access" [17]
- clean: `status: granted` â†’ the result is a `KeyGrant`

### 4.10 the exported short-lived value

what it is: the actual env var value exported to downstream processes â€” the "keycard"

**recommendation**: don't separate 4.9 and 4.10. the **KeyGrant** IS the exported value. no need for two terms.

---

## 5. relationships between domain objects

### 5.1 treestruct

```
Keyrack (the system)
â”œâ”€â”€ KeyManifest (per-repo, `.agent/keyrack.yml`)
â”‚   â””â”€â”€ KeyRequirement[] (one per declared key)
â”‚       â”œâ”€â”€ name: string (env var name)
â”‚       â””â”€â”€ mech: Mechanism (REPLICA | GITHUB_APP | AWS_SSO)
â”‚
â”œâ”€â”€ KeyrackConfig (per-machine, `~/.rhachet/keyrack.config.json`)
â”‚   â””â”€â”€ KeyBind[] (one per configured key)
â”‚       â”œâ”€â”€ name: string (env var name)
â”‚       â”œâ”€â”€ vault: Vault (os.direct | os.secure | 1password)
â”‚       â””â”€â”€ metadata: { createdAt, updatedAt, vault_ref? }
â”‚
â”œâ”€â”€ Vault (storage backend)
â”‚   â”œâ”€â”€ VaultDirect (os.direct â€” plaintext, `~/.rhachet/keyrack.direct.json`)
â”‚   â”œâ”€â”€ VaultSecure (os.secure â€” encrypted, `~/.rhachet/keyrack.secure.{hash}.age`)
â”‚   â””â”€â”€ Vault1Password (1password â€” op:// reference)
â”‚
â”œâ”€â”€ Mechanism (resolution adapter)
â”‚   â”œâ”€â”€ MechLonglived (pass through, no translation)
â”‚   â”œâ”€â”€ MechGithubApp (json blob â†’ installation access token)
â”‚   â””â”€â”€ MechAwsSso (sso profile â†’ temporary aws credentials)
â”‚
â””â”€â”€ KeyGrant (resolution output)
    â”œâ”€â”€ status: KeyStatus (granted | absent | locked | blocked)
    â”œâ”€â”€ value?: string (the exported env var value, only if granted)
    â”œâ”€â”€ name: string (env var name)
    â”œâ”€â”€ message?: string (human-readable status message)
    â””â”€â”€ fix?: string (the command to fix, if not granted)
```

### 5.2 dependencies

```
KeyManifest
  â””â”€â”€ references â†’ Mechanism (each requirement declares its mech)

KeyrackConfig
  â””â”€â”€ references â†’ Vault (each bind declares its vault)

KeyGrant
  â”œâ”€â”€ produced from â†’ KeyRequirement (what was required)
  â”œâ”€â”€ resolved via â†’ KeyBind (where was it stored)
  â”œâ”€â”€ translated by â†’ Mechanism (how was it resolved)
  â””â”€â”€ retrieved from â†’ Vault (which backend)
```

### 5.3 the resolution flow

```
KeyManifest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  (declares N KeyRequirements)                                â”‚
                                                              â–¼
KeyrackConfig â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ KeyGrant[]
  (maps each key name â†’ vault)                       (one per requirement)
                                                              â”‚
Vault â”€â”€â”€â”€ raw credential â”€â”€â”€â”€ Mechanism â”€â”€â”€â”€ resolved value â”€â”˜
  (retrieves)                    (translates)
```

### 5.4 domain object classification

| domain object | type | why |
|---------------|------|-----|
| KeyManifest | DomainLiteral | immutable per-repo declaration. if you change any requirement, it's a different manifest |
| KeyRequirement | DomainLiteral | immutable. name + mech = the identity. change either = different requirement |
| KeyrackConfig | DomainEntity | mutable per-machine state. same machine, different binds over time. identity = machine |
| KeyBind | DomainLiteral | immutable snapshot. a bind is name + vault + metadata. change vault = new bind |
| KeyGrant | DomainLiteral | immutable result of resolution. value + status + metadata. read-only, never mutated |
| Vault | DomainLiteral | value object â€” `os.direct`, `os.secure`, `1password` are enums, not entities |
| Mechanism | DomainLiteral | value object â€” `REPLICA`, `GITHUB_APP`, `AWS_SSO` are enums, not entities |
| KeyStatus | enum | `granted`, `absent`, `locked`, `blocked` |

---

## 6. strongest metaphor alignments (summary)

| # | metaphor | domain object | why it's the strongest fit |
|---|----------|---------------|---------------------------|
| 1 | oauth2 **Grant** [21][22] | KeyGrant | a "grant" is a resolved, scoped, time-limited authorization â€” exactly what keyrack exports |
| 2 | hashicorp vault **Lease** [10][12] | KeyGrant (alternative) | lease bundles value + ttl + renewability â€” accurate for resolution output |
| 3 | k8s **ExternalSecret** [16] | KeyManifest | declares what secrets are needed and references a store for how to get them |
| 4 | k8s **SecretStore** / **Provider** [15] | KeyrackConfig + Vault | the store maps to a backend provider â€” exactly what config does |
| 5 | hashicorp vault **Policy** [11] | KeyManifest (alternative) | deny-by-default declarative access control matches all-or-none mount |
| 6 | locksmith **Ward** [27] | firewall block logic | a ward blocks the wrong key â€” the firewall blocks unsafe credentials |
| 7 | locksmith **Keyway** [28] | Mechanism | the keyway shape determines which key fits â€” the mechanism determines which resolution applies |
| 8 | hotel **Keycard** [35][36] | KeyGrant (metaphor) | time-limited, issued at check-in, expires at checkout â€” perfect metaphor for the export |
| 9 | healthcare **Formulary** [34] | KeyManifest (alternative) | the approved list of medications, classified by schedule â€” the approved list of keys, classified by mechanism |
| 10 | airport **Checkpoint** [32] | the keyrack itself | the gate that screens all credentials â€” inspect, resolve, block contraband, clear passengers |

---

## 7. proposed ubiquitous language

| concept | proposed term | short form | precedent |
|---------|--------------|------------|-----------|
| the system | **Keyrack** | keyrack | apple macos keyrack |
| per-repo manifest | **KeyManifest** | manifest | k8s, docker, npm |
| manifest entry | **KeyRequirement** | requirement | npm peer deps, docker |
| per-machine config | **KeyrackConfig** | config | general convention |
| config entry | **KeyBind** | bind | general (env var bind, port bind) |
| storage backend | **Vault** | vault | hashicorp, 1password |
| resolution mechanism | **Mechanism** | mech | already coined in wish |
| resolution output | **KeyGrant** | grant | oauth2 rfc 6749 |
| credential status | **KeyStatus** | status | enum: granted, absent, locked, blocked |
| the exported value | (part of KeyGrant) | grant.value | no separate term needed |
| the firewall action | **screen** (verb) | screen | airport checkpoint |

### term relationships (one sentence)

> the **keyrack** reads a **manifest** of **requirements**, checks the **config** for **binds**, retrieves raw credentials from **vaults**, translates them via **mechanisms**, and produces **grants** â€” or fails fast with a clear status.
