# research: remote access required for rhachet/keyrack

> what remote repositories must we access, via what contracts, and with what best practices?

---

## overview

rhachet/keyrack must access 4 categories of remote resources:

| # | resource | interface | why |
|---|----------|-----------|-----|
| A | github api (app token mint) | rest api via https | resolve GITHUB_APP credentials to short-lived `ghs_` tokens |
| B | aws sso (iam identity center) | cli + oidc + sts api | resolve AWS_SSO credentials to temporary iam credentials |
| C | 1password cli (`op`) | cli subprocess | retrieve secrets from 1password vaults |
| D | os keyrack (macOS + linux) | cli subprocess or native binds | retrieve secrets from os-level credential stores |

---

## A. github api — app token mint

### A.1 what we access

the github rest api, to translate a github app's `appId` + `privateKey` json blob into a short-lived installation access token (`ghs_...`, 1h lifetime).

### A.2 the contract

#### step 1: build jwt

| field | value | source |
|-------|-------|--------|
| algorithm | RS256 | [1] |
| `iss` | app's client id (preferred) or application id | [1] |
| `iat` | current time minus 60 seconds | [1] |
| `exp` | current time plus up to 600 seconds (10 min max) | [1] |

> "Your JWT must be signed using the `RS256` algorithm." — [1]

> "Set this 60 seconds in the past to protect against clock drift." — [1]

> "The time must be no more than 10 minutes into the future." — [1]

> "Use of the client ID is recommended." — [1]

#### step 2: get installation id

| endpoint | auth | note |
|----------|------|------|
| `GET /orgs/{org}/installation` | Bearer jwt | org-level lookup |
| `GET /repos/{owner}/{repo}/installation` | Bearer jwt | repo-level lookup |

> "You must use a JWT to access this endpoint." — [4]

> "If you are responding to a webhook event, the webhook payload will include the installation ID." — [2]

#### step 3: mint installation access token

| endpoint | auth | body |
|----------|------|------|
| `POST /app/installations/{installation_id}/access_tokens` | Bearer jwt | optional: `permissions`, `repositories` |

> "You can use the `repositories` or `repository_ids` body parameters to specify individual repositories that the installation access token can access." — [2]

> "If `permissions` is not specified, the installation access token will have all of the permissions that were granted to the app." — [2]

#### step 4: use the token

the response contains `{ token: "ghs_...", expires_at: "..." }`. use as `Authorization: Bearer ghs_...` for rest and graphql. for git: `git clone https://x-access-token:TOKEN@github.com/owner/repo.git`.

> "Installation tokens expire one hour from the time you create them." — [5]

> "Include it in the `Authorization` header of an API request. The access token will work with both the GraphQL API and the REST API." — [3]

### A.3 token prefixes

| token type | prefix |
|------------|--------|
| personal access token (classic) | `ghp_` |
| fine-grained personal access token | `github_pat_` |
| installation access token (github app) | `ghs_` |
| user access token (github app) | `ghu_` |
| refresh token (github app) | `ghr_` |

> source: [6]

### A.4 best practices

> "User access tokens and installation access tokens are meant to be used until they expire. You should cache tokens that you create. Before you create a new token, check your cache to see if you already have a valid token. Reusing tokens will make your app faster since it will make fewer requests to generate tokens." — [7]

> "The private key for your GitHub App grants access to every account that the app is installed on. It must be stored securely and never shared broadly." — [7]

> "Consider storing your GitHub App's private key in a key vault, such as Azure Key Vault, and making it sign-only." — [7]

> "When you register a GitHub App, select the minimum permissions that your GitHub App needs. If any keys or tokens for your app become compromised, this will limit the amount of damage that can occur." — [7]

> "GitHub strongly encourages you to use user access tokens that expire." — [7]

### A.5 lessons

1. **jwt has 10-min max lifetime** — build a fresh jwt for each token mint; do not cache jwts
2. **cache installation tokens** — they last 1h; re-mint on every call wastes rate limit
3. **private key must stay in vault** — never export to env; consume in-process and discard
4. **least privilege** — scope tokens to the repositories and permissions needed
5. **prefix detection enables firewall** — `ghp_` = block, `ghs_` = pass through, json blob = resolve

### A.6 citations

| # | document | url |
|---|----------|-----|
| [1] | generate a jwt for a github app | https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-json-web-token-jwt-for-a-github-app |
| [2] | generate an installation access token | https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-an-installation-access-token-for-a-github-app |
| [3] | authenticate as a github app installation | https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/authenticating-as-a-github-app-installation |
| [4] | rest api endpoints for github apps | https://docs.github.com/en/rest/apps/apps |
| [5] | create an installation access token (rest ref) | https://docs.github.com/en/rest/apps/apps#create-an-installation-access-token-for-an-app |
| [6] | about authentication to github (token prefixes) | https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github |
| [7] | best practices for a github app | https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/best-practices-for-creating-a-github-app |

---

## B. aws sso — iam identity center

### B.1 what we access

aws iam identity center (sso) to obtain temporary sts credentials for a declared aws profile. the cli uses pkce-based oauth to authenticate the user, then retrieves session credentials via the sso api.

### B.2 the contract

#### authorization flow

since aws cli v2.22.0, `aws sso login` uses pkce by default. it opens a browser on the local machine and redirects to a localhost callback.

> "Proof Key for Code Exchange (PKCE) authorization is used by default for the AWS CLI starting with version 2.22.0 and must be used on devices with a browser." — [8]

> "PKCE authorization URLs must be opened on the same device you're signing in to and must be used for a device with a browser." — [8]

> "The AWS CLI attempts to open your default browser for the sign in process of your IAM Identity Center account." — [8]

for headless environments: `aws sso login --profile my-dev-profile --use-device-code`

> "Device authorization URLs do not need to be opened on the same device you're signing in to and can be used for a device with or without a browser." — [8]

#### config format (`~/.aws/config`)

```ini
[profile dev]
sso_session = my-sso
sso_account_id = 111122223333
sso_role_name = SampleRole

[sso-session my-sso]
sso_region = us-east-1
sso_start_url = https://my-sso-portal.awsapps.com/start
sso_registration_scopes = sso:account:access
```

> "The `sso-session` section of the `config` file is used to group configuration variables for acquiring SSO access tokens, which can then be used to acquire AWS credentials." — [10]

> "The `sso_region` and `sso_start_url` settings must be set within the `sso-session` section." — [10]

> "A minimum scope of `sso:account:access` must be granted to get a refresh token back from the IAM Identity Center service." — [11]

#### token cache

tokens are cached to `~/.aws/sso/cache/` as json files.

> "The authentication token is cached to disk under the `~/.aws/sso/cache` directory with a file name based on the session name." — [11]

#### session durations

| session type | default | max | source |
|-------------|---------|-----|--------|
| portal session (user interactive) | 8 hours | 90 days | [13] |
| permission set session (iam role) | 1 hour | 12 hours | [14] |

> "The default session duration for user interactive sessions is 8 hours." — [13]

> "Custom duration values must be entered in minutes and be between 15 minutes and 129,600 minutes (90 days)." — [13]

> "the session duration is set to 1 hour (in seconds) by default" and "can be set to a maximum of 12 hours" — [14]

> "IAM role sessions operate independently once established. They persist for the duration configured in the permission set, which can be up to 12 hours, regardless of the status of the original sign-in session." — [15]

#### auto-refresh via refresh token

> "When using the SSO token provider configuration, the hourly access token obtained from IAM Identity Center is automatically refreshed using the refresh token." — [12]

> "If the access token is expired when the SDK tries to use it, the SDK uses the refresh token to try to get a new access token." — [12]

> "Automated token refresh isn't supported using the legacy non-refreshable configuration. We recommend using the SSO token provider configuration instead." — [11]

#### check session validity

`aws sts get-caller-identity` — no permissions required.

> "No permissions are required to perform this operation." — [17]

#### retrieve credentials programmatically

`aws sso get-role-credentials --role-name X --account-id Y --access-token Z`

returns `{ roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } }`.

> "Returns the STS short-term credentials for a given role name that is assigned to the user." — [18]

#### what happens when the session expires

> "As long as you are signed in to IAM Identity Center and those cached credentials are not expired, the AWS CLI automatically renews expired AWS credentials when needed. However, if your IAM Identity Center credentials expire, you must explicitly renew them by logging in to your IAM Identity Center account again." — [8]

### B.3 lessons

1. **use `sso-session` config** — the modern format enables auto-refresh; legacy format has a fixed 8h session with no refresh
2. **portal session = outer clock** — once this expires, all credential renewal stops; re-login required
3. **permission set session = inner clock** — these are the actual sts credentials (default 1h, max 12h); they auto-renew while portal session is valid
4. **check validity via `aws sts get-caller-identity`** — zero-permission, always works if credentials are valid; error = expired
5. **pkce requires same-device browser** — headless ci must use `--use-device-code` fallback
6. **cache lives at `~/.aws/sso/cache/`** — the keyrack should read this to detect valid sessions

### B.4 citations

| # | document | url |
|---|----------|-----|
| [8] | configure iam identity center auth with aws cli | https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html |
| [9] | iam identity center concepts for aws cli | https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso-concepts.html |
| [10] | configure aws cli to use sso token provider | https://docs.aws.amazon.com/cli/latest/userguide/sso-configure-profile-token.html |
| [11] | iam identity center credential provider | https://docs.aws.amazon.com/sdkref/latest/guide/feature-sso-credentials.html |
| [12] | how iam identity center auth is resolved | https://docs.aws.amazon.com/sdkref/latest/guide/understanding-sso.html |
| [13] | user interactive sessions | https://docs.aws.amazon.com/singlesignon/latest/userguide/user-interactive-sessions.html |
| [14] | set session duration for aws accounts | https://docs.aws.amazon.com/singlesignon/latest/userguide/howtosessionduration.html |
| [15] | authentication sessions in iam identity center | https://docs.aws.amazon.com/singlesignon/latest/userguide/authconcept.html |
| [16] | aws cli pkce announcement (blog) | https://aws.amazon.com/blogs/developer/aws-cli-adds-pkce-based-authorization-for-sso/ |
| [17] | get-caller-identity cli reference | https://docs.aws.amazon.com/cli/latest/reference/sts/get-caller-identity.html |
| [18] | get-role-credentials cli reference | https://docs.aws.amazon.com/cli/latest/reference/sso/get-role-credentials.html |

---

## C. 1password cli (`op`)

### C.1 what we access

the 1password cli (`op`) to retrieve secrets from 1password vaults. the keyrack uses `op read` with secret references to fetch credentials on demand.

### C.2 the contract

#### secret retrieval: `op read`

syntax: `op read "op://vault/item/field"`

> "Read the value of the field in 1Password specified by a secret reference." — [19]

> "You can use `op read` with a secret reference to print the secret to `stdout`." — [20]

secret references are case-insensitive. if whitespace is present, the reference must be quoted. unsupported characters require the item's unique id instead of name.

> "Secret references are case-insensitive and support the following characters: alphanumeric characters (a-z, A-Z, 0-9), -, _, . and the whitespace character." — [21]

> "any part of a secret reference that includes an unsupported character must be referred to by its unique identifier (ID) instead of its name." — [21]

#### auth status check: `op whoami`

> "Returns the currently active account or service account." — [27]

returns an error if no accounts are authenticated. supports `--account` flag to query a specific account.

#### env injection: `op run`

`op run` scans environment variables for secret references, resolves them, then runs a subprocess with the resolved values.

> "`op run` scans environment variables for secret references, loads the corresponding values from 1Password, then runs the provided command in a subprocess." — [20]

> "You should assume that processes on your computer can access the environment of other processes run by the same user." — [29]

### C.3 authentication modes

| mode | idle timeout | hard timeout | mechanism |
|------|-------------|-------------|-----------|
| desktop app integration (biometric) | 10 min | 12 hours | biometric re-auth via 1password app |
| manual sign-in (`op signin`) | 30 min | none documented | `OP_SESSION` env var + encrypted key on disk |
| service account | none (stateless) | token expiry (configurable) | `OP_SERVICE_ACCOUNT_TOKEN` env var |
| connect server | n/a (rest api) | n/a | `OP_CONNECT_HOST` + `OP_CONNECT_TOKEN` |

#### biometric (desktop app integration)

> "Authenticate 1Password CLI the same way you unlock your device, like with your fingerprint, face, Apple Watch, Windows Hello PIN, or device user password." — [22]

> "Authorization expires after 10 minutes of inactivity in the terminal session." — [23]

> "There's a hard limit of 12 hours, after which you must reauthorize." — [23]

#### manual sign-in

> "1Password CLI creates a session token and sets the `OP_SESSION` environment variable to it." — [24]

> "Sessions expire after 30 minutes of inactivity, after which you'll need to sign in again and save a new token." — [24]

> "your session key encrypted on disk and the random wrapper key used in the environment of the current shell." — [24]

#### service accounts (ci)

> "Set the `OP_SERVICE_ACCOUNT_TOKEN` environment variable to the service account token." — [25]

> "A service account token is an authentication string that represents an SRPx object that's serialized and Base64 URL encoded." — [26]

> "The steps to create the token happen on your device (client-side); nothing sensitive goes to 1Password's servers." — [26]

token prefix: `ops_`. requires cli version 2.18.0+. tokens can be rotated or revoked.

> "You can rotate or revoke service account tokens." — [26]

### C.4 lessons

1. **`op read` is the primary retrirhachet completion --setupinterface** — takes a secret reference uri, returns the value to stdout
2. **biometric has two clocks** — 10min idle + 12h hard limit; after either, re-auth required
3. **manual sign-in has 30min idle** — session token in env var; new terminal = new sign-in
4. **service accounts for ci** — stateless via env var, no idle timeout, configurable expiry
5. **`op whoami` for auth check** — quick way to detect if 1password is authenticated before vault access
6. **`op run` for env injection** — alternative to `op read` when multiple secrets are needed; but note process env is visible to same-user processes
7. **connect server for self-hosted** — two docker containers; uses separate token auth; not relevant for local dev

### C.5 citations

| # | document | url |
|---|----------|-----|
| [19] | op read command reference | https://developer.1password.com/docs/cli/reference/commands/read/ |
| [20] | secret references | https://developer.1password.com/docs/cli/secret-references/ |
| [21] | secret reference syntax | https://developer.1password.com/docs/cli/secret-reference-syntax/ |
| [22] | app integration | https://developer.1password.com/docs/cli/app-integration/ |
| [23] | app integration security | https://developer.1password.com/docs/cli/app-integration-security/ |
| [24] | sign in manually | https://developer.1password.com/docs/cli/sign-in-manually/ |
| [25] | service accounts with cli | https://developer.1password.com/docs/service-accounts/use-with-1password-cli/ |
| [26] | service account security | https://developer.1password.com/docs/service-accounts/security/ |
| [27] | op whoami command reference | https://developer.1password.com/docs/cli/reference/commands/whoami/ |
| [28] | op run command reference | https://developer.1password.com/docs/cli/reference/commands/run/ |
| [29] | secrets as environment variables | https://developer.1password.com/docs/cli/secrets-environment-variables/ |

---

## D. os keyrack — macOS + linux + cross-platform node.js

### D.1 what we access

os-level credential stores for the `os.secure` vault backend. macOS uses the Keyrack Services via the `security` cli. linux uses the freedesktop.org Secret Service via `secret-tool`. for cross-platform node.js access, `@napi-rs/keyring` wraps the native apis.

note: `keyring` and `Keyring` appear throughout — these are proper nouns (GNOME Keyring, @napi-rs/keyring, keyring-rs) and not gerunds.

### D.2 the contract — macOS (`security` cli)

#### store a secret

```sh
security add-generic-password -a {account} -s {service} -w {password} [-U]
```

`-U` updates if already present. `-T appPath` controls which apps can access the item.

> "By default, the application which creates an item is trusted to access its data without warning." — [30]

#### retrieve a secret

```sh
security find-generic-password -a {account} -s {service} -w
```

`-w` outputs only the password. `-g` outputs all attributes plus the password.

#### lock/unlock behavior

```sh
security lock-keyrack          # explicit lock
security unlock-keyrack        # explicit unlock (prompts for password)
security set-keyrack-settings [-lu] [-t timeout] [keyrack]
```

> `-l`: "Lock keyrack when the system sleeps" — [35]

> `-u` + `-t timeout`: "Lock keyrack after timeout interval" (in seconds) — [35]

### D.3 the contract — linux (`secret-tool` cli)

#### store a secret

```sh
secret-tool store --label='Label' {attribute} {value} ...
```

password is read from stdin (interactive prompt if terminal).

> "To store a password run secret-tool with the store argument. You must also specify a label for the password with the --label argument." — [36]

#### retrieve a secret

```sh
secret-tool lookup {attribute} {value} ...
```

> "the first password that is already unlocked will be returned. If necessary an item will be unlocked." — [36]

### D.4 the contract — d-bus secret service api

the protocol that `secret-tool` wraps. d-bus bus name: `org.freedesktop.secrets`.

> "The Secret Service API allows client applications to store secrets securely in a service running in the user's login session." — [38]

> "A group of items together form a collection. A collection is similar in concept to the terms 'keyring' or 'wallet'." — [37]

implementations: GNOME Keyring (via `pam_gnome_keyring.so` for auto-unlock at login) and KDE Wallet.

> "It provides org.freedesktop.secrets, an API that allows client applications to store secrets securely in a service running in the user's login session." — [40]

### D.5 the contract — node.js `@napi-rs/keyring`

npm: `@napi-rs/keyring` — the modern replacement for the archived `keytar` (archived dec 15, 2022).

> "100% compatible node-keytar alternative." — [43]

wraps `keyring-rs` (rust) which supports:
- macOS: Keyrack Services — [45]
- linux: d-bus Secret Service — [45]
- windows: Credential Manager — [45]

#### api (sync)

```typescript
class Entry {
  constructor(service: string, username: string)
  getPassword(): string | null
  setPassword(password: string): void
  deleteCredential(): boolean
}
```

#### api (async)

```typescript
class AsyncEntry {
  constructor(service: string, username: string)
  getPassword(signal?: AbortSignal): Promise<string | undefined>
  setPassword(password: string, signal?: AbortSignal): Promise<void>
  deletePassword(signal?: AbortSignal): Promise<unknown>
}
```

#### keytar-compatible api

```typescript
function getPassword(service: string, account: string): Promise<string | null>
function setPassword(service: string, account: string, password: string): Promise<void>
function deletePassword(service: string, account: string): Promise<boolean>
function findPassword(service: string): Promise<string | null>
function findCredentials(service: string): Promise<Array<{ account: string; password: string }>>
```

### D.6 session semantics — cross-platform summary

all three platforms share the same fundamental behavior: **the keyrack unlocks at user login and stays unlocked for the duration of the login session.** screen lock does NOT lock the keyrack on any platform by default.

| property | macOS | linux (gnome) | windows |
|----------|-------|---------------|---------|
| unlock trigger | user login | pam at login | user login (dpapi) |
| lock on screen lock | no | no | no |
| lock on sleep | opt-in | n/a | no |
| lock on timeout | opt-in | n/a | no |
| lock on logout | yes | yes | yes |
| explicit lock api | `security lock-keyrack` | d-bus `Lock()` | n/a |

> "Normally, your login keyrack is left unlocked while you are logged in, sparing you from having to keep entering your password." — [32]

> "When the session is locked, the keyring is not automatically locked." — [40]

> "Any program running as that user will be able to access credentials in this store." — [46]

### D.7 lessons

1. **os keyrack is "always open" for logged-in users** — no unlock prompt needed for `os.direct`-like access; the login keyrack auto-unlocks at login
2. **screen lock ≠ keyrack lock** — on all platforms, screen lock does not lock the credential store
3. **`security` and `secret-tool` are the cli interfaces** — macOS and linux respectively; both are subprocess-invocable
4. **`@napi-rs/keyring` for node.js** — cross-platform, napi-based, sync + async apis; replaces archived `keytar`
5. **`os.secure` needs its own encryption layer** — since the os keyrack auto-unlocks and stays open, `os.secure` must add its own encryption on top (e.g., a separate encrypted file) to provide the "locked until explicitly unlocked" semantic that rhachet needs
6. **`os.direct` maps naturally to the os keyrack** — store and retrieve via `@napi-rs/keyring` with `service=rhachet` and `account=$keyName`
7. **GNOME Keyring auto-unlocks via pam** — `pam_gnome_keyring.so` initializes and unlocks the login keyring at login

### D.8 citations

| # | document | url |
|---|----------|-----|
| [30] | macOS `security` man page | https://www.unix.com/man_page/osx/1/security/ |
| [31] | macOS `security` man page (manpagez) | https://www.manpagez.com/man/1/security/osx-10.12.3.php |
| [32] | eclectic light: keyrack lock behavior | https://eclecticlight.co/2016/11/03/why-do-i-have-to-keep-entering-my-keyrack-password-in-sierra/ |
| [33] | apple support: keyrack password | https://support.apple.com/guide/keyrack-access/if-you-need-to-update-your-keyrack-password-kyca2429/mac |
| [34] | apple support: keyrack lock settings | https://support.apple.com/guide/keyrack-access/mac-keyrack-password-kyca1242/mac |
| [35] | ss64: set-keyrack-settings | https://ss64.com/mac/security-keyrack-settings.html |
| [36] | secret-tool(1) man page | https://man.archlinux.org/man/secret-tool.1.en |
| [37] | secret service api 0.1 spec | https://freedesktop.org/wiki/Specifications/secret-storage-spec/secrets-api-0.1.html |
| [38] | secret service api latest spec | https://specifications.freedesktop.org/secret-service/latest-single/ |
| [39] | secret service d-bus interface | https://specifications.freedesktop.org/secret-service/0.2/org.freedesktop.Secret.Service.html |
| [40] | arch wiki: GNOME Keyring | https://wiki.archlinux.org/title/GNOME/Keyring |
| [41] | gnome-keyring-daemon man page | https://manpages.ubuntu.com/manpages/jammy/man1/gnome-keyring-daemon.1.html |
| [42] | freedesktop.org secret storage spec | https://www.freedesktop.org/wiki/Specifications/secret-storage-spec/ |
| [43] | @napi-rs/keyring github | https://github.com/Brooooooklyn/keyring-node |
| [44] | node-keytar (archived) | https://github.com/atom/node-keytar |
| [45] | keyring-rs rust crate docs | https://docs.rs/keyring/latest/keyring/ |
| [46] | microsoft: cached and stored credentials | https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh994565(v=ws.11) |

---

## summary of all lessons

| # | lesson | resource |
|---|--------|----------|
| 1 | jwt has 10-min max lifetime — build fresh for each token mint | github api |
| 2 | cache installation tokens — they last 1h; re-mint wastes rate limit | github api |
| 3 | private key must stay in vault — never export to env; consume in-process | github api |
| 4 | least privilege — scope tokens to needed repos + permissions | github api |
| 5 | prefix detection enables firewall — `ghp_` = block, `ghs_` = pass, json = resolve | github api |
| 6 | use `sso-session` config — modern format enables auto-refresh | aws sso |
| 7 | portal session = outer clock (default 8h, max 90d) | aws sso |
| 8 | permission set session = inner clock (default 1h, max 12h) | aws sso |
| 9 | check validity via `aws sts get-caller-identity` — zero permissions required | aws sso |
| 10 | pkce requires same-device browser — headless ci must use device code | aws sso |
| 11 | `op read` is the primary retrirhachet completion --setupinterface — secret reference uri to stdout | 1password |
| 12 | biometric has two clocks — 10min idle + 12h hard limit | 1password |
| 13 | manual sign-in has 30min idle — session in env var | 1password |
| 14 | service accounts for ci — stateless via env var, no idle timeout | 1password |
| 15 | `op whoami` for auth check — detect if 1password is authenticated | 1password |
| 16 | os keyrack is "always open" for logged-in users — auto-unlocks at login | os keyrack |
| 17 | screen lock ≠ keyrack lock — on all platforms | os keyrack |
| 18 | `@napi-rs/keyring` for node.js — cross-platform replacement for archived keytar | os keyrack |
| 19 | `os.secure` needs its own encryption layer — os keyrack alone does not provide explicit lock/unlock | os keyrack |
| 20 | `os.direct` maps naturally to os keyrack — `service=rhachet`, `account=$keyName` | os keyrack |
