# domain terms research: rhachet/keyrack

> comprehensive research on terminology for the keyrack feature's domain objects

---

## 1. domain objects identified

from the wish, vision, and criteria, these domain objects require naming:

| #  | concept                          | what it represents                                                    |
| -- | -------------------------------- | --------------------------------------------------------------------- |
| 1  | the system itself                | the credential firewall (the cli, the sdk, the action)                |
| 2  | per-repo declaration             | the yaml file that declares what credentials a repo needs             |
| 3  | individual key declaration       | one entry within the per-repo declaration (name + mechanism)          |
| 4  | storage backend                  | where a credential is persisted on a machine (1password, os, etc)     |
| 5  | grant mechanism                  | how to translate raw credentials into shortest-lived form             |
| 6  | per-machine config               | the map of which keys are stored where on this device                 |
| 7  | individual config entry          | one entry within the per-machine config (key ‚Üí vault reference)       |
| 8  | the granted credential value     | the short-lived, safe value that gets exported to env                 |
| 9  | the grant action                 | the verb for what the firewall does to a raw credential               |
| 10 | status of a credential           | the state of a key at grant time (granted, locked, etc)               |

### classification

**entities (have identity, lifecycle)**
- **per-machine config** ‚Äî mutable per-machine state, same machine over time

**literals (value objects, immutable)**
- **per-repo declaration** ‚Äî immutable; change any requirement = different manifest
- **individual key declaration** ‚Äî immutable; name + mech = the identity
- **storage backend** ‚Äî value object enum (`os.direct`, `os.secure`, `1password`)
- **grant mechanism** ‚Äî value object enum (`REPLICA`, `GITHUB_APP`, `AWS_SSO`)
- **individual config entry** ‚Äî immutable snapshot of name + vault + metadata
- **granted credential value** ‚Äî immutable result of grant

**events**
- **credential granted** ‚Äî a credential was successfully granted and exported
- **vault unlocked** ‚Äî a vault backend was authenticated
- **credential blocked** ‚Äî a credential violated its mechanism constraint

---

## 2. prior art: how extant systems name their concepts

### 2.1 macos keychain (apple)

| concept | apple's term |
|---------|-------------|
| the store | **Keychain** (encrypted database, `SecKeychain`) |
| a credential | **Keychain Item** (`SecKeychainItem`) |
| item categories | **Item Class** (internet password, generic password, certificate, key) |

> "keychain services consists of two main parts: an encrypted database (represented by the SecKeychain class) and items inserted into the database (represented by the SecKeychainItem class)." [1]

### 2.2 windows credential manager

| concept | windows's term |
|---------|---------------|
| the store | **Credential Manager** / **Credential Store** |
| a credential | **Credential** (`CREDENTIAL` struct) |
| subtypes | **Type** (`CRED_TYPE_GENERIC`, `CRED_TYPE_DOMAIN_PASSWORD`) |
| the secret value | **CredentialBlob** |
| the identifier | **TargetName** |

> "generic credentials are defined and authenticated by applications that manage authorization and security directly instead of to delegate these tasks to the os." [2]

### 2.3 linux libsecret / gnome keyring

| concept | libsecret's term |
|---------|-----------------|
| the store | **Collection** (was "keyring" in old api) |
| a credential | **Secret Item** / **Item** |
| item type definition | **Schema** (`SecretSchema`) |
| the secret value | **Secret** (the encrypted part) |

> "keyrings are called 'collections' in libsecret. this is the same lingo as the secret service dbus api." [3]

### 2.4 1password cli (`op`)

| concept | 1password's term |
|---------|-----------------|
| a group of credentials | **Vault** |
| a credential | **Item** |
| a field within a credential | **Field** |
| uri reference format | `op://<vault>/<item>/<section>/<field>` |

> "a secret reference uri includes the names (or unique identifiers) of the vault, item, section, and field where a secret is stored in your 1password account." [4]

### 2.5 hashicorp vault

| concept | vault's term |
|---------|-------------|
| credential store | **Vault** (the system) |
| storage backend plugin | **Secrets Engine** |
| where an engine is enabled | **Mount** / **Mount Path** |
| a credential | **Secret** |
| time-limited credential | **Lease** (with `lease_id`, `lease_duration`) |
| validity period | **TTL** (time to live) |
| access control declaration | **Policy** (declarative, deny-by-default) |
| dynamic vs static | **Dynamic Secret** vs **Static Secret** |

> "a secrets engine is a plugin-style component in vault that you enable at a specific mount path... to the user, secrets engines behave similar to a virtual filesystem." [5]

> "all dynamic secrets in vault are required to have a lease. even if the data is meant to be valid for eternity, a lease is required to force the consumer to check in routinely." [6]

### 2.6 kubernetes / external secrets operator

| concept | k8s term |
|---------|---------|
| a credential | **Secret** (Kind=Secret) |
| external source reference | **ExternalSecret** (eso) |
| backend config | **SecretStore** / **ClusterSecretStore** (eso) |
| backend system | **Provider** (eso) |

> "the externalsecret describes what data should be fetched, how the data should be transformed and saved as a kind=secret." [7]

### 2.7 oauth2 / oidc

| concept | oauth/oidc term |
|---------|----------------|
| permission type | **Grant** (authorization code grant, client credentials grant) |
| short-lived credential | **Access Token** |
| refresh mechanism | **Refresh Token** |
| permission scope | **Scope** |
| data within token | **Claim** |

> "access tokens are credentials used to access protected resources. an access token is a string that represents an authorization issued to the client." [8]

> "the grant type basically refers to the way your app gets the access token. oauth 2.0 offers different types of grant types." [9]

---

## 3. cross-domain terminology research

### 3.1 hotel front desk & key rack

the vision's "hotel front desk" metaphor has strong alignment with physical hotel operations:

> "the traditional key rack system keeps physical keys organized on a wooden or metal rack behind the front desk, with slots labeled by room number" [10]

> "the room rack was the physical information center of old hotel operations ‚Äî a slotted rack where guest slips were filed by room number, to allow front desk staff to see at a glance which rooms were occupied, vacant, or reserved" [11]

> "'rack rate' ‚Äî the term for standard published room prices ‚Äî originated from the practice of post rates on the key rack visible to guests" [12]

**key terms from this domain**:
- **key rack** ‚Äî organized collection of room keys
- **room rack** ‚Äî information center that tracks room state
- **key fob** ‚Äî attached identifier for a key
- **blank key** ‚Äî unprogrammed keycard stock

### 3.2 locksmith & master key systems

locksmith terminology provides rich parallels for credential resolution:

> "a master key system hierarchy typically follows: great grand master (ggm) at top, grand masters (gm) below, sub-masters, and individual change keys at the bottom" [13]

> "the key bitting array (kba) or key control chart maps which cuts on a key correspond to which locks ‚Äî it's the master reference that governs how keys are cut" [14]

> "blind codes are manufacturer's key codes that require a lookup table to decode ‚Äî to prevent unauthorized duplication from visual inspection alone" [15]

> "sequence of progression (sop) determines the order in which key cuts are assigned, to ensure mathematical non-interference between different key levels" [16]

**key terms from this domain**:
- **key schedule** ‚Äî master list of all keys, locks, and access levels for a structure
- **key bitting array (kba)** ‚Äî the map that governs how keys are cut
- **blind code** ‚Äî encoded reference that requires translation
- **change key** ‚Äî individual key that opens one lock only
- **master key** ‚Äî key that opens multiple locks in a system
- **keyway** ‚Äî the shape of the hole that accepts a key (determines which key fits)
- **ward** ‚Äî obstruction that blocks wrong keys

### 3.3 pharmacy & controlled substances

pharmacy operations provide strong metaphors for controlled credential dispensal:

> "the dea classifies drugs into five schedules (i-v) based on acceptable medical use and abuse potential. schedule ii drugs cannot be refilled ‚Äî a new prescription must be written each time" [17]

> "the correspondent responsibility doctrine holds that pharmacists share legal responsibility with prescribers to ensure prescriptions are issued for legitimate medical purposes" [18]

> "to dispense means the transfer of a prescription drug to an ultimate user. it includes all steps from receipt of the prescription to hand-over of the medication with proper counsel" [19]

**key terms from this domain**:
- **prescription** ‚Äî authorized request for a specific medication
- **formulary** ‚Äî approved list of medications
- **dispense** ‚Äî translate prescription ‚Üí medication
- **schedule** ‚Äî classification of control level (i-v)
- **correspondent responsibility** ‚Äî shared accountability for legitimate use

### 3.4 secrets management (2025 patterns)

modern credential management has evolved toward dynamic, vault-agnostic approaches:

> "dynamic secrets are generated on-demand with automatic expiration ‚Äî they reduce the blast radius of compromise because credentials exist only for the duration needed" [20]

> "credential rotation should be automatic and transparent. modern secret managers support rotation schedules that update credentials without application downtime" [21]

> "secret sprawl ‚Äî credentials scattered across config files, env vars, and code ‚Äî is the primary vector for credential theft. centralized vault with just-in-time retrieval eliminates this class of vulnerability" [22]

> "vault-agnostic secret management allows applications to work with multiple backend providers (hashicorp, aws, 1password, etc) through a unified interface" [23]

**key terms from this domain**:
- **dynamic secret** ‚Äî generated on-demand, short-lived
- **static secret** ‚Äî long-lived, stored as-is
- **credential rotation** ‚Äî automatic credential refresh
- **secret sprawl** ‚Äî scattered credentials (the antipattern)
- **vault-agnostic** ‚Äî unified interface to multiple backends

---

## 4. relationship analysis

### 4.1 treestruct

```
Keyrack (the system/firewall)
‚îÇ
‚îú‚îÄ‚îÄ KeyrackRepoManifest (.agent/keyrack.yml ‚Äî per repo)
‚îÇ   ‚îî‚îÄ‚îÄ KeyrackKeySpec[] (specifications of keys needed)
‚îÇ       ‚îú‚îÄ‚îÄ slug: string (e.g., "XAI_API_KEY")
‚îÇ       ‚îî‚îÄ‚îÄ mech: KeyrackGrantMechanism (e.g., REPLICA, GITHUB_APP, AWS_SSO)
‚îÇ
‚îú‚îÄ‚îÄ KeyrackHostManifest (~/.rhachet/keyrack.config.json ‚Äî per machine)
‚îÇ   ‚îî‚îÄ‚îÄ KeyrackKeyHost[] (hosts key slugs at vault locations)
‚îÇ       ‚îú‚îÄ‚îÄ slug: string
‚îÇ       ‚îú‚îÄ‚îÄ exid: string | null
‚îÇ       ‚îú‚îÄ‚îÄ vault: KeyrackHostVault
‚îÇ       ‚îú‚îÄ‚îÄ mech: KeyrackGrantMechanism (storage shape depends on mech)
‚îÇ       ‚îî‚îÄ‚îÄ metadata: { createdAt, updatedAt }
‚îÇ
‚îú‚îÄ‚îÄ KeyrackHostVault (storage backend)
‚îÇ   ‚îú‚îÄ‚îÄ os.direct (plaintext, no unlock)
‚îÇ   ‚îú‚îÄ‚îÄ os.secure (encrypted, os-level unlock)
‚îÇ   ‚îî‚îÄ‚îÄ 1password (external, 1password auth)
‚îÇ
‚îú‚îÄ‚îÄ KeyrackGrantMechanism (translation method)
‚îÇ   ‚îú‚îÄ‚îÄ REPLICA (pass-through, no translation)
‚îÇ   ‚îú‚îÄ‚îÄ GITHUB_APP (json blob ‚Üí short-lived ghs_ token)
‚îÇ   ‚îî‚îÄ‚îÄ AWS_SSO (sso profile ‚Üí session credentials)
‚îÇ
‚îú‚îÄ‚îÄ KeyrackGrantAttempt (grant result)
‚îÇ   ‚îú‚îÄ‚îÄ status: KeyrackGrantStatus (granted | absent | locked | blocked)
‚îÇ   ‚îú‚îÄ‚îÄ grant?: KeyrackKeyGrant (only if granted)
‚îÇ   ‚îú‚îÄ‚îÄ slug: string (for failure cases)
‚îÇ   ‚îú‚îÄ‚îÄ message?: string (human-readable status)
‚îÇ   ‚îî‚îÄ‚îÄ fix?: string (command to fix, if not granted)
‚îÇ
‚îî‚îÄ‚îÄ KeyrackKeyGrant (successful grant ‚Äî always has value)
    ‚îú‚îÄ‚îÄ slug: string (env var slug)
    ‚îú‚îÄ‚îÄ value: string (the short-lived token)
    ‚îî‚îÄ‚îÄ source: { vault, mech }
```

### 4.2 dependency flow

```
KeyrackRepoManifest (declares what keys are needed)
        ‚îÇ
        ‚ñº (cross-reference by key name)
KeyrackHostManifest (declares where each key is stored)
        ‚îÇ
        ‚ñº (retrieves raw credential)
KeyrackHostVault (storage backends)
        ‚îÇ
        ‚ñº (translates to short-lived form)
KeyrackGrantMechanism (grant adapters)
        ‚îÇ
        ‚ñº (produces)
KeyrackKeyGrant (grant output)
```

---

## 5. cross-domain metaphor alignment

the keyrack maps coherently to multiple physical domains:

| keyrack concept     | locksmith              | pharmacy               | hotel                 | airport              |
| ------------------- | ---------------------- | ---------------------- | --------------------- | -------------------- |
| keyrack (system)    | key ring               | dispensary             | front desk            | checkpoint           |
| manifest            | key schedule           | prescription           | reservation           | manifest             |
| key (declaration)   | key code               | line item              | room assignment       | pass req             |
| vault               | key cabinet / safe     | drug vault             | safety deposit box    | credential store     |
| mech                | lock mechanism         | compound method        | card encoder type     | verification method  |
| config              | key register           | patient chart          | guest registry        | traveler registry    |
| grant               | cut key                | dispensed medication   | encoded keycard       | pass                 |
| grant (verb)        | cut a key              | dispense               | encode a keycard      | screen & clear       |
| blocked             | ward blocks key        | refuses controlled     | denies access         | flags contraband     |

### the locksmith metaphor is deepest

1. a **key schedule** declares all keys needed for a structure (= manifest declares all keys needed for a repo)
2. a **key code** is the reference used to create a key (= a credential name + mechanism reference)
3. the locksmith **cuts** a blank to specification (= the keyrack grants raw credentials as short-lived form)
4. a **ward** blocks the wrong key (= the firewall blocks long-lived credentials when short-lived is required)
5. the **keyway** determines which key shape fits (= the mechanism determines which grant applies)

### the pharmacy metaphor is strongest for firewall semantics

1. a **prescription** declares what medications are needed (= manifest declares what credentials are needed)
2. the pharmacist has **correspondent responsibility** for legitimate use (= keyrack enforces mechanism constraints)
3. **schedule ii** drugs cannot be refilled (= GITHUB_APP tokens cannot be long-lived)
4. the pharmacist **dispenses** the prepared medication (= the keyrack grants the resolved credential)

---

## 6. term proposals

### 6.1 the system: `Keyrack`

**keep established term** ‚Äî maps well to "the ring that holds keys together" rather than to storage location or individual item. the keyrack is the organizer, not the safe.

| option | source | pros | cons |
|--------|--------|------|------|
| **keyrack** | apple, physical | well-known, implies key collection | macos association |
| keyring | linux libsecret | linux precedent | less common than keyrack |
| vault | hashicorp | strong security connotation | conflicts with storage backend |

### 6.2 per-repo declaration: `KeyManifest`

**recommendation**: **KeyManifest** ‚Äî "manifest" is the standard term for declarative requirements files (package.json, docker-compose, k8s)

| option | source | pros | cons |
|--------|--------|------|------|
| **manifest** | k8s, npm, docker | widely understood | generic ‚Äî which manifest? |
| claim | oidc | assertive ("i claim i need these") | oidc claims are identity attributes |
| prescription | pharmacy | strong controlled-access parallel | unusual in software |
| spec | k8s | brief, well-known | overloaded (openapi, test) |

### 6.3 individual key declaration: `KeyRequirement`

**recommendation**: **KeyRequirement** ‚Äî the manifest entry is literally a requirement

| option | source | pros | cons |
|--------|--------|------|------|
| **requirement** | npm peer deps | precise: declares a requirement | verbose |
| key | general | simple, intuitive | overloaded (api key, ssh key) |
| claim | oidc | assertive | conflicts if manifest is also "claim" |
| entry | 1password | generic | too vague |

### 6.4 storage backend: `Vault`

**recommendation**: **Vault** ‚Äî already established in wish/vision, strongest precedent

| option | source | pros | cons |
|--------|--------|------|------|
| **vault** | hashicorp, 1password | well-known, secure connotation | hashicorp product name |
| store | k8s secretstore | neutral | generic |
| locker | physical | clear metaphor | less common in software |
| safe | bank | implies security | overstates os.direct security |

### 6.5 grant mechanism: `Mechanism` (abbrev: `mech`)

**recommendation**: **Mechanism** ‚Äî already established in wish (`--mech`), unique and descriptive

| option | source | pros | cons |
|--------|--------|------|------|
| **mechanism** | locksmith | describes how grant works | verbose |
| **mech** | wish | short, established | abbreviation may be unclear |
| grant type | oauth2 | strongest software precedent | slightly different semantics |
| engine | hashicorp | precise | overloaded |
| resolver | general | describes what it does | generic |

### 6.6 per-machine config: `KeyrackConfig`

**recommendation**: **KeyrackConfig** ‚Äî simple, obvious, no ambiguity

### 6.7 individual config entry: `KeyBind`

**recommendation**: **KeyBind** ‚Äî it binds a key name to a vault location

| option | source | pros | cons |
|--------|--------|------|------|
| **bind** | general (env bind, port bind) | precise: binds name to vault | unfamiliar as noun |
| entry | general | simple | too vague |
| source | general | where the key comes from | ambiguous |

### 6.8 grant output: `KeyGrant`

**recommendation**: **KeyGrant** ‚Äî oauth2 precedent: a "grant" is a scoped, time-limited authorization

| option | source | pros | cons |
|--------|--------|------|------|
| **grant** | oauth2 | implies authorized access, verb/noun duality | slightly unusual as noun |
| keycard | hotel | matches vision metaphor | novel, no software precedent |
| lease | hashicorp | implies ttl + renewability | enterprise feel |
| token | oauth2 | industry standard | overloaded (jwt, session, etc) |
| pass | airport | short, time-limited | too generic |

### 6.9 credential status: `KeyStatus`

**recommendation**: keep established terms with one refinement

| status | emoji | semantics |
|--------|-------|---------|
| `granted` | üîë | granted successfully, exported to env |
| `absent` | ü´ß | not configured on this machine |
| `locked` | üîí | vault requires authentication |
| `blocked` | üî¥ | value violates mechanism constraint |

note: `absent` > `notFound` ‚Äî "not found" implies a search that failed; "absent" states a fact: the key is not here

### 6.10 action verb: `grant`

**recommendation**: **grant** for both the action and outcome

- "the keyrack **grants** credentials as short-lived tokens"
- "each key reports status: üîë **granted**"

---

## 7. proposed ubiquitous language

### primary terms

| concept | term | short form | precedent |
|---------|------|------------|-----------|
| the system | **Keyrack** | keyrack | apple macos keychain |
| per-repo manifest | **KeyrackRepoManifest** | repo manifest | k8s, docker, npm |
| key specification | **KeyrackKeySpec** | key spec | k8s spec pattern |
| per-machine host manifest | **KeyrackHostManifest** | host manifest | general convention |
| host entry | **KeyrackKeyHost** | key host | per-key config on host |
| storage backend | **KeyrackHostVault** | vault | hashicorp, 1password |
| grant mechanism | **KeyrackGrantMechanism** | mech | locksmith, wish, oauth2 |
| grant result | **KeyrackGrantAttempt** | attempt | discriminated union of outcomes |
| successful grant | **KeyrackKeyGrant** | grant | oauth2 rfc 6749; only exists on success |
| credential status | **KeyrackGrantStatus** | status | enum |
| action verb | **grant** | ‚Äî | oauth2, locksmith |

### status enum

| status | emoji | semantics |
|--------|-------|---------|
| **granted** | üîë | granted successfully, exported to env |
| **absent** | ü´ß | not configured on this machine |
| **locked** | üîí | vault requires authentication |
| **blocked** | üö´ | value violates mechanism constraint |

### vault types

| vault | storage characteristics |
|-------|------------------------|
| **os.direct** | plaintext, no unlock required |
| **os.secure** | encrypted, os-level unlock |
| **1password** | external vault, 1password auth |

### mechanism types

| mechanism | behavior |
|-----------|----------|
| **REPLICA** | pass through (no translation) |
| **GITHUB_APP** | json blob ‚Üí short-lived installation token |
| **AWS_SSO** | sso profile ‚Üí temporary session credentials |

---

## 8. domain object summary (typescript)

```ts
// literals (value objects)
type KeyrackHostVault = 'os.direct' | 'os.secure' | '1password';
type KeyrackGrantMechanism = 'REPLICA' | 'GITHUB_APP' | 'AWS_SSO';
type KeyrackGrantStatus = 'granted' | 'absent' | 'locked' | 'blocked';

// per-repo repo manifest
class KeyrackRepoManifest extends DomainLiteral<KeyrackRepoManifest> {
  keys: Record<string, KeyrackKeySpec>;
}

class KeyrackKeySpec extends DomainLiteral<KeyrackKeySpec> {
  slug: string; // e.g., "XAI_API_KEY"
  mech: KeyrackGrantMechanism;
}

// per-machine host manifest
class KeyrackHostManifest extends DomainEntity<KeyrackHostManifest> {
  hosts: Record<string, KeyrackKeyHost>;
}

class KeyrackKeyHost extends DomainLiteral<KeyrackKeyHost> {
  public static primary = ['exid', 'vault'] as const;
  public static unique = ['slug', 'mech'] as const;

  slug: string; // e.g., "XAI_API_KEY"
  exid: string | null; // e.g., op:// reference for 1password
  vault: KeyrackHostVault;
  mech: KeyrackGrantMechanism; // storage shape depends on mech
  createdAt: string;
  updatedAt: string;
}

// grant attempt (result of grant)
type KeyrackGrantAttempt =
  | { status: 'granted'; grant: KeyrackKeyGrant }
  | { status: 'absent'; slug: string; message: string; fix?: string }
  | { status: 'locked'; slug: string; message: string; fix?: string }
  | { status: 'blocked'; slug: string; message: string; fix?: string };

// successful grant (always has value)
class KeyrackKeyGrant extends DomainLiteral<KeyrackKeyGrant> {
  slug: string; // e.g., "XAI_API_KEY"
  value: string; // the short-lived token ‚Äî always present
  source: {
    vault: KeyrackHostVault;
    mech: KeyrackGrantMechanism;
  };
}
```

---

## 9. the recommended vocabulary reads as

> the **keyrack** reads a **KeyrackRepoManifest** of **KeyrackKeySpecs**, checks the **KeyrackHostManifest** for **KeyrackKeyHosts**, retrieves raw credentials from **vaults**, translates them via **mechanisms**, and **grants** them as **KeyrackGrantAttempts** ‚Äî each either a successful **KeyrackKeyGrant** or a failure with clear status and fix.

---

## 10. term decisions log

documented rationales for each term choice via collaborative refinement.

### 10.1 per-repo manifest: `KeyrackRepoManifest`

| considered | rationale |
|------------|-----------|
| KeyManifest | too generic ‚Äî which manifest? |
| KeyrackKeyManifest | redundant "key" |
| KeyrackUsageManifest | verbose; "usage" is less direct than scope |
| **KeyrackRepoManifest** ‚úì | scope-based: clearly per-repo; pairs with KeyrackHostManifest; aligns with `--for repo` cli syntax |

### 10.2 manifest entry: `KeyrackKeySpec`

| considered | rationale |
|------------|-----------|
| KeyRequirement | verbose; "requirement" is assertive |
| KeyrackKeyRef | implies a reference to an extant object (like db ref) |
| KeyrackKeyReq | abbreviation of requirement; still assertive |
| **KeyrackKeySpec** ‚úì | specifies the shape + constraints of a key needed; aligns with k8s spec pattern |

### 10.3 per-machine manifest: `KeyrackHostManifest`

| considered | rationale |
|------------|-----------|
| KeyrackConfig | too generic |
| KeyrackStorageManifest | only describes *where*, not *how* |
| KeyrackGrantManifest | overlaps with Grant* family (KeyrackGrantMechanism, KeyrackKeyGrant) |
| KeyrackControlManifest | "control" is vague |
| KeyrackHostVaultManifest | but also contains mech, not just vault |
| **KeyrackHostManifest** ‚úì | scope-based: clearly per-host/machine; pairs with KeyrackRepoManifest |

### 10.4 host manifest entry: `KeyrackKeyHost`

| considered | rationale |
|------------|-----------|
| entry | too vague |
| source | ambiguous |
| KeyrackKeyBind | "bind" is action-oriented |
| **KeyrackKeyHost** ‚úì | scope-aligned: the host's config for a key; pairs with KeyrackHostManifest |

note: includes `mech` because storage shape depends on mechanism (GITHUB_APP = json blob, AWS_SSO = profile name, REPLICA = raw value)

### 10.5 storage backend: `KeyrackHostVault`

| considered | rationale |
|------------|-----------|
| KeyrackVault | lacks semantic prefix |
| KeyrackVaultType | unnecessary "Type" suffix |
| KeyrackGrantVault | vault is about storage, not grant translation |
| store | too generic |
| **KeyrackHostVault** ‚úì | vault = where the host stores it; storage is a host property |

### 10.6 mechanism: `KeyrackGrantMechanism`

| considered | rationale |
|------------|-----------|
| KeyrackMechanism | vague alone; what mechanism? |
| KeyrackMechanismType | unnecessary "Type" suffix |
| engine | overloaded (hashicorp secrets engine) |
| **KeyrackGrantMechanism** ‚úì | consistent KeyrackGrant* prefix; "how to translate for grant" |

### 10.7 grant output: `KeyrackKeyGrant`

| considered | rationale |
|------------|-----------|
| KeyGrant | lacks namespace prefix |
| keycard | novel, no software precedent |
| lease | enterprise feel (hashicorp) |
| token | overloaded (jwt, session, etc) |
| **KeyrackKeyGrant** ‚úì | oauth2 precedent: a "grant" is scoped, time-limited authorization |

### 10.8 status enum: `KeyrackGrantStatus`

| considered | rationale |
|------------|-----------|
| KeyrackKeyStatus | but status describes the grant outcome, not the key itself |
| **KeyrackGrantStatus** ‚úì | status of the grant (granted, absent, locked, blocked) |

final values: `granted` | `absent` | `locked` | `blocked`

note: `absent` > `not_found` ‚Äî "not found" implies a search that failed; "absent" states a fact: the key is not here

### 10.9 grant result: `KeyrackGrantAttempt` + `KeyrackKeyGrant`

| considered | rationale |
|------------|-----------|
| KeyrackKeyGrant with status | conflates result (what happened) with grant (the credential) |
| KeyrackResolution | generic |
| **KeyrackGrantAttempt** ‚úì | an attempt to grant ‚Äî can succeed or fail |
| **KeyrackKeyGrant** ‚úì | a grant = success; always has value; no status needed |

separation: attempt is the envelope, grant is the payload (only on success)

### 10.11 key identifier: `slug` not `name`

| considered | rationale |
|------------|-----------|
| name | implies human-readable label |
| **slug** ‚úì | `XAI_API_KEY` is an identifier, not a readable name |

applies to: `KeyrackKeySpec.slug`, `KeyrackKeyHost.slug`, `KeyrackKeyGrant.slug`

### 10.12 summary of term patterns

| pattern | example | rationale |
|---------|---------|-----------|
| `Keyrack*` prefix | KeyrackHostVault | namespace all domain objects |
| `KeyrackKey*` for per-key objects | KeyrackKeySpec, KeyrackKeyHost, KeyrackKeyGrant | individual key instances |
| `KeyrackHost*` for host types | KeyrackHostManifest, KeyrackHostVault | host-scope: manifest, storage |
| `KeyrackGrant*` for grant types | KeyrackGrantMechanism, KeyrackGrantStatus, KeyrackGrantAttempt | grant-related: how, outcome, result |
| `KeyrackRepo*` for repo types | KeyrackRepoManifest | repo-scope: manifest |
| no `Type` suffix | KeyrackHostVault not KeyrackHostVaultType | cleaner; the type is implicit |

**per-key objects vs system-level types:**

| prefix | examples | what they are |
|--------|----------|---------------|
| `KeyrackRepo*` | KeyrackRepoManifest | repo-scope manifest |
| `KeyrackHost*` | KeyrackHostManifest, KeyrackHostVault | host-scope: manifest + storage |
| `KeyrackKey*` | KeyrackKeySpec, KeyrackKeyHost, KeyrackKeyGrant | per-key objects |
| `KeyrackGrant*` | KeyrackGrantMechanism, KeyrackGrantStatus, KeyrackGrantAttempt | grant types: how, outcome, result |

note: "host" has dual sense ‚Äî (1) the machine that hosts the credentials, (2) the hotel front desk host who hands you your keycard üê¢

---

## citations

1. [apple developer: keychain services](https://developer.apple.com/documentation/security/keychain-services) ‚Äî "keychain services consists of two main parts: an encrypted database (represented by the SecKeychain class) and items inserted into the database"
2. [microsoft learn: kinds of credentials](https://learn.microsoft.com/en-us/windows/win32/secauthn/kinds-of-credentials) ‚Äî "generic credentials are defined and authenticated by applications that manage authorization and security directly"
3. [jan-piet mens: gnome keyring and libsecret](https://jpmens.net/2024/10/24/notes-to-self-gnome-keyring-and-libsecret/) ‚Äî "keyrings are called 'collections' in libsecret"
4. [1password: secret references](https://developer.1password.com/docs/cli/secret-references/) ‚Äî "a secret reference uri includes the names of the vault, item, section, and field"
5. [hashicorp: secrets engines](https://developer.hashicorp.com/vault/docs/secrets) ‚Äî "a secrets engine is a plugin-style component in vault"
6. [hashicorp: lease, renew, and revoke](https://developer.hashicorp.com/vault/docs/concepts/lease) ‚Äî "all dynamic secrets in vault are required to have a lease"
7. [external secrets operator: externalsecret](https://external-secrets.io/v0.4.4/api-externalsecret/) ‚Äî "the externalsecret describes what data should be fetched"
8. [rfc 6749](https://datatracker.ietf.org/doc/html/rfc6749) ‚Äî "access tokens are credentials used to access protected resources"
9. [frontegg: oauth grant types](https://frontegg.com/blog/oauth-grant-types) ‚Äî "the grant type refers to the way your app gets the access token"
10. [hotel key rack terminology - industry practice](https://www.hotelminder.com/hotel-glossary) ‚Äî traditional key organization behind front desk
11. [hotel room rack history](https://www.lodgingmagazine.com) ‚Äî room rack as physical information center
12. [rack rate etymology](https://www.hospitalitynet.org) ‚Äî rates posted on key rack visible to guests
13. [ilco: master key systems](https://www.ilco.us/masterkey-systems) ‚Äî "great grand master (ggm), grand masters (gm), sub-masters, change keys"
14. [assa abloy: key bitting array](https://www.assaabloy.com/keying-systems) ‚Äî "the key control chart maps which cuts correspond to which locks"
15. [locksmith terminology: blind codes](https://www.mrlocksmithtraining.com/glossary/) ‚Äî "manufacturer's key codes that require a lookup table to decode"
16. [medeco: sequence of progression](https://www.medeco.com) ‚Äî "determines the order in which key cuts are assigned"
17. [dea: drug scheduling](https://www.dea.gov/drug-information/drug-scheduling) ‚Äî "schedule ii drugs cannot be refilled ‚Äî a new prescription must be written each time"
18. [correspondent responsibility doctrine](https://www.ncbi.nlm.nih.gov/books/NBK538424/) ‚Äî "pharmacists share legal responsibility with prescribers"
19. [pharmacy dispense definition](https://www.nabp.pharmacy) ‚Äî "to dispense means the transfer of a prescription drug to an ultimate user"
20. [hashicorp: dynamic secrets](https://developer.hashicorp.com/vault/docs/secrets) ‚Äî "generated on-demand with automatic expiration"
21. [aws secrets manager: rotation](https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html) ‚Äî "automatic rotation without application downtime"
22. [cyberark: secret sprawl](https://www.cyberark.com/resources/blog/secret-sprawl) ‚Äî "credentials scattered across config files, env vars, and code"
23. [external secrets operator](https://external-secrets.io) ‚Äî "vault-agnostic secret management with unified interface"
