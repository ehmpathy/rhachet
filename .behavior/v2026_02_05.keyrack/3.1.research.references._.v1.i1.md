# research references for rhachet/keyrack

> authoritative references that ground the design of rhachet/keyrack -- a universal credential firewall that stores credential references in a local config (~/.rhachet/keyrack.config.json), supports vault backends (os.direct, os.secure, 1password), translates raw credentials to shortest-lived form via mechanism adapters (REPLICA, GITHUB_APP, AWS_SSO), enforces all-or-none mount policy, and blocks long-lived GitHub PATs (ghp_) regardless of declared mechanism.

---

## 1. the "secret zero" problem

### [1] Infisical -- "What is the Secret Zero Problem? A Deep Dive into Cloud-Native Authentication"

**url**: https://infisical.com/blog/solving-secret-zero-problem

**quotes**:

> "How do you securely access your secrets when you need a secret to access them?" [1a]

> "This circular dependency -- where secrets, access, and identity each rely on the others -- makes solving the security puzzle particularly complex." [1b]

> "How do you securely obtain that *first* secret that unlocks access to all your other application secrets?" [1c]

> "It's turtles all the way down! -- protecting one secret requires protecting another secret..." [1d]

> The solution: "leverage your existing infrastructure to delegate the authentication of machines" -- via established identity providers (AWS IAM, Azure AD, Kubernetes, OIDC) to bootstrap authentication through short-lived tokens. [1e]

**terms established**: secret zero, bootstrap problem, circular dependency, identity delegation, turtles all the way down

**lesson for rhachet/keyrack**: the keyrack itself faces the secret zero problem. it needs credentials to access vault backends (1password auth, os.secure decryption key). rhachet's design acknowledges this by never cached vault keys and delegates authentication to the vault's own auth flow (e.g., `op signin` for 1password, OS keyrack auth for `os.secure`). the vault backend *is* the root of trust; rhachet does not try to be one.

---

### [2] HashiCorp -- "Secure Introduction of Vault Clients"

**url**: https://developer.hashicorp.com/vault/tutorials/app-integration/secure-introduction

**quotes**:

> In the **Platform Integration** model, "Vault trusts the underlying platform (e.g. AliCloud, AWS, Azure, GCP) which assigns a token or cryptographic identity (such as IAM token, signed JWT) to virtual machine, container, or serverless function." [2a]

> In the **Trusted Orchestrator** model, "you have an orchestrator which is already authenticated against Vault with privileged permissions. The orchestrator launches new applications and injects a mechanism they can use to authenticate." [2b]

> "ACME can be the bootstrap mechanism by which clients securely obtain the secret zero certificate for Vault TLS authentication. Since DNS is the root of trust... we can consider this challenge the authentication before the authentication, or a 'secret zero zero.'" [2c]

> "Secure introduction means that we use a trusted entity (orchestrator) to provide (introduce) secrets to another entity in a secure manner." [2d]

**terms established**: platform integration, trusted orchestrator, secure introduction, secret zero zero, root of trust

**lesson for rhachet/keyrack**: rhachet/keyrack in CI uses the "trusted orchestrator" model -- GitHub Actions is the orchestrator that injects raw secrets into the keyrack step, and the keyrack resolves them into short-lived tokens. locally, it uses the "platform integration" model -- the OS itself (macOS Keyrack, Linux Secret Service) or 1password provides the identity platform.

---

### [3] GitGuardian -- "The Secret Zero Problem: Solutions and Alternatives"

**url**: https://www.gitguardian.com/nhi-hub/the-secret-zero-problem-solutions-and-alternatives

**quotes**:

> "If secret zero is compromised, it potentially gives an attacker access to all other secrets stored within the vault, thereby compromised the security of the entire system." [3a]

> On secret split: "Splitting, particularly through schemes like Shamir's Secret Sharing, divides secret zero into several shares. No single share is useful on its own; only a predefined number of shares can reconstruct the original secret." [3b]

> On auto-rotation: "Automatic rotation ensures that secret zero is changed at regular intervals without manual intervention, greatly reduced the window of opportunity for attackers to exploit a compromised secret." [3c]

**terms established**: cascade breach, secret split, Shamir's Secret Sharing, auto-rotation window

**lesson for rhachet/keyrack**: the all-or-none mount policy is a defense against cascade breach from secret zero compromise. if any single vault becomes compromised or unavailable, no credentials mount -- this prevents an attacker from partial access to escalate.

---

## 2. principle of least privilege

### [4] Saltzer & Schroeder -- "The Protection of Information in Computer Systems" (1975)

**url**: https://nocomplexity.com/documents/securityarchitecture/architecture/saltzer_designprinciples.html (original: https://www.cs.virginia.edu/~evans/cs551/saltzer/)

**quotes**:

> "Every program and every user of the system should operate using the least set of privileges necessary to complete the job." [4a]

> On fail-safe defaults: "Base access decisions on permission rather than exclusion." The principle establishes that "the default should be denial of service, and the protection scheme should then identify conditions under which access is permitted." [4b]

> On complete mediation: "Every access to every object must be checked for authority." [4c]

> On separation of privilege: "A protection mechanism that requires two keys to unlock it is more robust and flexible than one that allows access to the presenter of only a single key." [4d]

> "A conservative design must be based on arguments why objects should be accessible, rather than why they should not. In a large system some objects will be inadequately considered, so a default of lack of permission is safer." [4e]

**terms established**: least privilege, fail-safe defaults, complete mediation, separation of privilege, economy of mechanism, conservative default

**lesson for rhachet/keyrack**: these are the foundational principles behind four core keyrack behaviors: (a) mechanism adapters translate to *shortest-lived* form (least privilege in time), (b) the firewall *denies* mount by default unless all keys resolve (fail-safe defaults), (c) every key request is checked against the manifest and vault (complete mediation), (d) the vault key and the credential itself are separate secrets (separation of privilege).

---

### [5] OWASP Developer Guide -- "Principles of Security"

**url**: https://devguide.owasp.org/en/02-foundations/03-security-principles/

**quotes**:

> On fail-safe defaults: "Unless an entity is given explicit access to an object, it should be denied access to that object by default." [5a]

> On complete mediation: "Access requests by a subject for an object are completely mediated every time, so that all accesses to objects must be checked." [5b]

> On least privilege: "Given only the minimum level of access rights (privileges) that is necessary for that person or process to complete an assigned operation." [5c]

> On compartmentalization: "Compartmentalize the access to information on a 'need-to-know' basis in order to perform certain tasks." [5d]

**terms established**: deny by default, complete mediation, compartmentalization, need-to-know

**lesson for rhachet/keyrack**: the per-repo manifest (`.agent/keyrack.yml`) is a need-to-know declaration. each repo declares only the credentials it needs. the keyrack only loads those -- not all credentials on the machine. this is compartmentalization applied to credential access.

---

### [6] Microsoft Identity Platform -- "Increase Application Security with the Principle of Least Privilege"

**url**: https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access

**quotes**:

> "Apply only the least privileged set of permissions to the application by the least privileged permission in the permission list." [6a]

> "Roles with short-lived credentials are safer than static keys." [6b]

> On reducible permissions: "Reducible permissions pose a vertical privilege escalation security risk, where an entity that exploits a security vulnerability in the application could use the reducible permission for unauthorized access to data or to perform operations not normally allowed by that role." [6c]

**terms established**: reducible permissions, vertical privilege escalation, least privileged permission set

**lesson for rhachet/keyrack**: the mechanism adapter pattern (GITHUB_APP, AWS_SSO) is least privilege applied to credential *kind*. a GitHub App installation token has permissions scoped to the specific repositories the app is installed on -- far narrower than a PAT's `repo` scope which grants access to all repositories the user can access.

---

## 3. short-lived vs long-lived credentials

### [7] Chainguard -- "The Principle of Ephemerality"

**url**: https://www.chainguard.dev/unchained/the-principle-of-ephemerality

**quotes**:

> "Everything that *can* be ephemeral, *should* be ephemeral." [7a]

> "One of the main risks posed by long-lived credentials are 'exfiltration attacks' where a credential is leaked and used by the attacker until it is detected and revoked!" [7b]

> "Having things live only as long as they have to in order to accomplish the task at hand is the ideal." [7c]

> "The goal of ephemerality is to make any foothold an attacker gains like quicksand, or any credentials / keys the attacker exfiltrates like the self-destructing missions in Mission Impossible." [7d]

> "Generally speaking, 'time bombs' are preferable to 'rotation' because they do not rely on active revocation." [7e]

> On lifespan bounds: for "time bombed" credentials this means "typically O(min) to live," while for "rotated" credentials this is "often O(days) to O(months) depending on the cost of rotation and whether it can be automated." [7f]

**terms established**: principle of ephemerality, exfiltration attack, time bomb vs rotation, lifespan upper bound, quicksand foothold

**lesson for rhachet/keyrack**: the core design principle of the keyrack firewall. mechanism adapters exist to translate long-lived raw credentials into the shortest-lived form possible. a GitHub App private key (permanent) becomes a 1-hour installation token. an AWS SSO profile reference becomes a session-scoped credential. the credential that reaches the downstream process has a time bomb -- no active revocation needed.

---

### [8] Chainguard -- "The End of GitHub PATs: You Can't Leak What You Don't Have"

**url**: https://www.chainguard.dev/unchained/the-end-of-github-pats-you-cant-leak-what-you-dont-have

**quotes**:

> "Credential leaks are one of the most common ways systems are compromised, and long-lived credentials are at the heart of that." [8a]

> "These types of attacks have led to breaches at large enterprises like Mercedes and Toyota." [8b]

> On operational burden that causes reuse: "The toil of producing and managing the rotation of these long-lived secrets meant that developers would start to reuse existing tokens rather than go through the hassle of creating new ones, which violates the principle of least privilege (and increases the blast radius of a leaked token)." [8c]

> The core philosophy: "You can't leak what you don't have." [8d]

**terms established**: credential leak, blast radius, token reuse, operational toil, "you can't leak what you don't have"

**lesson for rhachet/keyrack**: this is the exact rationale for the keyrack to block `ghp_` tokens. the keyrack refuses to pass through long-lived PATs when the manifest declares `mech: GITHUB_APP`, because the operational toil of PAT creation leads to reuse, over-scope, and indefinite lifespan. the keyrack removes the toil by automated GitHub App token exchange -- so developers never need to create or rotate PATs.

---

### [9] IDPro Body of Knowledge -- "Token Lifetimes and Security in OAuth 2.0: Best Practices and Trends"

**url**: https://bok.idpro.org/article/id/108/

**quotes**:

> "Short-lived tokens are designed to expire after a brief period -- usually minutes or hours -- thereby minimized the window of opportunity for attackers to exploit them if they are intercepted or compromised." [9a]

> "By limited their lifespan, short-lived tokens reduce the risk of token misuse and improve the overall security posture of a system." [9b]

> "If these long-lived tokens are compromised, attackers can use them to gain persistent unauthorized access to systems or resources without detected for an extended period." [9c]

> "In a token replay attack, an attacker intercepts a token... and reuses it to impersonate a legitimate user. Tokens that are not tied to a specific client or have long expiration times are easy targets for replay attacks." [9d]

> "Once issued, long-lived tokens, session cookies, or API keys are often difficult to revoke in real time." [9e]

> "Short-lived, narrowly-scoped tokens, client-bound tokens, and strong cryptographic standards provide an effective framework for these risks." [9f]

**terms established**: token replay attack, persistent unauthorized access, real-time revocation difficulty, client-bound tokens, token misuse window

**lesson for rhachet/keyrack**: the IDPro Body of Knowledge is an authoritative professional reference. it establishes that the combination of short lifespan AND narrow scope is what provides security -- not either one alone. the keyrack's mechanism adapters address both dimensions: GITHUB_APP produces tokens that are both short-lived (1 hour) and narrowly scoped (specific repository installation).

---

### [10] AWS -- "Temporary Security Credentials in IAM"

**url**: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html

**quotes**:

> "You do not have to distribute or embed long-term AWS security credentials with an application." [10a]

> "The temporary security credentials have a limited lifetime, so you do not have to update them or explicitly revoke them when they're no longer needed. After temporary security credentials expire, they cannot be reused. You can specify how long the credentials are valid, up to a maximum limit." [10b]

> "Temporary security credentials are *short-term*, as the name implies. They can be configured to last for anywhere from a few minutes to several hours. After the credentials expire, AWS no longer recognizes them or allows any kind of access from API requests made with them." [10c]

> "Temporary security credentials are not stored with the user but are generated dynamically and provided to the user when requested." [10d]

**terms established**: temporary security credentials, dynamic generation, limited lifetime, no explicit revocation needed

**lesson for rhachet/keyrack**: AWS STS is the canonical example of the pattern the keyrack's AWS_SSO mechanism adapter implements. the raw credential (SSO profile reference) is translated into temporary STS credentials that expire automatically. the keyrack does not need to track or revoke these credentials -- they self-destruct.

---

### [11] AWS Well-Architected Framework -- "SEC02-BP02 Use Temporary Credentials"

**url**: https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/sec_identities_unique.html

**quotes**:

> "To reduce the risk of long-term credentials, use temporary credentials wherever possible for both human and machine identities. Long-term credentials create many risks, such as exposure through uploads to public repositories. By temporary credentials, you significantly reduce the chances of credentials compromised." [11a]

> "Level of risk exposed if this best practice is not established: High" [11b]

> "Use temporary security credentials instead of long-term credentials for all AWS API and CLI requests." [11c]

> "Configure temporary security credentials to have the shortest duration necessary for the specific task, as short-lived credentials reduce exposure time, and minimize the potential damage if credentials are compromised." [11d]

**terms established**: High risk classification, shortest duration necessary, exposure through public repositories

**lesson for rhachet/keyrack**: "shortest duration necessary" is the guide principle for mechanism adapters. the AWS Well-Architected Framework formally classifies the risk of not-temporary credentials as "High". this gives rhachet/keyrack a formal risk classification to cite.

---

## 4. the credential firewall / gateway pattern

### [12] OWASP -- "Secrets Management Cheat Sheet"

**url**: https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html

**quotes**:

> "New secrets must be securely generated and cryptographically robust enough for their purpose." [12a]

> "You should regularly rotate secrets so that any stolen credentials will only work for a short time." [12b]

> "Create secrets to expire after a defined time where possible." [12c]

> "Engineers should not have access to all secrets in the secrets management system." [12d]

> "Never transmit secrets via plaintext." [12e]

> "Ensure that secrets in your CI/CD that are not long-term, don't have a wide blast radius." [12f]

> On dynamic secrets: use dynamic secrets where feasible "to reduce the surface area of credential reuse," so that "upon reboot, compromised credentials would be expired." [12g]

> On the sidecar pattern: "Pod contains main application and sidecar containers. Sidecar authenticates and retrieves secrets to shared in-memory volumes. Periodic refresh ensures valid short-lived credentials. Decouples application from secrets manager specifics." [12h]

> On secret lifecycle: "The stages of the lifecycle are as follows: Creation, Rotation, Revocation, Expiration." [12i]

**terms established**: secret lifecycle (creation, rotation, revocation, expiration), dynamic vs static secrets, blast radius, sidecar pattern, credential reuse surface area

**lesson for rhachet/keyrack**: the OWASP cheat sheet establishes the full secret lifecycle that the keyrack must support. the keyrack's `set` command handles creation (guided setup). mechanism adapters handle rotation (by fresh short-lived tokens on each `get`). the all-or-none policy handles revocation (by refusal to mount if any key is unavailable). the firewall pattern in CI mirrors the sidecar pattern -- a dedicated step resolves credentials before downstream steps consume them.

---

### [13] Arcjet -- "Secrets in Environment Variables Considered Harmful"

**url**: https://blog.arcjet.com/storing-secrets-in-env-vars-considered-harmful/

**quotes**:

> "Environment variables are stored as plain text so if you manage to gain access to the runtime environment -- perhaps through a remote code execution vulnerability or by overly verbose logging -- you can then access all the environment variables." [13a]

> This is "a specific common weakness (CWE-526)" and has been "actively exploited by hacking groups like TeamTNT." [13b]

> "If an attacker gains a toehold in your system (maybe through a remote code execution bug), they can quickly scale up to grab the secrets." [13c]

> "That innocent console.log(process.env) you added during debugging could end up sending your API keys off to some third-party logging tool." [13d]

> The recommended alternative: "Store secret IDs instead of values" in environment variables, then fetch actual secrets at runtime from a centralized service. [13e]

**terms established**: CWE-526 (exposure of sensitive information in env vars), lateral movement, secret reference pattern, runtime fetch

**lesson for rhachet/keyrack**: the keyrack's `~/.rhachet/keyrack.config.json` stores *references* (vault type, vault ref), not raw credential values. the `os.direct` vault stores values on disk in a dedicated file -- not in env vars. the keyrack exports resolved values to env only at the moment of `get`, and for the shortest-lived form possible. this is the "secret reference" pattern applied locally.

---

### [14] Composio / MCP Gateway Architecture -- "Credential Gateway Pattern"

**url**: https://composio.dev/blog/mcp-gateways-guide

**quotes**:

> A gateway architecture "manages credentials for all upstream tools and securely injects them into requests as needed." [14a]

> Without a gateway: "each agent stores and manages credentials for every tool it accesses, which creates a massive attack surface with API keys, OAuth tokens, and database connection strings scattered across multiple agent codebases, configuration files, and environment variables." [14b]

> The gateway becomes "a single chokepoint for all interactions, where you can enforce authentication and authorization (e.g., role-based access control) and create detailed audit logs in one place." [14c]

> "No more security logic implemented in every single agent." [14d]

**terms established**: credential gateway, single chokepoint, centralized enforcement, scattered credentials, attack surface

**lesson for rhachet/keyrack**: the keyrack IS the credential gateway. without it, each developer's machine has credentials scattered across env files, `.env.local`, 1password, and random scripts. the keyrack centralizes the credential resolution into a single chokepoint -- the `rhx keyrack get` command -- and applies the same enforcement rules (mechanism validation, PAT block, all-or-none) every time.

---

## 5. all-or-none (atomic) access patterns & fail-safe defaults

### [15] OWASP -- "Fail Securely"

**url**: https://owasp.org/www-community/Fail_securely

**quotes**:

> On security control failures: "A failure will follow the same execution path as disallowed the operation." [15a]

> "Security methods like isAuthorized(), isAuthenticated(), and validate() should all return false if there is an exception." [15b]

> "You should never grant more access than required." [15c]

**terms established**: fail secure, deny on exception, failure path equals denial path

**lesson for rhachet/keyrack**: the all-or-none mount policy is fail-secure by design. if any key fails to resolve -- whether due to vault lock, absent config, expired session, or blocked PAT -- the keyrack denies ALL key mounts. the failure path is identical to the denial path: no credentials reach the downstream process. there is no partial-success state.

---

### [16] Saltzer & Schroeder (1975) -- Fail-Safe Defaults Applied to Atomicity

**url**: https://nocomplexity.com/documents/securityarchitecture/architecture/saltzer_designprinciples.html

**quotes**:

> "A conservative design must be based on arguments why objects should be accessible, rather than why they should not. In a large system some objects will be inadequately considered, so a default of lack of permission is safer." [16a]

**terms established**: conservative default, explicit permission, inadequate consideration

**lesson for rhachet/keyrack**: the all-or-none policy enforces the conservative default. the system must have an argument for why EVERY key should be accessible (all keys resolve successfully) before ANY key becomes accessible. if even one key is "inadequately considered" (not configured, locked, blocked), the entire mount fails. this prevents the dangerous scenario where a process runs with partial credentials -- e.g., it has AWS access but not GitHub access, which could cause it to read from AWS but fail to write status back to GitHub, which leaves resources in an inconsistent state.

---

### [17] OWASP Authorization Cheat Sheet -- "Deny by Default"

**url**: https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html

**quotes**:

> "An application should be configured to deny access by default." [17a]

> "One should be able to explicitly justify why a specific permission was granted to a particular user or group rather than assumed access to be the default position." [17b]

> "Error handled logic associated with security controls should deny access by default." [17c]

**terms established**: deny by default, explicit justification, error handled denial

**lesson for rhachet/keyrack**: every key must be explicitly justified by presence in both the per-repo manifest AND the per-machine config. a key that exists in the manifest but not in the config is denied (not found). a key that exists in the config but not in the manifest is ignored (not loaded). only the intersection -- keys that are both declared and configured -- can be granted.

---

## 6. vault patterns in secret management

### [18] HashiCorp -- "Why Use Vault" / "Static vs Dynamic Secrets"

**url**: https://developer.hashicorp.com/vault/tutorials/get-started/why-use-vault and https://developer.hashicorp.com/vault/tutorials/get-started/understand-static-dynamic-secrets

**quotes**:

> "Many organizations suffer from secret sprawl with credentials littered across many different systems, often times in plaintext with limited access control or audit capabilities." [18a]

> "A common anti-pattern in secrets management is secrets sprawl. When you keep secrets in a number of disparate systems, each potentially involved their own identity and authentication for access, operational efficiency is reduced and maintenance needs increase." [18b]

> On static secrets: "Static secrets do not expire. A static secret is a manual change process, and not expected to change for a long time. They are rarely, if ever rotated." [18c]

> On dynamic secrets: "A dynamic secret is generated on demand and is unique to a client, instead of a static secret, which is defined ahead of time and shared." And: "Dynamic secrets do not exist until read, so the risk of stolen is greatly reduced." [18d]

> "Vault associates each dynamic secret with a lease and automatically destroys the credentials when the lease expires." [18e]

**terms established**: secret sprawl, dynamic secrets, lease-based expiry, on-demand generation, static secret anti-pattern

**lesson for rhachet/keyrack**: the keyrack fights secret sprawl by centralized credential *references* in `~/.rhachet/keyrack.config.json`. the mechanism adapters implement dynamic secrets -- each `get` generates a fresh, short-lived token on demand. the raw credential (GitHub App private key, AWS SSO profile) is the static seed; the output token is the dynamic secret. this is HashiCorp's pattern applied at the developer-machine level rather than the datacenter level.

---

### [19] HashiCorp Vault -- Architecture: Secrets Engine Isolation

**url**: https://developer.hashicorp.com/vault/docs/internals/architecture

**quotes**:

> "At the storage layer, each engine is assigned a unique UUID, which becomes an internal file path prefix. An engine plugin only has access to their respective file path via a chroot implementation, which prevents access to other engines or vault internal storage paths." [19a]

> On request flow: "Once authenticated, requests are made by the client token. The client token is used to verify the client and ensure they are authorized while relevant policies load. The policies are used to authorize the client request." [19b]

**terms established**: engine isolation, chroot, policy-based authorization, client token, request flow

**lesson for rhachet/keyrack**: the keyrack's vault backends are analogous to Vault's secrets engines. each vault backend (os.direct, os.secure, 1password) has isolated storage and its own authentication mechanism. a compromised `os.direct` backend cannot access credentials stored in `1password`. this is isolation by construction -- not by policy.

---

### [20] Apple -- "Keyrack Data Protection"

**url**: https://support.apple.com/guide/security/keyrack-data-protection-secb0694df1a/web

**quotes**:

> "Keyrack items are encrypted with two different AES-256-GCM keys: a table key (metadata) and a per-row key (secret key)." [20a]

> "The metadata key is protected by the Secure Enclave but is cached in the Application Processor to allow fast queries of the keyrack. The secret key always requires a round trip through the Secure Enclave." [20b]

> "Items can establish conditions that require user presence by specified that they can't be accessed unless authenticated with Optic ID, Face ID, Touch ID, or by entry of the device's passcode or password." [20c]

> "ACLs are evaluated inside the Secure Enclave and are released to the kernel only if their specified constraints are met." [20d]

**terms established**: per-row encryption, AES-256-GCM, Secure Enclave round-trip, per-item ACL, user presence requirement

**lesson for rhachet/keyrack**: the `os.secure` vault backend should aspire to these same properties: per-item encryption (each key gets its own encrypted file `keyrack.secure.{hash}.age`), a master key that is not cached by rhachet (delegated to OS keyrack or user-provided passphrase), and user presence requirements (unlock required before access). rhachet does not replicate Apple's Secure Enclave, but it follows the same pattern: metadata (which key exists, which vault) is accessible without auth; the secret value requires auth.

---

### [21] 1Password Developer -- "Secrets Management for Developers"

**url**: https://1password.com/developers/secrets-management and https://developer.1password.com/docs/cli/secrets-scripts/

**quotes**:

> "Store important secrets in 1Password and then use secret references to securely load them in environment variables, configuration files, and anywhere else you might need them." [21a]

> "This allows you and your team to work collaboratively on projects without any plaintext secrets in code." [21b]

> "1Password recommends 1Password Service Accounts to follow the principle of least privilege. Service accounts support restricted 1Password CLI to specific vaults, so that processes in your authorized terminal session can only access items required for a given purpose." [21c]

> "Use 1Password CLI to load secrets into your scripts, so that the credentials in your scripts are always in sync with the information in your 1Password account and your secrets are never exposed in plaintext." [21d]

**terms established**: secret reference, vault restriction, service account, op CLI, plaintext elimination

**lesson for rhachet/keyrack**: the 1password vault backend in rhachet follows 1Password's own recommended pattern. the `keyrack.config.json` stores a secret reference (`op://Dev/bhuild-beaver-app-creds`), not the secret value. the `op` CLI retrieves the actual value at `get` time. the raw credential passes through rhachet's mechanism adapter and is discarded -- only the resolved short-lived token reaches the environment.

---

### [22] Cross-Platform Keyrack Security Comparison

**url**: https://crates.io/crates/keyring (Rust keyring crate documentation) and https://github.com/hrantzsch/keyrack

**quotes**:

> "On macOS, passwords are managed by the Keyrack; on Linux they are managed by the Secret Service API/libsecret; and on Windows they are managed by Credential Vault." [22a]

> "All platforms encrypt stored passwords with the user's login credentials or (on Linux) with a specific password for the keyring." [22b]

> "Neither on Windows nor on Linux any measures are taken to prevent other applications (of the same user) from access to stored credentials." [22c]

> "On Windows, persisted credentials are visible to all logon sessions of this same user on the same computer and to logon sessions for this user on other computers (via the roaming user profile)." [22d]

**terms established**: cross-platform access-control asymmetry, user-scoped encryption, no per-application ACLs on Windows/Linux

**lesson for rhachet/keyrack**: macOS has per-application ACLs, but Windows and Linux allow any process run as the same user to access stored credentials. this is why rhachet/keyrack's mechanism adapters provide defense-in-depth: the OS keyrack provides at-rest encryption, and the mechanism adapters add short-lived resolution on top. even if a credential is read from the keyrack by a malicious process, the credential may already be expired.

---

## 7. NIST guidelines on credential management

### [23] NIST SP 800-63B -- "Digital Identity Guidelines: Authentication and Lifecycle Management"

**url**: https://pages.nist.gov/800-63-3/sp800-63b.html

**quotes**:

> "AAL1 provides some assurance that the claimant controls an authenticator bound to the subscriber's account." [23a]

> "AAL2 provides high confidence that the claimant controls authenticator(s) bound to the subscriber's account." [23b]

> "AAL3 provides very high confidence that the claimant controls authenticator(s) bound to the subscriber's account." [23c]

> On bind: "The CSP SHALL bind at least one, and SHOULD bind at least two, physical authenticators to the subscriber's online identity." [23d]

> On revocation: The CSP "SHALL provide a mechanism to revoke or suspend the authenticator immediately upon notification from subscriber that loss or theft of the authenticator is suspected." [23e]

> On secrets: "Verifiers SHALL store memorized secrets in a form that is resistant to offline attacks" via "salted and hashed with a suitable one-way key derivation function." [23f]

> Referenced by OWASP and IDPro: "Reauthentication of the subscriber SHOULD be repeated at least once per 30 days, regardless of user activity." [23g]

**terms established**: authenticator assurance levels (AAL1/2/3), authenticator bind, immediate revocation, offline attack resistance, reauthentication interval

**lesson for rhachet/keyrack**: NIST's AAL levels map to the keyrack's vault tiers. `os.direct` (plaintext) is roughly AAL1. `os.secure` (encrypted, requires unlock) is roughly AAL2. `1password` with biometric or master password is roughly AAL2-AAL3. the reauthentication requirement (at least every 30 days) validates the design decision that rhachet should not cache vault authentication -- users should reauthenticate with their vault periodically.

---

### [24] NIST SP 800-57 -- "Recommendation for Key Management: Part 1 -- General"

**url**: https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final

**quotes**:

> "The proper management of cryptographic keys is essential to the effective use of cryptography for security." [24a]

> On cryptoperiods: "A cryptoperiod refers to the lifespan during which a cryptographic key is considered valid and safe to use." [24b]

> Best practices include "automated key rotation, enforced clear cryptoperiods, and use of a centralized KMI [Key Management Infrastructure] to cut down on human errors and save time." [24c]

> On key separation: "Different keys should be used for different functions -- one for encryption, another for signing, and so on." [24d]

**terms established**: cryptoperiod, key management infrastructure (KMI), key separation, automated rotation

**lesson for rhachet/keyrack**: the keyrack enforces cryptoperiods through mechanism adapters. a GITHUB_APP token has a 1-hour cryptoperiod. an AWS_SSO session has a provider-defined cryptoperiod. key separation is enforced by the manifest: each credential has its own key name, vault, and mechanism. there is no shared "master API key."

---

## 8. GitHub token security

### [25] GitHub Blog -- "Fine-Grained Personal Access Tokens"

**url**: https://github.blog/security/application-security/introducing-fine-grained-personal-access-tokens-for-github/

**quotes**:

> "Stolen and compromised credentials are the number one cause of data breaches across the industry." [25a]

> On classic PATs: they grant "access to all of the repositories and organizations that the owner user can access, without any control or visibility to organization owners." Classic PATs are "allowed to live forever" and the `repo` scope grants "broad access to all data in private repositories the user has access to, in perpetuity." [25b]

> On fine-grained tokens: "Fine-grained personal access tokens give developers granular control over the permissions and repository access they grant to a PAT." They "also expire, and they don't have access to all the repositories a user can access." [25c]

> On block: "Organization Owners can block the use of personal access tokens (classic) in their organization." [25d]

**terms established**: credential as #1 breach cause, perpetuity access, fine-grained permissions, organizational block

**lesson for rhachet/keyrack**: this is the authoritative source for the keyrack to block `ghp_` tokens. GitHub *itself* says classic PATs live forever and have overly broad scope. GitHub *itself* allows organizations to block them. the keyrack's PAT block is not an opinionated choice -- it mirrors GitHub's own recommendation.

---

### [26] GitHub Docs -- "When to Build a GitHub App"

**url**: https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/deciding-when-to-build-a-github-app

**quotes**:

> "GitHub Apps use short lived tokens. If the token is leaked, the token will be valid for a shorter amount of time, which reduces the damage that can be done." [26a]

> "These security features help harden your GitHub App's security by limited the damage that could be done if your app's credentials were leaked." [26b]

> On permissions: "GitHub Apps use fine-grained permissions" instead of broad scopes. "A GitHub App can request read-only access to repository contents, which will not let the app take more privileged actions." [26c]

> In contrast: "OAuth app tokens do not expire until the person who authorized the OAuth app revokes the token." [26d]

**terms established**: short-lived token leakage window, fine-grained permissions, damage limitation, read-only access granularity

**lesson for rhachet/keyrack**: the GITHUB_APP mechanism adapter is the *recommended* approach from GitHub's own documentation. the keyrack automates what GitHub recommends: exchange a long-lived app credential for a short-lived installation token scoped to specific repositories.

---

## 9. blast radius and scope limitation

### [27] Lumos / SGNL -- "Blast Radius in Cybersecurity"

**url**: https://www.lumos.com/topic/blast-radius-in-cybersecurity and https://sgnl.ai/2024/07/minimizing-the-blast-radius-when-authentication-is-compromised/

**quotes**:

> "A blast radius refers to the impact an organization could suffer from a security breach, such as an identity compromise, which represents the scope of damage an attacker can inflict on your company once they've gained unauthorized access to your systems." [27a]

> "When a user or service account is breached, attackers exploit that initial foothold to move laterally with the compromised identity's credentials, tokens, or permissions to access other systems -- the extent of that lateral movement defines the identity blast radius." [27b]

> On contextual access: "Instead of continuous access, access is granted only when necessary and for a limited duration... which ensures that if credentials are compromised, the attacker's window of opportunity is slashed." [27c]

> "By least privilege access -- minimum levels of access to each user -- the blast radius of a potential compromise can be carefully contained." [27d]

**terms established**: blast radius, lateral movement, identity blast radius, contextual access, window of opportunity

**lesson for rhachet/keyrack**: every design decision in the keyrack reduces blast radius. mechanism adapters reduce the *time* dimension (short-lived tokens). fine-grained permissions reduce the *scope* dimension (repository-specific vs user-wide). the all-or-none policy reduces the *consistency* dimension (no partial state where one system is accessible but another is not, which creates inconsistent lateral movement paths).

---

## 10. secret reference pattern and credential indirection

### [28] Node.js Security -- "Do Not Use Secrets in Environment Variables"

**url**: https://www.nodejs-security.com/blog/do-not-use-secrets-in-environment-variables-and-here-is-how-to-do-it-better

**quotes**:

> "The problem arises when a secret such as a database connection URL or API key is stored in the environment variable. This practice should be avoided because it's an easy way for an attacker to gain access to other systems once they have access to the environment." [28a]

> The recommended pattern: "Instead of stored the secret values themselves in environment variables, you store references or IDs, and at startup, your application uses these IDs to fetch the real secrets from a central secrets store." [28b]

> On bootstrap: "If the application needs a single secret to bootstrap and then access a secret management service, you can provide the initial secret through an environment variable as long as the initial secret is short-lived and has a limited usage count." [28c]

**terms established**: secret reference, credential indirection, bootstrap secret, limited usage count

**lesson for rhachet/keyrack**: `keyrack.config.json` stores references (vault type + vault ref), not values. this is credential indirection -- the config says *where* to find a credential, not *what* the credential is. at `get` time, the keyrack dereferences the pointer, fetches from the vault, runs the mechanism adapter, and exports only the resolved short-lived token. the raw credential is never written to an env var or a shared config file.

---

## 11. AWS incident data on long-lived credential exposure

### [29] AWS Security Blog -- "Practical Steps to Minimize Key Exposure"

**url**: https://aws.amazon.com/blogs/security/practical-steps-to-minimize-key-exposure-using-aws-security-services/

**quotes**:

> "Exposed long-term credentials continue to be the top entry point used by threat actors in security incidents observed by the AWS Customer Incident Response Team (CIRT)." [29a]

> "Use of long-term credentials is strongly discouraged and presents an opportunity to migrate towards AWS Identity and Access Management (IAM) roles and federated access." [29b]

**terms established**: exposed long-term credentials as #1 entry point, AWS CIRT incident data

**lesson for rhachet/keyrack**: real-world incident data from the AWS CIRT confirms that exposed long-term credentials are the number one attack vector in AWS security incidents. this is the strongest empirical validation for rhachet/keyrack's firewall design: long-lived credential blocks address the most common real-world threat directly.

---

## 12. GitHub token prefix format and detection

### [30] GitHub Engineering Blog -- "Behind GitHub's New Authentication Token Formats"

**url**: https://github.blog/engineering/platform-security/behind-githubs-new-authentication-token-formats/

**quotes**:

> "We are including specific 3 letter prefixes to represent each token, starting with a company signifier, `gh`, and the first letter of the token type. The results are: `ghp` for GitHub personal access tokens, `gho` for OAuth access tokens, `ghu` for GitHub user-to-server tokens, `ghs` for GitHub server-to-server tokens, `ghr` for refresh tokens." [30a]

> "Additionally, we want to make these prefixes clearly distinguishable within the token to improve readability. Thus, we are adding a separator: `_`. An underscore is not a Base64 character which helps ensure that our tokens cannot be accidentally duplicated by randomly generated strings like SHAs." [30b]

> "With this prefix alone, we anticipate the false positive rate for secret scanning will be down to 0.5%." [30c]

> "A checksum virtually eliminates false positives for secret scanning offline." And: "A 32 bit checksum in the last 6 digits of each token strikes the optimal balance between keeping the random token portion at a consistent entropy and enough confidence in the checksum... We start the implementation with a CRC32 algorithm. We then encode the result with a Base62 implementation, using leading zeros for padding as needed." [30d]

**terms established**: token prefix format (ghp_, gho_, ghu_, ghs_, ghr_), company signifier, CRC32 checksum, Base62 encode, identifiable token format, false positive rate, secret scan offline validation

**lesson for rhachet/keyrack**: the prefix format is the technical foundation of the keyrack's PAT block. the keyrack detects `ghp_` prefixed tokens to block classic PATs and `github_pat_` prefixed tokens to identify fine-grained PATs. the deliberate prefix design means the keyrack can perform credential-type validation with a simple string prefix check -- no API call or database lookup needed. this is what makes the firewall's `mech: GITHUB_APP` enforcement possible: if the raw value starts with `ghp_`, the keyrack knows it is a classic PAT and can refuse to pass it through. the CRC32 checksum further enables offline validation that a token is structurally valid before any attempt to use it.

---

### [31] GitHub Changelog -- "Authentication Token Format Updates Are Generally Available"

**url**: https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available/

**quotes**:

> "The character set changed from `[a-f0-9]` to `[A-Za-z0-9_]`." [31a]

> "This will give you additional security benefits and allow Secret Scanning to detect the tokens." [31b]

> "The length of our tokens is remaining the same for now. However, GitHub tokens will likely increase in length in future updates, so integrators should plan to support tokens up to 255 characters after June 1, 2021." [31c]

**terms established**: token character set expansion, secret scan detection, forward-compatible token length (up to 255 characters)

**lesson for rhachet/keyrack**: the keyrack's prefix-based detection (`ghp_`, `ghs_`, `github_pat_`) is forward-compatible with token length changes because it only checks the prefix, not the full token format. GitHub's own guidance to "plan to support tokens up to 255 characters" means the keyrack must not impose length-based validation -- only prefix-based validation. the expanded character set (`[A-Za-z0-9_]`) also means the underscore separator is a reliable structural marker for parse.

---

## 13. real-world breach data and scale of secret leakage

### [32] GitGuardian -- "The State of Secrets Sprawl 2024" (2023 data)

**url**: https://blog.gitguardian.com/the-state-of-secrets-sprawl-2024/ and https://www.gitguardian.com/state-of-secrets-sprawl-report-2024

**quotes**:

> "A staggering 12.8 million new secrets leaked in 2023" -- "a 28% increase from the previous year." [32a]

> "7 commits out of 1,000 exposed at least one secret." [32b]

> "Over 90% of exposed secrets remaining active five days post-leakage." [32c]

> "Over 1 million valid occurrences of Google API secrets, 250,000 Google Cloud secrets, and 140,000 AWS secrets were detected" in 2023 alone. [32d]

> "3,698,686 unique secrets were identified, up 25% from the prior year." [32e]

**terms established**: 12.8 million leaked secrets (2023), 28% year-over-year growth, 90%+ secrets remain active post-leak, unique vs total secret occurrences

**lesson for rhachet/keyrack**: the sheer scale -- 12.8 million new secret occurrences in a single year, with over 90% still active days after leakage -- establishes that leaked secrets are not revoked in practice. this validates the keyrack's design philosophy of self-expiry (time-bombed) credentials rather than reliance on detect-and-revoke workflows. if a short-lived token leaks, it expires in under an hour regardless of whether anyone detects the leak.

---

### [33] GitGuardian -- "The State of Secrets Sprawl 2025" (2024 data)

**url**: https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025/ and https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025-pr/

**quotes**:

> "23.8 million new credentials detected on public GitHub in 2024 alone" -- "a 25% increase in leaked secrets year-over-year." [33a]

> "70% of secrets leaked in 2022 remain active today." [33b]

> "A full 35% of all private repositories scanned contained at least one plaintext secret." [33c]

> "AWS IAM keys appeared in plaintext in 8% of private repositories -- over 5x more frequently than in public ones (1.5%)." [33d]

> "Generic passwords appeared nearly 3x more often in private repositories (24%) compared to public ones (9%)." [33e]

> "MongoDB credentials were the most frequently leaked secret type in public repositories (18.8%)." [33f]

**terms established**: 23.8 million leaked secrets (2024), 70% of 2022 secrets still active in 2025, private repos worse than public (35% contain secrets), AWS key prevalence in private repos

**lesson for rhachet/keyrack**: the 2025 report's most devastating datum for rhachet/keyrack's design is [33b]: 70% of secrets leaked in 2022 are STILL active three years later. this is the definitive empirical case for short-lived credentials. a 1-hour GitHub App installation token leaked in 2022 would have been dead within 60 minutes. a classic PAT leaked in 2022 has a 70% chance of still-exploitable status today. the fact that private repos are worse than public repos ([33c], [33d], [33e]) also validates that "security through obscurity" (repo kept private) is not a substitute for proper credential management.

---

### [34] GitHub Blog -- "Security Alert: Attack Campaign Involving Stolen OAuth User Tokens" (Heroku/Travis-CI Incident, April 2022)

**url**: https://github.blog/news-insights/company-news/security-alert-stolen-oauth-user-tokens/

**quotes**:

> "An attacker abused stolen OAuth user tokens issued to two third-party OAuth integrators, Heroku and Travis-CI, to download data from dozens of organizations, including npm." [34a]

> "The attacker authenticated to the GitHub API using the stolen OAuth tokens issued to Heroku and Travis CI." Then: "The attacker listed all the organizations for each compromised user account" and "selectively chose targets based on the listed organizations." [34b]

> "The attacker then proceeded to clone some of those private repositories." [34c]

> "Our analysis of other behavior by the threat actor suggests that the actors may be mining the downloaded private repository contents, to which the stolen OAuth token had access, for secrets that could be used to pivot into other infrastructure." [34d]

> On npm specifically: there was "unauthorized access to, and downloading of, the private repositories in the npm organization on GitHub.com." [34e]

**terms established**: OAuth token theft (Heroku/Travis-CI), supply chain attack via stolen tokens, lateral movement via mined secrets, npm private repository compromise, third-party integrator risk

**lesson for rhachet/keyrack**: this incident is the canonical example of why long-lived OAuth tokens are dangerous. the stolen tokens did not expire, so the attacker had persistent access until GitHub detected and revoked them. the attack pattern -- steal token, list orgs, clone private repos, mine for more secrets to pivot -- is exactly the blast radius expansion that short-lived tokens prevent. had these been 1-hour installation tokens, the attack window would have been minutes instead of days. the keyrack's mechanism adapters directly address this: even if a resolved token is stolen, it expires before an attacker can complete the list-orgs-clone-repos-mine-secrets kill chain.

---

### [35] BleepingComputer / RedHunt Labs -- "A Mishandled GitHub Token Exposed Mercedes-Benz Source Code" (January 2024)

**url**: https://www.bleepingcomputer.com/news/security/a-mishandled-github-token-exposed-mercedes-benz-source-code/

**quotes**:

> "On September 29, 2023, researchers at RedHunt Labs discovered a GitHub token in a public repository belonging to a Mercedes employee." [35a]

> "The GitHub token gave 'unrestricted' and 'unmonitored' access to the entire source code hosted at the Internal GitHub Enterprise Server." [35b]

> "The incident laid bare sensitive repositories housing a wealth of intellectual property, and the compromised information included database connection strings, cloud access keys, blueprints, design documents, SSO passwords, API keys, and other critical internal information." [35c]

> Mercedes confirmed: "We can confirm that source code containing an internal access token was published on a public GitHub repository by human error." [35d]

> "RedHunt, with help from TechCrunch, informed Mercedes-Benz of the token leak on January 22, 2024, and revoked it two days later." The token was exposed for nearly 4 months before revocation. [35e]

**terms established**: human error token exposure, unrestricted/unmonitored access, 4-month exposure window, cascade credential exposure (secrets inside leaked repos), intellectual property at risk

**lesson for rhachet/keyrack**: the Mercedes incident demonstrates three failures the keyrack prevents: (1) a long-lived token was committed to a public repo (the keyrack stores references, not raw tokens); (2) the token had "unrestricted and unmonitored" scope (the keyrack's mechanism adapters produce narrowly-scoped installation tokens); (3) the token remained active for ~4 months before revocation (the keyrack's short-lived tokens expire in 1 hour regardless of whether anyone detects them). the cascade exposure -- where the leaked token revealed database credentials, cloud keys, SSO passwords -- is the blast radius expansion that per-key scope and short TTLs are designed to contain.

---

## 14. GitHub App authentication protocol

### [36] GitHub Docs -- "About Authentication with a GitHub App"

**url**: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/about-authentication-with-a-github-app

**quotes**:

> "Your GitHub App can authenticate as itself, as an app installation, or on behalf of a user." [36a]

> "Your app should authenticate as itself when it needs to generate an installation access token." [36b]

> "Authenticating as an app installation lets your app access resources that are owned by the user or organization that installed the app." [36c]

> "Your app should authenticate on behalf of a user when you want to attribute app activity to a user." [36d]

**terms established**: three-tier GitHub App authentication (app-level, installation-level, user-level), installation access token generation, resource access scoped to installation

**lesson for rhachet/keyrack**: the keyrack's GITHUB_APP mechanism adapter implements the "authenticate as itself, then as an installation" two-step flow. the raw credential (private key + app ID) authenticates as the app to generate an installation access token. the installation token -- scoped to the specific repos where the app is installed -- is what reaches the downstream process. this is a security funnel: broad credential (private key) narrows to specific credential (installation token for specific repos).

---

### [37] GitHub Docs -- "Generating a JSON Web Token (JWT) for a GitHub App" and "Generating an Installation Access Token for a GitHub App"

**url**: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-json-web-token-jwt-for-a-github-app and https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-an-installation-access-token-for-a-github-app

**quotes**:

> "In order to authenticate as an app or generate an installation access token, you must generate a JSON Web Token (JWT)." [37a]

> "Your JWT must be signed using the `RS256` algorithm and must contain the following claims." And: "In all cases, you must have a private key and the ID of your GitHub App." [37b]

> "The expiration time of the JWT, after which it can't be used to request an installation token. The time must be no more than 10 minutes into the future." [37c]

> On token generation: "Send a REST API `POST` request to `/app/installations/INSTALLATION_ID/access_tokens`." [37d]

> "The installation access token will expire after 1 hour." [37e]

> On scope: "You can use the `repositories` or `repository_ids` body parameters to specify individual repositories" and "use the `permissions` body parameter to specify the permissions that the installation access token should have." [37f]

**terms established**: JWT (RS256-signed, 10-minute expiry), installation access token (1-hour expiry), POST /app/installations/{id}/access_tokens, repository-scoped token, permission-scoped token, private key + app ID as inputs

**lesson for rhachet/keyrack**: these two documents define the exact protocol the GITHUB_APP mechanism adapter implements. the flow is: (1) sign a JWT with the app's private key (RS256), valid for at most 10 minutes; (2) POST to `/app/installations/{id}/access_tokens` with the JWT; (3) receive a `ghs_`-prefixed installation token valid for 1 hour, scoped to specific repositories and permissions. the keyrack stores the private key and app ID in the vault; the JWT is ephemeral (never stored); the installation token is the output. the entire chain has cascaded time bounds: 10-minute JWT begets 1-hour token. this is the principle of ephemerality [7] applied as a concrete protocol.

---

## 15. AWS IAM Identity Center and SSO credential flow

### [38] AWS -- "IAM Identity Center Credential Provider"

**url**: https://docs.aws.amazon.com/sdkref/latest/guide/feature-sso-credentials.html

**quotes**:

> "When a user successfully authenticates with IAM Identity Center, the portal returns short-term credentials for the IAM role associated with that user." [38a]

> "(Recommended) SSO token provider configuration -- Extended session durations. Includes support for custom session durations." vs. "Legacy non-refreshable configuration -- Uses a fixed, eight-hour session." [38b]

> "When you use the SSO token provider configuration, your AWS SDK or tool automatically refreshes your session up to your extended session period." [38c]

> "Automated token refresh isn't supported using the legacy non-refreshable configuration." [38d]

> "The authentication token is cached to disk under the `~/.aws/sso/cache` directory with a file name based on the session name." [38e]

**terms established**: SSO token provider configuration, legacy non-refreshable configuration, short-term credentials, automatic session refresh, token cache, eight-hour fixed session

**lesson for rhachet/keyrack**: the AWS_SSO mechanism adapter must use the recommended SSO token provider configuration (not legacy) to get automatic token refresh. the keyrack references an SSO profile name, and the AWS SDK handles the token cache at `~/.aws/sso/cache`. rhachet does not manage SSO tokens directly -- it delegates to the AWS CLI/SDK credential chain, which itself handles the refresh-token-to-access-token exchange. the keyrack's role is to ensure the right profile is referenced and that the resolved credentials are temporary.

---

### [39] AWS -- "How IAM Identity Center Authentication Is Resolved for AWS SDKs and Tools"

**url**: https://docs.aws.amazon.com/sdkref/latest/guide/understanding-sso.html

**quotes**:

> "To retrieve credentials for sigv4 APIs using IAM Identity Center single sign-on, the SDK uses the IAM Identity Center access token to get an IAM session. This IAM session is called a permission set session, and it provides AWS access to the SDK by assuming an IAM role." [39a]

> "When using the SSO token provider configuration, the hourly access token obtained from IAM Identity Center is automatically refreshed using the refresh token." [39b]

> "If the access token is expired when the SDK tries to use it, the SDK uses the refresh token to try to get a new access token. The IAM Identity Center compares the refresh token to your IAM Identity Center access portal session duration. If the refresh token is not expired, the IAM Identity Center responds with another access token." [39c]

> "However, if the IAM Identity Center access portal session is expired, then no new access token is granted. Therefore, the permission set duration cannot be renewed. It will expire (and access will be lost) whenever the cached permission set session length times out for existing clients." [39d]

> "The maximum session length has been extended to 90 days to reduce the need for frequent sign-ins." [39e]

**terms established**: permission set session, access portal session, sigv4 credentials, refresh token chain, 90-day maximum session, access token hourly refresh, credential exchange (bearer to sigv4)

**lesson for rhachet/keyrack**: the AWS_SSO mechanism adapter operates within a three-layer session hierarchy: (1) the access portal session (up to 90 days), (2) the access token (refreshed hourly), and (3) the permission set session (1-12 hours). the keyrack references the SSO profile, which triggers this chain. if the access portal session expires, the user must re-authenticate via `aws sso login` -- the keyrack should detect this failure and surface a clear error rather than fail silently.

---

### [40] AWS -- "Set Session Duration for AWS Accounts"

**url**: https://docs.aws.amazon.com/singlesignon/latest/userguide/howtosessionduration.html

**quotes**:

> "When you create a new permission set, the session duration is set to 1 hour (in seconds) by default." [40a]

> "The minimum session duration is 1 hour, and can be set to a maximum of 12 hours." [40b]

> "When the specified duration elapses, AWS signs the user out of the session." [40c]

> "By default, IAM roles generated by IAM Identity Center for permission sets can only be assumed by IAM Identity Center users, which ensures that the session duration specified in the IAM Identity Center permission set is enforced." [40d]

**terms established**: permission set session duration, 1-hour default, 12-hour maximum, automatic sign-out, IAM role assumption restriction

**lesson for rhachet/keyrack**: the AWS_SSO mechanism adapter produces credentials with a maximum lifetime of 12 hours (default 1 hour). this is significantly shorter than a static AWS access key (which never expires). the keyrack does not need to enforce TTL itself -- AWS enforces it server-side. the keyrack's job is to ensure the SSO path is used instead of static keys, and to block any attempt to use long-lived `AKIA*` access keys when the manifest declares `mech: AWS_SSO`.

---

### [41] AWS -- "Getting IAM Identity Center User Credentials for the AWS CLI or AWS SDKs"

**url**: https://docs.aws.amazon.com/singlesignon/latest/userguide/howtogetcredentials.html

**quotes**:

> "Users in IAM Identity Center are different than IAM users. IAM users are granted long-term credentials to AWS resources. Users in IAM Identity Center are granted temporary credentials. We recommend that you use temporary credentials as a security best practice for accessing your AWS accounts because these credentials are generated every time you sign in." [41a]

> "When you assign a user in IAM Identity Center to a permission set, IAM Identity Center creates a corresponding IAM role from the permission set." [41b]

> "This session can be from one to 12 hours, depending the session duration configured for the permission set. The default session duration is one hour." [41c]

**terms established**: IAM users vs IAM Identity Center users, long-term vs temporary credentials, per-sign-in generation, permission-set-to-role map

**lesson for rhachet/keyrack**: AWS itself draws a bright line between IAM users (long-term credentials) and Identity Center users (temporary credentials), and recommends temporary. the keyrack's AWS_SSO mechanism adapter enforces this recommendation: it only resolves credentials through the SSO flow (temporary), and should reject any attempt to store or pass through static IAM user access keys.

---

## 16. OS credential storage: Windows DPAPI and Linux Secret Service

### [42] Microsoft -- "CryptProtectData Function (DPAPI)"

**url**: https://learn.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata

**quotes**:

> "The CryptProtectData function performs encryption on the data in a DATA_BLOB structure." [42a]

> "Typically, only a user with logon credentials that match those of the user who encrypted the data can decrypt the data. In addition, decryption usually can only be done on the computer where the data was encrypted. However, a user with a roaming profile can decrypt the data from another computer on the network." [42b]

> "The function creates a session key to perform the encryption. The session key is derived again when the data is to be decrypted." [42c]

> "The function also adds a Message Authentication Code (MAC) (keyed integrity check) to the encrypted data to guard against data tampering." [42d]

**terms established**: CryptProtectData, CryptUnprotectData, DATA_BLOB, user-bound encryption, session key derivation, MAC integrity check, roam profile exception, same-computer restriction

**lesson for rhachet/keyrack**: the Windows `os.secure` vault backend relies on DPAPI for at-rest encryption. DPAPI binds encrypted data to the logged-in user's credentials -- no separate master password is needed. this means the `os.secure` backend on Windows gets user-bind "for free" from the OS, similar to macOS Keyrack's Secure Enclave. however, the roam profile exception means that in enterprise environments, the encrypted credential could be decrypted on another domain-joined machine where the same user logs in -- the keyrack should document this as a known property, not a vulnerability.

---

### [43] Microsoft -- "Cached and Stored Credentials Technical Overview"

**url**: https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh994565(v=ws.11)

**quotes**:

> "Users may choose to save passwords in Windows by using an application or through the Credential Manager Control Panel applet. These credentials are stored on the hard disk drive and protected by using the Data Protection Application Programming Interface (DPAPI). Any program running as that user will be able to access credentials in this store." [43a]

> "Credential Manager uses the Credential Locker, formerly known as Windows Vault, for secure storage of user names and passwords." [43b]

**terms established**: Credential Manager, Credential Locker, Windows Vault, DPAPI at-rest protection, same-user access (no per-application ACL)

**lesson for rhachet/keyrack**: the critical detail is "any program running as that user will be able to access credentials in this store." unlike macOS Keyrack which has per-application ACLs, Windows Credential Manager grants access to all processes run as the same user. this confirms citation [22]'s cross-platform access-control asymmetry. the keyrack's mechanism adapters provide defense-in-depth: even if a malicious process reads the raw credential from Windows Credential Manager, the credential may be a long-lived seed (like a GitHub App private key) that cannot be used directly -- it must be exchanged for a short-lived token through the mechanism adapter.

---

### [44] freedesktop.org -- "Secret Service API Specification"

**url**: https://freedesktop.org/wiki/Specifications/secret-storage-spec/secrets-api-0.1.html and https://specifications.freedesktop.org/secret-service/latest/ch01.html

**quotes**:

> "The Secrets API allows client applications to store secrets securely in a service running in the user's login session." [44a]

> "The secrets are usually stored in an encrypted manner by the service." [44b]

> "Each secret is stored together with lookup attributes and a label. These together form an item." [44c]

> "A group of items together form a collection. A collection is similar in concept to the terms 'keyring' or 'wallet'." [44d]

> "The Secrets API has provision to encrypt secrets while in transit between the service and the client application." [44e]

> "The encryption is not envisioned to withstand man in the middle attacks, or other active attacks." [44f]

> "The lookup attributes are not treated as secret material, and the service may choose not to encrypt attributes when storing them to disk." [44g]

**terms established**: Secret Service API, D-Bus, collection, item, lookup attributes, label, in-transit encryption, login session scope, keyring/wallet equivalence

**lesson for rhachet/keyrack**: the Linux `os.secure` vault backend uses libsecret to communicate with the Secret Service daemon (gnome-keyring or KWallet) over D-Bus. each credential becomes an "item" in a "collection" (keyring). the specification's split between metadata (lookup attributes, unencrypted) and secret value (encrypted) mirrors rhachet's own split: `keyrack.config.json` stores metadata (key name, vault type, vault ref) unencrypted, while the actual credential value is encrypted at rest by the Secret Service implementation. the spec's caveat that in-transit encryption "is not envisioned to withstand man in the middle attacks" is acceptable because the D-Bus session bus is local to the machine.

---

### [45] LWN.net -- "Libsecret Revealed"

**url**: https://lwn.net/Articles/490518/

**quotes**:

> "Libsecret is designed to be a more modern replacement for libgnome-keyring -- the secret service daemon itself will remain unchanged." [45a]

> "Libsecret is designed from the ground up for Secret Service and D-Bus, not only implementing the full API, but doing away with the custom bits." [45b]

> "Applications will in theory be able to use libsecret to communicate with any Secret Service implementation, including ksecretservice." [45c]

> "The new project would improve on libgnome-keyring by being thread-safe, introspectable, and properly asynchronous." [45d]

**terms established**: libsecret, libgnome-keyring replacement, Secret Service D-Bus implementation, cross-implementation compatibility (gnome-keyring, KWallet), thread-safe, asynchronous

**lesson for rhachet/keyrack**: the `os.secure` vault backend on Linux should use libsecret (not the deprecated libgnome-keyring) to access credentials. libsecret's cross-implementation compatibility means the keyrack works whether the user runs GNOME (gnome-keyring) or KDE (KWallet) -- it does not need desktop-environment-specific code. this is itself an adapter pattern: libsecret adapts the desktop-specific keyring implementations behind a uniform D-Bus interface.

---

## 17. pit of success

### [46] Brad Abrams / Rico Mariani (Microsoft) -- "The Pit of Success"

**url**: https://learn.microsoft.com/en-us/archive/blogs/brada/the-pit-of-success (original blog) and https://blog.codinghorror.com/falling-into-the-pit-of-success/ (Jeff Atwood commentary)

**quotes**:

> "The Pit of Success: in stark contrast to a summit, a peak, or a journey across a desert to find victory through many trials and surprises, we want our customers to simply fall into winning practices by using our platform and frameworks. To the extent that we make it easy to get into trouble we fail." -- Rico Mariani, MS Research MindSwap, Oct 2003 [46a]

> "[Rico] admonished us to think about how we can build platforms that lead developers to write great, high performance code such that developers just fall into doing the 'right thing.'" -- Brad Abrams [46b]

> "A well-designed system makes it easy to do the right things and annoying (but not impossible) to do the wrong things." -- Jeff Atwood [46c]

> "If users aren't finding success on their own -- or if they're not finding it within a reasonable amount of time -- it's not their fault. It's our fault. We didn't make it easy enough for them to fall into the pit of success." -- Jeff Atwood [46d]

**terms established**: pit of success, pit of despair, platform-guided correctness, "to the extent we make it easy to get into trouble we fail"

**lesson for rhachet/keyrack**: the keyrack's entire UX design should embody the pit of success. the `rhx keyrack set` command guides developers through credential setup with prompts for vault type and mechanism -- so the *easiest* path also produces the *most secure* configuration. the keyrack blocks `ghp_` tokens not by request that developers remember a policy, but by refusal to process them -- the wrong path (long-lived PATs) is harder than the right path (GitHub App tokens). the all-or-none mount policy prevents partial credential setups from "sort of worked" -- it either fully works or fully fails, so misconfiguration is immediately obvious rather than silently dangerous.

---

## 18. defense in depth

### [47] NIST SP 800-53 Rev. 5 / NIST CSRC Glossary -- "Defense in Depth"

**url**: https://csrc.nist.gov/glossary/term/defense_in_depth and https://csf.tools/reference/nist-sp-800-53/r5/pl/pl-8/pl-8-1/

**quotes**:

> "An information security strategy that integrates people, technology, and operations capabilities to establish variable barriers across multiple layers and missions of the organization." -- NIST SP 800-53 Rev. 5 [47a]

> "The application of multiple countermeasures in a layered or stepwise manner to achieve security objectives. The methodology involves layering heterogeneous security technologies in the common attack vectors to ensure that attacks missed by one technology are caught by another." -- NISTIR 8183 [47b]

> PL-8(1) Defense in Depth: "Design the security and privacy architectures for the system using a defense-in-depth approach that allocates controls to locations and architectural layers and ensures coordinated, mutually reinforcing operation." [47c]

> "Organizations strategically allocate security and privacy controls so that adversaries must overcome multiple controls to achieve their objective." [47d]

> "Defense-in-depth architectural approaches include modularity and layering, separation of system and user functionality, and security function isolation." [47e]

**terms established**: defense in depth, variable barriers, multiple layers, heterogeneous security technologies, layered countermeasures, mutually reinforced controls, modularity and layer, security function isolation

**lesson for rhachet/keyrack**: the keyrack implements defense in depth through three independent, mutually reinforced layers: (1) the vault backend encrypts credentials at rest (barrier: at-rest encryption), (2) the mechanism adapter translates to shortest-lived form (barrier: temporal limitation), (3) the firewall policy blocks known-dangerous patterns like `ghp_` tokens (barrier: pattern enforcement). an attacker who defeats one layer -- e.g., reads the encrypted vault -- still faces the other two: the credential they obtain may require mechanism exchange and may be blocked by policy. NIST's emphasis on "heterogeneous security technologies" validates use of different security strategies at each layer rather than reliance on encryption alone.

---

## 19. adapter pattern

### [48] Gamma, Helm, Johnson, Vlissides -- "Design Patterns: Elements of Reusable Object-Oriented Software" (1994) -- Adapter Pattern

**url**: https://en.wikipedia.org/wiki/Adapter_pattern and https://sourcemaking.com/design_patterns/adapter and https://refactoring.guru/design-patterns/adapter

**quotes**:

> "Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces." -- Gang of Four, Design Patterns (1994) [48a]

> "An 'off the shelf' component offers compelling functionality that you would like to reuse, but its 'view of the world' is not compatible with the philosophy and architecture of the system currently being developed." [48b]

> "Adapter is about creating an intermediary abstraction that translates, or maps, the old component to the new system." [48c]

> "The adapter gets an interface, compatible with one of the existing objects. Using this interface, the existing object can safely call the adapter's methods. Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects." [48d]

**terms established**: adapter pattern, structural pattern, target interface, adaptee, wrapper, interface translation, incompatible interfaces, intermediary abstraction

**lesson for rhachet/keyrack**: the keyrack uses the adapter pattern at two architectural levels. **vault backend adapters**: `os.direct`, `os.secure`, and `1password` are adapters that present a uniform `get(ref): string` interface while they wrap incompatible storage backends (filesystem, OS keyrack APIs, 1Password CLI). the keyrack code does not know or care *how* a credential is stored -- it calls the same interface regardless. **mechanism adapters**: `REPLICA`, `GITHUB_APP`, and `AWS_SSO` are adapters that present a uniform `resolve(rawCredential): resolvedCredential` interface while they wrap incompatible credential exchange protocols (passthrough, GitHub App JWT-to-installation-token exchange, AWS SSO profile-to-STS-session exchange). the GoF pattern is the formal name for what the keyrack calls "mechanism" -- an intermediary abstraction that translates a raw credential into the format the downstream consumer expects.

---

## summary of terms established across all citations

| term | citation(s) | relevance to rhachet/keyrack |
|------|-------------|-------------------------------|
| secret zero / bootstrap problem | [1], [2], [3] | the bootstrap problem of vault authentication; rhachet delegates to vault's own auth |
| platform integration / trusted orchestrator | [2] | CI uses orchestrator model; local uses platform integration model |
| cascade breach | [3] | all-or-none mount prevents cascade from partial vault compromise |
| least privilege | [4], [5], [6] | mechanism adapters produce narrowest-scope, shortest-lived tokens |
| fail-safe defaults | [4], [5], [15], [16] | all-or-none mount = deny by default unless all keys resolve |
| complete mediation | [4], [5] | every key request checked against manifest + config + vault |
| separation of privilege | [4] | vault key and credential are separate secrets |
| deny by default | [5], [15], [17] | no keys mount unless ALL keys resolve successfully |
| principle of ephemerality | [7], [8] | core design principle: shortest-lived form possible |
| "you can't leak what you don't have" | [8] | raw credentials consumed and discarded; only tokens exported |
| token replay attack | [9] | mitigated by short-lived tokens with automatic expiry |
| real-time revocation difficulty | [9], [10] | why time-bombed credentials are preferred over revocation |
| temporary security credentials | [10], [11] | the output of AWS_SSO mechanism adapter |
| shortest duration necessary | [11] | guide principle for mechanism adapter TTL configuration |
| secret lifecycle (create/rotate/revoke/expire) | [12] | the OWASP framework the keyrack implements |
| blast radius | [8], [12], [27] | reduced by short TTL, narrow scope, and all-or-none mount |
| credential reuse surface area | [12] | dynamic secrets generated per-request minimize reuse |
| CWE-526 | [13] | env var exposure vulnerability that keyrack mitigates |
| secret reference / credential indirection | [13], [21], [28] | config stores pointers to vaults, not raw values |
| credential gateway / single chokepoint | [14] | keyrack is the single chokepoint for all credential access |
| fail secure | [15] | failure path equals denial path; no partial-success state |
| secret sprawl | [18] | the problem keyrack.config.json solves via centralized references |
| dynamic secrets / on-demand generation | [10], [18] | mechanism adapters generate on-demand, unique, lease-bound tokens |
| engine isolation / chroot | [19] | vault backends have isolated storage and auth mechanisms |
| per-row encryption / per-item ACL | [20] | os.secure encrypts each credential independently |
| cross-platform access-control asymmetry | [22] | why defense in depth (short-lived tokens) matters on Windows/Linux |
| authenticator assurance levels (AAL1/2/3) | [23] | vault tiers map to AAL1 (os.direct), AAL2 (os.secure), AAL2-3 (1password) |
| cryptoperiod | [24] | each mechanism defines a TTL (1h for GitHub, session for AWS) |
| credential as #1 breach cause | [25], [29] | empirical data that validates the firewall design |
| classic PATs "allowed to live forever" | [25] | authoritative basis for the keyrack to block ghp_ tokens |
| fine-grained permissions | [25], [26] | GitHub App tokens are narrowly scoped, unlike PATs |
| lateral movement / identity blast radius | [27] | all-or-none prevents partial state that enables lateral movement |
| bootstrap secret | [28] | keyrack.config.json is the minimal bootstrap reference |
| exposed long-term credentials = #1 entry point | [29] | AWS CIRT data: strongest empirical case for the firewall |
| token prefix format (ghp_, ghs_, ghr_, gho_, ghu_) | [30], [31] | prefix-based detection enables offline credential-type validation |
| CRC32 checksum / Base62 encode | [30] | offline structural validation of GitHub tokens |
| forward-compatible token length | [31] | prefix-only validation is resilient to future token format changes |
| 12.8M / 23.8M leaked secrets (2023/2024) | [32], [33] | scale of the problem: millions of secrets leaked per year |
| 70% of 2022 secrets still active in 2025 | [33] | empirical proof that revocation does not happen in practice |
| private repos worse than public | [33] | obscurity is not security; proper credential management is required |
| OAuth token theft (Heroku/Travis-CI) | [34] | canonical supply chain attack via long-lived tokens |
| 4-month exposure window (Mercedes-Benz) | [35] | real-world cost of long-lived token committed to public repo |
| three-tier GitHub App auth (app/installation/user) | [36] | the auth model the GITHUB_APP adapter implements |
| JWT (RS256, 10-min) to installation token (1-hour) | [37] | cascaded time bounds: the ephemerality chain |
| SSO token provider vs legacy config | [38] | recommended AWS SSO configuration for automatic refresh |
| three-layer SSO session hierarchy | [39] | portal (90d) to access token (hourly) to permission set (1-12h) |
| permission set session (1h default, 12h max) | [40] | server-enforced TTL for AWS_SSO resolved credentials |
| IAM users (long-term) vs Identity Center users (temporary) | [41] | AWS's own recommended credential model |
| DPAPI / CryptProtectData (Windows) | [42] | user-bound encryption for os.secure on Windows |
| Credential Manager / same-user access | [43] | no per-app ACL on Windows; defense-in-depth needed |
| Secret Service API / D-Bus / item+collection model | [44] | the protocol os.secure uses on Linux |
| libsecret / cross-desktop compatibility | [45] | uniform vault access on Linux (GNOME + KDE) |
| pit of success | [46] | the UX design principle: easiest path = most secure path |
| defense in depth | [47] | three independent layers: vault encryption, mechanism TTL, firewall policy |
| adapter pattern (GoF) | [48] | the formal pattern for vault backends and mechanism adapters |
