# domain distillation: rhachet/keyrack

> distillation of domain objects, operations, and daos for the keyrack feature

---

## 1. domain objects

### 1.1 literals (value objects)

```ts
/**
 * .what = where credentials are stored on the host machine
 * .why = determines unlock requirements and security level
 */
type KeyrackHostVault = 'os.direct' | 'os.secure' | '1password';

/**
 * .what = how to translate stored credentials into usable grants
 * .why = different credential types require different translation logic
 */
type KeyrackGrantMechanism = 'REPLICA' | 'GITHUB_APP' | 'AWS_SSO';

/**
 * .what = outcome of a grant attempt
 * .why = enables typed handling of all possible results
 */
type KeyrackGrantStatus = 'granted' | 'absent' | 'locked' | 'blocked';
```

### 1.2 per-repo manifest

```ts
/**
 * .what = declares which keys a repo requires
 * .why = enables repos to specify credential requirements without storage details
 *
 * location: @gitroot/.agent/keyrack.yml
 */
interface KeyrackRepoManifest {
  keys: Record<string, KeyrackKeySpec>;
}
class KeyrackRepoManifest extends DomainLiteral<KeyrackRepoManifest> implements KeyrackRepoManifest {}

/**
 * .what = specification for a single required key
 * .why = declares the mechanism constraint for firewall enforcement
 */
interface KeyrackKeySpec {
  slug: string;
  mech: KeyrackGrantMechanism;
}
class KeyrackKeySpec extends DomainLiteral<KeyrackKeySpec> implements KeyrackKeySpec {}
```

### 1.3 per-machine host manifest

```ts
/**
 * .what = machine-level credential storage configuration
 * .why = maps key slugs to their storage locations on this host
 *
 * location: ~/.rhachet/keyrack.manifest.json
 */
interface KeyrackHostManifest {
  uri: string; // e.g., ~/.rhachet/keyrack.manifest.json
  hosts: Record<string, KeyrackKeyHost>;
}
class KeyrackHostManifest extends DomainEntity<KeyrackHostManifest> implements KeyrackHostManifest {
  public static unique = ['uri'] as const;
}

/**
 * .what = storage host for a single key on this machine
 * .why = tells keyrack where to find credentials and how to translate them
 */
interface KeyrackKeyHost {
  slug: string;
  exid: string | null; // e.g., op:// reference for 1password
  vault: KeyrackHostVault;
  mech: KeyrackGrantMechanism;
  createdAt: string;
  updatedAt: string;
}
class KeyrackKeyHost extends DomainLiteral<KeyrackKeyHost> implements KeyrackKeyHost {
  public static primary = ['exid', 'vault'] as const;
  public static unique = ['slug', 'mech'] as const;
}
```

### 1.4 grant objects

```ts
/**
 * .what = result of attempting to grant a key
 * .why = discriminated union enables typed handling of all outcomes
 *
 * note: this is the "envelope" - contains either a grant or error info
 */
type KeyrackGrantAttempt =
  | { status: 'granted'; grant: KeyrackKeyGrant }
  | { status: 'absent'; slug: string; message: string; fix?: string }
  | { status: 'locked'; slug: string; message: string; fix?: string }
  | { status: 'blocked'; slug: string; message: string; fix?: string };

/**
 * .what = a successfully granted credential value
 * .why = ephemeral, short-lived credential ready for use
 *
 * note: this is the "payload" - only exists when status is 'granted'
 */
interface KeyrackKeyGrant {
  slug: string;
  value: string; // never persisted, ephemeral
  source: {
    vault: KeyrackHostVault;
    mech: KeyrackGrantMechanism;
  };
}
class KeyrackKeyGrant extends DomainLiteral<KeyrackKeyGrant> implements KeyrackKeyGrant {}
```

---

## 2. domain operations

### 2.1 keyrack get

```ts
/**
 * .what = attempts to grant credentials for a repo or specific key
 * .why = core operation that resolves credentials from host storage
 *
 * cli: rhx keyrack get --for repo | --key $key
 */
async function getKeyrackKeyGrant(
  input: { for: { repo: true } },
  context: KeyrackGrantContext,
): Promise<KeyrackGrantAttempt[]>;
async function getKeyrackKeyGrant(
  input: { for: { key: string } },
  context: KeyrackGrantContext,
): Promise<KeyrackGrantAttempt>;
async function getKeyrackKeyGrant(
  input: { for: { repo: true } | { key: string } },
  context: KeyrackGrantContext,
): Promise<KeyrackGrantAttempt | KeyrackGrantAttempt[]> { ... }

type KeyrackGrantContext = {
  hostManifest: KeyrackHostManifest;
  repoManifest?: KeyrackRepoManifest;
  vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter>;
  mechAdapters: Record<KeyrackGrantMechanism, KeyrackGrantMechanismAdapter>;
};

/**
 * .what = constructs the context required for grant operations
 * .why = encapsulates adapter and manifest setup
 */
const genKeyrackGrantContext = async (
  input: { gitroot?: string },
  context: { fs: FsMethods },
): Promise<KeyrackGrantContext> => {
  const hostManifest = await daoKeyrackHostManifest.get({}, context);
  const repoManifest = input.gitroot
    ? await daoKeyrackRepoManifest.get({ gitroot: input.gitroot }, context)
    : undefined;
  return {
    hostManifest: hostManifest ?? new KeyrackHostManifest({ uri: '~/.rhachet/keyrack.manifest.json', hosts: {} }),
    repoManifest: repoManifest ?? undefined,
    vaultAdapters: {
      'os.direct': vaultAdapterOsDirect,
      'os.secure': vaultAdapterOsSecure,
      '1password': vaultAdapter1Password,
    },
    mechAdapters: {
      REPLICA: mechAdapterReplica,
      GITHUB_APP: mechAdapterGithubApp,
      AWS_SSO: mechAdapterAwsSso,
    },
  };
};
```

**behavior:**
- if `--for repo`: reads `@gitroot/.agent/keyrack.yml`, attempts grant for each key
- if `--key $key`: attempts grant for that specific key
- **all-or-none**: if any key fails (absent/locked/blocked), mount none
- returns discriminated union with fix instructions for failures

### 2.2 keyrack set

```ts
/**
 * .what = configures storage for a credential on this host
 * .why = guides users through secure credential storage setup
 *
 * cli: rhx keyrack set --key $key --mech $mech --vault $vault
 */
const setKeyrackKeyHost = async (
  input: {
    slug: string;
    mech: KeyrackGrantMechanism;
    vault: KeyrackHostVault;
    exid?: string;
  },
  context: KeyrackHostContext,
): Promise<KeyrackKeyHost> => { ... };

type KeyrackHostContext = {
  hostManifest: KeyrackHostManifest;
  vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter>;
};

/**
 * .what = constructs the context required for host operations
 * .why = encapsulates manifest and vault adapter setup
 */
const genKeyrackHostContext = async (
  input: {},
  context: { fs: FsMethods },
): Promise<KeyrackHostContext> => {
  const hostManifest = await daoKeyrackHostManifest.get({}, context);
  return {
    hostManifest: hostManifest ?? new KeyrackHostManifest({ uri: '~/.rhachet/keyrack.manifest.json', hosts: {} }),
    vaultAdapters: {
      'os.direct': vaultAdapterOsDirect,
      'os.secure': vaultAdapterOsSecure,
      '1password': vaultAdapter1Password,
    },
  };
};
```

**behavior:**
- validates mechanism + vault compatibility
- guides user through vault-specific setup (e.g., 1password item creation)
- persists to `~/.rhachet/keyrack.manifest.json`
- idempotent: findsert semantics on slug + mech

### 2.3 keyrack unlock

```ts
/**
 * .what = unlocks a vault for the current session
 * .why = enables subsequent get operations without re-authentication
 *
 * cli: rhx keyrack unlock --for repo | --key $key
 */
const unlockKeyrackVault = async (
  input: {
    for: { repo: true } | { key: string };
  },
  context: KeyrackHostContext,
): Promise<{ unlocked: KeyrackHostVault[] }> => { ... };
```

**behavior:**
- for `os.secure`: prompts for passphrase, caches unlock state
- for `1password`: triggers `op signin`, caches session token
- session duration controlled by vault, not keyrack
- never persists vault credentials

---

## 3. daos

### 3.1 host manifest dao

```ts
/**
 * .what = persistence for the per-machine host manifest
 * .why = stores key hosts in ~/.rhachet/keyrack.manifest.json
 */
const daoKeyrackHostManifest = {
  get: async (
    input: {},
    context: { fs: FsMethods },
  ): Promise<KeyrackHostManifest | null> => { ... },

  set: async (
    input: { upsert: KeyrackHostManifest },
    context: { fs: FsMethods },
  ): Promise<KeyrackHostManifest> => { ... },
};
```

### 3.2 repo manifest dao

```ts
/**
 * .what = reads the per-repo keyrack manifest
 * .why = discovers credential requirements from @gitroot/.agent/keyrack.yml
 */
const daoKeyrackRepoManifest = {
  get: async (
    input: { gitroot: string },
    context: { fs: FsMethods },
  ): Promise<KeyrackRepoManifest | null> => { ... },
};
```

---

## 4. vault adapters

```ts
/**
 * .what = interface for vault-specific operations
 * .why = adapter pattern enables support for multiple storage backends
 */
interface KeyrackHostVaultAdapter {
  unlock: (input: {}) => Promise<void>;
  isUnlocked: () => Promise<boolean>;
  get: (input: { exid: string | null; slug: string }) => Promise<string | null>;
  set: (input: { exid: string | null; slug: string; value: string }) => Promise<void>;
  del: (input: { exid: string | null; slug: string }) => Promise<void>;
}
```

**implementations:**
- `vaultAdapterOsDirect`: plaintext file storage, no unlock required
- `vaultAdapterOsSecure`: encrypted file storage, passphrase unlock
- `vaultAdapter1Password`: 1password cli, `op signin` unlock

---

## 5. mechanism adapters

```ts
/**
 * .what = interface for mechanism-specific translation
 * .why = adapter pattern enables support for different credential types
 */
interface KeyrackGrantMechanismAdapter {
  validate: (input: { value: string }) => { valid: boolean; reason?: string };
  translate: (input: { value: string }) => Promise<string>;
}
```

**implementations:**
- `mechAdapterReplica`: passthrough, validates not a long-lived token pattern
- `mechAdapterGithubApp`: json blob → short-lived installation token
- `mechAdapterAwsSso`: sso profile → temporary session credentials

---

## 6. firewall enforcement

the keyrack acts as a **credential firewall**:

1. **mechanism constraint**: repo declares required mechanism per key
2. **validation on grant**: mechanism adapter validates value shape
3. **block on violation**: if value looks like a long-lived token when mechanism forbids it → `blocked` status
4. **fail-safe**: if any key fails → mount none (all-or-none semantics)

this prevents accidental exposure of long-lived credentials where short-lived alternatives exist.

---

## 7. file locations

| file | location | purpose |
|------|----------|---------|
| repo manifest | `@gitroot/.agent/keyrack.yml` | declares required keys + mechanisms |
| host manifest | `~/.rhachet/keyrack.manifest.json` | maps keys to hosts |
| direct storage | `~/.rhachet/keyrack.direct.json` | plaintext key-value store |
| secure storage | `~/.rhachet/keyrack.secure.$hash.enc` | encrypted per-key files |

---

## 8. cli surface

```sh
# get credentials
rhx keyrack get --for repo          # grant all keys from repo manifest
rhx keyrack get --key $key          # grant specific key

# set credential storage
rhx keyrack set --key $key --mech REPLICA --vault os.direct
rhx keyrack set --key $key --mech GITHUB_APP --vault 1password
rhx keyrack set --key $key --mech AWS_SSO --vault os.secure

# unlock vaults
rhx keyrack unlock --for repo
rhx keyrack unlock --key $key
```

---

## 9. sdk surface

```ts
import { keyrack } from 'rhachet/keyrack';

// get credentials
const grants = await keyrack.get({ for: { repo: true } });
const grant = await keyrack.get({ for: { key: 'XAI_API_KEY' } });

// set credential storage
await keyrack.set({
  slug: 'XAI_API_KEY',
  mech: 'REPLICA',
  vault: 'os.direct',
});

// unlock vaults
await keyrack.unlock({ for: { repo: true } });
```
