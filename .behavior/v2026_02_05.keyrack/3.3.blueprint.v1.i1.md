# blueprint: rhachet/keyrack v1

> implementation blueprint for the keyrack credential management feature

---

## 1. filediffs treestruct

**legend:**
- `[+] create` — file to create
- `[~] update` — file to update
- `[-] delete` — file to delete

```
[~] package.json                                    # add exports["./keyrack"] entrypoint
[~] bin/rhx                                         # short-circuit 'keyrack' before skill proxy

src/
├── contract/
│   ├── cli/
│   │   ├── [~] invoke.ts                           # register invokeKeyrack
│   │   └── [+] invokeKeyrack.ts                    # keyrack get/set/unlock commands
│   └── sdk/
│       └── [+] keyrack.ts                          # sdk entrypoint: export { keyrack }
│
├── domain.objects/
│   ├── [+] KeyrackHostVault.ts                     # literal: 'os.direct' | 'os.secure' | '1password'
│   ├── [+] KeyrackGrantMechanism.ts                # literal: 'REPLICA' | 'GITHUB_APP' | 'AWS_SSO'
│   ├── [+] KeyrackGrantStatus.ts                   # literal: 'granted' | 'absent' | 'locked' | 'blocked'
│   ├── [+] KeyrackRepoManifest.ts                  # literal: per-repo keyrack.yml
│   ├── [+] KeyrackKeySpec.ts                       # literal: key requirement in manifest
│   ├── [+] KeyrackHostManifest.ts                  # entity: per-machine config
│   ├── [+] KeyrackKeyHost.ts                       # literal: per-key storage host
│   ├── [+] KeyrackGrantAttempt.ts                  # union: result envelope
│   └── [+] KeyrackKeyGrant.ts                      # literal: granted credential value
│
├── domain.operations/
│   └── keyrack/
│       ├── [+] getKeyrackKeyGrant.ts               # get --for repo | --key $key
│       ├── [+] setKeyrackKeyHost.ts                # set --key $key --mech --vault
│       ├── [+] unlockKeyrackVault.ts               # unlock --for repo | --key $key
│       ├── [+] genKeyrackGrantContext.ts           # context factory for grant ops
│       ├── [+] genKeyrackHostContext.ts            # context factory for host ops
│       └── adapters/
│           ├── vaults/
│           │   ├── [+] vaultAdapterOsDirect.ts     # plaintext file storage
│           │   ├── [+] vaultAdapterOsSecure.ts     # age-encrypted storage
│           │   └── [+] vaultAdapter1Password.ts    # 1password cli integration
│           └── mechanisms/
│               ├── [+] mechAdapterReplica.ts       # passthrough + validation
│               ├── [+] mechAdapterGithubApp.ts     # json → installation token
│               └── [+] mechAdapterAwsSso.ts        # sso → session credentials
│
├── access/
│   └── daos/
│       ├── [+] daoKeyrackHostManifest/
│       │   ├── [+] index.ts                        # get/set for ~/.rhachet/keyrack.manifest.json
│       │   └── [+] schema.ts                       # zod schema for host manifest
│       └── [+] daoKeyrackRepoManifest/
│           ├── [+] index.ts                        # get for @gitroot/.agent/keyrack.yml
│           └── [+] schema.ts                       # zod schema for repo manifest
│
├── infra/
│   ├── [←] upsertFile.ts                           # reuse for config writes
│   ├── [←] findsertFile.ts                         # reuse for config init
│   └── [+] ageEncrypt.ts                           # age cli wrapper for os.secure
│
└── .test/
    └── assets/
        ├── [+] genMockKeyrackHostManifest.ts       # fixture generator
        ├── [+] genMockKeyrackRepoManifest.ts       # fixture generator
        └── [+] genMockVaultAdapter.ts              # mock vault for tests

accept.blackbox/
├── .test/
│   └── assets/
│       ├── [+] with-keyrack-manifest/              # fixture: repo with .agent/keyrack.yml
│       ├── [+] with-keyrack-config/                # fixture: ~/.rhachet/keyrack.manifest.json
│       └── [+] with-vault-os-direct/               # fixture: plaintext vault state
└── cli/
    └── [+] keyrack.acceptance.test.ts              # blackbox cli tests
```

---

## 2. codepaths treestruct

**legend:**
- `[+]` create — codepath to create
- `[~]` update — codepath to update
- `[○]` retain — codepath to retain
- `[-]` delete — codepath to delete
- `[←]` reuse — codepath to reuse from elsewhere
- `[→]` eject — codepath to decompose for reuse

```
cli invocation
├── [~] bin/rhx
│   └── [+] if argv[1] === 'keyrack' → route to invoke.ts (skip skill proxy)
│
├── [○] invoke.ts
│   └── [+] invokeKeyrack({ program }, context)
│       ├── [+] keyrack get --for repo
│       │   ├── [+] genKeyrackGrantContext()
│       │   │   ├── [+] daoKeyrackHostManifest.get()
│       │   │   ├── [+] daoKeyrackRepoManifest.get({ gitroot })
│       │   │   └── [+] load vault + mech adapters
│       │   └── [+] getKeyrackKeyGrant({ for: { repo: true } }, context)
│       │       ├── [+] for each key in repoManifest.keys
│       │       │   ├── [+] find KeyrackKeyHost in hostManifest
│       │       │   ├── [+] vaultAdapter.get({ exid, slug })
│       │       │   ├── [+] mechAdapter.validate({ value })
│       │       │   ├── [+] mechAdapter.translate({ value })
│       │       │   └── [+] yield KeyrackGrantAttempt
│       │       └── [+] all-or-none: if any fail, return all failures
│       │
│       ├── [+] keyrack get --key $key
│       │   ├── [+] genKeyrackGrantContext()
│       │   └── [+] getKeyrackKeyGrant({ for: { key } }, context)
│       │       └── [+] same as above, single key
│       │
│       ├── [+] keyrack set --key $key --mech $mech --vault $vault
│       │   ├── [+] genKeyrackHostContext()
│       │   │   ├── [+] daoKeyrackHostManifest.get()
│       │   │   └── [+] load vault adapters
│       │   └── [+] setKeyrackKeyHost({ slug, mech, vault, exid? }, context)
│       │       ├── [+] validate mech + vault compatibility
│       │       ├── [+] guide user through vault-specific setup
│       │       ├── [+] findsert KeyrackKeyHost in hostManifest
│       │       └── [+] daoKeyrackHostManifest.set({ upsert })
│       │
│       └── [+] keyrack unlock --for repo | --key $key
│           ├── [+] genKeyrackHostContext()
│           └── [+] unlockKeyrackVault({ for }, context)
│               ├── [+] resolve vault(s) from hostManifest
│               └── [+] vaultAdapter.unlock() for each

vault adapters
├── [+] vaultAdapterOsDirect
│   ├── [+] unlock() → no-op (always unlocked)
│   ├── [+] isUnlocked() → true
│   ├── [+] get() → read ~/.rhachet/keyrack.direct.json[slug]
│   ├── [+] set() → write ~/.rhachet/keyrack.direct.json[slug]
│   └── [+] del() → remove ~/.rhachet/keyrack.direct.json[slug]
│
├── [+] vaultAdapterOsSecure
│   ├── [+] unlock() → prompt passphrase, cache session
│   ├── [+] isUnlocked() → check session cache
│   ├── [+] get() → age decrypt ~/.rhachet/keyrack.secure.$hash.enc
│   ├── [+] set() → age encrypt to ~/.rhachet/keyrack.secure.$hash.enc
│   └── [+] del() → rm ~/.rhachet/keyrack.secure.$hash.enc
│
└── [+] vaultAdapter1Password
    ├── [+] unlock() → op signin, cache session token
    ├── [+] isUnlocked() → op whoami check
    ├── [+] get() → op read $exid
    ├── [+] set() → op item create/edit
    └── [+] del() → op item delete

mechanism adapters
├── [+] mechAdapterReplica
│   ├── [+] validate() → reject if matches ghp_*, gho_*, aws long-lived patterns
│   └── [+] translate() → passthrough (no translation)
│
├── [+] mechAdapterGithubApp
│   ├── [+] validate() → must be valid json with app_id, private_key
│   └── [+] translate() → generate short-lived installation token
│
└── [+] mechAdapterAwsSso
    ├── [+] validate() → must be valid sso profile name
    └── [+] translate() → refresh sso session, return temp credentials

dao codepaths
├── [+] daoKeyrackHostManifest
│   ├── [+] get() → read ~/.rhachet/keyrack.manifest.json, parse, validate
│   └── [+] set({ upsert }) → merge, write ~/.rhachet/keyrack.manifest.json
│
└── [+] daoKeyrackRepoManifest
    └── [+] get({ gitroot }) → read @gitroot/.agent/keyrack.yml, parse, validate

error codepaths
├── [←] BadRequestError (helpful-errors) → validation errors
├── [+] KeyrackVaultLockedError → vault requires unlock
├── [+] KeyrackKeyAbsentError → key not configured on host
└── [+] KeyrackMechViolationError → value violates mechanism constraint
```

---

## 3. contracts

### 3.0 package.json exports

```json
{
  "exports": {
    ".": "./dist/index.js",
    "./keyrack": "./dist/contract/sdk/keyrack.js"
  }
}
```

### 3.1 domain objects

```typescript
// literals (value objects)
type KeyrackHostVault = 'os.direct' | 'os.secure' | '1password';
type KeyrackGrantMechanism = 'REPLICA' | 'GITHUB_APP' | 'AWS_SSO';
type KeyrackGrantStatus = 'granted' | 'absent' | 'locked' | 'blocked';

// per-repo manifest (@gitroot/.agent/keyrack.yml)
interface KeyrackRepoManifest {
  keys: Record<string, KeyrackKeySpec>;
}
class KeyrackRepoManifest extends DomainLiteral<KeyrackRepoManifest> implements KeyrackRepoManifest {}

interface KeyrackKeySpec {
  slug: string;
  mech: KeyrackGrantMechanism;
}
class KeyrackKeySpec extends DomainLiteral<KeyrackKeySpec> implements KeyrackKeySpec {}

// per-machine host manifest (~/.rhachet/keyrack.manifest.json)
interface KeyrackHostManifest {
  uri: string;
  hosts: Record<string, KeyrackKeyHost>;
}
class KeyrackHostManifest extends DomainEntity<KeyrackHostManifest> implements KeyrackHostManifest {
  public static unique = ['uri'] as const;
}

interface KeyrackKeyHost {
  slug: string;
  exid: string | null;
  vault: KeyrackHostVault;
  mech: KeyrackGrantMechanism;
  createdAt: string;
  updatedAt: string;
}
class KeyrackKeyHost extends DomainLiteral<KeyrackKeyHost> implements KeyrackKeyHost {
  public static primary = ['exid', 'vault'] as const;
  public static unique = ['slug', 'mech'] as const;
}

// grant result (discriminated union)
type KeyrackGrantAttempt =
  | { status: 'granted'; grant: KeyrackKeyGrant }
  | { status: 'absent'; slug: string; message: string; fix?: string }
  | { status: 'locked'; slug: string; message: string; fix?: string }
  | { status: 'blocked'; slug: string; message: string; fix?: string };

interface KeyrackKeyGrant {
  slug: string;
  value: string; // ephemeral, never persisted
  source: {
    vault: KeyrackHostVault;
    mech: KeyrackGrantMechanism;
  };
}
class KeyrackKeyGrant extends DomainLiteral<KeyrackKeyGrant> implements KeyrackKeyGrant {}
```

### 3.2 domain operations

```typescript
// get credentials
async function getKeyrackKeyGrant(
  input: { for: { repo: true } },
  context: KeyrackGrantContext,
): Promise<KeyrackGrantAttempt[]>;
async function getKeyrackKeyGrant(
  input: { for: { key: string } },
  context: KeyrackGrantContext,
): Promise<KeyrackGrantAttempt>;

// set credential storage
const setKeyrackKeyHost = async (
  input: { slug: string; mech: KeyrackGrantMechanism; vault: KeyrackHostVault; exid?: string },
  context: KeyrackHostContext,
): Promise<KeyrackKeyHost>;

// unlock vaults
const unlockKeyrackVault = async (
  input: { for: { repo: true } | { key: string } },
  context: KeyrackHostContext,
): Promise<{ unlocked: KeyrackHostVault[] }>;
```

### 3.3 context types

```typescript
type KeyrackHostContext = {
  hostManifest: KeyrackHostManifest;
  vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter>;
};

type KeyrackGrantContext = {
  hostManifest: KeyrackHostManifest;
  repoManifest?: KeyrackRepoManifest;
  vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter>;
  mechAdapters: Record<KeyrackGrantMechanism, KeyrackGrantMechanismAdapter>;
};
```

### 3.4 adapter interfaces

```typescript
interface KeyrackHostVaultAdapter {
  unlock: (input: {}) => Promise<void>;
  isUnlocked: () => Promise<boolean>;
  get: (input: { exid: string | null; slug: string }) => Promise<string | null>;
  set: (input: { exid: string | null; slug: string; value: string }) => Promise<void>;
  del: (input: { exid: string | null; slug: string }) => Promise<void>;
}

interface KeyrackGrantMechanismAdapter {
  validate: (input: { value: string }) => { valid: boolean; reason?: string };
  translate: (input: { value: string }) => Promise<string>;
}
```

---

## 4. test coverage plan

### 4.1 unit tests

| file | coverage |
|------|----------|
| `invokeKeyrack.test.ts` | cli command registration, arg parse, mock vault calls |
| `getKeyrackKeyGrant.test.ts` | grant logic with mocked adapters, all-or-none semantics |
| `setKeyrackKeyHost.test.ts` | host upsert logic, mech+vault validation |
| `unlockKeyrackVault.test.ts` | unlock dispatch to vault adapters |
| `mechAdapterReplica.test.ts` | validation patterns, passthrough |
| `mechAdapterGithubApp.test.ts` | json validation, token generation |
| `mechAdapterAwsSso.test.ts` | sso profile validation |

### 4.2 integration tests

| file | coverage |
|------|----------|
| `daoKeyrackHostManifest.integration.test.ts` | read/write ~/.rhachet/keyrack.manifest.json |
| `daoKeyrackRepoManifest.integration.test.ts` | read/parse @gitroot/.agent/keyrack.yml |
| `vaultAdapterOsDirect.integration.test.ts` | plaintext file read/write/del |
| `vaultAdapterOsSecure.integration.test.ts` | age encrypt/decrypt with temp files |
| `vaultAdapter1Password.integration.test.ts` | op cli calls (skip if op not installed) |
| `getKeyrackKeyGrant.integration.test.ts` | end-to-end with real filesystem |

### 4.3 acceptance tests

| scenario | test |
|----------|------|
| **[uc1] get --for repo** | reads keyrack.yml, resolves all keys, mounts grants |
| **[uc2] get --key $key** | resolves single key from host manifest |
| **[uc3] set --key --mech --vault** | creates host entry, persists to config |
| **[uc4] unlock --for repo** | prompts vault unlock, caches session |
| **[uc5] key absent** | returns absent status with fix instructions |
| **[uc6] vault locked** | returns locked status with unlock instructions |
| **[uc7] firewall violation** | blocks ghp_* tokens when mech != REPLICA |
| **[uc8] all-or-none** | if any key fails, none are mounted |
| **[uc9] findsert semantics** | host found with same attrs returns found |
| **[uc10] findsert conflict** | host found with diff attrs throws error |

### 4.4 test fixtures

```
accept.blackbox/.test/assets/
├── with-keyrack-manifest/
│   ├── .agent/
│   │   └── keyrack.yml               # keys: [XAI_API_KEY, GITHUB_APP_CREDS]
│   ├── rhachet.use.ts
│   └── package.json
│
├── with-keyrack-config/
│   └── .rhachet/
│       └── keyrack.manifest.json     # hosts: { XAI_API_KEY: { vault: os.direct, ... } }
│
└── with-vault-os-direct/
    └── .rhachet/
        ├── keyrack.manifest.json
        └── keyrack.direct.json       # { XAI_API_KEY: "xai-abc123..." }
```

---

## 5. implementation order

### phase 1: domain foundation
1. create domain objects (literals, entities, interfaces)
2. create adapter interfaces
3. create context types

### phase 2: daos
1. implement daoKeyrackHostManifest (get/set)
2. implement daoKeyrackRepoManifest (get only)
3. add integration tests for both

### phase 3: vault adapters
1. implement vaultAdapterOsDirect (simplest)
2. implement vaultAdapterOsSecure (age wrapper)
3. implement vaultAdapter1Password (op cli)
4. add integration tests for each

### phase 4: mechanism adapters
1. implement mechAdapterReplica (passthrough + validation)
2. implement mechAdapterGithubApp (json → token)
3. implement mechAdapterAwsSso (sso refresh)
4. add unit tests for each

### phase 5: domain operations
1. implement genKeyrackHostContext
2. implement genKeyrackGrantContext
3. implement getKeyrackKeyGrant
4. implement setKeyrackKeyHost
5. implement unlockKeyrackVault
6. add unit + integration tests

### phase 6: cli integration
1. implement invokeKeyrack with get/set/unlock commands
2. register in invoke.ts
3. add unit tests with mocked context
4. add acceptance tests with fixtures

### phase 7: firewall enforcement
1. add ghp_*, gho_*, aws long-lived token patterns to mechAdapterReplica
2. add blocked status handle to getKeyrackKeyGrant
3. add acceptance tests for firewall scenarios

---

## 6. key design decisions

### 6.1 all-or-none semantics
when `get --for repo` is called, if any key fails to grant:
- return all KeyrackGrantAttempts (with failures)
- do not export any env vars
- prevents partial credential exposure

### 6.2 vault-controlled session duration
rhachet does not cache vault unlock state. the vault backend controls session duration:
- os.secure: session token expires per vault policy
- 1password: `op` cli session expires per 1password settings

### 6.3 findsert semantics for set
`set` uses findsert (find-or-insert) semantics:
- if host found with same attrs → return found, no update
- if host found with diff attrs → throw error
- if host absent → create new

### 6.4 ephemeral grant values
KeyrackKeyGrant.value is never persisted by rhachet. it exists only in memory for the duration of the command execution.

---

## 7. file locations

| file | location | purpose |
|------|----------|---------|
| repo manifest | `@gitroot/.agent/keyrack.yml` | declares required keys + mechanisms |
| host manifest | `~/.rhachet/keyrack.manifest.json` | maps keys to hosts |
| direct storage | `~/.rhachet/keyrack.direct.json` | plaintext key-value store |
| secure storage | `~/.rhachet/keyrack.secure.$hash.enc` | age-encrypted per-key files |

---

## 8. cli surface

```sh
# get credentials
rhx keyrack get --for repo          # grant all keys from repo manifest
rhx keyrack get --key $key          # grant specific key

# set credential storage
rhx keyrack set --key $key --mech REPLICA --vault os.direct
rhx keyrack set --key $key --mech GITHUB_APP --vault 1password
rhx keyrack set --key $key --mech AWS_SSO --vault os.secure

# unlock vaults
rhx keyrack unlock --for repo
rhx keyrack unlock --key $key
```

---

## 9. sdk surface

```typescript
import { keyrack } from 'rhachet/keyrack';

// get credentials
const grants = await keyrack.get({ for: { repo: true } });
const grant = await keyrack.get({ for: { key: 'XAI_API_KEY' } });

// set credential storage
await keyrack.set({
  slug: 'XAI_API_KEY',
  mech: 'REPLICA',
  vault: 'os.direct',
});

// unlock vaults
await keyrack.unlock({ for: { repo: true } });
```
