# blueprint: rhachet/keyrack v2 — ephemeral key caching

> pit of success: passphrase never in env. ephemeral keys cached for reuse. unlock inline with get.

---

## 1. design decisions

### 1.1 remove sourcing pattern

**before (v1):**
```sh
# user must source to export passphrase to shell
. rhx keyrack unlock --passphrase "xxx"

# then subsequent get works
rhx keyrack get --key SECURE_API_KEY
```

**after (v2):**
```sh
# single command with inline unlock
rhx keyrack get --key SECURE_API_KEY --unlock

# prompts for passphrase, resolves, caches ephemeral key
```

**why:** the sourcing pattern exposes the passphrase to the shell environment. this is an antipattern — we want credentials to be consumed and discarded, not persisted in env vars.

### 1.2 ephemeral key caching

when `--unlock` is used, keyrack:

1. prompts for passphrase (os.secure) or triggers vault auth (1password)
2. retrieves the source credential from the vault
3. translates via mechanism adapter (e.g., GITHUB_APP json blob → `ghs_` token)
4. **caches the ephemeral key to os.direct vault** (never the source credential)
5. returns the ephemeral key as the grant

on subsequent `get` calls (without `--unlock`):

1. checks os.direct for cached ephemeral key
2. validates the cached key is still usable (e.g., `aws sts get-caller-identity`, github api call)
3. if valid → returns cached key as grant
4. if expired or invalid → reports `locked`, suggests `--unlock`

**why:** this pattern matches how declastruct-aws handles sso credentials. ephemeral keys are safe to cache — they're short-lived by design. source credentials (passphrase, private keys) are never persisted outside their vault.

### 1.3 mechanism-specific caching rules

| mechanism | source credential | cached ephemeral | cache location | validation |
|-----------|------------------|------------------|----------------|------------|
| `REPLICA` | api key | (same value) | os.direct | none (no expiry) |
| `GITHUB_APP` | json blob (appId + privateKey) | `ghs_...` token | os.direct | github api call |
| `AWS_SSO` | sso profile reference | sts temp creds | os.direct | `aws sts get-caller-identity` |

**note:** only non-REPLICA mechanisms have ephemeral keys to cache. REPLICA keys are "pass-through" — the source IS the grant.

### 1.4 cli surface changes

**removed:**
```sh
# no longer needed — passphrase never exported to shell
. rhx keyrack unlock --passphrase "xxx"
```

**updated:**
```sh
# inline unlock with get
rhx keyrack get --key SECURE_API_KEY --unlock

# unlock for all repo keys
rhx keyrack get --for repo --unlock
```

**retained:**
```sh
# set still guides vault setup
rhx keyrack set --key XAI_API_KEY --mech REPLICA --vault os.direct
rhx keyrack set --key EHMPATHY_AWS_SSO_PREP --mech AWS_SSO --vault os.secure

# list still shows configured keys
rhx keyrack list
```

---

## 2. architecture

### 2.1 flow: get without unlock (happy path)

```
rhx keyrack get --key EHMPATHY_AWS_SSO_PREP
       │
       ▼
┌─────────────────────────────────────────┐
│ 1. check os.direct cache for ephemeral  │
│    (lookup by slug + mech)              │
└─────────────────────────────────────────┘
       │
       ▼ found
┌─────────────────────────────────────────┐
│ 2. validate cached key                  │
│    aws sts get-caller-identity          │
└─────────────────────────────────────────┘
       │
       ▼ valid
┌─────────────────────────────────────────┐
│ 3. return grant                         │
│    status: granted                      │
│    value: cached sts credentials        │
└─────────────────────────────────────────┘
```

### 2.2 flow: get without unlock (cache miss or expired)

```
rhx keyrack get --key EHMPATHY_AWS_SSO_PREP
       │
       ▼
┌─────────────────────────────────────────┐
│ 1. check os.direct cache for ephemeral  │
└─────────────────────────────────────────┘
       │
       ▼ not found OR expired
┌─────────────────────────────────────────┐
│ 2. return locked status                 │
│    status: locked                       │
│    fix: rhx keyrack get --key ... --unlock
└─────────────────────────────────────────┘
```

### 2.3 flow: get with unlock

```
rhx keyrack get --key EHMPATHY_AWS_SSO_PREP --unlock
       │
       ▼
┌─────────────────────────────────────────┐
│ 1. lookup host manifest                 │
│    vault: os.secure, mech: AWS_SSO      │
└─────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│ 2. prompt for vault unlock              │
│    age passphrase (os.secure)           │
└─────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│ 3. retrieve source credential           │
│    decrypt .age file → sso profile ref  │
└─────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│ 4. translate via mech adapter           │
│    aws sso login → sts temp creds       │
└─────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│ 5. cache ephemeral to os.direct         │
│    (key: slug + mech, value: sts creds) │
└─────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│ 6. return grant                         │
│    status: granted                      │
│    value: sts temp credentials          │
└─────────────────────────────────────────┘
```

### 2.4 os.direct as precheck (like os.envvar)

os.direct is checked as a precheck step, just like os.envvar. the grant resolution order:

```
1. os.envvar   — CI passthrough (already implemented)
2. os.direct   — ephemeral cache (translated grants from prior unlock)
3. source vault — os.secure, 1password (requires --unlock if vault locked)
```

when `--unlock` translates a credential (e.g., GITHUB_APP json → ghs_ token), the translated value is stored to os.direct with expiry. on subsequent `get` (no `--unlock`), os.direct precheck finds it.

```json
// ~/.rhachet/keyrack.direct.json
{
  "XAI_API_KEY": {
    "value": "sk-..."
  },
  "EHMPATHY_AWS_SSO_PREP": {
    "value": "{\"accessKeyId\":\"...\",\"secretAccessKey\":\"...\",\"sessionToken\":\"...\"}",
    "expiresAt": "2026-02-06T18:00:00Z"
  }
}
```

**precheck flow:**
1. os.envvar? → grant (CI passthrough)
2. os.direct? → if found and not expired → grant
3. os.direct expired? → delete, continue to source vault
4. source vault? → if `--unlock` → unlock, translate, store to os.direct, grant
5. source vault locked? → report locked status

---

## 3. domain objects

### 3.1 extend os.direct vault entry (add expiry)

```ts
import type { IsoTimeStamp } from 'iso-time';

/**
 * .what = value stored in os.direct vault
 * .why = extend to track ephemeral expiry
 *
 * [~] add optional expiresAt for ephemeral grants
 */
interface KeyrackDirectVaultEntry {
  value: string;
  expiresAt?: IsoTimeStamp;  // if set, entry is ephemeral
}
```

no new domain objects needed — os.direct vault already stores values; we add optional expiry.

### 3.2 updated: grant attempt

```ts
import type { IsoTimeStamp } from 'iso-time';

/**
 * .what = result of attempting to grant a key
 * .why = discriminated union enables typed handling
 *
 * [+] added: expiresAt for granted from cache
 */
type KeyrackGrantAttempt =
  | { status: 'granted'; grant: KeyrackKeyGrant; expiresAt?: IsoTimeStamp }
  | { status: 'absent'; slug: string; message: string; fix?: string }
  | { status: 'locked'; slug: string; message: string; fix?: string }
  | { status: 'blocked'; slug: string; message: string; fix?: string };
```

---

## 4. domain operations

### 4.1 updated: getKeyrackKeyGrant

```ts
/**
 * .what = attempts to grant credentials for a repo or specific key
 * .why = core operation that resolves credentials from host storage
 *
 * [~] updated: --unlock flag triggers inline unlock flow
 * [+] added: ephemeral cache check before vault access
 */
async function getKeyrackKeyGrant(
  input: {
    for: { repo: true } | { key: string };
    unlock?: boolean; // [+] new flag
  },
  context: KeyrackGrantContext,
): Promise<KeyrackGrantAttempt | KeyrackGrantAttempt[]>;
```

**behavior:**

1. if `--unlock` NOT specified:
   - check ephemeral cache for valid entry
   - if found and valid → return grant from cache
   - if not found or expired → return `locked` status with fix command

2. if `--unlock` IS specified:
   - prompt for vault unlock (passphrase, 1password auth, etc)
   - retrieve source credential from vault
   - translate via mechanism adapter
   - cache ephemeral to os.direct (`~/.rhachet/keyrack.direct.json`)
   - return grant

### 4.2 updated: vaultAdapterOsDirect

```ts
/**
 * .what = vault adapter for os-direct storage
 * .why = stores credentials in plaintext json file
 *
 * [~] extended: support entries with optional expiresAt
 */
interface DirectStoreEntry {
  value: string;
  expiresAt?: string;  // ISO8601 — if set, entry is ephemeral
}

// store format: Record<string, DirectStoreEntry>
// backwards compat: legacy string values auto-migrate to { value: str }
```

**expiry check in get:**

1. read entry from store
2. if `expiresAt` is set and past → delete entry, return null
3. else → return value

**mechanism-specific validation (via adapter):**

| mech | validation method |
|------|------------------|
| `REPLICA` | no validation (no expiry) |
| `GITHUB_APP` | `GET /user` with token → 401 = invalid |
| `AWS_SSO` | `aws sts get-caller-identity` → error = invalid |

---

## 5. mechanism adapters (updated)

### 5.1 interface update

```ts
import type { IsoTimeStamp } from 'iso-time';

/**
 * .what = interface for mechanism-specific translation
 * .why = adapter pattern enables support for different credential types
 *
 * [~] updated: validate accepts { source, cached } for unified validation
 * [~] updated: translate returns inline { value, expiresAt? }
 */
interface KeyrackGrantMechanismAdapter {
  validate: (input: { source?: string; cached?: string }) => { valid: boolean; reason?: string };
  translate: (input: { value: string }) => Promise<{ value: string; expiresAt?: IsoTimeStamp }>;
}
```

**validate semantics:**
- `{ source: value }` — validate source credential from vault (blocks long-lived tokens)
- `{ cached: value }` — validate cached ephemeral from os.direct (async check if still usable)

### 5.2 GITHUB_APP adapter

```ts
import type { IsoTimeStamp } from 'iso-time';
import { toIsoTimeStamp } from 'iso-time';

const mechAdapterGithubApp: KeyrackGrantMechanismAdapter = {
  validate: ({ source, cached }) => {
    // validate cached ephemeral (ghs_ token)
    if (cached) {
      if (!cached.startsWith('ghs_'))
        return { valid: false, reason: 'cached value must be ghs_ token' };
      // async validation would check via github api — but validate is sync
      // expiry is handled by os.direct; additional api check is optional
      return { valid: true };
    }

    // validate source credential
    if (source) {
      // block ghp_ pats (long-lived)
      if (source.startsWith('ghp_'))
        return { valid: false, reason: 'ghp_ classic pats are long-lived and forbidden' };
      // pass through ghs_ tokens (already ephemeral)
      if (source.startsWith('ghs_')) return { valid: true };
      // expect json blob with appId + privateKey
      try {
        const parsed = JSON.parse(source);
        if (!parsed.appId || !parsed.privateKey)
          return { valid: false, reason: 'missing appId or privateKey' };
        return { valid: true };
      } catch {
        return { valid: false, reason: 'invalid json' };
      }
    }

    return { valid: false, reason: 'no value to validate' };
  },
  translate: async ({ value }) => {
    // if already a ghs_ token, pass through with 55 min expiry
    if (value.startsWith('ghs_')) {
      const expiresAt = toIsoTimeStamp(new Date(Date.now() + 55 * 60 * 1000));
      return { value, expiresAt };
    }

    // parse json blob and mint installation token
    const { appId, privateKey } = JSON.parse(value);
    const token = await mintGithubAppInstallationToken({ appId, privateKey });
    return {
      value: token.token,
      expiresAt: token.expiresAt as IsoTimeStamp,
    };
  },
};
```

### 5.3 AWS_SSO adapter

```ts
import type { IsoTimeStamp } from 'iso-time';
import { toIsoTimeStamp } from 'iso-time';

const mechAdapterAwsSso: KeyrackGrantMechanismAdapter = {
  validate: ({ source, cached }) => {
    // validate cached ephemeral (sts creds json)
    if (cached) {
      try {
        const creds = JSON.parse(cached);
        if (!creds.accessKeyId || !creds.secretAccessKey || !creds.sessionToken)
          return { valid: false, reason: 'missing sts credential fields' };
        // expiry is handled by os.direct; additional sts check is optional
        return { valid: true };
      } catch {
        return { valid: false, reason: 'invalid json' };
      }
    }

    // validate source credential (profile name)
    if (source) {
      if (!source || source.length === 0)
        return { valid: false, reason: 'profile name required' };
      // block AKIA long-lived keys
      if (source.startsWith('AKIA'))
        return { valid: false, reason: 'aws long-lived access key forbidden' };
      return { valid: true };
    }

    return { valid: false, reason: 'no value to validate' };
  },
  translate: async ({ value: profileName }) => {
    // trigger sso login and get credentials
    const creds = await getAwsSsoCredentials({ profile: profileName });
    const expiresAt = (creds.expiration ?? toIsoTimeStamp(new Date(Date.now() + 55 * 60 * 1000))) as IsoTimeStamp;
    return {
      value: JSON.stringify({
        accessKeyId: creds.accessKeyId,
        secretAccessKey: creds.secretAccessKey,
        sessionToken: creds.sessionToken,
      }),
      expiresAt,
    };
  },
};
```

---

## 6. file structure

### 6.1 filediff treestruct

```
rhachet/
├── src/
│   ├── contract/cli/
│   │   └── [~] invokeKeyrack.ts           # add --unlock flag
│   ├── domain.operations/keyrack/
│   │   ├── [~] getKeyrackKeyGrant.ts      # os.direct precheck + --unlock flow
│   │   └── adapters/vaults/
│   │       └── [~] vaultAdapterOsDirect.ts  # extend for expiry support
│   └── domain.adapters/
│       └── mechs/
│           ├── [~] mechAdapterGithubApp.ts   # add validateEphemeral
│           └── [~] mechAdapterAwsSso.ts      # add validateEphemeral
├── bin/
│   └── [~] rhx                            # remove source pattern for unlock
└── accept.blackbox/cli/
    ├── [~] keyrack.vault.osSecure.acceptance.test.ts  # update for --unlock
    └── [+] keyrack.osdirect.cache.acceptance.test.ts  # test ephemeral flow

**legend:**
- `[+] create` — file to create
- `[~] update` — file to update
- `[-] delete` — file to delete
```

### 6.2 codepath treestruct

```
getKeyrackKeyGrant
├── [○] input validation
├── [+] precheck: os.envvar (retain)
├── [+] precheck: os.direct
│   ├── [+] vaultAdapterOsDirect.get(slug)
│   ├── [+] if found and not expired → return grant
│   └── [+] if expired → delete entry, continue
├── [○] lookupHostManifest
├── [○] resolveVaultAdapter
├── [~] unlockVaultIfNeeded
│   └── [~] only if --unlock flag set
├── [○] mechAdapter.translate
├── [+] cacheEphemeralGrantToOsDirect
│   ├── [+] vaultAdapterOsDirect.set(slug, value, expiresAt)
│   └── [+] only after successful translate when expiresAt is set
└── [○] returnGrant

**legend:**
- `[+]` create — codepath to create
- `[~]` update — codepath to update
- `[○]` retain — codepath to retain
- `[-]` delete — codepath to delete
```

---

## 7. test coverage

### 7.1 unit tests

| test file | coverage |
|-----------|----------|
| `validateEphemeralCache.test.ts` | valid entry returns true; expired entry returns false; validation error returns false |
| `cacheEphemeralGrant.test.ts` | writes to ephemeral.json; cleans expired entries; handles concurrent writes |
| `mechAdapterGithubApp.validateEphemeral.test.ts` | valid token returns true; 401 response returns false |
| `mechAdapterAwsSso.validateEphemeral.test.ts` | valid creds returns true; expired creds returns false |

### 7.2 integration tests

| test file | coverage |
|-----------|----------|
| `getKeyrackKeyGrant.integration.test.ts` | cache hit returns cached grant; cache miss returns locked; --unlock populates cache |
| `daoKeyrackEphemeralCache.integration.test.ts` | read/write/delete; expiry cleanup; concurrent access |

### 7.3 acceptance tests

```ts
describe('keyrack ephemeral caching', () => {
  given('[case1] key with cached ephemeral', () => {
    // setup: ephemeral.json has valid entry for SECURE_API_KEY
    when('[t0] get --key SECURE_API_KEY')
      then('returns grant from cache')
      then('does not prompt for passphrase')
  });

  given('[case2] key with expired ephemeral', () => {
    // setup: ephemeral.json has expired entry
    when('[t0] get --key SECURE_API_KEY')
      then('returns locked status')
      then('fix command includes --unlock')
  });

  given('[case3] key with no ephemeral', () => {
    when('[t0] get --key SECURE_API_KEY')
      then('returns locked status')
      then('fix command includes --unlock')
  });

  given('[case4] key with --unlock flag', () => {
    // setup: os.secure vault has the key
    when('[t0] get --key SECURE_API_KEY --unlock')
      then('prompts for passphrase')
      then('returns grant')
      then('caches ephemeral to ~/.rhachet/keyrack.ephemeral.json')
  });
});
```

---

## 8. cleanup: remove sourcing pattern

### 8.1 bin/rhx changes

```sh
# REMOVE: sourcing detection and passphrase export
# _rhx_is_sourced() { ... }
# if [ "$1" = "keyrack" ] && [ "$2" = "unlock" ]; then ... fi

# RETAIN: keyrack command short-circuit
if [ "$1" = "keyrack" ]; then
  shift
  exec "$SCRIPT_DIR/run.jit" keyrack "$@"
fi
```

### 8.2 unlock command behavior change

**before:**
```sh
rhx keyrack unlock
# prints: "to unlock, source this command: . rhx keyrack unlock --passphrase ..."
```

**after:**
```sh
rhx keyrack unlock
# prints: "unlock is now inline with get: rhx keyrack get --key KEY --unlock"
```

the standalone `unlock` command becomes a migration helper that points users to the new pattern.

---

## 9. security properties

| property | mechanism |
|----------|-----------|
| passphrase never in env | consumed and discarded during unlock; never exported |
| source credentials never cached | only ephemeral tokens written to ephemeral.json |
| ephemeral cache is machine-local | ~/.rhachet/keyrack.ephemeral.json per machine |
| ephemeral cache auto-expires | entries have expiresAt; validated before use |
| validation before grant | mechAdapter.validateEphemeral checks token still works |

---

## 10. migration path

1. **v1 users:** `rhx keyrack unlock` now prints deprecation message with new command
2. **bin/rhx:** sourcing pattern removed; simpler shell executable
3. **tests:** update acceptance tests to use `--unlock` flag instead of env var

---

## 11. summary

keyrack v2 eliminates the need for passphrase env vars by:

1. **inline unlock:** `rhx keyrack get --key KEY --unlock` prompts and resolves in one command
2. **ephemeral caching:** short-lived tokens cached to os.direct for reuse
3. **validation on access:** cached tokens validated before grant to catch expiry
4. **pit of success:** passphrase never touches the shell environment

> passphrase consumed and discarded. ephemeral tokens cached for reuse. never source again.
