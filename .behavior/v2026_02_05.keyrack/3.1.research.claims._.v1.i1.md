# research claims: credential & secret management for developer tools and CI/CD

> worldwide facts, assumptions, questions, and opinions from authoritative sources

---

## 1. long-lived secrets rank as one of the most dangerous NHI vulnerabilities

**[FACT]** "Long-lived Secrets refers to the use of sensitive NHIs such as API keys, tokens, encryption keys, and certificates with expiration dates that are too far in the future or that don't expire at all."

- source: [OWASP Non-Human Identities Top 10 — NHI7:2025 Long-Lived Secrets](https://owasp.org/www-project-non-human-identities-top-10/2025/7-long-lived-secrets/)

---

## 2. the majority of cloud organizations still rely on long-lived credentials despite known risks

**[FACT]** OWASP NHI7:2025 cites these statistics:
- "46% of AWS organizations use long-lived console credentials"
- "60% of keys across cloud providers exceed 1 year in age"
- "45% of NHI incidents stem from absent credential rotation practices"
- "51% of organizations lack formal processes for revoking long-lived API keys"
- "79% maintain access keys older than 90 days"

- source: [OWASP Non-Human Identities Top 10 — NHI7:2025 Long-Lived Secrets](https://owasp.org/www-project-non-human-identities-top-10/2025/7-long-lived-secrets/)

---

## 3. secrets sprawl accelerates, not decelerates

**[FACT]** "23.8 million new credentials detected on public GitHub in 2024 alone" — a "25% increase in leaked secrets year-over-year." Furthermore, "70% of secrets leaked in 2022 remain active today."

- source: [GitGuardian — State of Secrets Sprawl 2025](https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025-pr/)

---

## 4. even organizations with secrets managers still leak secrets

**[FACT]** "Organizations using secrets managers still showed a 5.1% secret leakage rate." Also, "35% of all private repositories scanned contained at least one plaintext secret."

- source: [GitGuardian — State of Secrets Sprawl 2025](https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025-pr/)

---

## 5. OWASP prescribes short-lived, scoped tokens and automated rotation

**[FACT]** OWASP Secrets Management Cheat Sheet defines four lifecycle phases — Creation, Rotation, Revocation, Expiration — and states: "You should regularly rotate secrets so that any stolen credentials will only work for a short time." It also recommends: "Implement Short-Lived Credentials" via cloud platforms' temporary credentials that auto-expire and refresh.

- source: [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)
- source: [OWASP NHI7:2025 Long-Lived Secrets](https://owasp.org/www-project-non-human-identities-top-10/2025/7-long-lived-secrets/)

---

## 6. NIST discourages routine rotation of human memorized secrets but NOT of machine credentials

**[FACT]** NIST SP 800-63B states: "Verifiers SHOULD NOT require memorized secrets to be changed arbitrarily (e.g., periodically). However, verifiers SHALL force a change if there is evidence of compromise of the authenticator."

This applies to human passwords. OWASP separately states for application/machine credentials: "User credentials are excluded from regular rotation. These should only be rotated if there is suspicion or evidence that they have been compromised, according to NIST recommendations." However, for non-human identities (API keys, tokens), automated rotation is explicitly recommended.

- source: [NIST SP 800-63B Section 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html)
- source: [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)

---

## 7. AWS explicitly recommends temporary credentials over long-lived access keys

**[FACT]** AWS IAM documentation states: "Temporary security credentials are short-term, as the name implies. They can be configured to last for anywhere from a few minutes to several hours. After the credentials expire, AWS no longer recognizes them or allows any kind of access from API requests made with them." And: "The temporary security credentials have a limited lifetime, so you do not have to update them or explicitly revoke them when they're no longer needed."

AWS best practice: "Use users only for humans, and roles for everything else (applications, automation, services). It's strongly recommended that you use temporary credentials provided by IAM roles and federated principals instead of the long-term credentials provided by IAM users and access keys."

- source: [AWS IAM — Temporary security credentials](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html)

---

## 8. stolen credentials are the number one cause of data breaches — GitHub acknowledges this

**[FACT]** GitHub's blog post on fine-grained PATs states: "Stolen and compromised credentials are the number one cause of data breaches across the industry." Classic PATs are specifically problematic because: "They have access to all of the repositories and organizations that the user could access, and are allowed to live forever."

- source: [GitHub Blog — fine-grained personal access tokens](https://github.blog/security/application-security/introducing-fine-grained-personal-access-tokens-for-github/)

---

## 9. GitHub moves toward deprecation of classic PATs

**[FACT]** "Fine-grained PATs are now enabled by default for all organizations on GitHub, unless that organization or enterprise explicitly disabled them during the preview." GitHub states: "After that, we'll continue to invest in this area with a goal of enabling organizations to eventually disable the use of PATs (Classic) for their resources."

No specific deprecation date has been announced, but the direction is unambiguous: fine-grained, expirable, scoped tokens are the intended replacement.

- source: [GitHub Changelog — Fine-grained PATs are now generally available (2025-03-18)](https://github.blog/changelog/2025-03-18-fine-grained-pats-are-now-generally-available/)
- source: [GitHub Blog — fine-grained personal access tokens](https://github.blog/security/application-security/introducing-fine-grained-personal-access-tokens-for-github/)

---

## 10. OIDC workload identity federation eliminates stored secrets in CI/CD

**[FACT]** GitHub Actions OIDC documentation states that workflows can access cloud resources "without having to store any credentials as long-lived GitHub secrets." Access tokens are time-limited, "available only to individual job runs, not permanently stored." Google Cloud confirms: "The best way to alleviate the challenges around service account keys is not to use them at all."

- source: [GitHub Docs — OIDC in cloud providers](https://docs.github.com/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers)
- source: [Google Cloud Blog — Enable keyless access to GCP with Workload Identity Federation](https://cloud.google.com/blog/products/identity-security/enable-keyless-access-to-gcp-with-workload-identity-federation)

---

## 11. HashiCorp defines dynamic secrets as the gold standard for machine credentials

**[OPIN]** HashiCorp states: "Static, long-lived credentials or 'secrets' (e.g. passwords, API keys, SSH keys) remain one of the most significant security vulnerabilities in modern infrastructures." Their prescription is dynamic secrets: "A short-lived (dynamic) secret is automatically revoked after just minutes or hours, leaving attackers with a tiny window — if any — to exploit stolen credentials."

They further argue: "This approach significantly narrows the window of vulnerability compared to long-lived static secrets, aligning well with secured-by-default practices and zero trust principles."

- source: [HashiCorp Blog — Why we need short-lived credentials and how to adopt them](https://www.hashicorp.com/en/blog/why-we-need-short-lived-credentials-and-how-to-adopt-them)
- source: [HashiCorp Developer — Understand static and dynamic secrets](https://developer.hashicorp.com/vault/tutorials/get-started/understand-static-dynamic-secrets)

---

## 12. secrets management must be easy to adopt or developers will circumvent it

**[FACT]** OWASP Secrets Management Cheat Sheet states: "For a secrets management solution to be effective, it must be easy for developers to adopt and use." It recommends "self-service workflows that enable developers to request and receive secrets with minimal manual intervention."

1Password corroborates: "73% of developers agree that the work or tools their security team typically requires them to use interfere with their productivity and innovation."

- source: [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)
- source: [1Password Blog — Secrets Management for Developers](https://1password.com/blog/secrets-management-for-developers)

---

## 13. half of devops practitioners cannot even count how many places their secrets reside

**[FACT]** "50% of individual contributors in IT or DevOps roles admit they're storing secrets in more locations than they can count." Also, "25% of companies reported secrets spread across 10+ storage locations."

- source: [1Password Blog — Secrets Management for Developers](https://1password.com/blog/secrets-management-for-developers)

---

## 14. .env file transfer is a known antipattern that slows onboard

**[SUMP]** The industry widely assumes that .env file transfer is an acceptable workflow despite known risks. Doppler case studies document the reality: "When a new developer would receive an .env file from the team, in many instances it was out of date or missing a secret or configuration, which would lead to blocking of the new developer." Teams report that proper secrets management reduced "onboard from two hours to two minutes."

The antipattern chain: "sharing .env files was not smooth, changes would occur but there was no central hub for these secrets, nor did users communicate the updates, and their solution was to send a new .env file via Slack with the assumption that everyone would update independently, with no way to verify if they did or did not until an incident."

- source: [Doppler Case Study — Hyper](https://www.doppler.com/case-studies/hyper)
- source: [Doppler Blog — Secrets setup guide](https://www.doppler.com/blog/doppler-secrets-setup-guide)

---

## 15. OWASP MCP Top 10 places token mismanagement as the #1 risk for AI agent systems

**[FACT]** OWASP MCP01:2025 states: "Tokens and credentials serve as the primary means of authentication and authorization between models, tools, and servers." Key mitigations include: "Issue short-lived, scoped tokens aligned with least privilege principles," "Require token renewal for every new MCP session," "Bind tokens to the specific agent, tool, or session context," and "Use ephemeral contexts for operations involving credentials."

- source: [OWASP MCP Top 10 — MCP01:2025 Token Mismanagement and Secret Exposure](https://owasp.org/www-project-mcp-top-10/2025/MCP01-2025-Token-Mismanagement-and-Secret-Exposure)

---

## 16. credential injection should happen at runtime, never at build time

**[OPIN]** Multiple authoritative sources converge: OWASP recommends three injection methods — mounted volumes, fetch from secret store via sidecar, and environment variables (only as a last resort since they are "generally accessible to all processes"). HashiCorp states: "Inject secrets at runtime, not build time." The universal guidance: "secrets themselves should never be hardcoded."

- source: [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)
- source: [HashiCorp — Secure CI/CD secrets](https://developer.hashicorp.com/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets)

---

## 17. the "fail closed" pattern is the security-correct default for credential systems

**[OPIN]** Security architecture consensus: "Fail-closed prioritizes security by denying access or stopping operation in the event of a failure, and is essential in scenarios where security is paramount." For credential systems, this means: if any credential is unavailable, the system should refuse to proceed rather than operate with partial credentials.

The counter-argument is availability: "For systems where availability is critical (e.g., e-commerce website), failing open may minimize disruptions." However, for credential gates, the industry consensus favors fail-closed because partial credential availability creates privilege escalation vectors.

- source: [AuthZed Blog — Failed Open and Fail Closed](https://authzed.com/blog/fail-open)
- source: [OpenText — Security Fundamentals Part 1: Fail Open vs. Fail Closed](https://community.opentext.com/cyberres/b/sws-22/posts/security-fundamentals-part-1-fail-open-vs-fail-closed)

---

## 18. should developer tools ever cache vault credentials?

**[KHUE]** OWASP MCP01:2025 warns that "Models or agents retain conversational memory that includes secrets" creates unintended credential repositories. The question for developer tools: should a keyrack tool ever cache a vault unlock token (e.g., 1Password session, OS keyrack unlock state) to reduce friction, or should it always require re-authentication? The tradeoff is between developer experience (fewer auth prompts) and security (smaller window if the machine is compromised). OWASP's position: "Use ephemeral contexts for operations involving credentials" and "Redact or sanitize inputs and outputs before logging."

- source: [OWASP MCP Top 10 — MCP01:2025](https://owasp.org/www-project-mcp-top-10/2025/MCP01-2025-Token-Mismanagement-and-Secret-Exposure)

---

## 19. is "all-or-none" credential mount an established pattern or a novel design?

**[KHUE]** No authoritative source uses the exact term "all-or-none credential mount" as an established pattern name. However, the principle is implicit in multiple security frameworks. The "fail closed" pattern (claim #17) implies it. OWASP's "least privilege" principle implies it (partial mounts could grant a superset of intended access). Kubernetes secret injection is atomic at the pod level (all secrets mounted or pod fails to start). The question: should rhachet/keyrack formalize and name this pattern, or align with prior terminology like "fail-closed credential resolution"?

- source: synthesis of [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html), Kubernetes pod security model, and fail-closed security architecture

---

## 20. what is the right credential lifetime for developer-faced short-lived tokens?

**[KHUE]** AWS allows "anywhere from a few minutes to several hours" with a default of 1 hour for STS sessions. GitHub App installation tokens last 1 hour. OWASP states the lifetime "could be from minutes...to years" dependent on function. The IDPro Body of Knowledge notes that "an access token should be limited in the duration of its validity — a good duration depends on the application and may be 5 to 15 minutes" for OAuth access tokens. For developer tools, the question is: what lifetime balances security (short window) with developer experience (not re-auth every 15 minutes for a full work session)?

- source: [AWS IAM — Temporary security credentials](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html)
- source: [IDPro Body of Knowledge — Token Lifetimes and Security in OAuth 2.0](https://bok.idpro.org/article/id/108/)

---

## 21. should environment variables be used for secret injection at all?

**[KHUE]** OWASP Secrets Management Cheat Sheet warns that environment variables are "generally accessible to all processes" and recommends them only "when other methods aren't feasible." However, environment variables are the de facto standard in CI/CD (GitHub Actions `env:`, Docker `--env`, etc.) and local development (`.env` files, `export`). The pragmatic question: given that most developer tools and CI systems consume credentials via environment variables, is it more secure to fight this convention or to work within it while an added resolution/sanitization layer runs first?

- source: [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)

---

## 22. credential rotation causes operational disruption that teams deprioritize

**[SUMP]** The industry assumes rotation is a burden that can be deferred. HashiCorp documents: "Canva realized it needed a better secrets automation and management system when teams had to stop work on development priorities in order to do rotations." This assumption leads to the reality in claim #2 (79% of organizations maintain keys older than 90 days). The rhachet/keyrack approach of automatic short-lived resolution sidesteps manual rotation entirely — the credential is fresh every time.

- source: [HashiCorp Blog — Why we need short-lived credentials](https://www.hashicorp.com/en/blog/why-we-need-short-lived-credentials-and-how-to-adopt-them)

---

## 23. GitHub Copilot usage correlates with higher secret leakage rates

**[FACT]** "GitHub Copilot usage increased by 27% between 2023 and 2024, with public repositories using Copilot having a 6.4% secret leakage rate."

**[KHUE]** As AI code assistants become prevalent, does the risk of AI agents that inadvertently commit or suggest credentials increase the urgency for credential firewalls that prevent raw secrets from ever reached the development environment?

- source: [GitGuardian — State of Secrets Sprawl 2025](https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025-pr/)

---

## 24. the gradual adoption path matters — rip-and-replace fails

**[OPIN]** HashiCorp recommends: "Rather than jumping straight to dynamic secrets across multiple clouds and on-prem resources, gradually funnel secrets into a single point of control — like a Vault deployment configured with a clear set of policies. Once you prove dynamic secrets work in one environment, replicate that success in others."

This aligns with rhachet/keyrack's vault flexibility (os.direct for convenience, os.secure for safety, 1password for teams) — developers can start with the easiest vault and graduate to more secure backends.

- source: [HashiCorp Blog — Why we need short-lived credentials](https://www.hashicorp.com/en/blog/why-we-need-short-lived-credentials-and-how-to-adopt-them)

---

## 25. DockerHub leaks reveal that secrets persist in image layers

**[FACT]** GitGuardian found that "98% of detected secrets were embedded exclusively in image layers" on DockerHub, with "over 7,000 valid AWS keys currently exposed." This demonstrates that secrets leak not just through code commits but through any artifact that captures environment state.

- source: [GitGuardian — State of Secrets Sprawl 2025](https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025-pr/)

---

## summary of claim types

| label | count | description |
|-------|-------|-------------|
| [FACT] | 14 | indisputable, immutable truths from authoritative sources |
| [OPIN] | 4 | subjective opinions/recommendations we should consider |
| [KHUE] | 5 | open questions we should consider for rhachet/keyrack design |
| [SUMP] | 2 | assumptions the industry has made, explicitly or implicitly |

---

## sources index

1. [OWASP NHI7:2025 Long-Lived Secrets](https://owasp.org/www-project-non-human-identities-top-10/2025/7-long-lived-secrets/)
2. [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)
3. [OWASP MCP01:2025 Token Mismanagement and Secret Exposure](https://owasp.org/www-project-mcp-top-10/2025/MCP01-2025-Token-Mismanagement-and-Secret-Exposure)
4. [NIST SP 800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html)
5. [AWS IAM — Temporary security credentials](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html)
6. [GitHub Blog — fine-grained personal access tokens](https://github.blog/security/application-security/introducing-fine-grained-personal-access-tokens-for-github/)
7. [GitHub Changelog — Fine-grained PATs GA](https://github.blog/changelog/2025-03-18-fine-grained-pats-are-now-generally-available/)
8. [GitHub Docs — OIDC in cloud providers](https://docs.github.com/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers)
9. [Google Cloud Blog — Workload Identity Federation](https://cloud.google.com/blog/products/identity-security/enable-keyless-access-to-gcp-with-workload-identity-federation)
10. [HashiCorp Blog — Why we need short-lived credentials](https://www.hashicorp.com/en/blog/why-we-need-short-lived-credentials-and-how-to-adopt-them)
11. [HashiCorp Developer — Understand static and dynamic secrets](https://developer.hashicorp.com/vault/tutorials/get-started/understand-static-dynamic-secrets)
12. [1Password Blog — Secrets Management for Developers](https://1password.com/blog/secrets-management-for-developers)
13. [GitGuardian — State of Secrets Sprawl 2025](https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025-pr/)
14. [IDPro Body of Knowledge — Token Lifetimes in OAuth 2.0](https://bok.idpro.org/article/id/108/)
15. [Doppler Case Study — Hyper](https://www.doppler.com/case-studies/hyper)
16. [AuthZed Blog — Failed Open and Fail Closed](https://authzed.com/blog/fail-open)
17. [OpenText — Fail Open vs. Fail Closed](https://community.opentext.com/cyberres/b/sws-22/posts/security-fundamentals-part-1-fail-open-vs-fail-closed)
