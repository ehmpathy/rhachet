# blueprint: keyrack get --output export

## overview

1. add `--output words|json|export` flag to `keyrack get` (replaces `--json`)
2. implement export format: `export KEY='value'` statements
3. auto-detect sourced: when `bin/rhx` detects it's being sourced, auto-supply `--output export`
4. remove sourceable unlock flow from `bin/rhx` (replaced by auto-detect)

## filediff

```
src/
â”œâ”€â”€ contract/cli/
â”‚   â””â”€â”€ [~] invokeKeyrack.ts
â”‚       â”œâ”€â”€ [~] keyrack get: replace --json with --output
â”‚       â”œâ”€â”€ [+] export format output handler
â”‚       â””â”€â”€ [~] words format: extract to named handler
â”‚
bin/
â””â”€â”€ [~] rhx
    â””â”€â”€ [-] remove sourceable unlock flow (lines 10-80)
```

## implementation

### 1. replace --json with --output

```ts
// before
.option('--json', 'output as json (robot mode)')

// after (no backwards compat, --json is gone)
.option('--output <format>', 'output format: words | json | export (default: words)')
```

### 2. output format handler

```ts
// in keyrack get action
const format = opts.output ?? 'words';

if (format === 'json') {
  console.log(JSON.stringify(attempts, null, 2));
} else if (format === 'export') {
  // only emit granted keys
  for (const attempt of attempts) {
    if (attempt.status === 'granted') {
      const keyName = asKeyrackKeyName({ slug: attempt.grant.slug });
      const value = escapeForShell(attempt.grant.value);
      console.log(`export ${keyName}='${value}'`);
    }
  }
} else {
  // words format (default) - current implementation
  // ...
}
```

### 3. shell escape helper

```ts
/**
 * .what = escape a value for safe use in single-quoted shell string
 * .why = prevent shell injection in export statements
 */
const escapeForShell = (value: string): string => {
  // single quotes: replace ' with '\''
  return value.replace(/'/g, "'\\''");
};
```

### 4. auto-detect sourced + remove old unlock flow from bin/rhx

replace the old sourceable unlock flow with simpler auto-detect for `keyrack get`:

```sh
#!/bin/sh
# .what = proxy that prepends `run --skill` and delegates to rhachet
# .why = shorthand for `rhachet run --skill`

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# detect if being sourced
# when sourced, $0 is the shell (bash, zsh, sh) not the executable path
_rhx_is_sourced() {
  case "$0" in
    *rhx*) return 1 ;;  # executed
    *) return 0 ;;      # sourced
  esac
}

# short-circuit keyrack commands
if [ "$1" = "keyrack" ]; then
  shift

  # keyrack get: auto-supply --output export when sourced
  if [ "$1" = "get" ] && _rhx_is_sourced; then
    shift
    # source the output (eval export statements)
    eval "$("$SCRIPT_DIR/run.jit" keyrack get --output export "$@")"
    return 0 2>/dev/null || exit 0
  fi

  exec "$SCRIPT_DIR/run.jit" keyrack "$@"
fi

# short-circuit upgrade command (top-level rhachet command, not a skill)
if [ "$1" = "upgrade" ]; then
  shift
  exec "$SCRIPT_DIR/run.jit" upgrade "$@"
fi

# default: proxy to run --skill
exec "$SCRIPT_DIR/run" run --skill "$@"
```

key changes:
- `keyrack get` when sourced â†’ auto `--output export` + eval
- `keyrack unlock` no longer needs special sourceable handling (passphrase no longer exported)
- simpler: no KEYRACK_PASSPHRASE export, no passphrase arg parsing

## contracts

### keyrack get --output export (single key)

```sh
$ rhx keyrack get --key AWS_PROFILE --env test --output export
export AWS_PROFILE='ehmpathy.dev'
```

### keyrack get --output export (repo)

```sh
$ rhx keyrack get --for repo --env test --output export
export AWS_PROFILE='ehmpathy.dev'
export OPENAI_API_KEY='sk-xxx'
```

### keyrack get --output export (with locked key)

```sh
$ rhx keyrack get --for repo --env test --output export
# only granted keys output, locked/blocked/absent silently skipped
export OPENAI_API_KEY='sk-xxx'
# AWS_PROFILE was locked, no output for it
```

### keyrack get --output json (unchanged)

```sh
$ rhx keyrack get --key AWS_PROFILE --env test --output json
{
  "status": "granted",
  "grant": {
    "slug": "ehmpathy.test.AWS_PROFILE",
    "keyName": "AWS_PROFILE",
    "value": "ehmpathy.dev",
    ...
  }
}
```

### keyrack get (default words, unchanged)

```sh
$ rhx keyrack get --key AWS_PROFILE --env test
ğŸ” rhachet/keyrack
   â””â”€ ehmpathy.test.AWS_PROFILE
      â”œâ”€ vault: aws.iam.sso
      â”œâ”€ mech: EPHEMERAL_VIA_AWS_SSO
      â””â”€ status: granted ğŸ”‘
```

## test cases

### unit tests

```ts
given('[case1] keyrack get --output export')
  when('[t0] single granted key')
    then('outputs: export KEY=\'value\'')

  when('[t1] value contains single quotes')
    then('escapes as: export KEY=\'val'\\''ue\'')

  when('[t2] key is locked')
    then('outputs empty (no export statement)')

  when('[t3] multiple keys, some granted some locked')
    then('outputs only granted keys')

given('[case2] keyrack get --output json')
  when('[t0] outputs JSON object')
    then('outputs JSON object')

given('[case3] keyrack get (no --output)')
  when('[t0] default format')
    then('outputs words format')

given('[case4] keyrack get when sourced')
  when('[t0] `. rhx keyrack get --for repo --env test`')
    then('auto-supplies --output export')
    then('evals export statements into parent shell')
    then('env vars are set in caller shell')
```

## verification

```sh
# test export format
rhx keyrack get --for repo --env test --output export

# test eval integration
eval "$(rhx keyrack get --for repo --env test --output export)"
echo $AWS_PROFILE

# test json format
rhx keyrack get --key AWS_PROFILE --env test --output json

# test words default
rhx keyrack get --key AWS_PROFILE --env test

# test auto-export when sourced
. rhx keyrack get --for repo --env test
echo $AWS_PROFILE
```
