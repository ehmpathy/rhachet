# zoomin: will `. rhx keyrack get ...` actually export vars to parent shell?

## the question

when you run `. rhx keyrack get --for repo --env test`, will the exported env vars actually land in the user's shell?

## answer: yes

### why it works

1. `. rhx` sources bin/rhx → runs in **current shell** (not subshell)
2. `$("$SCRIPT_DIR/run.jit" keyrack get --output export ...)` → subshell captures stdout
3. `rhachet completion --setup"export FOO='bar'"` → runs in **current shell**
4. `FOO` is now set in user's shell ✓

the key: `eval` runs in the current shell, so export statements it executes ARE visible.

### sources

- [How To Export A Bash Variable To Parent Shell](https://marketsplash.com/tutorials/bash-shell/how-to-export-a-bash-variable-to-parent-shell/)
- [How to Use rhachet completion --setupin Linux](https://www.howtogeek.com/818088/bash-eval/)

> "because rhachet completion --setupruns in the current shell, the variables set by rhachet completion --setupare usable from the shell that launched the rhachet completion --setupcommand."

---

## why source is required (the fundamental limitation)

a child process **cannot modify its parent's environment**. this is a fundamental unix constraint.

```
parent shell
├── spawns child process (subshell)
│   ├── child can read parent's exported vars
│   ├── child can modify its OWN env
│   └── child CANNOT modify parent's env  ← fundamental limitation
└── parent continues unchanged
```

when you run `rhx keyrack get --output export` (executed, not sourced):
1. your shell spawns a child process
2. the child outputs `export FOO='bar'`
3. the child exits
4. your shell's environment is **unchanged**

the output goes to stdout, but there's no mechanism for a child to reach back and modify the parent.

**solution**: source the executable so it runs in the current shell (not a subshell).

```sh
. rhx keyrack get --for repo --env test
# bin/rhx runs in YOUR shell
# rhachet completion --setupinside bin/rhx runs in YOUR shell
# exports land in YOUR shell ✓
```

---

## why bin/rhx uses rhachet completion --setupinstead of source

bin/rhx uses `eval` to execute the export statements:

```sh
rhachet completion --setup"$("$SCRIPT_DIR/run.jit" keyrack get --output export "$@")"
```

why not `source`?

### source expects a file path

```sh
source /path/to/file.sh    # ✓ works
source "export FOO='bar'"  # ✗ not a file path
```

`source` (and its synonym `.`) read and execute commands **from a file**. they do not accept a string of commands.

### rhachet completion --setuptakes a string

```sh
rhachet completion --setup"export FOO='bar'"    # ✓ executes the string as a command
```

`eval` constructs a command from its arguments and executes it in the current shell.

### process substitution is not POSIX

bash has process substitution:

```sh
source <(echo "export FOO='bar'")  # bash-only, not POSIX
```

but bin/rhx uses `#!/bin/sh` for POSIX portability. process substitution (`<(...)`) is not available.

### the pattern

```sh
rhachet completion --setup"$(command-that-outputs-shell-code)"
```

this is the standard POSIX pattern for:
1. run a command in a subshell
2. capture its stdout (the shell code)
3. execute that shell code in the current shell

---

## appendix: source detection

## current detection method

bin/rhx uses `$0` pattern matching:

```sh
_rhx_is_sourced() {
  case "$0" in
    *rhx*) return 1 ;;  # executed: $0 = /path/to/rhx
    *) return 0 ;;      # sourced: $0 = bash, zsh, -bash, etc.
  esac
}
```

## how it works

| invocation | `$0` value | detection |
|------------|-----------|-----------|
| `./bin/rhx keyrack get` | `/path/to/bin/rhx` | executed (contains "rhx") |
| `rhx keyrack get` | `/usr/local/bin/rhx` | executed (contains "rhx") |
| `. rhx keyrack get` | `bash` or `-bash` | sourced (no "rhx") |
| `source rhx keyrack get` | `zsh` | sourced (no "rhx") |

## verified: this works

the `$0` method is documented and used in practice:
- [Nick Janetakis: Detect If a Shell Executable Is Executed or Sourced](https://nickjanetakis.com/blog/detect-if-a-shell-script-is-being-executed-or-sourced)
- [TecAdmin: Identify a Bash Executable is Sourced or Executed](https://tecadmin.net/how-to-identify-a-bash-script-is-sourced-or-executed-directly/)

when sourced, `$0` refers to the current shell (e.g., `-bash`, `/bin/bash`, `zsh`), not the sourced file.

## alternative: return-based detection

a more portable POSIX method uses `return` at top level:

```sh
(return 0 2>/dev/null) && sourced=1 || sourced=0
```

- [W3Tutorials: How to Detect If Executable Is Sourced](https://www.w3tutorials.net/blog/how-to-detect-if-a-script-is-being-sourced/)

this works because `return` is only valid in a sourced context (not in a subshell/executed context).

## edge cases

### symlinks with different names

if someone creates a symlink with a name that doesn't contain "rhx":

```sh
ln -s /path/to/rhx /usr/local/bin/myalias
. myalias keyrack get  # $0 = bash, works ✓
myalias keyrack get    # $0 = /usr/local/bin/myalias, no "rhx", FALSELY detected as sourced ✗
```

**mitigation**: the `return 0` at end of sourced path would fail if executed (no function to return from), causing a fallback to exit 0. but this is still fragile.

### shell names containing "rhx"

if someone's shell path contains "rhx" (extremely unlikely):

```sh
# hypothetical: /opt/rhx-shell/bin/bash
. rhx keyrack get  # $0 = /opt/rhx-shell/bin/bash, contains "rhx", FALSELY detected as executed ✗
```

**mitigation**: this is astronomically unlikely.

## recommendation

the current `$0` pattern matching is good enough:

1. symlink edge case is unlikely (who renames rhx?)
2. shell-name edge case is astronomically unlikely
3. simpler than return-based detection
4. already tested and works

if robustness is critical, switch to return-based:

```sh
_rhx_is_sourced() {
  # return at top-level only valid when sourced
  (return 0 2>/dev/null)
}
```

but the current method works for the expected usage: `. rhx keyrack get ...`

## verdict

✓ **yes, it works.** the `. rhx keyrack get --for repo --env test` pattern will correctly detect sourced and rhachet completion --setupexports.
