# vision: aws sso support for keyrack

## the outcome world

### before

aws credentials are a special case. robots have to know about `AWS_PROFILE` envvars, sso sessions, and credential expiration. this breaks the uniform firewall model.

```
human: "run the integration tests"
robot: *checks for AWS_ACCESS_KEY_ID in env*
robot: *checks for AWS_PROFILE in env*
robot: *tries to run aws command*
robot: âœ— error: sso session expired
robot: "please run `aws sso login --profile ehmpathy.dev`"
human: *runs command, approves in browser*
human: "ok try again"
robot: *tries again, works*
```

the problem:
- robot has to know about aws sso specifics
- no uniform credential firewall
- error handling is ad-hoc
- no visibility into credential health before failure

### after

aws credentials flow through keyrack like all other keys. robot runs test:integration, test:integration uses keyrack, keyrack handles it.

```
human: *runs `rhx keyrack unlock` (validates and refreshes sso session)*
human: "run the integration tests"
robot: *runs `npm run test:integration`*
  â””â”€ test:integration: *uses keyrack directly, gets AWS_PROFILE*
       â””â”€ keyrack: âœ“ session valid, granted
  â””â”€ test:integration: *runs with AWS_PROFILE=ehmpathy.dev*
```

the robot doesn't even know keyrack is involved. test:integration uses keyrack directly â€” no middlemen.

or when session is expired:

```
human: "run the integration tests"
robot: *runs `npm run test:integration`*
  â””â”€ test:integration: *uses keyrack, requests AWS_PROFILE*
       â””â”€ keyrack: âœ— sso session expired, unlock required
  â””â”€ test:integration: *fails with unlock-required error*
robot: "keyrack unlock required for AWS_PROFILE. please run `rhx keyrack unlock`"
human: *consciously runs `rhx keyrack unlock`*
  â””â”€ keyrack: *validates sso session, triggers login if expired*
human: *approves in browser with full awareness*
  â””â”€ keyrack: âœ“ unlocked
robot: *retries, now works*
```

the robot only learns about keyrack when unlock is needed. otherwise it's invisible.

critical: unlock is always a conscious human action via `rhx keyrack unlock`. no surprise browser popups.

### the "aha" moment

> "wait, i just answered a few questions and keyrack set up my entire aws config? i didn't have to google anything about sso_start_url or profile sections?"

> "and the robot just asked for AWS_PROFILE and keyrack handled it? same as GITHUB_TOKEN? same as OPENAI_API_KEY? it's all just... keys?"

the value clicks twice:
1. **setup is guided** â€” keyrack asks questions, writes config, validates â€” user never touches config files
2. **usage is uniform** â€” all credentials flow through the same firewall, robot never special-cases

## user experience

### usecase 1: human sets up AWS_PROFILE

keyrack owns the full setup guidance. the user doesn't need to know aws cli config details â€” keyrack walks them through it.

```sh
rhx keyrack set AWS_PROFILE --mech EPHEMERAL_VIA_AWS_SSO

# keyrack guides the user:
# 1. "which aws sso start url?" â†’ user enters https://acme.awsapps.com/start
# 2. "which region?" â†’ user selects us-east-1
# 3. *triggers browser auth* â†’ user approves in browser
# 4. *keyrack calls `aws sso list-accounts` to enumerate available accounts*
# 5. "which account?" â†’ keyrack lists available accounts, user picks
# 6. *keyrack calls `aws sso list-account-roles` to enumerate roles*
# 7. "which role?" â†’ keyrack lists available roles, user picks
# 8. "what should we call this profile?" â†’ user enters "acme.prod"
#
# keyrack then:
# - writes ~/.aws/config with best-practice settings
# - stores the profile name in keyrack
# - validates the setup works via `aws sts get-caller-identity`
```

note: keyrack must authenticate before it can enumerate accounts/roles. the [ListAccountRoles](https://docs.aws.amazon.com/singlesignon/latest/PortalAPIReference/API_ListAccountRoles.html) and [list-accounts](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/sso/list-accounts.html) apis require an access token obtained from browser auth.

the user never touches `~/.aws/config` directly. keyrack handles:
- config file structure
- sso session settings
- credential process setup
- profile naming conventions

```sh
# what keyrack writes to ~/.aws/config
[profile acme.prod]
sso_start_url = https://acme.awsapps.com/start
sso_region = us-east-1
sso_account_id = 123456789012
sso_role_name = AdministratorAccess
region = us-east-1
output = json
```

the user just answers questions. keyrack does the rest with best practices built in.

### usecase 2: human unlocks keyrack

```sh
rhx keyrack unlock

# keyrack:
# 1. unlocks os.secure vault (passphrase)
# 2. for each EPHEMERAL_VIA_AWS_SSO key:
#    - validates sso session via `aws sts get-caller-identity`
#    - if expired, triggers `aws sso login --profile $profile`
# 3. human approves in browser (consciously, they initiated unlock)
# 4. keyrack caches validated grants in daemon
```

unlock is always explicit. human runs the command, human knows what happens next.

### usecase 3: test:integration uses keyrack directly (robot unaware)

```ts
// inside npm run test:integration â€” robot never sees this
// note: slugs are env-scoped as $org.$env.$key (e.g., 'acme.prod.AWS_PROFILE')
const grants = await getKeyrackKeyGrant({ for: { repo: true }, env: 'test' }, context);
// or for a single key:
// const grant = await getKeyrackKeyGrant({ for: { key: 'acme.test.AWS_PROFILE' } }, context);

// if unlocked and session valid:
// - grant.key.secret = "ehmpathy.dev" (the profile name)
// - AWS_PROFILE set in env
// - test:integration runs

// if not unlocked or session expired:
// - throws KeyrackUnlockRequiredError
// - test:integration fails
// - robot sees error, tells human to unlock
```

the robot runs `npm run test:integration`. test:integration uses keyrack directly â€” no middlemen. robot only learns about keyrack when unlock is needed.

### usecase 4: session expires mid-work

```
robot: *runs `npm run test:integration`*
  â””â”€ test:integration: *uses keyrack, requests AWS_PROFILE*
       â””â”€ keyrack: âœ— session expired since last unlock
  â””â”€ test:integration: *fails with unlock-required error*
robot: "keyrack reports AWS_PROFILE session expired. please run `rhx keyrack unlock`"
*robot blocks, waits*
human: *consciously runs `rhx keyrack unlock`*
human: *approves browser prompt with awareness*
robot: *retries, continues*
```

the robot only knows about keyrack when test:integration fails with unlock error. otherwise it's invisible.

future enhancement: keyrack could push notifications to human's device when unlock is needed â€” but never auto-trigger.

### timeline

```
t0: human
    â””â”€ sets up AWS_PROFILE in keyrack

t1: human
    â””â”€ runs `rhx keyrack unlock`
         â””â”€ keyrack: validates sso session (triggers login if expired)

t2: human
    â””â”€ approves browser prompt (they initiated this)
         â””â”€ keyrack: caches grants in daemon

t3: robot
    â””â”€ runs `npm run test:integration`
         â””â”€ test:integration: uses keyrack transparently
              â””â”€ keyrack: âœ“ session valid, granted

...

tN: sso session expires

tN+1: robot
      â””â”€ runs `npm run test:integration`
           â””â”€ test:integration: uses keyrack
                â””â”€ keyrack: âœ— unlock-required
           â””â”€ test:integration: fails
      â””â”€ tells human "please unlock"

tN+2: human
      â””â”€ consciously runs `rhx keyrack unlock`
```

## mental model

### how users would describe this

> "keyrack handles my aws profile the same way it handles all keys. i unlock once, robot works until things expire, then i unlock again."

> "the robot doesn't even know keyrack exists. the tools just work. only when something expires does the robot ask me to unlock."

### the uniform model

| key | mechanism | what's stored | what's granted |
|-----|-----------|---------------|----------------|
| OPENAI_API_KEY | PERMANENT_VIA_REPLICA | api key | api key |
| GITHUB_TOKEN | EPHEMERAL_VIA_GITHUB_APP | app credentials | installation token |
| AWS_PROFILE | EPHEMERAL_VIA_AWS_SSO | profile name | profile name (+ validation) |

all keys flow through the same firewall:
1. robot runs command
2. command uses keyrack
3. keyrack checks if unlocked
4. keyrack validates grant is still valid
5. keyrack returns grant (or blocks)

### term map

| user says | keyrack term |
|-----------|--------------|
| "my aws profile" | KeyrackKeySpec with mech=EPHEMERAL_VIA_AWS_SSO |
| "unlock my aws creds" | unlock vault + validate sso session |
| "session expired" | grant validation failed |
| "the profile name" | reference-protection key |

## evaluation

### how well does it solve the goals?

| goal | solution | stars |
|------|----------|-------|
| uniform credential firewall | âœ“ AWS_PROFILE is just another key | â­â­â­â­â­ |
| robot is unaware of details | âœ“ same `getKeyrackKeyGrant` call | â­â­â­â­â­ |
| human controls unlock lifecycle | âœ“ explicit `rhx keyrack unlock` | â­â­â­â­â­ |
| no surprise popups | âœ“ unlock is always conscious action | â­â­â­â­â­ |
| proactive session validation | âœ“ validates before grant | â­â­â­â­â­ |

### pros

1. **guided setup** â€” user answers questions, keyrack writes config with best practices
2. **uniform model** â€” aws is not special-cased in robot code
3. **human-controlled unlock** â€” no surprise browser popups, ever
4. **conscious approval** â€” human knows what they're approving
5. **proactive validation** â€” knows if session is valid before robot tries to use it
6. **reference protection** â€” no secrets stored, just profile name
7. **zero config knowledge required** â€” user never needs to learn aws cli config structure

### cons

1. **human must unlock** â€” robot blocks until human intervenes (this is a feature, not a bug)

### dependencies

keyrack guides users through dependency installation when needed:

```sh
rhx keyrack set AWS_PROFILE --mech EPHEMERAL_VIA_AWS_SSO

# if aws cli not installed:
# keyrack: "aws cli is required for EPHEMERAL_VIA_AWS_SSO"
# keyrack: "install via: brew install awscli (macos) or see https://aws.amazon.com/cli/"
# keyrack: *waits for user to install*
# keyrack: *detects aws cli now available*
# keyrack: "âœ“ aws cli detected, setup proceeds..."
```

no silent failures â€” keyrack detects absent dependencies and walks users through installation.

### the new grade: 'reference'

`AWS_PROFILE` value is not a secret â€” it's a **reference** to external credential management.

```ts
// security hierarchy (most secure first)
protection: 'reference' | 'encrypted' | 'plaintext';
```

`reference` is the **most secure** protection level:
- no secret ever touches keyrack storage
- only a pointer (e.g., "ehmpathy.dev") is stored
- even if keyrack is compromised, no secrets leak

| protection | what's stored | compromise impact |
|------------|---------------|-------------------|
| `reference` | pointer only | profile name leaked, no secrets |
| `encrypted` | encrypted secret | secrets leaked if decryption key compromised |
| `plaintext` | raw secret | secrets leaked immediately |

### session validation on grant

the key difference for EPHEMERAL_VIA_AWS_SSO: the mechanism adapter must **validate** the session before grant.

```ts
mechAdapterAwsSso: {
  validate: async ({ source }) => {
    // check if sso session is still valid
    try {
      await exec(`aws sts get-caller-identity --profile "${source}"`);
      return { valid: true };
    } catch {
      return { valid: false, reason: 'sso session expired' };
    }
  },
  // ... translate for cached credentials
}
```

if validation fails, keyrack blocks the grant and signals unlock required. it does **not** try to trigger login.

## design decisions

1. **unlock flow** â€” `rhx keyrack unlock` handles EPHEMERAL_VIA_AWS_SSO specially: validate session, trigger `aws sso login` if expired. only during explicit unlock, never during grant.

2. **profile scope** â€” each profile is a separate KeyrackKeySpec. unlock validates/refreshes only those declared in the repo's `keyrack.yml`.

3. **session expiration** â€” keyrack reads `expiresAt` from `~/.aws/sso/cache/<hash>.json` after login. token duration is fixed at 8 hours per [CreateToken API](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html).

4. **ci scope** â€” ci uses `EPHEMERAL_VIA_AWS_OIDC` (separate mechanism). `EPHEMERAL_VIA_AWS_SSO` is for human-initiated local dev only.

5. **grade hierarchy** â€” `reference > encrypted > plaintext`. degradation (e.g., `reference` â†’ `encrypted`) is blocked.

## summary

when complete, aws credentials flow through keyrack like all other keys:

```sh
# human sets up â€” keyrack guides them step by step
rhx keyrack set AWS_PROFILE --mech EPHEMERAL_VIA_AWS_SSO
# â†’ "which sso start url?"
# â†’ "which region?"
# â†’ *browser auth*
# â†’ "which account?" (lists via aws sso list-accounts)
# â†’ "which role?" (lists via aws sso list-account-roles)
# â†’ keyrack writes ~/.aws/config, stores profile name, validates

# human unlocks (validates sso session, triggers login if needed)
rhx keyrack unlock

# robot runs test:integration â€” same as any key
# note: slugs are env-scoped as $org.$env.$key (e.g., 'acme.test.AWS_PROFILE')
robot: *runs `npm run test:integration`*
  â””â”€ test:integration: await getKeyrackKeyGrant({ for: { repo: true }, env: 'test' }, context)
       â””â”€ keyrack: âœ“ granted
```

three things make this work:
1. **guided setup** â€” user answers questions, keyrack does the rest
2. **uniform firewall** â€” robot doesn't know aws sso exists, it's all just keys
3. **conscious unlock** â€” always explicit human action, never automatic

ðŸ”‘
