# blueprint: aws sso support for keyrack

## overview

implement aws sso support via:
1. new protection level `'reference'` for profile names (not secrets)
2. new vault `'aws.iam.sso'` for sso profile storage and unlock flow
3. update `mechAdapterAwsSso` to validate session (not trigger login) at grant time
4. grade hierarchy: `reference > encrypted > plaintext`
5. **`keyrack set` auto-updates repo manifest** — no manual edits to `.agent/keyrack.yml` required

note: keyrack now supports env-scoped keys. slugs follow `$org.$env.$key` format (e.g., `acme.prod.AWS_PROFILE`). this blueprint is compatible — vault adapters store by full slug, mechanism adapters operate on profile name values.

## core ux requirement: zero manual edits

when a user runs:
```sh
rhx keyrack set --key AWS_PROFILE --env test --vault aws.iam.sso
```

keyrack must automatically:
1. add `AWS_PROFILE` to `env.test` in `.agent/keyrack.yml` (repo manifest) if not present
2. add the host entry to `~/.rhachet/keyrack.hosts.yml` (host manifest)
3. store any vault-specific data (e.g., profile name in `~/.rhachet/keyrack.aws-iam-sso.json`)

the user should **never** need to manually edit `.agent/keyrack.yml`.

## filediff treestruct

```
src/
├── domain.objects/keyrack/
│   ├── [~] KeyrackKeyGrade.ts              # add 'reference' to protection union
│   └── [~] KeyrackHostVault.ts             # add 'aws.iam.sso' to vault union
│
├── domain.operations/keyrack/
│   ├── [~] setKeyrackKeyHost.ts            # auto-update repo manifest on set
│   ├── [+] upsertKeyrackRepoManifestKey.ts # add key to repo manifest env
│   ├── adapters/
│   │   ├── mechanisms/
│   │   │   ├── [~] mechAdapterAwsSso.ts    # validate session, not trigger login
│   │   │   └── [+] mechAdapterAwsSso.test.ts # unit tests for validation
│   │   └── vaults/
│   │       ├── [+] vaultAdapterAwsIamSso.ts    # new vault for sso unlock
│   │       ├── [+] vaultAdapterAwsIamSso.test.ts
│   │       └── [~] index.ts                    # export new adapter
│   │
│   ├── grades/
│   │   ├── [~] inferKeyGrade.ts            # handle aws.iam.sso -> reference
│   │   ├── [~] inferKeyGrade.test.ts       # add reference tests
│   │   ├── [~] detectKeyGradeChange.ts     # add reference protection rank
│   │   └── [~] assertKeyGradeProtected.test.ts # add reference degradation tests
│   │
│   └── [~] genKeyrackGrantContext.ts       # wire up aws.iam.sso adapter
│
└── .test/
    └── assets/
        ├── [~] genMockMechAdapter.ts       # support expiresAt for ephemeral
        └── [+] genMockAwsCliExecutor.ts    # mock aws cli for tests
```

## codepath treestruct

### domain.objects

```
KeyrackKeyGrade
├── [○] protection
│   ├── [○] 'encrypted'
│   ├── [○] 'plaintext'
│   └── [+] 'reference'         # new: profile names, not secrets
└── [○] duration
    ├── [○] 'permanent'
    ├── [○] 'ephemeral'
    └── [○] 'transient'

KeyrackHostVault
├── [○] 'os.envvar'
├── [○] 'os.direct'
├── [○] 'os.secure'
├── [○] 'os.daemon'
├── [○] '1password'
└── [+] 'aws.iam.sso'           # new: sso profile storage
```

### domain.operations/adapters/mechanisms/mechAdapterAwsSso

```
mechAdapterAwsSso
├── [○] isValidProfileName()            # retain: validate profile format
├── [○] isValidCachedCredentials()      # retain: validate json creds
├── [~] validate()
│   ├── [○] if cached: validate json format
│   ├── [○] if source: validate profile name
│   └── [+] if source: validate session via sts get-caller-identity
│       ├── [+] exec: aws sts get-caller-identity --profile $name
│       ├── [+] if success: { valid: true }
│       └── [+] if fail: { valid: false, reason: 'sso session expired' }
└── [~] translate()
    ├── [-] remove: aws sso login trigger      # move to vault unlock
    ├── [○] exec: aws configure export-credentials
    └── [○] return: { value: json, expiresAt }
```

### domain.operations/adapters/vaults/vaultAdapterAwsIamSso (new)

```
vaultAdapterAwsIamSso [+]
├── [+] unlock()
│   ├── [+] for each profile in vault storage:
│   │   ├── [+] validate session via aws sts get-caller-identity
│   │   └── [+] if expired: trigger aws sso login --sso-session $ssoSessionName
│   └── [+] return after all profiles refreshed
├── [+] isUnlocked()
│   └── [+] validate all profiles via sts get-caller-identity
├── [+] get({ slug })
│   └── [+] read profile name from storage file
├── [+] set({ slug, value })
│   └── [+] write profile name to storage file
└── [+] del({ slug })
    └── [+] remove profile name from storage file

storage file: ~/.rhachet/keyrack.aws-iam-sso.json
format: { [slug]: { profileName, createdAt, updatedAt } }

note: slugs are env-scoped as $org.$env.$key (e.g., 'acme.prod.AWS_PROFILE')
example: { "acme.prod.AWS_PROFILE": { profileName: "acme-prod", ... } }
```

### domain.operations/grades/inferKeyGrade

```
inferKeyGrade
├── [~] inferProtection()
│   ├── [○] os.envvar -> 'plaintext'
│   ├── [○] os.direct -> 'plaintext'
│   ├── [○] os.secure -> 'encrypted'
│   ├── [○] os.daemon -> 'encrypted'
│   ├── [○] 1password -> 'encrypted'
│   └── [+] aws.iam.sso -> 'reference'      # new: highest protection
└── [○] inferDuration()                      # retain: mechanism-based
```

### domain.operations/grades/detectKeyGradeChange

```
detectKeyGradeChange
├── [~] PROTECTION_RANK
│   ├── [+] 'reference': 0      # new: most secure (lowest rank = most restrictive)
│   ├── [~] 'encrypted': 1      # was 0
│   └── [~] 'plaintext': 2      # was 1
└── [○] DURATION_RANK           # retain: transient=0, ephemeral=1, permanent=2
```

### domain.operations/genKeyrackGrantContext

```
genKeyrackGrantContext
├── [○] load host manifest
├── [○] load repo manifest (optional)
├── [~] assemble vault adapters
│   ├── [○] os.envvar, os.direct, os.secure, os.daemon, 1password
│   └── [+] aws.iam.sso: vaultAdapterAwsIamSso
└── [○] assemble mechanism adapters
```

## contracts

### KeyrackKeyGrade (updated)

```ts
export interface KeyrackKeyGrade {
  protection: 'reference' | 'encrypted' | 'plaintext';  // reference added
  duration: 'permanent' | 'ephemeral' | 'transient';
}
```

### vaultAdapterAwsIamSso (new)

```ts
export const vaultAdapterAwsIamSso: KeyrackHostVaultAdapter = {
  unlock: async (input?: { passphrase?: string }) => {
    // passphrase not used for sso (browser-based)
    // validates all stored profiles, triggers login for expired
  },
  isUnlocked: async () => {
    // validates all stored profiles via sts get-caller-identity
    // returns true if all valid, false if any expired
  },
  get: async (input: { slug: string; exid?: string }) => {
    // slug is env-scoped (e.g., 'acme.prod.AWS_PROFILE')
    // reads profile name from storage file
    // returns profile name or null
  },
  set: async (input: { slug: string; value: string; exid?: string; expiresAt?: IsoTimeStamp }) => {
    // slug is env-scoped (e.g., 'acme.prod.AWS_PROFILE')
    // value is the aws profile name (e.g., 'acme-prod')
    // writes profile name to storage file
    // expiresAt stored but not enforced (sso tokens self-expire)
  },
  del: async (input: { slug: string; exid?: string }) => {
    // removes profile from storage file
  },
};
```

### mechAdapterAwsSso (updated validate)

```ts
export const mechAdapterAwsSso: KeyrackGrantMechanismAdapter = {
  validate: (input: { source?: string; cached?: string }) => {
    // if cached: validate json credentials format
    if (input.cached) {
      return isValidCachedCredentials(input.cached);
    }

    // if source: validate profile name format
    if (!input.source) return { valid: false, reason: 'no source or cached value' };
    if (!isValidProfileName(input.source)) {
      return { valid: false, reason: 'invalid profile name format' };
    }

    // NEW: validate session via sts get-caller-identity
    const result = execSync(`aws sts get-caller-identity --profile "${input.source}"`, {
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    // if command fails, session is expired
    // return { valid: false, reason: 'sso session expired' }

    return { valid: true };
  },

  translate: async (input: { value: string }) => {
    // REMOVED: aws sso login trigger (moved to vault unlock)

    // export credentials
    const creds = execSync(
      `aws configure export-credentials --profile "${input.value}" --format env-no-export`,
    );

    // parse and return
    return {
      value: JSON.stringify(parsedCreds),
      expiresAt: computeExpiresAt(parsedCreds),
    };
  },
};
```

## test coverage

### unit tests

| file | coverage |
|------|----------|
| `mechAdapterAwsSso.test.ts` | validate profile names, validate cached creds, validate session check |
| `vaultAdapterAwsIamSso.test.ts` | unlock flow, get/set/del, session validation |
| `inferKeyGrade.test.ts` | aws.iam.sso -> reference protection |
| `detectKeyGradeChange.test.ts` | reference degradation blocked |

### integration tests

| file | coverage |
|------|----------|
| `vaultAdapterAwsIamSso.integration.test.ts` | real aws cli calls with test profile |
| `getKeyrackKeyGrant.integration.test.ts` | full grant flow with aws.iam.sso vault |
| `unlockKeyrack.integration.test.ts` | unlock triggers sso login for expired |

### acceptance tests

| scenario | test |
|----------|------|
| grant with valid session | keyrack returns profile name |
| grant with expired session | keyrack throws unlock-required |
| unlock refreshes expired session | browser auth triggered |
| grade degradation blocked | reference -> encrypted fails |
| **set auto-updates repo manifest** | key added to env in `.agent/keyrack.yml` |
| **set with key already in manifest** | no duplicate added, host still configured |
| **set creates env section if absent** | `env.$env` section created with key |

## implementation phases

### phase 0: domain objects

1. add `'reference'` to `KeyrackKeyGrade.protection`
2. add `'aws.iam.sso'` to `KeyrackHostVault`
3. update tests for new types

### phase 1: grade logic

1. update `inferKeyGrade` for aws.iam.sso -> reference
2. update `detectKeyGradeChange` protection rank
3. add unit tests for reference protection
4. add degradation tests for reference

### phase 2: vault adapter

1. create `vaultAdapterAwsIamSso`
2. implement storage at `~/.rhachet/keyrack.aws-iam-sso.json`
3. implement unlock flow with sts validation + sso login
4. add unit tests with mock aws cli
5. add integration tests with real aws cli

### phase 3: mechanism adapter

1. update `mechAdapterAwsSso.validate()` to check session
2. remove login trigger from `mechAdapterAwsSso.translate()`
3. update unit tests for validation behavior
4. add integration tests for session validation

### phase 4: context wire-up

1. update `genKeyrackGrantContext` to include aws.iam.sso adapter
2. verify full grant flow works end-to-end
3. add integration tests for complete flow

### phase 5: acceptance tests

1. add blackbox tests for grant scenarios
2. add blackbox tests for unlock scenarios
3. add blackbox tests for grade protection

## security considerations

### protection hierarchy

```
reference (0) > encrypted (1) > plaintext (2)
```

- reference: only profile name stored, no secrets ever touch keyrack
- encrypted: secrets stored but encrypted at rest
- plaintext: secrets stored in clear (e.g., os.envvar, os.direct)

### degradation rules

| from | to | allowed |
|------|----|---------|
| reference | encrypted | no |
| reference | plaintext | no |
| encrypted | reference | yes |
| encrypted | plaintext | no |
| plaintext | reference | yes |
| plaintext | encrypted | yes |

### unlock flow security

- browser auth always triggered by explicit `rhx keyrack unlock`
- never triggered at grant request time (no surprise popups)
- human consciously initiates, consciously approves

### sso-session requirement (mandatory)

**forbidden**: `aws sso login --profile $name` (boto credential resolution flow)

**required**: `aws sso login --sso-session $ssoSessionName` (direct sso-session flow)

the `--profile` flag routes through boto's credential resolution, which:
- has inconsistent behavior across aws cli versions
- may fall back to legacy credential providers
- produces unclear "Allow access" prompts in device code flow

the `--sso-session` flag directly uses the sso-session configuration, which:
- always uses the v2 sso-session config format
- produces clean device code prompts with url and code
- is the aws-recommended approach since cli v2.22

all sso login triggers must:
1. parse the `sso_session` reference from the profile config
2. use `--sso-session $ssoSessionName --use-device-code` flags
3. reject profiles that use legacy inline sso config (no `sso_session` reference)

## dependencies

| tool | usage |
|------|-------|
| aws cli | sso login, sts get-caller-identity, configure export-credentials |
| @smithy/shared-ini-file-loader | optional: read aws config for validation |

no new npm dependencies required. aws cli invoked via subprocess.
