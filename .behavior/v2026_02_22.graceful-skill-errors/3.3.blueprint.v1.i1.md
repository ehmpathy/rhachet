# blueprint: graceful skill errors

## summary

change skill error output to show clean status lines instead of JSON error blocks.

**requirements**:
1. skill identifier line ALWAYS shows (even on error)
2. status line shows after skill identifier
3. no JSON noise â€” just the status and skill output

**root cause**: skill identifier is printed to stdout, but errors go to stderr. Claude Code only shows stderr on error, so the identifier is lost.

**solution**:
1. buffer stderr when skill executes
2. on error, print to stderr: skill identifier + status + buffered skill stderr

---

## filediffs

```
src/
  contract/
    cli/
      [~] invokeRun.ts                    # change error output
  domain.operations/
    invoke/
      [~] executeSkill.ts                 # buffer stderr, include in error
      [~] executeSkill.integration.test.ts # add tests for stderr capture
```

---

## codepaths

### executeSkill.ts

```
executeSkill()
  â”œâ”€ [~] spawnSync: buffer stderr (pipe instead of inherit)
  â”œâ”€ [~] SkillExecutionError: include captured stderr
  â””â”€ [â—‹] preserve original exit code in error
```

### invokeRun.ts

```
invokeRun()
  â””â”€ performRunViaCommandMode()
       â”œâ”€ [â—‹] findUniqueSkillExecutable()
       â”œâ”€ [~] remove console.log(skill identifier) â€” moved to catch block
       â”œâ”€ [â—‹] executeSkill()
       â””â”€ [~] catch block:
            â”œâ”€ [+] console.error(skill identifier)
            â”œâ”€ [+] if exitCode === 2: console.error("âœ‹ blocked by constraints")
            â”œâ”€ [+] else: console.error("ðŸ’¥ failed with an error")
            â”œâ”€ [+] console.error(error.stderr) â€” captured from skill
            â”œâ”€ [-] remove: console.error(`\nâ›ˆï¸ ${error.message}`)
            â””â”€ [â—‹] process.exit(error.exitCode)
```

---

## detailed changes

### 1. executeSkill.ts â€” buffer stderr and include in error

**before**:
```ts
const result = spawnSync(command, [], {
  // ...
  stdio: stream
    ? [process.stdin, process.stdout, process.stderr]  // all passthrough
    : ['inherit', 'pipe', 'inherit'],
});

if (result.status !== 0)
  throw new SkillExecutionError('skill execution failed', {
    skill: input.skill.slug,
    path: input.skill.path,
    exitCode: result.status,
  });
```

**after**:
```ts
const result = spawnSync(command, [], {
  // ...
  stdio: stream
    ? [process.stdin, process.stdout, 'pipe']  // buffer stderr
    : ['inherit', 'pipe', 'pipe'],
});

if (result.status !== 0)
  throw new SkillExecutionError('skill execution failed', {
    skill: input.skill.slug,
    path: input.skill.path,
    exitCode: result.status,
    stderr: result.stderr,  // include captured stderr
  });
```

### 2. invokeRun.ts â€” error handler

**before**:
```ts
// log which skill will run
console.log(``);
console.log(`ðŸª¨ run solid skill repo=${skill.slugRepo}/role=${skill.slugRole}/skill=${skill.slug}`);
console.log(``);

// execute
executeSkill({ skill, args: rawArgs });

// ...catch block:
} catch (error) {
  if (error instanceof SkillExecutionError) {
    console.error(`\nâ›ˆï¸ ${error.message}`);
    process.exit(error.exitCode);
  }
  throw error;
}
```

**after**:
```ts
// keep identifier print for success path (stdout)
console.log(``);
console.log(`ðŸª¨ run solid skill repo=${skill.slugRepo}/role=${skill.slugRole}/skill=${skill.slug}`);
console.log(``);

try {
  executeSkill({ skill, args: rawArgs });
} catch (error) {
  if (error instanceof SkillExecutionError) {
    // on error: print header + status to stderr (so it shows when stdout hidden)
    console.error(``);
    console.error(`ðŸª¨ run solid skill repo=${skill.slugRepo}/role=${skill.slugRole}/skill=${skill.slug}`);
    if (error.exitCode === 2) {
      console.error(`   â””â”€ âœ‹ blocked by constraints`);
    } else {
      console.error(`   â””â”€ ðŸ’¥ failed with an error`);
    }
    console.error(``);
    if (error.stderr) console.error(error.stderr);
    process.exit(error.exitCode);
  }
  throw error;
}
```

### 3. init error handler (parity)

apply same pattern to `performRunViaInitMode` catch block for consistency.

---

## output flow

### success (exit 0) â€” stdout

```
ðŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set

[skill stdout streams here]
```

### graceful failure (exit 2) â€” stderr

```
ðŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ âœ‹ blocked by constraints

ðŸ¢ bummer dude...

ðŸš git.commit.set
   â””â”€ error: no commit quota set

ask your human to grant:
  $ git.commit.uses set --quant N --push allow|block
```

### unexpected error (exit 1, 3-255) â€” stderr

```
ðŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ ðŸ’¥ failed with an error

bash: line 42: jq: command not found
```

**key**: on error, everything goes to stderr so it shows even when stdout is hidden (like in Claude Code error display).

---

## test coverage

### integration tests with snapshots

**add to `executeSkill.integration.test.ts`**:

```ts
given('[case1] skill that exits 0', () => {
  when('[t0] executeSkill is called', () => {
    then('returns without error', () => { ... });
  });
});

given('[case2] skill that exits 2 with stderr', () => {
  when('[t0] executeSkill is called', () => {
    then('throws SkillExecutionError with exitCode 2', () => { ... });
    then('error.stderr contains skill output', () => { ... });
  });
});

given('[case3] skill that exits 1 with stderr', () => {
  when('[t0] executeSkill is called', () => {
    then('throws SkillExecutionError with exitCode 1', () => { ... });
    then('error.stderr contains skill output', () => { ... });
  });
});
```

**add CLI output tests to `invokeRun.integration.test.ts`** (or create new):

```ts
given('[case1] skill that exits 2 with stderr "quota error"', () => {
  when('[t0] rhachet run --skill is invoked', () => {
    then('stderr matches snapshot', () => {
      expect(result.stderr).toMatchSnapshot();
    });
    then('skill header appears BEFORE skill stderr', () => {
      const headerIdx = result.stderr.indexOf('ðŸª¨ run solid skill');
      const statusIdx = result.stderr.indexOf('âœ‹ blocked by constraints');
      const skillStderrIdx = result.stderr.indexOf('quota error');
      expect(headerIdx).toBeLessThan(statusIdx);
      expect(statusIdx).toBeLessThan(skillStderrIdx);
    });
    then('stderr does NOT contain JSON', () => {
      expect(result.stderr).not.toContain('"skill":');
      expect(result.stderr).not.toContain('"exitCode":');
    });
    then('process exits 2', () => {
      expect(result.exitCode).toEqual(2);
    });
  });
});

given('[case2] skill that exits 1 with stderr "jq not found"', () => {
  when('[t0] rhachet run --skill is invoked', () => {
    then('stderr matches snapshot', () => {
      expect(result.stderr).toMatchSnapshot();
    });
    then('skill header appears BEFORE skill stderr', () => {
      const headerIdx = result.stderr.indexOf('ðŸª¨ run solid skill');
      const statusIdx = result.stderr.indexOf('ðŸ’¥ failed with an error');
      const skillStderrIdx = result.stderr.indexOf('jq not found');
      expect(headerIdx).toBeLessThan(statusIdx);
      expect(statusIdx).toBeLessThan(skillStderrIdx);
    });
    then('stderr does NOT contain JSON', () => {
      expect(result.stderr).not.toContain('"skill":');
    });
    then('process exits 1', () => {
      expect(result.exitCode).toEqual(1);
    });
  });
});
```

**why both?**
- **snapshots**: visual verification in PRs â€” see the exact output format
- **explicit assertions**: behavioral guarantees â€” order (header â†’ status â†’ stderr), no JSON

### acceptance tests

**create `accept.blackbox/cli/run.graceful-errors.acceptance.test.ts`**:

blackbox tests invoke the CLI binary and verify observable output.

```ts
given('[case1] skill that exits 0', () => {
  when('[t0] npx rhachet run --skill is invoked', () => {
    then('process exits 0', () => {
      expect(result.exitCode).toEqual(0);
    });
    then('stdout contains skill identifier', () => {
      expect(result.stdout).toContain('ðŸª¨ run solid skill');
    });
  });
});

given('[case2] skill that exits 2', () => {
  when('[t0] npx rhachet run --skill is invoked', () => {
    then('stderr matches snapshot', () => {
      expect(result.stderr).toMatchSnapshot();
    });
    then('stderr contains skill identifier THEN status THEN skill output', () => {
      const headerIdx = result.stderr.indexOf('ðŸª¨ run solid skill');
      const statusIdx = result.stderr.indexOf('âœ‹ blocked by constraints');
      const skillOutputIdx = result.stderr.indexOf('quota error');
      expect(headerIdx).toBeGreaterThan(-1);
      expect(headerIdx).toBeLessThan(statusIdx);
      expect(statusIdx).toBeLessThan(skillOutputIdx);
    });
    then('stderr does NOT contain JSON', () => {
      expect(result.stderr).not.toContain('"skill":');
      expect(result.stderr).not.toContain('"exitCode":');
    });
    then('process exits 2', () => {
      expect(result.exitCode).toEqual(2);
    });
  });
});

given('[case3] skill that exits 1', () => {
  when('[t0] npx rhachet run --skill is invoked', () => {
    then('stderr matches snapshot', () => {
      expect(result.stderr).toMatchSnapshot();
    });
    then('stderr contains skill identifier THEN status THEN skill output', () => {
      const headerIdx = result.stderr.indexOf('ðŸª¨ run solid skill');
      const statusIdx = result.stderr.indexOf('ðŸ’¥ failed with an error');
      const skillOutputIdx = result.stderr.indexOf('error output');
      expect(headerIdx).toBeGreaterThan(-1);
      expect(headerIdx).toBeLessThan(statusIdx);
      expect(statusIdx).toBeLessThan(skillOutputIdx);
    });
    then('stderr does NOT contain JSON', () => {
      expect(result.stderr).not.toContain('"skill":');
    });
    then('process exits 1', () => {
      expect(result.exitCode).toEqual(1);
    });
  });
});
```

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| stderr no longer streams in real-time | acceptable â€” error messages are short; benefit outweighs cost |
| break extant skills | no risk â€” behavior is additive (exit 2 opt-in) |
| init parity | apply same pattern to init error handler |

---

## verification

1. `npm run test:integration` â€” extant tests pass, new snapshot tests pass
2. manual test: `npx rhachet run --skill git.commit.set -m 'test'` without quota
   - should show `âœ‹ blocked by constraints`, no JSON
   - skill header should appear first
3. manual test: create skill that exits 1
   - should show `ðŸ’¥ failed with an error`, no JSON
   - skill header should appear first
