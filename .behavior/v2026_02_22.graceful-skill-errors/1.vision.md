# vision: graceful skill errors

## the outcome world

### before: error noise buries the message

a mechanic tries to commit without quota:

```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set

ğŸ’¥  skill execution failed

{
  "skill": "git.commit.set",
  "path": "/home/vlad/.../skills/claude.tools/git.commit.set.sh",
  "exitCode": 1
}

ğŸ¢ bummer dude...

ğŸš git.commit.set
   â””â”€ error: no commit quota set

ask your human to grant:
  $ git.commit.uses set --quant N --push allow|block
```

the mechanic (or human) must parse through JSON noise to find the actual message. the skill author crafted a beautiful, helpful error â€” but it's buried under system scaffolding.

### after: the skill speaks for itself

```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ âœ‹ blocked by constraints

ğŸ¢ bummer dude...

ğŸš git.commit.set
   â””â”€ error: no commit quota set

ask your human to grant:
  $ git.commit.uses set --quant N --push allow|block
```

the skill's message shines through. rhachet steps aside and lets the skill communicate directly.

### the "aha" moment

> "oh â€” when my skill knows what went wrong and explains it clearly, rhachet trusts me and shows my message. when something unexpected breaks, rhachet helps diagnose."

skill authors realize they're in control. exit 2 = "i handled this, here's what the user needs to know." exit 1 = "something unexpected broke, rhachet should help debug."

---

## user experience

### usecase 1: controlled denial (exit 2)

**goal**: skill detects a constraint violation and explains how to fix it.

**contract**:
- skill outputs user-friendly message to stderr
- skill exits with code 2
- rhachet passes through stderr cleanly
- rhachet adds minimal context: `â””â”€ âœ‹ blocked by constraints`
- process exits 2

**example: commit quota check**

```bash
# skill: git.commit.set.sh
if [[ "$QUOTA" -eq 0 ]]; then
  echo "ğŸ¢ bummer dude..."
  echo ""
  echo "ğŸš git.commit.set"
  echo "   â””â”€ error: no commit quota set"
  echo ""
  echo "ask your human to grant:"
  echo "  \$ git.commit.uses set --quant N --push allow|block"
  exit 2  # graceful failure
fi
```

**output**:
```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ âœ‹ blocked by constraints

ğŸ¢ bummer dude...

ğŸš git.commit.set
   â””â”€ error: no commit quota set

ask your human to grant:
  $ git.commit.uses set --quant N --push allow|block
```

### usecase 2: unexpected error (exit 1)

**goal**: skill breaks unexpectedly; rhachet helps diagnose.

**contract**:
- skill outputs whatever it can to stderr
- skill exits with code 1 (or any non-zero except 2)
- rhachet shows stderr
- rhachet adds context: `â””â”€ ğŸ’¥ failed with an error`
- process exits with original code

**example: missing dependency**

```bash
# skill crashes because jq isn't installed
jq '.foo' <<< '{"foo": "bar"}'  # fails
```

**output**:
```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ ğŸ’¥ failed with an error

bash: line 42: jq: command not found
```

### usecase 3: success (exit 0)

**goal**: skill completes successfully.

**contract**: no change â€” works as today.

**output**:
```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set

âœ¨ committed: fix(api): validate input

ğŸ¢ shell yeah!
```

---

## output format pattern

rhachet emits a skill identifier line, then a status subtree based on exit code:

### exit 0 â€” success (no subtree)

```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set

[skill stdout/stderr streams through]
```

### exit 2 â€” graceful failure (blocked)

```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ âœ‹ blocked by constraints

[skill stderr streams through]
```

### exit 1, 3, 4, ... 255 â€” unexpected error (failed)

```
ğŸª¨ run solid skill repo=ehmpathy/role=mechanic/skill=git.commit.set
   â””â”€ ğŸ’¥ failed with an error

[skill stderr streams through]
```

the status subtree (`â””â”€`) makes it visually clear what happened. no JSON, no stack traces, no noise â€” just the skill identifier, status, and output.

---

## timeline

| phase | user action | system response |
|-------|-------------|-----------------|
| invoke | `npx rhachet run --skill git.commit.set -m 'fix: thing'` | skill starts executing |
| output | skill prints to stdout/stderr | streams through |
| exit | skill exits with code N | rhachet interprets code |
| display | â€” | code 0: done<br>code 2: `âœ‹ blocked`<br>code 1/other: `ğŸ’¥ failed` |
| propagate | â€” | process.exit(N) |

---

## mental model

### how users describe it

> "if my skill knows what went wrong, it uses exit 2 and explains nicely. if something unexpected breaks, it uses exit 1 and rhachet helps debug."

### analogy: the bouncer pattern

- **exit 0** = "welcome in" â€” success, proceed
- **exit 2** = "sorry, you're not on the list" â€” denied, but here's why and what to do
- **exit 1** = "whoa, something's wrong with the door" â€” system broke, need to investigate

the bouncer (skill) either lets you in, politely turns you away with instructions, or calls for help when the door itself breaks.

### terms

| rhachet term | user term | unix analogy |
|--------------|-----------|--------------|
| graceful failure | "blocked" | exit 2 (misuse) |
| unexpected error | "crashed" | exit 1 (error) |
| success | "done" | exit 0 |

---

## evaluation

### how well does it address the goals?

| goal | status | notes |
|------|--------|-------|
| clean output for user-friendly errors | âœ… | no JSON noise, skill message shines |
| preserve debugging for unexpected errors | âœ… | exit 1 still gets context |
| backward compatible | âœ… | extant skills work, authors opt-in to exit 2 |
| minimal change | âœ… | one exit code check in rhachet |

### pros

- **skill authors control the message** â€” craft the perfect explanation, rhachet passes it through
- **unix convention** â€” exit 2 = misuse is a common pattern (e.g., grep, diff)
- **minimal implementation** â€” one conditional in error handling
- **opt-in** â€” extant skills continue working, authors adopt when ready
- **agent-friendly** â€” clean messages parse better than JSON + prose mix

### cons

- **new convention to learn** â€” skill authors must know exit 2 means graceful
- **potential confusion** â€” some might expect exit 2 to mean "no match" (like grep)

### edgecases

| exit code | handling |
|-----------|----------|
| 0 | success â€” pass through output |
| 2 | graceful failure â€” show `âœ‹ blocked by constraints` + stderr |
| 2 (no stderr) | show `âœ‹ blocked by constraints` alone |
| 1, 3, 4, ... 255 | unexpected error â€” show `ğŸ’¥ failed with an error` + stderr |

### pit of success

- **default is safe** â€” exit 1 (crash) shows debugging info
- **opt-in is explicit** â€” exit 2 requires intentional skill change
- **convention matches unix** â€” authors already know exit codes
- **no API changes** â€” skills just change their exit code

---

## summary

the world after this change:

1. **skill authors** use exit 2 for "blocked but explained" scenarios
2. **rhachet** interprets exit 2 as "pass through cleanly"
3. **users** see the skill's crafted message, not system noise
4. **debugging** remains for unexpected errors (exit 1)

the skill speaks for itself. rhachet steps aside when the skill has things handled.
