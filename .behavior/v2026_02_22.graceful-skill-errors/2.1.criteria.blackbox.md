# blackbox criteria: graceful skill errors

## usecase.1 = skill succeeds (exit 0)

```
given('a skill that exits 0')
  when('rhachet run --skill is invoked')
    then('skill identifier line is emitted')
      sothat('user knows which skill ran')
    then('no status subtree is shown')
      sothat('success is implied by absence of failure indicator')
    then('skill stdout streams through')
    then('skill stderr streams through')
    then('process exits 0')
```

## usecase.2 = skill gracefully fails (exit 2)

```
given('a skill that exits 2 with stderr output')
  when('rhachet run --skill is invoked')
    then('skill identifier line is emitted')
    then('status subtree shows "â””â”€ âœ‹ blocked by constraints"')
      sothat('user sees the skill was blocked, not crashed')
    then('skill stderr streams through cleanly')
      sothat('skill author controls the message')
    then('no JSON error block is shown')
      sothat('output is human-readable')
    then('process exits 2')
      sothat('caller can detect graceful failure')

given('a skill that exits 2 with no stderr')
  when('rhachet run --skill is invoked')
    then('skill identifier line is emitted')
    then('status subtree shows "â””â”€ âœ‹ blocked by constraints"')
    then('no additional output is shown')
    then('process exits 2')
```

## usecase.3 = skill unexpectedly fails (exit 1, 3, ... 255)

```
given('a skill that exits 1 with stderr output')
  when('rhachet run --skill is invoked')
    then('skill identifier line is emitted')
    then('status subtree shows "â””â”€ ðŸ’¥ failed with an error"')
      sothat('user sees the skill crashed unexpectedly')
    then('skill stderr streams through')
      sothat('debug info is visible')
    then('no JSON error block is shown')
      sothat('output is human-readable')
    then('process exits 1')
      sothat('caller can detect failure')

given('a skill that exits with any code except 0 and 2')
  when('rhachet run --skill is invoked')
    then('status subtree shows "â””â”€ ðŸ’¥ failed with an error"')
    then('process exits with the original exit code')
      sothat('signals are preserved (e.g., 128+N for signals)')
```

## usecase.4 = output format consistency

```
given('any skill invocation')
  when('rhachet run --skill is invoked')
    then('skill identifier line format is "ðŸª¨ run solid skill repo={repo}/role={role}/skill={slug}"')
    then('status subtree (if present) is indented with "   â””â”€"')
    then('skill output follows after a blank line')
      sothat('visual separation is clear')
```

## usecase.5 = backward compatibility

```
given('a skill authored before this change (uses exit 1 for controlled denial)')
  when('rhachet run --skill is invoked')
    then('behavior is unchanged from before')
      sothat('extant skills continue to work')
    then('status subtree shows "ðŸ’¥ failed with an error"')
      sothat('skill authors are encouraged to adopt exit 2')
```
