# blueprint: auto-resolve merge conflicts for linked roles

## .summary

when `npx rhachet roles link --role x` runs, upsert a `.gitattributes` file with `merge=theirs` rules for the linked role's `.agent/repo=$repo/` directory. this auto-resolves merge conflicts when branches link different versions of the same package.

---

## .domain model

### domain objects

**GitattributesEntry** (domain literal)
```ts
interface GitattributesEntry {
  pattern: string;      // e.g., ".agent/repo=ehmpathy/** merge=theirs"
  attribute: string;    // e.g., "merge=theirs"
}
```

### domain operations

**upsertGitattributesEntry**
- input: `{ repoSlug: string }`
- behavior:
  1. read existing `.gitattributes` content (or empty string if absent)
  2. parse into lines
  3. compute the entry pattern: `.agent/repo=${repoSlug}/** merge=theirs`
  4. if pattern already exists â†’ no change, return `unchanged`
  5. if pattern absent â†’ append entry, write file, return `created` or `updated`
- output: `{ status: 'created' | 'updated' | 'unchanged' }`

---

## .integration point

modify `execRoleLink` to call `upsertGitattributesEntry` after directory creation, before symlink operations:

```
execRoleLink flow:
â”œâ”€â”€ create .agent directory structure
â”œâ”€â”€ **upsertGitattributesEntry({ repoSlug })** â† new step
â”œâ”€â”€ findsert readme files
â”œâ”€â”€ symlink readmes
â”œâ”€â”€ symlink resource directories
â””â”€â”€ log summary
```

---

## .gitattributes format

### single role linked

```gitattributes
# rhachet: auto-resolve merge conflicts for linked roles
.agent/repo=ehmpathy/** merge=theirs
```

### multiple roles linked

```gitattributes
# rhachet: auto-resolve merge conflicts for linked roles
.agent/repo=ehmpathy/** merge=theirs
.agent/repo=acme/** merge=theirs
```

### idempotency

- each entry is unique by `repoSlug`
- re-linking the same role does not duplicate entries
- linking a different role from the same repo does not duplicate entries
- linking a role from a different repo appends a new entry

---

## .file structure

### new files

```
src/domain.operations/invoke/link/
  upsertGitattributesEntry.ts           # core logic
  upsertGitattributesEntry.test.ts      # unit tests
```

### modified files

```
src/domain.operations/invoke/link/
  execRoleLink.ts                       # add upsertGitattributesEntry call

accept.blackbox/cli/
  roles.link.acceptance.test.ts         # add gitattributes assertions

src/contract/cli/
  invokeRolesLink.integration.test.ts   # add gitattributes assertions
```

---

## .implementation details

### upsertGitattributesEntry.ts

```ts
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { relative, resolve } from 'node:path';

const GITATTRIBUTES_HEADER = '# rhachet: auto-resolve merge conflicts for linked roles';

/**
 * .what = upserts a merge=theirs entry for a repo's .agent directory
 * .why = auto-resolves merge conflicts when branches link different package versions
 */
export const upsertGitattributesEntry = (input: {
  repoSlug: string;
}): { status: 'created' | 'updated' | 'unchanged' } => {
  const gitattributesPath = resolve(process.cwd(), '.gitattributes');
  const entryPattern = `.agent/repo=${input.repoSlug}/**`;
  const entryLine = `${entryPattern} merge=theirs`;

  // read existing content
  const contentBefore = existsSync(gitattributesPath)
    ? readFileSync(gitattributesPath, 'utf8')
    : '';

  // check if entry already exists
  const lines = contentBefore.split('\n');
  const entryExists = lines.some((line) => line.trim().startsWith(entryPattern));
  if (entryExists) return { status: 'unchanged' };

  // determine if file existed before
  const fileExisted = contentBefore.length > 0;

  // build new content
  const hasHeader = contentBefore.includes(GITATTRIBUTES_HEADER);
  const newLines: string[] = [];

  if (!hasHeader) {
    // add header if not present
    if (contentBefore.trim().length > 0) {
      newLines.push(''); // blank line before our section
    }
    newLines.push(GITATTRIBUTES_HEADER);
  }
  newLines.push(entryLine);

  const contentAfter = contentBefore.trimEnd() + '\n' + newLines.join('\n') + '\n';

  // write file
  writeFileSync(gitattributesPath, contentAfter, 'utf8');

  // log action
  const relativePath = relative(process.cwd(), gitattributesPath);
  const status = fileExisted ? 'updated' : 'created';
  console.log(`  ${status === 'updated' ? 'â†»' : '+'} ${relativePath} (${status})`);

  return { status };
};
```

### execRoleLink.ts changes

```ts
// add import
import { upsertGitattributesEntry } from './upsertGitattributesEntry';

// in execRoleLink, after mkdirSync calls, before findsertFile calls:
export const execRoleLink = (input: { ... }): { ... } => {
  // create .agent directory structure
  // ... existing mkdirSync calls ...

  // upsert gitattributes entry for this repo
  upsertGitattributesEntry({ repoSlug: input.repo.slug });

  // findsert .agent/readme.md
  // ... existing code ...
};
```

---

## .test coverage

### unit tests: upsertGitattributesEntry.test.ts

| case | scenario | expected |
|------|----------|----------|
| [case1] | no .gitattributes file exists | creates file with header + entry, status=created |
| [case2] | .gitattributes exists without our header | appends header + entry, status=updated |
| [case3] | .gitattributes exists with our header but no matching entry | appends entry under header, status=updated |
| [case4] | .gitattributes exists with matching entry | no change, status=unchanged |
| [case5] | .gitattributes exists with different repo entry | appends new entry, keeps existing, status=updated |
| [case6] | .gitattributes has trailing whitespace | preserves structure, appends cleanly |

```ts
import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { given, then, when } from 'test-fns';

import { upsertGitattributesEntry } from './upsertGitattributesEntry';

describe('upsertGitattributesEntry', () => {
  const testDir = resolve(__dirname, './.temp/upsertGitattributesEntry');
  const originalCwd = process.cwd();

  beforeAll(() => {
    rmSync(testDir, { recursive: true, force: true });
    mkdirSync(testDir, { recursive: true });
    process.chdir(testDir);
  });

  afterAll(() => {
    process.chdir(originalCwd);
  });

  beforeEach(() => {
    // clean up gitattributes before each test
    const gitattributesPath = resolve(testDir, '.gitattributes');
    if (existsSync(gitattributesPath)) {
      rmSync(gitattributesPath);
    }
  });

  given('[case1] no .gitattributes file exists', () => {
    when('[t0] upsertGitattributesEntry called', () => {
      then('creates file with header and entry', () => {
        const result = upsertGitattributesEntry({ repoSlug: 'ehmpathy' });

        expect(result.status).toEqual('created');

        const content = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');
        expect(content).toContain('# rhachet: auto-resolve merge conflicts');
        expect(content).toContain('.agent/repo=ehmpathy/** merge=theirs');
      });
    });
  });

  given('[case2] .gitattributes exists without our header', () => {
    beforeEach(() => {
      writeFileSync(
        resolve(testDir, '.gitattributes'),
        '*.pbxproj binary\n',
        'utf8',
      );
    });

    when('[t0] upsertGitattributesEntry called', () => {
      then('appends header and entry', () => {
        const result = upsertGitattributesEntry({ repoSlug: 'ehmpathy' });

        expect(result.status).toEqual('updated');

        const content = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');
        expect(content).toContain('*.pbxproj binary');
        expect(content).toContain('# rhachet: auto-resolve merge conflicts');
        expect(content).toContain('.agent/repo=ehmpathy/** merge=theirs');
      });
    });
  });

  given('[case3] .gitattributes exists with our header but no matching entry', () => {
    beforeEach(() => {
      writeFileSync(
        resolve(testDir, '.gitattributes'),
        '# rhachet: auto-resolve merge conflicts for linked roles\n.agent/repo=acme/** merge=theirs\n',
        'utf8',
      );
    });

    when('[t0] upsertGitattributesEntry called for different repo', () => {
      then('appends new entry under header', () => {
        const result = upsertGitattributesEntry({ repoSlug: 'ehmpathy' });

        expect(result.status).toEqual('updated');

        const content = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');
        expect(content).toContain('.agent/repo=acme/** merge=theirs');
        expect(content).toContain('.agent/repo=ehmpathy/** merge=theirs');
      });
    });
  });

  given('[case4] .gitattributes exists with matching entry', () => {
    beforeEach(() => {
      writeFileSync(
        resolve(testDir, '.gitattributes'),
        '# rhachet: auto-resolve merge conflicts for linked roles\n.agent/repo=ehmpathy/** merge=theirs\n',
        'utf8',
      );
    });

    when('[t0] upsertGitattributesEntry called for same repo', () => {
      then('returns unchanged, no modification', () => {
        const contentBefore = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');

        const result = upsertGitattributesEntry({ repoSlug: 'ehmpathy' });

        expect(result.status).toEqual('unchanged');

        const contentAfter = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');
        expect(contentAfter).toEqual(contentBefore);
      });
    });
  });

  given('[case5] .gitattributes exists with different repo entry', () => {
    beforeEach(() => {
      writeFileSync(
        resolve(testDir, '.gitattributes'),
        '# rhachet: auto-resolve merge conflicts for linked roles\n.agent/repo=acme/** merge=theirs\n',
        'utf8',
      );
    });

    when('[t0] upsertGitattributesEntry called for new repo', () => {
      then('appends new entry, keeps existing', () => {
        const result = upsertGitattributesEntry({ repoSlug: 'ehmpathy' });

        expect(result.status).toEqual('updated');

        const content = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');
        const lines = content.split('\n').filter((l) => l.includes('merge=theirs'));
        expect(lines).toHaveLength(2);
        expect(lines).toContain('.agent/repo=acme/** merge=theirs');
        expect(lines).toContain('.agent/repo=ehmpathy/** merge=theirs');
      });
    });
  });
});
```

### integration tests: invokeRolesLink.integration.test.ts additions

```ts
when('invoked with "link --repo test --role mechanic"', () => {
  then('it should create/update .gitattributes with merge=theirs for repo', async () => {
    await rolesCommand.parseAsync(
      ['link', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );

    const gitattributesPath = resolve(testDir, '.gitattributes');
    expect(existsSync(gitattributesPath)).toBe(true);

    const content = readFileSync(gitattributesPath, 'utf8');
    expect(content).toContain('.agent/repo=test/** merge=theirs');
  });
});

when('re-linking same role', () => {
  then('it should not duplicate gitattributes entry', async () => {
    // first link
    await rolesCommand.parseAsync(
      ['link', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );

    // second link
    await rolesCommand.parseAsync(
      ['link', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );

    const content = readFileSync(resolve(testDir, '.gitattributes'), 'utf8');
    const matches = content.match(/\.agent\/repo=test\/\*\* merge=theirs/g);
    expect(matches).toHaveLength(1);
  });
});
```

### acceptance tests: roles.link.acceptance.test.ts additions

```ts
when('[t0] roles link --repo test-repo --role tester', () => {
  // ... existing assertions ...

  then('creates .gitattributes with merge=theirs for repo directory', () => {
    const gitattributesPath = resolve(repo.path, '.gitattributes');
    expect(existsSync(gitattributesPath)).toBe(true);

    const content = readFileSync(gitattributesPath, 'utf-8');
    expect(content).toContain('# rhachet: auto-resolve merge conflicts');
    expect(content).toContain('.agent/repo=test-repo/** merge=theirs');
  });
});

given('[case4] repo with existing .gitattributes', () => {
  const repo = useBeforeAll(async () => {
    const r = genTestTempRepo({ fixture: 'with-link-sources' });
    // create pre-existing .gitattributes
    writeFileSync(
      resolve(r.path, '.gitattributes'),
      '*.pbxproj binary\n',
      'utf8',
    );
    return r;
  });

  when('[t0] roles link --repo test-repo --role tester', () => {
    const result = useBeforeAll(async () =>
      invokeRhachetCliBinary({
        args: ['roles', 'link', '--repo', 'test-repo', '--role', 'tester'],
        cwd: repo.path,
      }),
    );

    then('exits with status 0', () => {
      expect(result.status).toEqual(0);
    });

    then('preserves existing .gitattributes content', () => {
      const content = readFileSync(resolve(repo.path, '.gitattributes'), 'utf-8');
      expect(content).toContain('*.pbxproj binary');
    });

    then('appends merge=theirs entry', () => {
      const content = readFileSync(resolve(repo.path, '.gitattributes'), 'utf-8');
      expect(content).toContain('.agent/repo=test-repo/** merge=theirs');
    });
  });
});
```

---

## .edge cases

### handled

1. **no .gitattributes exists** â†’ create with header + entry
2. **file exists without our content** â†’ append our section
3. **file exists with our header, no matching entry** â†’ append entry
4. **file exists with matching entry** â†’ no-op, return unchanged
5. **multiple repos linked** â†’ each gets its own entry
6. **re-linking same repo** â†’ idempotent, no duplicates

### out of scope

1. **removing entries when unlinking** â†’ not supported (unlink is not a command)
2. **merging conflicting .gitattributes** â†’ user's responsibility
3. **custom merge strategies** â†’ only `merge=theirs` supported

---

## .output behavior

### console output on link

```
ðŸ”— link role ehmpathy/mechanic
  + .gitattributes (created)            # first time
  + .agent/repo=ehmpathy/readme.md
  + .agent/repo=ehmpathy/role=mechanic/readme.md
   â”œâ”€â”€ 5 brief(s)
   â””â”€â”€ 3 skill(s)
```

```
ðŸ”— link role ehmpathy/mechanic
  âœ“ .gitattributes (unchanged)          # re-link same repo
  â†» .agent/repo=ehmpathy/readme.md (updated)
  ...
```

```
ðŸ”— link role acme/devops
  â†» .gitattributes (updated)            # different repo added
  + .agent/repo=acme/readme.md
  ...
```

---

## .rationale

### why merge=theirs?

- symlinks point to node_modules paths which are version-specific
- when branches have different linked versions, conflicts are guaranteed
- auto-resolving to "theirs" (incoming branch) ensures the checkout wins
- if symlinks break, `roles link` re-establishes them quickly

### why at repo level, not role level?

- `.agent/repo=$slug/` contains all roles from that package
- all roles from the same package share the same version
- one entry per repo is sufficient and cleaner

### why append, not prepend?

- preserves user's existing gitattributes structure
- our entries are clearly grouped under our header
- easier to identify and manage rhachet's contributions

---

## .migration

### existing repos

- no migration needed
- `.gitattributes` entries added on next `roles link` invocation
- existing symlinks continue to work

### new repos

- `.gitattributes` created automatically on first `roles link`

---

## .test matrix summary

| layer | scope | file | cases |
|-------|-------|------|-------|
| unit | upsertGitattributesEntry logic | upsertGitattributesEntry.test.ts | 6 |
| integration | execRoleLink + gitattributes | invokeRolesLink.integration.test.ts | 2+ |
| acceptance | blackbox CLI behavior | roles.link.acceptance.test.ts | 2+ |

---

## .implementation order

1. create `upsertGitattributesEntry.ts` with unit tests
2. integrate into `execRoleLink.ts`
3. add integration test assertions
4. add acceptance test cases
5. verify all tests pass
