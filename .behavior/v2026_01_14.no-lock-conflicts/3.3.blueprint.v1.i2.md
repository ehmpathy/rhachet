# blueprint: gitignore linked role directories (self-contained)

## .summary

when `npx rhachet roles link --role x` links a role from a published package, create a `.gitignore` file inside `.agent/repo=$slug/` containing `*`. this ignores all symlinked content without mutating the shared root `.gitignore`.

---

## .rationale

### why gitignore (not gitattributes with merge=theirs)?

1. **symlinks depend on node_modules** â€” they won't work until `npm install` anyway
2. **version already tracked** â€” `package.json` declares which `rhachet-roles-*` version is used
3. **simpler mental model** â€” symlinks are a local cache, not source of truth
4. **no merge conflicts** â€” nothing to conflict on if not tracked

### why per-repo gitignore files (not entries in root .gitignore)?

- only ignore repos linked from published packages
- never touch `repo=.this` or other collocated roles
- explicit per-directory files show which external repos are linked
- no mutation of shared root `.gitignore` file

### why a gitignore inside each repo directory?

1. **no shared file mutation** â€” doesn't touch root `.gitignore`
2. **self-contained** â€” the ignore rule lives with the content it ignores
3. **no merge conflicts** â€” each `roles link` only touches its own directory
4. **automatic cleanup** â€” if directory is deleted, gitignore goes with it

### why `*` (not specific patterns)?

- everything in `.agent/repo=$slug/` is symlinked from `node_modules/`
- all of it should be ignored
- `*` is the simplest, most complete solution

---

## .result

```
.agent/
  repo=.this/              # tracked (collocated roles)
    role=any/
      briefs/
      skills/
  repo=ehmpathy/           # ignored via local .gitignore
    .gitignore             # contains comment + *
    role=mechanic/  â†’      # symlink to node_modules/...
  repo=acme/               # ignored via local .gitignore
    .gitignore             # contains comment + *
    role=devops/  â†’        # symlink to node_modules/...
```

### .gitignore content

```gitignore
# .what = tells git to ignore this dir
# .why = keeps git history clean
#   - just symlinks here, no real code
#   - package.json already tracks the version
# .note = safe to delete; run `npx rhachet init --roles` to bring it back
*
```

---

## .domain operations

**findsertRepoGitignore**
- input: `{ repoDir: string }`
- behavior:
  1. check if `.gitignore` already exists with correct content â†’ return `unchanged`
  2. if `.gitignore` missing â†’ run `git rm --cached -r <repoDir>` to untrack old content
  3. write `.gitignore` with content `*` to `repoDir/.gitignore`
  4. return appropriate status
- output: `{ status: 'created' | 'updated' | 'unchanged' }`

---

## .integration point

modify `execRoleLink` to call `findsertRepoGitignore` when linking an external repo:

```
execRoleLink flow:
â”œâ”€â”€ create .agent directory structure (mkdirSync)
â”œâ”€â”€ **findsertRepoGitignore({ repoDir })** â† new step (skip if repoSlug === '.this')
â”œâ”€â”€ findsert readme files
â”œâ”€â”€ symlink readmes
â”œâ”€â”€ symlink resource directories
â””â”€â”€ log summary
```

---

## .file structure

### new files

```
src/domain.operations/invoke/link/
  findsertRepoGitignore.ts                    # core logic
  findsertRepoGitignore.integration.test.ts   # integration tests
```

### modified files

```
src/domain.operations/invoke/link/
  execRoleLink.ts                  # add findsertRepoGitignore call (conditional)

accept.blackbox/cli/
  roles.link.acceptance.test.ts    # add gitignore assertions

src/contract/cli/
  invokeRolesLink.integration.test.ts  # add gitignore assertions
```

---

## .implementation details

### findsertRepoGitignore.ts

```ts
import { execSync } from 'node:child_process';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { relative, resolve } from 'node:path';

const GITIGNORE_CONTENT = `# .what = tells git to ignore this dir
# .why = keeps git history clean
#   - just symlinks here, no real code
#   - package.json already tracks the version
# .note = safe to delete; run \`npx rhachet init --roles\` to bring it back
*
`;

/**
 * .what = creates a .gitignore file inside a linked repo directory
 * .why = ignores symlinked content without mutating shared root .gitignore
 */
export const findsertRepoGitignore = (input: {
  repoDir: string;
}): { status: 'created' | 'updated' | 'unchanged' } => {
  const gitignorePath = resolve(input.repoDir, '.gitignore');
  const relativePath = relative(process.cwd(), gitignorePath);
  const relativeRepoDir = relative(process.cwd(), input.repoDir);

  // check if file already exists with correct content
  if (existsSync(gitignorePath)) {
    const contentBefore = readFileSync(gitignorePath, 'utf8');
    if (contentBefore === GITIGNORE_CONTENT) {
      return { status: 'unchanged' };
    }
    // file exists but content differs â€” update it
    writeFileSync(gitignorePath, GITIGNORE_CONTENT, 'utf8');
    console.log(`  â†» ${relativePath} (updated)`);
    return { status: 'updated' };
  }

  // gitignore missing â€” untrack any previously tracked content
  try {
    execSync(`git rm --cached -r "${relativeRepoDir}"`, { stdio: 'ignore' });
    console.log(`  - ${relativeRepoDir} (detached from git)`);
  } catch {
    // ignore errors â€” dir may not be tracked
  }

  // create the gitignore
  writeFileSync(gitignorePath, GITIGNORE_CONTENT, 'utf8');
  console.log(`  + ${relativePath} (created)`);
  return { status: 'created' };
};
```

### execRoleLink.ts changes

```ts
// add import
import { findsertRepoGitignore } from './findsertRepoGitignore';

export const execRoleLink = (input: { ... }): { ... } => {
  // create .agent directory structure
  const agentDir = resolve(process.cwd(), '.agent');
  const repoThisDir = resolve(agentDir, 'repo=.this');
  const repoDir = resolve(agentDir, `repo=${input.repo.slug}`);
  const repoRoleDir = resolve(repoDir, `role=${input.role.slug}`);

  mkdirSync(agentDir, { recursive: true });
  mkdirSync(repoThisDir, { recursive: true });
  mkdirSync(repoDir, { recursive: true });
  mkdirSync(repoRoleDir, { recursive: true });

  // create .gitignore for external repos (not .this)
  if (input.repo.slug !== '.this') {
    findsertRepoGitignore({ repoDir });
  }

  // findsert .agent/readme.md
  // ... existing code ...
};
```

---

## .test coverage

### integration tests: findsertRepoGitignore.integration.test.ts

| case | scenario | expected |
|------|----------|----------|
| [case1] | directory exists, no .gitignore | runs `git rm --cached -r`, creates file, status=created |
| [case2] | .gitignore exists with correct content | no change, status=unchanged |
| [case3] | .gitignore exists with different content | overwrites with correct content, status=updated |

```ts
import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { given, then, when } from 'test-fns';

import { findsertRepoGitignore } from './findsertRepoGitignore';

describe('findsertRepoGitignore', () => {
  const testDir = resolve(__dirname, './.temp/findsertRepoGitignore');
  const repoDir = resolve(testDir, '.agent/repo=test');
  const originalCwd = process.cwd();

  beforeAll(() => {
    rmSync(testDir, { recursive: true, force: true });
    mkdirSync(repoDir, { recursive: true });
    process.chdir(testDir);
  });

  afterAll(() => {
    process.chdir(originalCwd);
  });

  beforeEach(() => {
    const gitignorePath = resolve(repoDir, '.gitignore');
    if (existsSync(gitignorePath)) {
      rmSync(gitignorePath);
    }
  });

  given('[case1] directory exists, no .gitignore', () => {
    when('[t0] findsertRepoGitignore called', () => {
      then('creates file with * content', () => {
        const result = findsertRepoGitignore({ repoDir });

        expect(result.status).toEqual('created');

        const content = readFileSync(resolve(repoDir, '.gitignore'), 'utf8');
        expect(content).toContain('.what = tells git to ignore this dir');
        expect(content).toContain('.why = keeps git history clean');
        expect(content).toContain('*');
      });
    });
  });

  given('[case2] .gitignore exists with correct content', () => {
    beforeEach(() => {
      writeFileSync(resolve(repoDir, '.gitignore'), GITIGNORE_CONTENT, 'utf8');
    });

    when('[t0] findsertRepoGitignore called', () => {
      then('returns unchanged, no modification', () => {
        const result = findsertRepoGitignore({ repoDir });

        expect(result.status).toEqual('unchanged');

        const content = readFileSync(resolve(repoDir, '.gitignore'), 'utf8');
        expect(content).toContain('.what = tells git to ignore this dir');
        expect(content).toContain('.why = keeps git history clean');
        expect(content).toContain('*');
      });
    });
  });

  given('[case3] .gitignore exists with different content', () => {
    beforeEach(() => {
      writeFileSync(resolve(repoDir, '.gitignore'), '*.log\n', 'utf8');
    });

    when('[t0] findsertRepoGitignore called', () => {
      then('overwrites with * content', () => {
        const result = findsertRepoGitignore({ repoDir });

        expect(result.status).toEqual('updated');

        const content = readFileSync(resolve(repoDir, '.gitignore'), 'utf8');
        expect(content).toContain('.what = tells git to ignore this dir');
        expect(content).toContain('.why = keeps git history clean');
        expect(content).toContain('*');
      });
    });
  });
});
```

### integration tests: invokeRolesLink.integration.test.ts additions

```ts
when('invoked with "link --repo test --role mechanic" (external repo)', () => {
  then('it should create .gitignore inside .agent/repo=test/', async () => {
    await rolesCommand.parseAsync(
      ['link', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );

    const gitignorePath = resolve(testDir, '.agent/repo=test/.gitignore');
    expect(existsSync(gitignorePath)).toBe(true);

    const content = readFileSync(gitignorePath, 'utf8');
    expect(content).toContain('.what = tells git to ignore this dir');
        expect(content).toContain('.why = keeps git history clean');
        expect(content).toContain('*');
  });
});

when('re-linking same role', () => {
  then('it should not error on existing .gitignore', async () => {
    await rolesCommand.parseAsync(
      ['link', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );
    await rolesCommand.parseAsync(
      ['link', '--repo', 'test', '--role', 'mechanic'],
      { from: 'user' },
    );

    const content = readFileSync(
      resolve(testDir, '.agent/repo=test/.gitignore'),
      'utf8',
    );
    expect(content).toContain('.what = tells git to ignore this dir');
        expect(content).toContain('.why = keeps git history clean');
        expect(content).toContain('*');
  });
});

when('linking a role from repo=.this (collocated)', () => {
  // setup with .this registry...

  then('it should NOT create .gitignore inside .agent/repo=.this/', async () => {
    await thisRolesCommand.parseAsync(
      ['link', '--repo', '.this', '--role', 'local-role'],
      { from: 'user' },
    );

    const gitignorePath = resolve(testDir, '.agent/repo=.this/.gitignore');
    expect(existsSync(gitignorePath)).toBe(false);
  });
});
```

### acceptance tests: roles.link.acceptance.test.ts additions

```ts
when('[t0] roles link --repo test-repo --role tester', () => {
  // ... existing assertions ...

  then('creates .gitignore inside .agent/repo=test-repo/', () => {
    const gitignorePath = resolve(repo.path, '.agent/repo=test-repo/.gitignore');
    expect(existsSync(gitignorePath)).toBe(true);

    const content = readFileSync(gitignorePath, 'utf-8');
    expect(content).toContain('.what = tells git to ignore this dir');
        expect(content).toContain('.why = keeps git history clean');
        expect(content).toContain('*');
  });

  then('does not modify root .gitignore', () => {
    const rootGitignorePath = resolve(repo.path, '.gitignore');
    // root .gitignore should not exist or not contain .agent entries
    if (existsSync(rootGitignorePath)) {
      const content = readFileSync(rootGitignorePath, 'utf-8');
      expect(content).not.toContain('.agent/');
    }
  });
});
```

---

## .edge cases

### handled

1. **directory exists, no .gitignore** â†’ run `git rm --cached -r`, then create gitignore
2. **.gitignore exists with correct content** â†’ no-op, return unchanged
3. **.gitignore exists with different content** â†’ overwrite with correct content
4. **linking from repo=.this** â†’ no .gitignore created (collocated roles stay tracked)
5. **re-linking same repo** â†’ idempotent
6. **dir not tracked by git** â†’ `git rm` fails silently, gitignore still created

### out of scope

1. **cleanup when directory deleted** â†’ automatic (gitignore goes with directory)

---

## .console output

```
ðŸ”— link role ehmpathy/mechanic
  - .agent/repo=ehmpathy (detached from git)      # only if was previously tracked
  + .agent/repo=ehmpathy/.gitignore (created)
  + .agent/repo=ehmpathy/readme.md
  ...
```

```
ðŸ”— link role ehmpathy/mechanic
  âœ“ .agent/repo=ehmpathy/.gitignore (unchanged)    # or no output if unchanged
  ...
```

```
ðŸ”— link role .this/local-role
  + .agent/repo=.this/readme.md                    # no .gitignore for .this
  ...
```

---

## .test matrix summary

| layer | scope | file | cases |
|-------|-------|------|-------|
| integration | findsertRepoGitignore logic | findsertRepoGitignore.integration.test.ts | 3 |
| integration | execRoleLink + gitignore | invokeRolesLink.integration.test.ts | 3 |
| acceptance | blackbox CLI behavior | roles.link.acceptance.test.ts | 2 |

---

## .implementation order

1. create `findsertRepoGitignore.ts` with integration tests
2. integrate into `execRoleLink.ts` with `.this` guard
3. add integration test assertions to `invokeRolesLink.integration.test.ts`
4. add acceptance test cases
5. verify all tests pass

---

## .simplicity note

this is the simplest possible implementation:
- one new file: `findsertRepoGitignore.ts` (~25 lines)
- one conditional call in `execRoleLink.ts` (~3 lines)
- total change: ~30 lines of production code
