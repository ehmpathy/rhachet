# research: claims

## citations

[1] npm docs - package.json bin field
    https://docs.npmjs.com/cli/v7/configuring-npm/package-json/

[2] npm docs - npx command
    https://docs.npmjs.com/cli/v7/commands/npx/

[3] dev.to - bin vs operations in package.json
    https://dev.to/rameshpvr/bin-vs-scripts-in-packagejson-1pnp

[4] dev.to - npm built-in aliases
    https://dev.to/stuartcreed/npm-in-built-aliases-1c8n

[5] bun docs - single-file executable
    https://bun.com/docs/bundler/executables

[6] greg's wiki - wrapper executable
    https://mywiki.wooledge.org/WrapperScript

[7] yosefk.com - shell arguments to subprocess
    https://yosefk.com/blog/passing-shell-script-arguments-to-a-subprocess.html

[8] github - nodejs-cli-apps-best-practices
    https://github.com/lirantal/nodejs-cli-apps-best-practices

[9] github - npm-run-all package.json
    https://github.com/mysticatea/npm-run-all/blob/master/package.json

[10] medium - what bin does in package.json
     https://medium.com/nerd-for-tech/what-bin-does-in-package-json-931d691b1e33

---

## claims

### package.json bin field

[FACT] [1] npm allows multiple bin entries in package.json
> "to use the bin field, supply it in your package.json as a map of command name to local file name"

[FACT] [1] bin entries become available globally after `npm install -g`
> "when this package is installed globally, that file will be linked where global bins go so it is available to run by name"

[FACT] [3] bin field enables global command accessibility
> "the 'bin' field is all about global accessibility. you define commands here that users can run directly from their terminal after installing your package"

[FACT] [10] bin field can point multiple commands to same or different files
> "the bin feature allows you to execute not only bash executables but any file (with the help of shebang) under the command name of your choice"

### npx behavior with multiple bins

[FACT] [2] npx auto-selects bin when package name matches
> "if the package has a single entry in its bin field in package.json, or if all entries are aliases of the same command, then that command will be used"

[FACT] [2] npx requires --package flag for non-matching bin names
> "to run a binary other than the named binary, specify one or more --package options, which will prevent npm from inferring the package from the first command argument"

[SUMP] [2] npx assumes package name equals bin name by default
> "unless a --package option is specified, npx will try to guess the name of the binary to invoke depending on the specifier provided"

### bun compilation

[FACT] [5] bun can compile to single-file executable
> "build a single executable using the compile flag: bun build ./index.js --compile"

[FACT] [5] bun compilation moves cost from runtime to build-time
> "compiled executables reduce memory usage and improve bun's start time... with compiled executables, you can move that cost from runtime to build-time"

[FACT] [5] bun executables are self-contained
> "creates a self-contained binary that includes your server code, the bun runtime... the result is a single file that can be deployed anywhere without needing node.js, bun, or any dependencies installed"

### shell wrapper best practices

[FACT] [6] always quote "$@" to prevent word splitting
> "when using $@, it's generally a good idea to always quote it to prevent word splitting"

[FACT] [6] use exec for true wrapper executables
> "the point of using exec my_command rather than plain my_command is to not leave a /bin/sh process waiting for my_command"

[FACT] [7] "$@" preserves argument boundaries
> "with '$@', the executable treats 'apple pie' and 'banana split' as separate arguments, as intended"

[SUMP] [6] wrapper executables should use most portable syntax
> "generally, when writing a wrapper, we use the most portable syntax possible. there's normally no need for fancy, shell-specific or platform-specific code"

### cli tool conventions

[FACT] [4] npm has built-in shorthand aliases
> "npm has several built-in shorthands parsed on the command-line, including: i: install, -v: --version, -g: --global"

[FACT] [9] npm-run-all provides run-s and run-p as shorthand aliases
> "both run-s and run-p are shorthand commands. run-s is for sequential, run-p is for parallel"

[SUMP] [8] cli tools should use posix-compliant syntax
> "use posix-compliant command line argument syntax, which is widely accepted as a standard for command line tools"

[OPIN] [8] users expect consistent cli conventions
> "users may get frustrated when a cli's syntax for arguments, options, or command parameters deviate from the de facto unix standards they are used to"

---

## open questions (resolved)

[KHUE] ✓ should rhx be a shell wrapper or a separate bun-compiled binary?
- **decision: shell wrapper**
- rationale: simpler, delegates to rhachet binary, ~0 maintenance
- rejected: separate binary (duplicates compilation effort, no benefit)

[KHUE] ✓ should rhx support `npx rhx` without --package flag?
- **decision: yes, register `rhx` as bin entry in package.json**
- rationale: `npx rhx` resolves because bin entry exists
- mechanism: `"bin": { "rhachet": "./bin/run", "rhx": "./bin/rhx" }`

[KHUE] ✓ should rhx be a symlink to rhachet or a separate entrypoint?
- **decision: separate entrypoint (shell wrapper)**
- rationale: cleaner separation, explicit delegation, no argv[0] detection needed
- mechanism: `bin/rhx` contains `exec rhachet run --skill "$@"`

[KHUE] ✓ what happens when rhx is called via npx vs global install?
- **answer: both work identically**
- npx: resolves `rhx` bin entry from local node_modules or fetches from registry
- global: uses symlinked `rhx` binary in PATH
- both execute the same shell wrapper that delegates to rhachet
