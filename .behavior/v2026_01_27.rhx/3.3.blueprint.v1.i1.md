# blueprint: rhx alias for rhachet run --skill

## summary

implement `rhx` as a thin shell proxy that prepends `run --skill` and delegates to the rhachet binary.

**change surface**: minimal
- 1 file created (bin/rhx)
- 1 file extended (package.json)
- 1 file extended (invokeRhachetCliBinary.ts)
- 1 file created (rhx.acceptance.test.ts)
- readme update (document rhx)

---

## filediffs

```
[+] bin/rhx                                           # shell proxy
[~] package.json                                      # add rhx bin entry
[~] accept.blackbox/.test/infra/invokeRhachetCliBinary.ts  # extend for rhx
[+] accept.blackbox/cli/rhx.acceptance.test.ts        # acceptance tests
[~] readme.md                                         # document rhx alias
```

---

## codepaths

### prod codepath

```
npx rhx say-hello
  │
  └─► bin/rhx (shell proxy)
        │
        └─► exec rhachet run --skill say-hello
              │
              └─► bin/run (dispatcher)
                    │
                    └─► bin/run.bun
                          │
                          └─► bin/run.bun.rhachet-run.bc
```

### test codepath

```
rhx.acceptance.test.ts
  │
  ├─► genTestTempRepo({ fixture: 'with-skills' })
  │     └─► creates temp repo in os.tmpdir()
  │
  ├─► invokeRhxCliBinary({ args: ['say-hello'], cwd: repo.path })
  │     └─► spawns bin/rhx with args
  │
  └─► invokeRhachetCliBinary({ args: ['run', '--skill', 'say-hello'], cwd: repo.path })
        └─► spawns bin/run with args (for comparison)
```

---

## contracts

### bin/rhx contract

```sh
#!/bin/sh
# .what = proxy that prepends `run --skill` and delegates to rhachet
# .why = shorthand for `rhachet run --skill`
exec rhachet run --skill "$@"
```

**guarantees**:
- `rhx <args>` === `rhachet run --skill <args>`
- preserves argument boundaries via `"$@"`
- no shell process left via `exec`
- posix-compliant (portable)

### package.json bin contract

```json
{
  "bin": {
    "rhachet": "./bin/run",
    "rhx": "./bin/rhx"
  }
}
```

**guarantees**:
- `npm install -g rhachet` registers both `rhachet` and `rhx` in PATH
- `pnpm add -g rhachet` registers both `rhachet` and `rhx` in PATH
- `npx rhx` resolves via bin entry (no --package flag needed)

---

## test coverage

### acceptance tests (accept.blackbox/cli/rhx.acceptance.test.ts)

| case | test | assertion |
|------|------|-----------|
| [case1] repo with skills | [t0] rhx say-hello | stdout matches rhachet run --skill say-hello |
| [case1] repo with skills | [t1] rhx say-hello | exit code matches rhachet run --skill |
| [case1] repo with skills | [t2] rhx say-hello foo | args pass through correctly |
| [case2] error cases | [t0] rhx nonexistent | error matches rhachet run --skill nonexistent |
| [case2] error cases | [t1] rhx nonexistent | exit code is non-zero |

### test strategy

tests verify **equivalence** between:
- `rhx <args>` output/status
- `rhachet run --skill <args>` output/status

no need to test internal behavior — only that the proxy produces identical results.

---

## decomposition

### no domain.objects needed

rhx is a pure shell proxy with no typescript domain logic.

### no domain.operations needed

all logic is in the shell wrapper (3 lines).

---

## implementation notes

### why shell wrapper (not bun binary)

per research claims [6][7]:
- shell wrapper is simpler, zero maintenance
- `exec` replaces shell process (no orphan)
- `"$@"` preserves argument boundaries
- posix compliant (works everywhere)

### why separate entrypoint (not symlink)

per research claims:
- cleaner separation
- explicit delegation
- no argv[0] detection needed

### invokeRhachetCliBinary extension

two options:
1. **add `binary` param**: `invokeRhachetCliBinary({ binary: 'rhx', args, cwd })`
2. **create invokeRhxCliBinary**: separate helper

recommend option 1 — minimal change, reuses infrastructure.

```ts
export const invokeRhachetCliBinary = (input: {
  binary?: 'rhachet' | 'rhx';  // default: 'rhachet'
  args: string[];
  cwd: string;
  // ...
}) => {
  const binPath = input.binary === 'rhx'
    ? resolve(__dirname, '../../../bin/rhx')
    : resolve(__dirname, '../../../bin/run');
  // ...
};
```

---

## blackbox criteria satisfaction

| usecase | satisfied by |
|---------|--------------|
| usecase.1: invoke skills via rhx shorthand | bin/rhx + package.json bin entry |
| usecase.2: install with rhx alias globally | package.json bin entry |
| usecase.3: npx without global install | package.json bin entry |
| usecase.4: readme documents rhx alias | readme update |
| usecase.5: disambiguation behavior preserved | passthrough via `"$@"` |

---

## blueprint criteria satisfaction

| contract | satisfied by |
|----------|--------------|
| rhx bin contract | bin/rhx shell proxy |
| package.json bin contract | bin entry addition |
| help output contract | (future: add to invokeRun.ts description) |
| readme contract | readme update |

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| shell compatibility | use posix `/bin/sh`, not bash-specific syntax |
| npx resolution failure | register as bin entry (verified in claims research) |
| argument boundary break | use quoted `"$@"` (verified in claims research) |

---

## maintenance burden

**minimal**:
- bin/rhx: 3 lines, zero dependencies, no updates needed
- package.json: 1 line addition, stable
- tests: verify equivalence, stable as long as `run --skill` is stable
