# blueprint: preserve `file:.` dependencies in upgrade

## summary

when `npx rhachet upgrade` runs inside a `rhachet-roles-*` repo, it must preserve any dependencies with `file:.` version specifiers. these are self-referential dependencies used for local test workflows (e.g., `"rhachet-roles-brain": "file:."` inside `rhachet-roles-brain` repo).

---

## problem statement

currently, `execNpmInstall` appends `@latest` to all packages unconditionally. when run inside a `rhachet-roles-*` repo that has itself listed as a dependency with `file:.`, the upgrade command overwrites the `file:.` with the latest published version. this breaks the local development workflow.

---

## solution approach

introduce a filter step that identifies and excludes packages with `file:.` version specifiers before the npm install command executes.

### domain operation: `getFileDotDependencies`

create a new operation to read package.json and return a set of package names that have `file:.` or `file:` prefix versions.

```
src/domain.operations/upgrade/getFileDotDependencies.ts
```

**input**: `{ cwd: string }`
**output**: `Set<string>` (package names with file:. versions)

**logic**:
1. read package.json from cwd
2. merge dependencies + devDependencies
3. filter entries where version starts with `file:` or `file:.`
4. return set of package names

### modification: `execUpgrade.ts`

update `buildInstallList` to accept excluded packages and filter them out.

**before**:
```ts
const buildInstallList = (input: {
  self: boolean;
  packages: string[];
}): string[] => {
```

**after**:
```ts
const buildInstallList = (input: {
  self: boolean;
  packages: string[];
  exclude: Set<string>;
}): string[] => {
  // ... filter out packages in exclude set
```

### modification: `execUpgrade` main flow

1. call `getFileDotDependencies({ cwd: context.cwd })`
2. pass the result as `exclude` to `buildInstallList`

---

## implementation files

### new files

| file | purpose |
|------|---------|
| `src/domain.operations/upgrade/getFileDotDependencies.ts` | reads package.json, returns file:. dependency names |
| `src/domain.operations/upgrade/getFileDotDependencies.test.ts` | unit tests for the operation |
| `accept.blackbox/.test/assets/with-file-dot-dep/package.json` | fixture with file:. dependency |

### modified files

| file | change |
|------|--------|
| `src/domain.operations/upgrade/execUpgrade.ts` | integrate file:. exclusion |
| `src/domain.operations/upgrade/execUpgrade.test.ts` | add test cases for file:. exclusion |
| `accept.blackbox/cli/upgrade.acceptance.test.ts` | add acceptance test case |

---

## detailed implementation

### 1. `getFileDotDependencies.ts`

```ts
import { readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

/**
 * .what = identifies dependencies with file:. version specifiers
 * .why = these dependencies should be excluded from upgrade (they're local refs)
 */
export const getFileDotDependencies = (input: { cwd: string }): Set<string> => {
  const packageJsonPath = join(input.cwd, 'package.json');

  // handle absent package.json gracefully
  if (!existsSync(packageJsonPath)) return new Set();

  // read and parse package.json
  const pkg = JSON.parse(readFileSync(packageJsonPath, 'utf8')) as {
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
  };

  // merge all dependencies
  const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };

  // filter to file:. versions
  const fileDotDeps = new Set<string>();
  for (const [name, version] of Object.entries(allDeps)) {
    if (version.startsWith('file:')) {
      fileDotDeps.add(name);
    }
  }

  return fileDotDeps;
};
```

### 2. `getFileDotDependencies.test.ts`

```ts
import { given, then, when, useBeforeAll } from 'test-fns';
import { writeFileSync, mkdirSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';

import { getFileDotDependencies } from './getFileDotDependencies';

describe('getFileDotDependencies', () => {
  given('[case1] package.json with file:. dependency', () => {
    const scene = useBeforeAll(() => {
      const dir = join(tmpdir(), `test-file-dot-${Date.now()}`);
      mkdirSync(dir, { recursive: true });
      writeFileSync(
        join(dir, 'package.json'),
        JSON.stringify({
          dependencies: {
            'rhachet-roles-brain': 'file:.',
            'rhachet-roles-ehmpathy': '^1.0.0',
          },
          devDependencies: {
            'rhachet': 'file:../rhachet',
          },
        }),
      );
      return { dir };
    });

    afterAll(() => rmSync(scene.dir, { recursive: true, force: true }));

    when('[t0] getFileDotDependencies is called', () => {
      then('returns set that contains file:. deps', () => {
        const result = getFileDotDependencies({ cwd: scene.dir });
        expect(result.has('rhachet-roles-brain')).toBe(true);
        expect(result.has('rhachet')).toBe(true);
      });

      then('excludes non-file:. deps', () => {
        const result = getFileDotDependencies({ cwd: scene.dir });
        expect(result.has('rhachet-roles-ehmpathy')).toBe(false);
      });
    });
  });

  given('[case2] package.json without file:. dependencies', () => {
    const scene = useBeforeAll(() => {
      const dir = join(tmpdir(), `test-no-file-dot-${Date.now()}`);
      mkdirSync(dir, { recursive: true });
      writeFileSync(
        join(dir, 'package.json'),
        JSON.stringify({
          dependencies: { 'rhachet-roles-ehmpathy': '^1.0.0' },
        }),
      );
      return { dir };
    });

    afterAll(() => rmSync(scene.dir, { recursive: true, force: true }));

    when('[t0] getFileDotDependencies is called', () => {
      then('returns empty set', () => {
        const result = getFileDotDependencies({ cwd: scene.dir });
        expect(result.size).toBe(0);
      });
    });
  });

  given('[case3] no package.json exists', () => {
    const scene = useBeforeAll(() => {
      const dir = join(tmpdir(), `test-no-pkg-${Date.now()}`);
      mkdirSync(dir, { recursive: true });
      return { dir };
    });

    afterAll(() => rmSync(scene.dir, { recursive: true, force: true }));

    when('[t0] getFileDotDependencies is called', () => {
      then('returns empty set', () => {
        const result = getFileDotDependencies({ cwd: scene.dir });
        expect(result.size).toBe(0);
      });
    });
  });
});
```

### 3. `execUpgrade.ts` modifications

```ts
// add import
import { getFileDotDependencies } from './getFileDotDependencies';

// modify buildInstallList
const buildInstallList = (input: {
  self: boolean;
  packages: string[];
  exclude: Set<string>;
}): string[] => {
  const list: string[] = [];

  // add rhachet if self upgrade requested (and not excluded)
  if (input.self && !input.exclude.has('rhachet')) {
    list.push('rhachet');
  }

  // add role packages (exclude file:. deps)
  for (const pkg of input.packages) {
    if (!input.exclude.has(pkg)) {
      list.push(pkg);
    }
  }

  return list;
};

// in execUpgrade, before buildInstallList call:
// detect file:. dependencies to exclude
const fileDotDeps = getFileDotDependencies({ cwd: context.cwd });

// log skipped packages
if (fileDotDeps.size > 0) {
  const skipped = [...fileDotDeps].filter(
    (pkg) => packages.includes(pkg) || (upgradeSelf && pkg === 'rhachet'),
  );
  if (skipped.length > 0) {
    console.log(`⏭️  skip (file:. deps): ${skipped.join(', ')}`);
  }
}

// build npm install command
const installList = buildInstallList({
  self: upgradeSelf,
  packages,
  exclude: fileDotDeps,
});
```

### 4. `execUpgrade.test.ts` additions

```ts
given('package has file:. dependency for a role package', () => {
  beforeEach(() => {
    // mock file:. detection
    jest.mock('./getFileDotDependencies', () => ({
      getFileDotDependencies: jest.fn().mockReturnValue(
        new Set(['rhachet-roles-ehmpathy']),
      ),
    }));
  });

  when('execUpgrade is called with --roles *', () => {
    then('excludes file:. packages from install', async () => {
      mockDiscoverLinkedRoles.mockReturnValue([
        { repo: 'ehmpathy', role: 'mechanic' },
      ]);
      mockResolveRolesToPackages.mockResolvedValue(['rhachet-roles-ehmpathy']);

      await execUpgrade({ roleSpecs: ['*'] }, context);

      // should NOT include rhachet-roles-ehmpathy
      expect(mockExecNpmInstall).toHaveBeenCalledWith(
        { packages: [] },
        context,
      );
    });
  });
});

given('rhachet itself has file:. dependency', () => {
  beforeEach(() => {
    jest.mock('./getFileDotDependencies', () => ({
      getFileDotDependencies: jest.fn().mockReturnValue(new Set(['rhachet'])),
    }));
  });

  when('execUpgrade is called with --self', () => {
    then('excludes rhachet from install', async () => {
      await execUpgrade({ self: true }, context);

      expect(mockExecNpmInstall).toHaveBeenCalledWith(
        { packages: [] },
        context,
      );
    });
  });
});
```

### 5. acceptance test fixture: `with-file-dot-dep/package.json`

```json
{
  "name": "rhachet-roles-test-self",
  "version": "0.0.0",
  "private": true,
  "dependencies": {
    "rhachet-roles-test-self": "file:.",
    "rhachet-roles-ehmpathy": "1.17.20"
  }
}
```

### 6. acceptance test case

```ts
given('[case5] repo with file:. self-referential dependency', () => {
  const scene = useBeforeAll(async () => {
    const repo = genTestTempRepo({
      fixture: 'with-file-dot-dep',
      install: true,
    });
    return { repo };
  });

  when('[t0] rhachet upgrade --roles *', () => {
    const result = useBeforeAll(async () =>
      invokeRhachetCliBinary({
        args: ['upgrade', '--roles', '*'],
        cwd: scene.repo.path,
      }),
    );

    then('exits with status 0', () => {
      expect(result.status).toEqual(0);
    });

    then('stdout mentions skip of file:. deps', () => {
      expect(result.stdout).toContain('skip');
      expect(result.stdout).toContain('file:.');
    });

    then('package.json still has file:. version', async () => {
      const pkg = JSON.parse(
        readFileSync(join(scene.repo.path, 'package.json'), 'utf8'),
      );
      expect(pkg.dependencies['rhachet-roles-test-self']).toEqual('file:.');
    });
  });
});
```

---

## test coverage summary

### unit tests (`getFileDotDependencies.test.ts`)

| case | description |
|------|-------------|
| [case1] | package.json with file:. dependency → returns in set |
| [case2] | package.json without file:. deps → returns empty set |
| [case3] | no package.json → returns empty set gracefully |

### unit tests (`execUpgrade.test.ts` additions)

| case | description |
|------|-------------|
| file:. role package | excludes from install list |
| file:. rhachet | excludes from install list |

### acceptance tests (`upgrade.acceptance.test.ts` additions)

| case | description |
|------|-------------|
| [case5] file:. self-ref | preserves file:. version, logs skip message |

---

## edge cases handled

1. **file:. in dependencies** → excluded
2. **file:. in devDependencies** → excluded
3. **file:../path in either** → excluded (any `file:` prefix)
4. **no package.json** → empty set, no error
5. **no file:. deps** → none excluded, normal upgrade
6. **mixed deps** → only file:. excluded, others upgraded

---

## backward compatibility

this change is fully backward compatible:
- repos without file:. deps behave identically
- no new cli flags required
- no changes that break current behavior

---

## implementation order

1. create `getFileDotDependencies.ts` + unit tests
2. modify `execUpgrade.ts` to integrate exclusion
3. update `execUpgrade.test.ts` with new cases
4. create acceptance test fixture
5. add acceptance test case
6. run full test suite to verify
