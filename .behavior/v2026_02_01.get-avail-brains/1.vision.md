# vision: getAvailableBrains

## the outcome world

### before

skill authors who want to leverage brains must manually wire up every brain:

```ts
import { genContextBrain } from 'rhachet';
import { claudeCode, claudeOpus } from 'rhachet-brains-anthropic';
import { gpt4o } from 'rhachet-brains-openai';

// manually enumerate every brain you want available
const context = genContextBrain({
  repls: [claudeCode],
  atoms: [claudeOpus, gpt4o],
  choice: 'anthropic/claude-code',
});
```

this creates friction:
- skill authors must know which brain packages are installed
- to add a new brain package requires code changes in every skill
- `--help` output can't show available brains without hardcoded values
- no way to "just use whatever brains are installed"

### after

skill authors leverage auto-discovery — brains are found automatically:

```ts
import { genContextBrain } from 'rhachet';

// auto-discovers all installed rhachet-brains-* packages
const context = await genContextBrain({
  choice: 'anthropic/claude-code',
});
```

or explicitly for `--help` output:

```ts
import { getAvailableBrains } from 'rhachet';

const brains = await getAvailableBrains(); // { atoms: BrainAtom[], repls: BrainRepl[] }

console.log('available brains:');
console.log('  atoms:', brains.atoms.map(a => a.slug).join(', '));
console.log('  repls:', brains.repls.map(r => r.slug).join(', '));
```

### the "aha" moment

> "wait, i just `npm install rhachet-brains-xai` and now grok is available everywhere? i didn't have to change any code?"

yes. brain packages self-register. skills that use discovery get new brains for free.

---

## user experience

### usecase 1: skill author who builds a review tool

**goal**: build a code review skill that works with whatever brains the user has installed

**before**:
```ts
// author must predict which brains users might have
import { claudeCode } from 'rhachet-brains-anthropic';
import { gpt4o } from 'rhachet-brains-openai';

const context = genContextBrain({
  repls: [claudeCode],
  atoms: [gpt4o],
  choice: input.brain ?? 'anthropic/claude-code',
});
```

**after**:
```ts
// just discover whatever's installed
const context = await genContextBrain({
  choice: input.brain ?? 'anthropic/claude-code',
});
```

**timeline**:
1. user installs skill package
2. user installs their preferred brain package(s)
3. user runs skill with `--brain xai/grok-3` — it just works

### usecase 2: cli help output

**goal**: show users which brains they can use

```ts
import { getAvailableBrains } from 'rhachet';

const showHelp = async () => {
  const brains = await getAvailableBrains();

  console.log(`
usage: my-skill [options]

options:
  --brain <slug>   brain to use for analysis

available brains:
  repls (agentic, tool-use):
${brains.repls.map(r => `    ${r.slug} - ${r.description}`).join('\n')}

  atoms (single-turn inference):
${brains.atoms.map(a => `    ${a.slug} - ${a.description}`).join('\n')}
  `);
};
```

### usecase 3: explicit brains (opt-out of discovery)

**goal**: skill author wants to restrict which brains are allowed

```ts
// explicit: only these brains, no discovery
const context = genContextBrain({
  brains: {
    repls: [claudeCode],
    atoms: [claudeOpus],
  },
  choice: 'anthropic/claude-code',
});
```

### usecase 4: hybrid (discovery + custom)

**goal**: discover installed brains, then extend with custom brains

```ts
const discovered = await getAvailableBrains();

const context = genContextBrain({
  brains: {
    atoms: [...discovered.atoms, myCustomAtom],
    repls: [...discovered.repls, myCustomRepl],
  },
  choice: 'my-org/custom-brain',
});
```

---

## mental model

### how users would describe this to a friend

> "rhachet auto-discovers brain packages. install `rhachet-brains-anthropic`, and claude is available. install `rhachet-brains-openai`, and gpt is available. skills don't need to know which brains you have — they just work with whatever's installed."

### analogies

| concept | analogy |
|---------|---------|
| brain packages | printer drivers — install the driver, the printer appears |
| discovery | usb plug-and-play — plug it in, it's recognized |
| `genContextBrain` | device manager — shows what's available, lets you pick |

### terms alignment

| user term | rhachet term | notes |
|-----------|--------------|-------|
| "model" | brain | users say "which model?" we say "which brain?" |
| "provider" | brain repo | anthropic, openai, xai |
| "api" vs "agent" | atom vs repl | atom = one-shot; repl = agentic loop |

---

## contract design

### getAvailableBrains

```ts
/**
 * .what = discovers all brain atoms and repls from installed rhachet-brains-* packages
 * .why = enables skills to work with whatever brains users have installed
 */
export const getAvailableBrains = async (
  context?: ContextCli,
): Promise<{ atoms: BrainAtom[]; repls: BrainRepl[] }>
```

**inputs**:
- `context?: ContextCli` — optional; defaults to `{ cwd: process.cwd() }`

**outputs**:
- `{ atoms: BrainAtom[], repls: BrainRepl[] }` — all discovered brains

**behavior**:
1. resolve cwd to find `package.json`
2. scan dependencies for `rhachet-brains-*` packages
3. dynamically import each package
4. extract and aggregate all atoms and repls
5. return deduplicated collection

### genContextBrain (updated)

```ts
// discovery mode (new default) - async
const context = await genContextBrain({
  choice: 'anthropic/claude-code',
});

// explicit mode (opt-out of discovery) - sync
const context = genContextBrain({
  brains: {
    atoms: [myAtom],
    repls: [myRepl],
  },
  choice: 'my/brain',
});
```

**signature**:

```ts
// discovery mode - async
export function genContextBrain(
  input: { choice?: string },
  context?: ContextCli,
): Promise<ContextBrain>;

// explicit mode - sync
export function genContextBrain(
  input: {
    brains: { atoms?: BrainAtom[]; repls?: BrainRepl[] };
    choice?: string;
  },
): ContextBrain;
```

---

## evaluation

### how well does it solve the goals?

| goal | solution | score |
|------|----------|-------|
| skills work with any installed brain | discovery is default | ✅ |
| `--help` can show available brains | `getAvailableBrains()` returns list | ✅ |
| no code changes upon new brain install | discovery auto-detects new packages | ✅ |
| explicit opt-out available | `{ brains: { atoms, repls } }` | ✅ |

### pros

- **zero-config default** — discovery just works
- **extensible** — new brain packages auto-appear
- **explicit opt-out** — can still hardcode brains when needed
- **composable** — discovery result can be extended

### cons

- **async requirement** — discovery needs `await`; changes sync → async signature
- **dynamic imports** — slightly slower startup (one-time cost)
- **implicit behavior** — users might not realize which brains are available

### edgecases and pit of success

| edgecase | handled via |
|----------|-------------|
| no brain packages installed | return `{ atoms: [], repls: [] }`; `BrainChoiceNotFoundError` if choice specified |
| invalid brain package (no exports) | skip with warn, don't fail discovery |
| duplicate brain slugs across packages | first-wins or error? → first-wins with warn |
| choice doesn't match any brain | `BrainChoiceNotFoundError` with helpful list (prior behavior) |
| ContextCli not provided | default to `{ cwd: process.cwd() }` |

### what's awkward?

1. **sync vs async** — `genContextBrain` becomes async in discovery mode. callers must `await`. mitigated by: sync overload for explicit brains via `{ brains: {...} }`.

2. **discovery context** — needs `ContextCli` to find `package.json`. mitigated by: optional with sensible default (`process.cwd()`).

---

## summary

the world after `getAvailableBrains`:

- skill authors write `await genContextBrain({ choice })` — discovery handles the rest
- users `npm install rhachet-brains-xai` — grok appears everywhere
- `--help` shows real available brains via `getAvailableBrains()`
- explicit mode via `{ brains: { atoms, repls } }` for controlled environments
- hybrid mode via spread: `{ brains: { atoms: [...discovered.atoms, custom] } }`
