# blueprint: getAvailableBrains

## summary

add `getAvailableBrains()` for brain package discovery, and update `genContextBrain()` to use discovery by default.

---

## filediffs

```
src/
├── domain.operations/
│   ├── brains/
│   │   ├── [+] getAvailableBrains.ts
│   │   ├── [+] getAvailableBrains.test.ts
│   │   ├── [+] getAvailableBrains.integration.test.ts
│   │   └── [○] discoverBrainPackages.ts
│   └── context/
│       ├── [~] genContextBrain.ts
│       └── [~] genContextBrain.test.ts
├── contract/
│   └── [~] sdk.ts
└── domain.objects/
    └── [○] ContextCli.ts
```

---

## codepaths

```
getAvailableBrains (input?, context?)
├── [←] discoverBrainPackages(context)           # reuse: find rhachet-brains-* packages
├── [+] importBrainPackage(packageName)          # create: dynamic import
├── [+] extractBrainsFromPackage(exports)        # create: find getBrainAtomsBy*/getBrainReplsBy*
└── [+] aggregateBrains(packages)                # create: dedupe and return { atoms, repls }

genContextBrain (input, context?)
├── [+] detectDiscoveryMode(input)               # create: no brains? → discover
├── [+] await getAvailableBrains(context)        # create: when discovery mode
├── [○] validateNoDuplicates(atoms, repls)       # retain: duplicate check
├── [○] resolveChoice(choice, atoms, repls)      # retain: choice resolution
└── [○] buildContextBrain(atoms, repls, choice)  # retain: context construction
```

---

## contracts

### getAvailableBrains

```ts
/**
 * .what = discovers all brain atoms and repls from installed rhachet-brains-* packages
 * .why = enables skills to work with whatever brains users have installed
 */
export const getAvailableBrains = async (
  input?: {},
  context?: ContextCli,
): Promise<{ atoms: BrainAtom[]; repls: BrainRepl[] }>
```

**algorithm**:
1. resolve context (default: `{ cwd: process.cwd(), gitroot: await getGitRepoRoot() }`)
2. call `discoverBrainPackages(context)` → `['rhachet-brains-anthropic', ...]`
3. for each package:
   - `import(packageName)`
   - find exports that match `getBrainAtomsBy*` → call each → collect atoms
   - find exports that match `getBrainReplsBy*` → call each → collect repls
   - on error: log warn, skip package
4. deduplicate by full slug (`repo/slug`)
5. return `{ atoms, repls }`

### genContextBrain (updated)

```ts
// discovery mode (new default) - async
export function genContextBrain(
  input: { choice?: string | { repl: string } | { atom: string } },
  context?: ContextCli,
): Promise<ContextBrain>;

// explicit mode (opt-out) - sync
export function genContextBrain(
  input: {
    brains: { atoms?: BrainAtom[]; repls?: BrainRepl[] };
    choice?: string | { repl: string } | { atom: string };
  },
): ContextBrain;
```

**mode detection**:
- `input.brains` provided → explicit mode (sync, use provided brains)
- `input.brains` absent → discovery mode (async, call `getAvailableBrains()`)

### hybrid usage (discovery + custom)

```ts
// discover installed brains, then extend with custom
const discovered = await getAvailableBrains();

const context = genContextBrain({
  brains: {
    atoms: [...discovered.atoms, myCustomAtom],
    repls: [...discovered.repls, myCustomRepl],
  },
  choice: 'my-org/custom-brain',
});
```

---

## implementation details

### extractBrainsFromPackage

brain packages export functions named `getBrainAtomsBy{Provider}` and `getBrainReplsBy{Provider}`:

```ts
// rhachet-brains-anthropic exports:
export const getBrainAtomsByAnthropic = () => [...]
export const getBrainReplsByAnthropic = () => [...]

// rhachet-brains-openai exports:
export const getBrainAtomsByOpenai = () => [...]
export const getBrainReplsByOpenai = () => [...]
```

extraction logic:

```ts
const extractBrainsFromPackage = (exports: Record<string, unknown>) => {
  const atoms: BrainAtom[] = [];
  const repls: BrainRepl[] = [];

  for (const [key, value] of Object.entries(exports)) {
    if (typeof value !== 'function') continue;

    if (key.startsWith('getBrainAtomsBy')) {
      atoms.push(...value());
    }
    if (key.startsWith('getBrainReplsBy')) {
      repls.push(...value());
    }
  }

  return { atoms, repls };
};
```

### deduplication

brains are deduplicated by full slug to handle edge case where same brain appears in multiple packages:

```ts
const dedupeBySlug = <T extends { repo: string; slug: string }>(brains: T[]): T[] => {
  const seen = new Set<string>();
  return brains.filter((b) => {
    const key = getBrainSlugFull(b);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
};
```

---

## test coverage

### unit tests

| file | coverage |
|------|----------|
| `getAvailableBrains.test.ts` | extractBrainsFromPackage logic, deduplication, error skip |
| `genContextBrain.test.ts` | mode detection, explicit mode behavior |

### integration tests

| file | coverage |
|------|----------|
| `getAvailableBrains.integration.test.ts` | real package discovery, dynamic import |

### acceptance tests

| criteria | test |
|----------|------|
| discovery returns brains | call `getAvailableBrains()`, verify non-empty |
| `genContextBrain` discovers | call without brains, verify choice works |
| explicit mode bypasses discovery | call with `brains:`, verify only those used |

---

## api changes

| change | migration |
|--------|-----------|
| `genContextBrain({ atoms, repls })` no longer supported | use `genContextBrain({ brains: { atoms, repls } })` |
| `genContextBrain()` returns `Promise` in discovery mode | add `await` |

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| dynamic import fails | wrap in try/catch, log warn, skip package |
| no brain packages installed | return empty arrays, let `BrainChoiceNotFoundError` guide user |
| circular dependency | `getAvailableBrains` imports only `discoverBrainPackages` and domain objects |
