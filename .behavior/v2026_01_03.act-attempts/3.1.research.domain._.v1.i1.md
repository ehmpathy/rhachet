# domain research: `rhachet act --attempts`

## sources

this research is based on direct codebase exploration of the rhachet CLI tool.
no external SDK research was required as this is internal domain modeling.

| # | source | path |
|---|--------|------|
| 1 | Actor domain object | `src/domain.objects/Actor.ts` |
| 2 | Role domain object | `src/domain.objects/Role.ts` |
| 3 | RoleSkill domain object | `src/domain.objects/RoleSkill.ts` |
| 4 | ActorRoleSkill domain object | `src/domain.objects/ActorRoleSkill.ts` |
| 5 | BrainRepl domain object | `src/domain.objects/BrainRepl.ts` |
| 6 | Thread domain object | `src/domain.objects/Thread.ts` |
| 7 | Stitch domain object | `src/domain.objects/Stitch.ts` |
| 8 | RoleSkillExecutable domain object | `src/domain.objects/RoleSkillExecutable.ts` |
| 9 | genActor operation | `src/domain.operations/actor/genActor.ts` |
| 10 | actorAct operation | `src/domain.operations/actor/actorAct.ts` |
| 11 | actorRun operation | `src/domain.operations/actor/actorRun.ts` |
| 12 | performInIsolatedThreads operation | `src/domain.operations/invoke/performInIsolatedThreads.ts` |
| 13 | performInIsolatedThread.invoke | `src/domain.operations/invoke/performInIsolatedThread.invoke.ts` |
| 14 | performInCurrentThread operation | `src/domain.operations/invoke/performInCurrentThread.ts` |
| 15 | invokeAct CLI | `src/contract/cli/invokeAct.ts` |
| 16 | invokeAsk CLI | `src/contract/cli/invokeAsk.ts` |
| 17 | invokeRun CLI | `src/contract/cli/invokeRun.ts` |

---

## 1. domain objects

### 1.1 entities

#### Actor [1]
- **what**: a role assumed by a brain, ready for invocation
- **unique**: `['role.slug']`
- **properties**:
  ```ts
  {
    role: TRole;                    // the role this actor assumes
    brains: BrainRepl[];            // allowlist of brains (first is default)
    act(): ActorActOp<TRole>;       // invokes rigid skills (brain-augmented)
    run(): ActorRunOp<TRole>;       // invokes solid skills (no brain)
    ask(): ActorAskOp;              // fluid conversation with default brain
  }
  ```
- **generic**: `Actor<TRole extends Role>` preserves literal skill names for type safety

#### Role [2]
- **what**: defines a role with traits, skills, and briefs
- **unique**: `['slug']`
- **properties**:
  ```ts
  {
    slug: string;                   // unique identifier (e.g., "mechanic")
    name: string;                   // display name
    purpose: string;                // why the role exists
    readme: string;                 // detailed documentation
    traits: RoleTrait[];            // behavioral modifiers
    skills: {
      solid?: Record<string, RoleSkillSchema>;   // deterministic, no brain
      rigid?: Record<string, RoleSkillSchema>;   // deterministic harness + brain
      dirs: string[];                            // directory-based discovery
      refs: RoleSkill[];                         // programmatic references
    };
    briefs: { dirs: string[] };     // knowledge library
  }
  ```

#### RoleSkill [3]
- **what**: a reusable action a role can perform (stitch-based)
- **unique**: `['slug']`
- **properties**:
  ```ts
  {
    slug: string;                           // short identifier
    readme: string;                         // full description
    route: Stitcher<TStitcher>;             // execution route
    threads: RoleSkillThreadsGetter;        // thread instantiation logic
    context: RoleSkillContextGetter;        // context instantiation logic
  }
  ```

#### BrainRepl [5]
- **what**: brain operating behind a REPL (read-execute-print-loop)
- **unique**: `['repo', 'slug']`
- **properties**:
  ```ts
  {
    repo: string;                   // plugin package (e.g., "anthropic", "openai")
    slug: string;                   // unique repl identifier (e.g., "claude-code")
    description: string;            // capabilities description
    ask<TOutput>(): Promise<TOutput>;  // readonly analysis
    act<TOutput>(): Promise<TOutput>;  // read+write actions
  }
  ```

#### Stitch [7]
- **what**: a unit of thought execution
- **primary**: `['uuid']`
- **properties**:
  ```ts
  {
    uuid: Uuid;                     // unique identifier
    createdAt: UniDateTime;         // when set
    stitcher: StitcherDesc | null;  // which stitcher created it
    trail: { desc, markers? } | null;  // execution trail
    input: any;                     // prompt input
    output: TOutput;                // result
  }
  ```

### 1.2 literals

#### ActorRoleSkill [4]
- **what**: a resolved skill ready to be acted upon
- **properties**:
  ```ts
  {
    slug: string;                   // skill identifier
    route: 'solid' | 'rigid';       // skill type
    source: 'role.skills' | '.agent/';  // where resolved from
    schema: RoleSkillSchema;        // Zod input/output validation
    executable: RoleSkillExecutable;    // executable file reference
  }
  ```

#### RoleSkillExecutable [8]
- **what**: discovered executable skill file
- **unique**: `['repoSlug', 'roleSlug', 'slug']`
- **properties**:
  ```ts
  {
    slug: string;                   // skill identifier
    path: string;                   // absolute file path
    repoSlug: string;               // registry/repo name
    roleSlug: string;               // role name
  }
  ```

#### Thread [6]
- **what**: a declaration of a thought thread
- **properties**:
  ```ts
  {
    context: TThreadContext;        // accumulated context
    stitches: Stitch<any>[];        // executed stitches
    history?: StitchSetEvent[];     // execution history (optional)
  }
  ```

### 1.3 events

#### StitchSetEvent
- **what**: records when a stitch is set on a thread
- **usage**: optional history tracking in Thread

---

## 2. domain operations

### 2.1 actor operations [9-11]

| operation | input | output | description |
|-----------|-------|--------|-------------|
| `genActor` | `{ role, brains }` | `Actor<TRole>` | creates actor from role + brain allowlist |
| `actorAct` | `{ role, brain, skill, args }` | `TOutput` | executes rigid skill with brain |
| `actorRun` | `{ skill, args }` | `TOutput` | executes solid skill via spawn |
| `actorAsk` | `{ role, brain, prompt }` | `{ response }` | fluid conversation with brain |
| `findActorRoleSkillBySlug` | `{ slug, role, route }` | `ActorRoleSkill` | resolves skill from role |
| `findActorBrainInAllowlist` | `{ brain, allowlist }` | `BrainRepl` | validates brain in allowlist |

### 2.2 invoke operations [12-14]

| operation | input | output | description |
|-----------|-------|--------|-------------|
| `performInCurrentThread` | `{ opts, registries }` | `void` | perform skill in main thread |
| `performInIsolatedThreads` | `{ opts }` | `void` | perform skill N times in isolated threads |
| `performInIsolatedThread.invoke` | `{ opts, peer }` | `{ attempt, code, clock }` | invoke single isolated execution |
| `executeSkill` | `{ skill, args, stream? }` | `TOutput \| void` | spawns skill executable |
| `getSkillThreads` | `{ getter, from }` | `TOutput` | hydrates skill threads |
| `getSkillContext` | `{ getter, from }` | `TOutput` | hydrates skill context |
| `addAttemptQualifierToOutputPath` | `{ path, attempt }` | `string` | qualifies output path with `.iN` suffix |

### 2.3 CLI operations [15-17]

| operation | command | modes | description |
|-----------|---------|-------|-------------|
| `invokeAct` | `npx rhachet act` | actor-mode only | invoke rigid skill with brain |
| `invokeAsk` | `npx rhachet ask` | stitch-mode, actor-mode | invoke skill or fluid conversation |
| `invokeRun` | `npx rhachet run` | actor-mode, command-mode | invoke solid skill |

---

## 3. relationships

### 3.1 treestruct: actor composition

```
Actor<TRole>
â”œâ”€â”€ role: Role
â”‚   â”œâ”€â”€ skills.solid: Record<string, RoleSkillSchema>   â†’ actorRun
â”‚   â”œâ”€â”€ skills.rigid: Record<string, RoleSkillSchema>   â†’ actorAct
â”‚   â”œâ”€â”€ skills.refs: RoleSkill[]                        â†’ performInCurrentThread
â”‚   â””â”€â”€ briefs: { dirs }                                â†’ brain context
â””â”€â”€ brains: BrainRepl[]
    â””â”€â”€ default: brains[0]                              â†’ actorAct, actorAsk
```

### 3.2 treestruct: skill resolution

```
skill resolution
â”œâ”€â”€ role.skills.rigid[slug]     â†’ ActorRoleSkill (route: 'rigid')
â”œâ”€â”€ role.skills.solid[slug]     â†’ ActorRoleSkill (route: 'solid')
â”œâ”€â”€ role.skills.refs[slug]      â†’ RoleSkill (stitch-based)
â””â”€â”€ .agent/ discovery           â†’ RoleSkillExecutable (shell-based)
```

### 3.3 treestruct: execution routes

```
execution routes
â”œâ”€â”€ ðŸª¨ solid (deterministic, no brain)
â”‚   â””â”€â”€ actorRun â†’ executeSkill â†’ spawn
â”œâ”€â”€ ðŸ”© rigid (deterministic harness + brain)
â”‚   â””â”€â”€ actorAct â†’ brain.act() â†’ LLM inference
â””â”€â”€ ðŸ’§ fluid (probabilistic throughout)
    â””â”€â”€ actorAsk â†’ brain.ask() â†’ open conversation
```

### 3.4 dependencies

| from | to | relationship |
|------|-----|--------------|
| Actor | Role | has-one (assumes role) |
| Actor | BrainRepl[] | has-many (brain allowlist) |
| Role | RoleSkillSchema | has-many (solid, rigid skills) |
| Role | RoleSkill | has-many (stitch skills via refs) |
| ActorRoleSkill | RoleSkillExecutable | has-one (resolved executable) |
| ActorRoleSkill | RoleSkillSchema | has-one (input/output schema) |
| performInIsolatedThreads | performInIsolatedThread.invoke | spawns-many |
| performInCurrentThread | enweaveOneStitcher | delegates-to |

---

## 4. composition to support wish

### 4.1 current state

**`invokeAsk --skill --attempts`** [16, 12]
- uses `performInIsolatedThreads` for attempts
- spawns isolated child processes
- bottleneck-controlled parallelism
- careful logging with `â—‹ i1 â€º` prefixes
- summary table output

**`invokeAct --attempts`** [15]
- uses sequential loop (NOT `performInIsolatedThreads`)
- no parallelism
- no isolated processes
- basic attempt logging

### 4.2 gap analysis

| aspect | `ask --attempts` | `act --attempts` (current) | `act --attempts` (desired) |
|--------|------------------|---------------------------|---------------------------|
| execution | parallel isolated | sequential loop | parallel isolated |
| concurrency | bottleneck-controlled | none | bottleneck-controlled |
| isolation | child processes | same process | child processes |
| logging | `â—‹ iN â€º` prefixes | basic | `â—‹ iN â€º` prefixes |
| summary | table output | none | table output |

### 4.3 required changes

1. **move `ask --skill` behavior into `act --skill`**
   - when skill is registered as rigid â†’ use `actorAct` (current behavior)
   - when skill is NOT rigid but exists as stitch â†’ use `performInCurrentThread`
   - mirrors how `invokeRun` handles solid vs shell skills

2. **standardize `--attempts` mechanism**
   - both modes should use `performInIsolatedThreads`
   - requires generalizing `performInIsolatedThreads` to support both:
     - stitch-mode (current)
     - actor-mode (new)

3. **failfast for rigid skill without `output` input**
   - validate `ActorRoleSkill.schema.input` includes `output` property
   - throw `BadRequestError` if missing when `--attempts` provided

### 4.4 domain object changes

**none required** - existing domain objects support the wish:
- `Actor<TRole>` already supports both `.act()` and stitch execution
- `ActorRoleSkill` already tracks `route` and `schema`
- `performInIsolatedThreads` is already generalized

### 4.5 operation changes

| operation | change required |
|-----------|----------------|
| `invokeAct` | refactor to use `performInIsolatedThreads` for `--attempts` |
| `invokeAsk` | deprecate `--skill` mode (move to `invokeAct`) |
| `performInIsolatedThreads` | may need minor generalization for actor-mode |
| `performInIsolatedThread.invoke` | may need to support actor-mode invocation |

### 4.6 composition diagram (desired)

```
npx rhachet act --role R --skill S --attempts N --output /path

invokeAct
â”œâ”€â”€ validate: brains available
â”œâ”€â”€ validate: role exists
â”œâ”€â”€ resolve: skill (rigid from role.skills.rigid, OR stitch from role.skills.refs)
â”œâ”€â”€ validate: if rigid + attempts â†’ skill.schema.input has 'output'
â””â”€â”€ execute:
    â”œâ”€â”€ if attempts > 1:
    â”‚   â””â”€â”€ performInIsolatedThreads
    â”‚       â”œâ”€â”€ for i in 1..N:
    â”‚       â”‚   â””â”€â”€ performInIsolatedThread.invoke
    â”‚       â”‚       â””â”€â”€ (child process)
    â”‚       â”‚           â”œâ”€â”€ if rigid: actorAct
    â”‚       â”‚           â””â”€â”€ if stitch: performInCurrentThread
    â”‚       â””â”€â”€ print summary table
    â””â”€â”€ if attempts == 1 or no attempts:
        â”œâ”€â”€ if rigid: actorAct
        â””â”€â”€ if stitch: performInCurrentThread
```
