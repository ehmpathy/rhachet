# blueprint: standardize `rhachet act --attempts`

## overview

this blueprint proposes changes to standardize `npx rhachet act --attempts` with the behavior of `npx rhachet ask --attempts`, while also moving stitch-mode skill invocation from `ask` to `act`.

---

## 1. architectural approach

### 1.1 key insight: dual-mode pattern

the `invokeRun` command already implements a dual-mode pattern:
- **actor-mode**: when skill is registered in `role.skills.solid` â†’ use `actor.run()`
- **command-mode**: otherwise â†’ use shell skill discovery via `.agent/`

we replicate this pattern for `invokeAct`:
- **actor-mode**: when skill is registered in `role.skills.rigid` â†’ use `actor.act()`
- **stitch-mode**: otherwise â†’ use `performInCurrentThread()` (thread stitching)

### 1.2 key insight: isolated thread mechanism

`invokeAsk` uses `performInIsolatedThreads` for `--attempts`:
1. spawns N child processes via `performInIsolatedThread.invoke`
2. each child deserializes opts from env and calls `performInIsolatedThread.execute`
3. `performInIsolatedThread.execute` calls `performInCurrentThread` (stitch-mode only)

to support actor-mode, we generalize the isolated thread mechanism:
- add a `mode` field to opts: `'stitch' | 'actor'`
- executor branches based on mode

---

## 2. file changes

### 2.1 modify: `src/contract/cli/invokeAct.ts`

**current**: sequential loop with `actor.act()` only
**desired**: dual-mode (actor vs stitch) + use `performInIsolatedThreads` for attempts

```
changes:
â”œâ”€â”€ add stitch skill resolution (from role.skills.refs)
â”œâ”€â”€ add mode detection (rigid â†’ actor-mode, else â†’ stitch-mode)
â”œâ”€â”€ add failfast: rigid skill must have `output` in schema.input when --attempts
â”œâ”€â”€ refactor --attempts to use performInIsolatedThreads
â”œâ”€â”€ add dynamic CLI flag injection (like invokeAsk) for stitch-mode
â””â”€â”€ deprecate direct sequential loop
```

### 2.2 modify: `src/contract/cli/invokeAsk.ts`

**current**: supports both stitch-mode (`--skill`) and actor-mode (no `--skill`)
**desired**: remove stitch-mode entirely, keep only actor-mode (fluid conversation)

```
changes:
â”œâ”€â”€ remove --skill option entirely
â”œâ”€â”€ remove --concurrency option (no longer applicable)
â”œâ”€â”€ delete performAskViaStitchMode helper
â”œâ”€â”€ delete dynamic CLI flag injection (preAction hook)
â”œâ”€â”€ keep only performAskViaActorMode (fluid conversation via actor.ask)
â”œâ”€â”€ simplify to: ask -r <role> -a <ask>
â””â”€â”€ add helpful error if --attempts is passed:
    "--attempts is inapplicable to `ask`.
     fluid skills are exploratory; outputs are divergent by design.
     did you mean `npx rhachet act`?"
```

### 2.3 modify: `src/domain.operations/invoke/performInIsolatedThreads.ts`

**current**: assumes stitch-mode only (requires `ask` in opts)
**desired**: support both stitch-mode and actor-mode

```
changes:
â”œâ”€â”€ make `ask` optional in InvokeOpts (not required for actor-mode)
â”œâ”€â”€ add `mode: 'stitch' | 'actor'` to InvokeOpts for attempts
â”œâ”€â”€ pass mode through to performInIsolatedThread
â””â”€â”€ no logic changes (just type relaxation)
```

### 2.4 modify: `src/domain.operations/invoke/performInIsolatedThread.invoke.ts`

**current**: spawns child with stitch-mode executor
**desired**: spawns child with mode-aware executor

```
changes:
â”œâ”€â”€ pass `mode` through env (RHACHET_INVOKE_MODE)
â””â”€â”€ no other changes needed (executor handles branching)
```

### 2.5 modify: `src/domain.operations/invoke/performInIsolatedThread.execute.ts`

**current**: only calls `performInCurrentThread` (stitch-mode)
**desired**: branch based on mode

```
changes:
â”œâ”€â”€ read RHACHET_INVOKE_MODE from env
â”œâ”€â”€ if mode === 'stitch': performInCurrentThread (existing)
â”œâ”€â”€ if mode === 'actor': performActorActInIsolatedThread (new)
â””â”€â”€ add performActorActInIsolatedThread inline or as import
```

### 2.6 new: `src/domain.operations/invoke/performActorActInIsolatedThread.ts`

**purpose**: execute actor.act() in an isolated child thread

```ts
/**
 * .what = executes actor.act() within an isolated thread
 * .why = enables parallel attempts for rigid skills with same isolation as stitch-mode
 */
export const performActorActInIsolatedThread = async (input: {
  opts: InvokeOpts<{
    config: string;
    role: string;
    skill: string;
    brain?: string;
    output?: string;
  }>;
}): Promise<void> => {
  // get registries + brains from config
  const { registries, brains } = await getRegistriesByOpts({ opts: input.opts });

  // find role
  const role = assureFindRole({ registries, slug: input.opts.role });

  // create actor
  const actor = genActor({ role, brains });

  // parse skill input from opts (excluding meta fields)
  const skillInput = extractSkillInputFromOpts({ opts: input.opts });

  // invoke actor.act
  const result = await actor.act({
    brain: input.opts.brain ? parseBrainRef(input.opts.brain) : undefined,
    skill: { [input.opts.skill]: skillInput },
  });

  // write output (skill handles writing via its own logic)
  // note: the skill receives --output as input and writes itself
  console.log(JSON.stringify(result, null, 2));
};
```

### 2.7 new: `src/domain.operations/invoke/assureRigidSkillHasOutputInput.ts`

**purpose**: failfast validation for rigid skill + attempts

```ts
/**
 * .what = validates rigid skill declares `output` as input
 * .why = rigid skills must accept --output to support --attempts
 */
export const assureRigidSkillHasOutputInput = (input: {
  skill: ActorRoleSkill;
  slug: string;
}): void => {
  // check if schema.input has 'output' property
  const inputShape = input.skill.schema?.input;
  if (!inputShape) return; // no schema = no validation

  // check zod shape for 'output' key
  const hasOutput = 'output' in (inputShape.shape ?? {});
  if (!hasOutput)
    BadRequestError.throw(
      `rigid skill "${input.slug}" must declare "output" as input to support --attempts`,
      { skill: input.slug, schema: inputShape },
    );
};
```

### 2.8 modify: `src/contract/cli/invokeRun.ts`

**current**: no handling for --attempts
**desired**: helpful error explaining why --attempts is inapplicable

```
changes:
â””â”€â”€ add helpful error if --attempts is passed:
    "--attempts is inapplicable to `run`.
     solid skills are deterministic; outputs are identical by design.
     did you mean `npx rhachet act`?"
```

---

## 3. data flow

### 3.1 current flow: `act --attempts` (sequential)

```
invokeAct.action
â””â”€â”€ for attempt in 1..N:
    â””â”€â”€ actor.act({ skill })
        â””â”€â”€ brain.act()
```

### 3.2 desired flow: `act --attempts` (parallel isolated)

```
invokeAct.action
â”œâ”€â”€ resolve mode (rigid â†’ actor, else â†’ stitch)
â”œâ”€â”€ validate (if rigid + attempts â†’ assureRigidSkillHasOutputInput)
â””â”€â”€ performInIsolatedThreads({ opts: { mode, ... } })
    â””â”€â”€ for attempt in 1..N (parallel via bottleneck):
        â””â”€â”€ performInIsolatedThread.invoke
            â””â”€â”€ spawn child process
                â””â”€â”€ performInIsolatedThread.execute
                    â”œâ”€â”€ if mode === 'actor':
                    â”‚   â””â”€â”€ performActorActInIsolatedThread
                    â”‚       â””â”€â”€ actor.act({ skill })
                    â””â”€â”€ if mode === 'stitch':
                        â””â”€â”€ performInCurrentThread
                            â””â”€â”€ enweaveOneStitcher
```

---

## 4. interface changes

### 4.1 InvokeOpts extension

```ts
// current
InvokeOpts<{ config: string; ask: string; output?: string }>

// desired
InvokeOpts<{
  config: string;
  mode: 'stitch' | 'actor';
  // stitch-mode fields
  ask?: string;
  // actor-mode fields
  role?: string;
  skill?: string;
  brain?: string;
  // shared fields
  output?: string;
}>
```

### 4.2 CLI changes

```
# current act
npx rhachet act -r <role> -s <skill> [--brain <ref>] [-i <json>] [-o <output>] [--attempts N]

# desired act (adds stitch-mode support + parallel attempts)
npx rhachet act -r <role> -s <skill> [--brain <ref>] [-i <json>] [-o <output>] [--attempts N] [--concurrency N]
  # if skill in role.skills.rigid â†’ actor-mode (brain.act)
  # if skill in role.skills.refs â†’ stitch-mode (thread stitching, with dynamic flags)

# current ask
npx rhachet ask -r <role> [-s <skill>] [-a <ask>] [--attempts N] [--concurrency N]

# desired ask (stitch-mode removed entirely)
npx rhachet ask -r <role> -a <ask>
  # only actor-mode (fluid conversation via brain.ask)
  # --skill, --attempts, --concurrency options removed
```

---

## 5. test coverage

### 5.1 acceptance tests: `accept.blackbox/cli/act.acceptance.test.ts`

```ts
describe('rhachet act', () => {
  // usecase.1: actor-mode (rigid skill)
  given('[case1] repo with registered rigid skill', () => {
    when('[t0] act --role --skill', () => {
      then('executes with brain augmentation');
      then('stdout shows ðŸ”© skill prefix');
    });
    when('[t1] act --role --skill --brain', () => {
      then('uses specified brain');
    });
  });

  // usecase.2: stitch-mode (fallback)
  given('[case2] repo with stitch skill only', () => {
    when('[t0] act --role --skill', () => {
      then('executes via thread stitching');
    });
  });

  // usecase.3: --attempts parallel
  given('[case3] repo with skill', () => {
    when('[t0] act --attempts 3 --output /path', () => {
      then('executes 3 times in parallel');
      then('logs with â—‹ iN â€º prefix');
      then('outputs qualified with .iN suffix');
      then('shows summary table');
    });
  });

  // usecase.5: --attempts requires --output
  given('[case5] any repo', () => {
    when('[t0] act --attempts 3 without --output', () => {
      then('fails with "--attempts requires --output path"');
    });
  });

  // usecase.6: rigid skill failfast
  given('[case6] rigid skill without output input', () => {
    when('[t0] act --attempts 3 --output /path', () => {
      then('fails with "rigid skill must declare output as input"');
    });
  });

  // boundary cases
  given('[case7] attempts edge cases', () => {
    when('[t0] --attempts 0', () => then('fails: must be >= 1'));
    when('[t1] --attempts 1 --output /path', () => then('no suffix on output'));
  });
});
```

### 5.2 integration tests: `src/contract/cli/invokeAct.integration.test.ts`

```ts
describe('invokeAct', () => {
  // extend existing tests with:
  given('[case-stitch] stitch-mode skill', () => {
    when('[t0] invoked via act', () => {
      then('executes via performInCurrentThread');
    });
  });

  given('[case-attempts-parallel] --attempts with concurrency', () => {
    when('[t0] --attempts 3 --concurrency 2', () => {
      then('at most 2 concurrent executions');
    });
  });
});
```

---

## 6. migration summary

this is a **clean move**, not a phased deprecation:

| command | before | after |
|---------|--------|-------|
| `ask --skill` | stitch-mode skill invocation | **removed** (use `act --skill`) |
| `ask` (no skill) | fluid conversation | fluid conversation (unchanged) |
| `act --skill` | rigid skill only | **rigid OR stitch** (dual-mode) |
| `act --attempts` | sequential loop | **parallel isolated threads** |

### breaking change

`npx rhachet ask --skill <slug>` will no longer work.
users must use `npx rhachet act --skill <slug>` instead.

---

## 7. risk analysis

| risk | mitigation |
|------|------------|
| breaking existing `act` users | opts remain compatible; only adds new functionality |
| breaking existing `ask --skill` users | **intentional breaking change** - behavior moved to `act --skill` |
| isolated thread env deserialization | reuse existing pattern from stitch-mode |
| mode detection false positives | explicit check: `role.skills.rigid[slug]` exists |

---

## 8. implementation order

1. **`assureRigidSkillHasOutputInput.ts`** - new validation helper
2. **`performActorActInIsolatedThread.ts`** - new isolated executor for actor-mode
3. **`performInIsolatedThread.execute.ts`** - add mode branching
4. **`performInIsolatedThread.invoke.ts`** - pass mode via env
5. **`performInIsolatedThreads.ts`** - relax types for actor-mode
6. **`invokeAct.ts`** - refactor to dual-mode + isolated threads
7. **`invokeAsk.ts`** - remove stitch-mode, add helpful --attempts error
8. **`invokeRun.ts`** - add helpful --attempts error
9. **tests** - acceptance + integration coverage
