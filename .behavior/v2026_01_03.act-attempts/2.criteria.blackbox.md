# blackbox criteria = experience bounds for `rhachet act --attempts`

## usecase.1 = `act --skill` invokes rigid skill with brain (actor-mode)

given('a repo with a registered rigid skill')
  when('user invokes `npx rhachet act --role <role> --skill <skill>`')
    then('skill executes with brain augmentation')
    then('stdout shows `ðŸ”© skill "<skill>" from role="<role>"`')
    then('exit code 0 on success')
      sothat('users can invoke brain-augmented skills')

given('a repo with a registered rigid skill')
  when('user invokes `npx rhachet act --role <role> --skill <skill> --brain <repo/slug>`')
    then('skill executes with specified brain')
    then('brain must be in allowlist or error')
      sothat('users can control which brain to use')


## usecase.2 = `act --skill` invokes stitch skill (stitch-mode fallback)

given('a repo where skill is NOT registered as rigid but exists as stitch skill')
  when('user invokes `npx rhachet act --role <role> --skill <skill>`')
    then('skill executes via thread stitching (same behavior as legacy `ask --skill`)')
    then('stdout shows appropriate stitch execution output')
    then('exit code 0 on success')
      sothat('users can invoke stitch skills via `act` without separate `ask --skill` command')

given('a repo with skill registered as BOTH rigid and stitch')
  when('user invokes `npx rhachet act --role <role> --skill <skill>`')
    then('rigid (actor) version takes precedence')
      sothat('users get brain-augmented execution when available')


## usecase.3 = `act --attempts` parallelizes execution with isolated threads

given('a repo with a rigid skill')
  when('user invokes `npx rhachet act --role <role> --skill <skill> --attempts 3 --output /path/to/output.json`')
    then('skill executes 3 times in parallel isolated threads')
    then('each thread logs with prefix like `â—‹ i1 â€º`, `â—‹ i2 â€º`, `â—‹ i3 â€º`')
    then('`--output` is qualified with suffix before passing to skill: `/path/to/output.i1.json`, `.i2.json`, `.i3.json`')
    then('stdout shows summary table with pass/fail status per attempt')
    then('stdout shows total wall time and success/failure counts')
    then('exit code 0 if all attempts succeed, exit code 1 if any fail')
      sothat('users can generate multiple independent outputs efficiently')

given('a repo with a stitch skill (fallback mode)')
  when('user invokes `npx rhachet act --role <role> --skill <skill> --attempts 3 --output /path/to/output.md`')
    then('skill executes 3 times in parallel isolated threads (same mechanism as rigid mode)')
    then('`--output` is qualified with suffix before passing to skill')
    then('summary table displayed')
      sothat('parallelization works consistently regardless of skill type')


## usecase.4 = `act --attempts` respects concurrency limits

given('a repo with a skill')
  when('user invokes `npx rhachet act --skill <skill> --attempts 10 --output /path --concurrency 2`')
    then('at most 2 attempts execute in parallel at any time')
      sothat('users can control resource usage')

given('a repo with a skill')
  when('user invokes `npx rhachet act --skill <skill> --attempts 5 --output /path`')
    then('default concurrency of 3 is applied')
      sothat('reasonable parallelism by default')


## usecase.5 = `act --attempts` requires `--output`

given('any repo with a skill')
  when('user invokes `npx rhachet act --skill <skill> --attempts 3` WITHOUT `--output`')
    then('command fails immediately')
    then('stderr shows error: "--attempts requires --output path"')
    then('exit code non-zero')
      sothat('users know output path is mandatory for multiple attempts')


## usecase.6 = rigid skill via actor-mode failfast on missing `--output` input

given('a repo with a rigid skill that does NOT have `output` as a declared input')
  when('user invokes `npx rhachet act --role <role> --skill <skill> --attempts 3 --output /path`')
    then('command fails immediately with clear error')
    then('error indicates rigid skill must declare `output` as input for `--attempts` support')
    then('exit code non-zero')
      sothat('users know their skill schema must support output for attempts')


## usecase.7 = single execution (no `--attempts`) behavior

given('a repo with a skill')
  when('user invokes `npx rhachet act --skill <skill>` without `--attempts`')
    then('skill executes once')
      sothat('simple single invocation works')

given('a repo with a skill that accepts `--output`')
  when('user invokes `npx rhachet act --skill <skill> --output /path/to/output.json` without `--attempts`')
    then('skill executes once')
    then('`--output` is passed to skill as input (skill handles writing, not CLI)')
      sothat('CLI does not special-case output handling')


## usecase.8 = error handling for invalid inputs

given('any repo')
  when('user invokes `npx rhachet act --role <nonexistent>`')
    then('command fails with clear error: role not found')
    then('exit code non-zero')

given('any repo')
  when('user invokes `npx rhachet act --role <role> --skill <nonexistent>`')
    then('command fails with clear error: skill not found')
    then('exit code non-zero')

given('a repo without brains configured')
  when('user invokes `npx rhachet act --role <role> --skill <skill>`')
    then('command fails with error: "no brains available. add getBrainRepls() to your rhachet.use.ts"')
    then('exit code non-zero')
      sothat('users know how to configure brains')

given('a repo with brains configured')
  when('user invokes `npx rhachet act --brain invalidformat`')
    then('command fails with error: brain must be in `repo/slug` format')
    then('exit code non-zero')

given('a repo with brains configured')
  when('user invokes `npx rhachet act --brain repo/slug` where slug is not in allowlist')
    then('command fails with error: brain not in allowlist')
    then('exit code non-zero')


## usecase.9 = dynamic input flags from skill schema

given('a rigid skill with declared inputs `{ topic: string, depth: number }`')
  when('user invokes `npx rhachet act --skill <skill> --topic "AI" --depth 3`')
    then('inputs are parsed and passed to skill')
      sothat('skill inputs are configurable via CLI flags')

given('a rigid skill with declared inputs')
  when('user invokes `npx rhachet act --skill <skill> -i \'{"topic": "AI", "depth": 3}\'`')
    then('JSON input is parsed and passed to skill')
      sothat('complex inputs can be provided as JSON')


## usecase.10 = `ask --skill` is removed

given('any repo')
  when('user invokes `npx rhachet ask --skill <skill>`')
    then('command fails with error: --skill option no longer exists')
    then('error message suggests using `act --skill` instead')
      sothat('skill invocation is consolidated under `act` command')


## usecase.11 = `ask --attempts` explains why inapplicable

given('any repo')
  when('user invokes `npx rhachet ask --attempts N`')
    then('command fails with helpful error')
    then('error states: --attempts is inapplicable to `ask`')
    then('error explains: fluid skills are exploratory; outputs are divergent by design')
    then('error asks: did you mean `npx rhachet act`?')
      sothat('users understand the conceptual difference and are guided without being told what to do')


## usecase.12 = `run --attempts` explains why inapplicable

given('any repo')
  when('user invokes `npx rhachet run --attempts N`')
    then('command fails with helpful error')
    then('error states: --attempts is inapplicable to `run`')
    then('error explains: solid skills are deterministic; outputs are identical by design')
    then('error asks: did you mean `npx rhachet act`?')
      sothat('users understand determinism and are guided without being told what to do')


## boundary cases

given('attempts value edge cases')
  when('user invokes with `--attempts 0`')
    then('command fails with error: attempts must be >= 1')
  when('user invokes with `--attempts -1`')
    then('command fails with error: attempts must be >= 1')
  when('user invokes with `--attempts 1 --output /path`')
    then('single execution, `--output` passed to skill without suffix')
  when('user invokes with `--attempts abc`')
    then('command fails with error: attempts must be integer')

given('concurrency value edge cases')
  when('user invokes with `--concurrency 0`')
    then('command fails with error: concurrency must be >= 1')
  when('user invokes with `--concurrency -1`')
    then('command fails with error: concurrency must be >= 1')

given('partial attempt failures')
  when('2 of 3 attempts succeed, 1 fails')
    then('summary table shows 2 ok, 1 fail')
    then('exit code is 1')
    then('successful attempt outputs exist (skill wrote them)')
      sothat('partial success is preserved')
