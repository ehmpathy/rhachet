# research: prod codepath patterns for keyrack --owner

## pattern.1 = host manifest path resolution [REUSE]

**file:** `src/domain.operations/keyrack/getKeyrackHostManifestPath.ts:24-33`

```typescript
export const getKeyrackHostManifestPath = (input: {
  owner: string | null;
}): string => {
  const home = getHomeDir();
  const filename =
    input.owner === null
      ? 'keyrack.host.age'                        // default
      : `keyrack.host.${input.owner}.age`;        // per-owner
  return join(home, '.rhachet', 'keyrack', filename);
};
```

**relation:** already namespaced per owner. no changes needed.

---

## pattern.2 = daemon socket path resolution [REUSE]

**file:** `src/domain.operations/keyrack/daemon/infra/getKeyrackDaemonSocketPath.ts:18-51`

```typescript
const owner = input?.owner ?? null;
const filename =
  owner === null
    ? `keyrack.${sessionId}.sock`                    // default
    : `keyrack.${sessionId}.${owner}.sock`;          // per-owner
return `${runtimeDir}/${filename}`;
```

**relation:** already namespaced per owner. no changes needed.

---

## pattern.3 = cli flag parse [EXTEND]

**file:** `src/contract/cli/invokeKeyrack.ts`

current state — inconsistent flags:
- init: `--for <owner>` (line 49)
- set: `--for <owner>` (line 517)
- get: `--owner <owner>` (line 266)
- status: `--for <owner>` (line 990)
- recipient set: `--for <owner>` (line 162)
- unlock: `--for <owner>` (line 845)
- relock: `--for <owner>` (line 943)
- del: `--for <owner>` (line 736)
- list: `--for <owner>` (line 1048)

**relation:** need to standardize all to `--owner` with `--for` as alias. the get command already uses `--owner`.

---

## pattern.4 = os.direct vault adapter [EXTEND]

**file:** `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsDirect.ts:39-49`

```typescript
const getDirectStorePath = (): string => {
  const home = getHomeDir();
  return join(
    home,
    '.rhachet',
    'keyrack',
    'vault',
    'os.direct',
    'keyrack.direct.json',  // ⚠️ single file for all owners
  );
};
```

**relation:** **GAP** — needs owner namespace. change to:
```
os.direct/owner=default/keyrack.direct.json
os.direct/owner={owner}/keyrack.direct.json
```

---

## pattern.5 = os.secure vault adapter [EXTEND]

**file:** `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsSecure.ts:40-52`

```typescript
const getSecureVaultDir = (): string => {
  const home = getHomeDir();
  return join(home, '.rhachet', 'keyrack', 'vault', 'os.secure');
};

const getCredentialPath = (slug: string): string => {
  const hash = asHashSha256Sync(slug).slice(0, 16);
  return join(getSecureVaultDir(), `${hash}.age`);  // ⚠️ single dir for all owners
};
```

**relation:** **GAP** — needs owner namespace. change to:
```
os.secure/owner=default/{hash}.age
os.secure/owner={owner}/{hash}.age
```

---

## pattern.6 = os.daemon vault adapter [REUSE]

**file:** `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsDaemon.ts:43-55`

```typescript
get: async (input: { slug: string }) => {
  const result = await daemonAccessGet({ slugs: [input.slug] });
  // ...
}
```

**relation:** daemon access is already per-owner via socket path. each owner has separate daemon socket, so vault storage within daemon is isolated. no changes needed to adapter itself.

note: daemon socket path already namespaced (see pattern.2).

---

## pattern.7 = genKeyrackHostContext [REUSE]

**file:** `src/domain.operations/keyrack/genKeyrackHostContext.ts:38-72`

```typescript
export const genKeyrackHostContext = async (input: {
  owner: string | null;
}): Promise<KeyrackHostContext> => {
  const { owner } = input;
  const hostManifest = await daoKeyrackHostManifest.get({ owner });
  // ...
};
```

**relation:** already accepts and threads owner through. vault adapters are initialized here — this is where owner needs to be passed to vault adapters.

---

## pattern.8 = host manifest dao [REUSE]

**file:** `src/access/daos/daoKeyrackHostManifest/index.ts:140-271`

```typescript
get: async (input: {
  owner?: string | null;
  prikey?: string;
}): Promise<KeyrackHostManifest | null> => {
  const owner = input.owner ?? null;
  const path = getKeyrackHostManifestPath({ owner });
  // ...
}
```

**relation:** already threads owner through to path resolution. no changes needed.

---

## pattern.9 = context for get operations [EXTEND]

**file:** `src/domain.operations/keyrack/genContextKeyrackGrantGet.ts:35-66`

```typescript
export const genContextKeyrackGrantGet = async (input: {
  gitroot: string;
  // ⚠️ no owner parameter
}): Promise<ContextKeyrackGrantGet>
```

**relation:** get context doesn't accept owner. need to add owner parameter so vault adapters can be namespaced properly.

---

## summary

| pattern | action | reason |
|---------|--------|--------|
| host manifest path | [REUSE] | already namespaced per owner |
| daemon socket path | [REUSE] | already namespaced per owner |
| cli flag parse | [EXTEND] | standardize `--for` → `--owner` everywhere |
| os.direct vault | [EXTEND] | add `owner={owner}/` directory namespace |
| os.secure vault | [EXTEND] | add `owner={owner}/` directory namespace |
| os.daemon vault | [REUSE] | already isolated via daemon socket |
| genKeyrackHostContext | [REUSE] | already accepts owner |
| host manifest dao | [REUSE] | already threads owner |
| genContextKeyrackGrantGet | [EXTEND] | add owner parameter |

---

## key insight

the host manifest and daemon socket are already namespaced per owner — that's good.

the vault adapters (os.direct, os.secure) are the gap. they use a single shared store, which means keys from different owners could collide or overwrite each other.

the fix is to thread `owner` through to vault adapters and namespace their storage paths:

```
before:
  os.direct/keyrack.direct.json
  os.secure/{hash}.age

after:
  os.direct/owner=default/keyrack.direct.json
  os.direct/owner={owner}/keyrack.direct.json
  os.secure/owner=default/{hash}.age
  os.secure/owner={owner}/{hash}.age
```
