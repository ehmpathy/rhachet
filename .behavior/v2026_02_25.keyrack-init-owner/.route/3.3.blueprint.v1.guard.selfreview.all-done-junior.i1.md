# junior review: keyrack init --owner

## reviewer role

review of this implementation as a check of a junior's work. scope:
- correctness against criteria
- edge cases missed
- code quality concerns
- test coverage gaps

---

## implementation review

### critical fix in unlockKeyrackKeys.ts ✅

the fix passes `owner: input.owner ?? null` to `adapter.get()`. reviewed the diff:

```diff
- const secret = await adapter.get({ slug, exid: hostConfig.exid });
+ const secret = await adapter.get({
+   slug,
+   exid: hostConfig.exid,
+   owner: input.owner ?? null,
+ });
```

**assessment:** correct. without this, unlock reads from wrong vault path for custom owners.

### test file keyrack.owner.acceptance.test.ts ✅

reviewed all 7 given blocks:
- case1: init command (3 scenarios)
- case2: set command (2 scenarios)
- case3: get isolation (2 scenarios)
- case4: vault file structure (1 scenario, 3 assertions)
- case5: status isolation (2 scenarios)
- case6: flag consistency (4 scenarios)
- case7: fallback pattern (2 scenarios)

**assessment:** comprehensive coverage of the criteria.

---

## criteria verification

### usecase.1 = init custom owner

| criterion | tested | evidence |
|-----------|--------|----------|
| manifest created at correct path | ✅ | case1 t0 checks `keyrack.host.ehmpath.demo.age` |
| output shows "freshly minted" | ✅ | case1 t0 asserts `stdout.contains('freshly minted')` |
| output shows owner name | ✅ | case1 t0 asserts `stdout.contains('ehmpath.demo')` |
| extant manifest shows "found" | ✅ | case1 t1 asserts `stdout.contains('already active')` |
| --for alias works | ✅ | case1 t2 uses `--for` flag |

### usecase.2 = set key with custom owner

| criterion | tested | evidence |
|-----------|--------|----------|
| key stored in owner-namespaced path | ✅ | case2 t0 checks `owner=ehmpath.demo/keyrack.direct.json` |
| error when no manifest | ✅ | case2 t1 checks non-zero exit and error message |
| error includes tip | ✅ | case2 t1 checks for init/manifest keywords |

### usecase.3 = get key with custom owner

| criterion | tested | evidence |
|-----------|--------|----------|
| key found for custom owner | ✅ | case3 t1, case7 t1 |
| key not found from wrong owner | ✅ | case7 t0 |
| isolation between owners | ✅ | case3 demonstrates different values |

### usecase.4 = vault isolation per owner

| criterion | tested | evidence |
|-----------|--------|----------|
| physical file separation | ✅ | case4 verifies both directories |
| default owner path | ✅ | case4 checks `owner=default` |
| custom owner path | ✅ | case4 checks `owner=ehmpath.demo` |

### usecase.5 = status with custom owner

| criterion | tested | evidence |
|-----------|--------|----------|
| shows keys for correct owner | ✅ | case5 t1 (list --owner) |
| does not show other owner's keys | ✅ | case5 t0 (default status) |

### usecase.6 = --owner flag consistency

| criterion | tested | evidence |
|-----------|--------|----------|
| init | ✅ | case1 |
| set | ✅ | case2 |
| get | ✅ | case3, case7 |
| list | ✅ | case5 t1, case6 t0 |
| unlock | ✅ | case6 t1, case7 setup |
| relock | ✅ | case6 t2 |
| recipient set | ✅ | case6 t3 |

### usecase.7 = fallback pattern

| criterion | tested | evidence |
|-----------|--------|----------|
| default owner returns not granted | ✅ | case7 t0 |
| demo owner returns granted | ✅ | case7 t1 |
| value matches demo owner | ✅ | case7 t1 second assertion |

---

## code verification

### verified: unlockKeyrackKeys.ts line 152-155
```typescript
const secret = await adapter.get({
  slug,
  exid: hostConfig.exid,
  owner: input.owner ?? null,  // ✅ owner parameter added
});
```

### verified: unlockKeyrackKeys.ts line 35
```typescript
const socketPath = getKeyrackDaemonSocketPath({ owner: input.owner ?? null });  // ✅ per-owner daemon
```

### verified: getKeyrackKeyGrant.ts line 106-109
```typescript
const daemonResult = await daemonAccessGet({
  slugs: [slug],
  owner: context.owner,  // ✅ owner flows through context
});
```

### verified: writeDirectStoreEntry.ts line 17-18
```typescript
const ownerDir = `owner=${input.owner ?? 'default'}`;
const path = join(home, '.rhachet', 'keyrack', 'vault', 'os.direct', ownerDir, 'keyrack.direct.json');  // ✅ test helper supports owner
```

---

## potential concerns checked

### concern 1: race conditions in tests?
**check:** tests use `useBeforeAll` which runs once per suite. setup order is deterministic.
**verdict:** no issue

### concern 2: test cleanup?
**check:** tests use temp repos via `genTestTempRepo`. no shared state between given blocks.
**verdict:** no issue

### concern 3: daemon state leakage?
**check:** `beforeAll` kills daemons for both owners before tests run.
**verdict:** addressed

### concern 4: case7 uses sudo env - is that correct?
**check:** yes. sudo keys unlock directly from hostManifest without repoManifest. the test comment explains this.
**verdict:** correct design decision

### concern 5: case7 adds unlock step - required?
**check:** yes. `keyrack get` reads from daemon only. keys must be unlocked first.
**verdict:** matches design

### concern 6: owner flows through entire codepath?
**check:** verified via grep:
- unlockKeyrackKeys.ts → adapter.get({ owner })
- unlockKeyrackKeys.ts → getKeyrackDaemonSocketPath({ owner })
- getKeyrackKeyGrant.ts → daemonAccessGet({ owner: context.owner })
**verdict:** owner flows correctly through all paths

---

## gaps found

none. the implementation covers all criteria.

---

## conclusion

the junior's work is complete and correct. all criteria are tested. the critical fix in `unlockKeyrackKeys.ts` addresses the root cause. the test coverage is comprehensive.

**recommendation:** approve and mark stone as passed.
