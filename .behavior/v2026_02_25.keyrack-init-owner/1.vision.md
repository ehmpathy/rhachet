# vision: keyrack init --owner

## the outcome world

### day-in-the-life

**before:**
```sh
# maintainer tries to init keyrack for their demo owner
$ npx rhachet keyrack init --owner ehmpath.demo
error: Unknown option '--owner'

# confused, they try --for
$ npx rhachet keyrack init --for ehmpath.demo
ğŸ” keyrack init
   â”œâ”€ host manifest: freshly minted âœ¨
   â”‚   â”œâ”€ path: ~/.rhachet/keyrack/keyrack.host.ehmpath.demo.age
   â”‚   â”œâ”€ owner: ehmpath.demo
   â”‚   â””â”€ recipient: default
   â””â”€ repo manifest: not in repo
       â””â”€ run 'rhachet keyrack init --org <org>' to init one

# wait, that worked? but why is it --for on init but --owner on get/set?
# this is confusing...
```

**after:**
```sh
# maintainer inits keyrack for their demo owner
$ npx rhachet keyrack init --owner ehmpath.demo
ğŸ” keyrack init
   â”œâ”€ host manifest: freshly minted âœ¨
   â”‚   â”œâ”€ path: ~/.rhachet/keyrack/keyrack.host.ehmpath.demo.age
   â”‚   â”œâ”€ owner: ehmpath.demo
   â”‚   â””â”€ recipient: default
   â””â”€ repo manifest: not in repo

# consistent --owner flag across all commands
$ npx rhachet keyrack set --key DEMO_TOKEN --vault os.direct --owner ehmpath.demo --org @all
enter secret for DEMO_TOKEN: ****

ğŸ” keyrack set (org: @all, env: all)
   â””â”€ @all.all.DEMO_TOKEN
      â”œâ”€ mech: PERMANENT_VIA_REPLICA
      â””â”€ vault: os.direct

# skill can now try both owners
$ npx rhachet keyrack get --key DEMO_TOKEN --owner ehmpath.demo --org @all
ğŸ” keyrack
   â””â”€ @all.all.DEMO_TOKEN
      â”œâ”€ vault: os.direct
      â”œâ”€ mech: PERMANENT_VIA_REPLICA
      â””â”€ status: granted ğŸ”‘
```

### before/after contrast

| aspect | before | after |
|--------|--------|-------|
| flag consistency | `--for` on init/set, `--owner` on get | `--owner` everywhere (with `--for` as alias) |
| demo key setup | blocked â€” unclear how to init custom owner | smooth â€” `init --owner` works |
| vault isolation | untested â€” demo could overwrite prod? | tested â€” vault entries namespaced per owner |
| test credentials | use same keys as prod (risky) | separate demo manifests with narrow-priv keys |

### the "aha" moment

the value clicks when a maintainer realizes:
- "i can have passwordless ssh key for demo tests (convenience)"
- "i can have passphrase-protected key for prod (security)"
- "they live in completely separate manifests"
- "my tests can use `--owner demo` as fallback without touching prod"

---

## user experience

### usecases

1. **demo credential setup** â€” maintainers create a separate keyrack owner for integration tests with narrow-priv tokens
2. **prod/demo isolation** â€” demo keys use passwordless ssh for automated tests; prod keys stay passphrase-protected
3. **fallback pattern** â€” skills try default owner first, fall back to demo owner for tests

### contract inputs & outputs

#### init

```sh
# input
npx rhachet keyrack init --owner <owner> [--pubkey <path>] [--label <label>]

# output (json)
{
  "host": {
    "effect": "created" | "found",
    "manifestPath": "~/.rhachet/keyrack/keyrack.host.<owner>.age",
    "owner": "<owner>",
    "recipient": { "mech": "age", "pubkey": "age1...", "label": "default" }
  },
  "repo": null
}
```

#### set (with owner)

```sh
# input
npx rhachet keyrack set --key DEMO_TOKEN --vault os.direct --owner ehmpath.demo --org @all

# stores in:
# - host manifest: ~/.rhachet/keyrack/keyrack.host.ehmpath.demo.age
# - vault file: ~/.rhachet/keyrack/vault/os.direct/owner=ehmpath.demo/keyrack.direct.json
```

#### get (with owner fallback)

```sh
# try default first
value=$(npx rhachet keyrack get --key DEMO_TOKEN --org @all --json 2>/dev/null | jq -r '.grant.value // empty')

# fallback to demo owner
if [ -z "$value" ]; then
  value=$(npx rhachet keyrack get --key DEMO_TOKEN --org @all --owner ehmpath.demo --json | jq -r '.grant.value')
fi
```

### timelines

1. **setup (once per machine)**
   - `keyrack init --owner demo` â€” creates demo manifest with passwordless key
   - `keyrack set --key X --vault os.direct --owner demo` â€” stores demo creds

2. **usage (every test run)**
   - skill tries `keyrack get --key X` (default owner)
   - if locked/absent, falls back to `keyrack get --key X --owner demo`
   - demo owner is unlocked (passwordless key), returns value

---

## mental model

### how users describe it

> "i have two keyracks â€” one for real credentials (protected) and one for demo credentials (easy access). the demo one uses a passwordless ssh key so tests can grab tokens without prompts."

### analogies

| concept | analogy |
|---------|---------|
| owner | a separate keychain on your keyring |
| manifest | the encrypted container for that keychain |
| vault | the physical lock mechanism (os.secure = combination lock, os.direct = unlocked drawer) |
| fallback | try your main keychain first, then check your spare |

### terms mapping

| user term | internal term | what it means |
|-----------|---------------|---------------|
| "demo keyrack" | `--owner ehmpath.demo` | separate manifest with demo identity |
| "main keyrack" | `--owner` omitted (null) | default manifest |
| "passwordless key" | `cipher: none` in ssh key | enables automated access |
| "fallback" | try default, then demo | resilient credential fetch |

---

## evaluation

### how well does it solve the goals?

| goal | solved? | how |
|------|---------|-----|
| init custom owner | âœ… | `init --owner` works (consistency with get/set) |
| demo key isolation | âœ… | separate manifest + separate vault storage |
| passwordless demo | âœ… | each owner can have different ssh key with different cipher |
| test coverage | âœ… | acceptance tests verify vault isolation per owner |

### pros

- **consistent api** â€” `--owner` works on all commands
- **full isolation** â€” manifests AND vault files are namespaced
- **backwards compat** â€” `--for` still works as alias
- **pit of success** â€” demo keys can't accidentally overwrite prod

### cons

- **one more flag** â€” `--owner` to remember (but it's consistent)
- **multiple manifests** â€” must init each owner separately (intentional friction)

### edgecases and pit of success

| edgecase | protection |
|----------|------------|
| demo key overwrites prod | vault files namespaced per owner â€” impossible |
| forget which owner | `keyrack status --owner X` shows keys for that owner |
| use wrong key in prod | default owner (prod) is the default path; demo requires explicit flag |
| demo key in wrong vault | each vault type is namespaced separately per owner |

### vault namespace (key insight)

the critical protection is that **vault storage is namespaced per owner**:

```
~/.rhachet/keyrack/vault/
  os.direct/
    owner=default/
      keyrack.direct.json
    owner=ehmpath.demo/
      keyrack.direct.json
  os.secure/
    owner=default/
      <hash>.age
    owner=ehmpath.demo/
      <hash>.age

$XDG_RUNTIME_DIR/
  keyrack.{sessionId}.sock              # default owner
  keyrack.{sessionId}.ehmpath.demo.sock # custom owner
```

os.direct and os.secure follow the `key=value/` directory pattern from `.agent/repo=.this/role=any/`.

os.daemon uses XDG_RUNTIME_DIR with owner as filename suffix (already per-owner, no changes needed).

this ensures:
- demo keys stored separately from prod keys
- no accidental overwrite possible
- each owner is a complete isolated universe

---

## awkward bits uncovered

### 1. flag inconsistency (pre-extant)

the `--for` vs `--owner` inconsistency already exists:
- `init --for <owner>` â† uses --for
- `recipient set --for <owner>` â† uses --for
- `get --owner <owner>` â† uses --owner
- `set --for <owner>` â† uses --for

**recommendation:** standardize on `--owner` everywhere, keep `--for` as deprecated alias.

### 2. vault namespace gap (HARD REQUIREMENT)

current vault adapters do NOT namespace by owner:
- `os.direct` â†’ single `keyrack.direct.json` for all owners
- `os.secure` â†’ single directory for all owners

**this MUST be fixed.** without vault namespace per owner, demo keys could overwrite prod keys â€” that defeats the entire purpose of separate owners.

the host manifest IS namespaced (`keyrack.host.${owner}.age`), but the vault storage is not. this means keys from different owners currently share the same vault file â€” which breaks isolation.

**required:** update vault adapters to namespace by owner directory:
- `os.direct` â†’ `owner=${owner ?? 'default'}/keyrack.direct.json`
- `os.secure` â†’ `owner=${owner ?? 'default'}/<hash>.age`
- `os.daemon` â†’ already per-owner via `$XDG_RUNTIME_DIR/keyrack.{sessionId}.{owner}.sock`

### 3. test coverage gap

no acceptance tests verify vault isolation per owner. the tests verify manifest isolation but not vault file isolation.

**recommendation:** add acceptance tests that:
1. set key with `--owner a` to vault
2. set different key with `--owner b` to same vault
3. verify vault files are separate
4. verify get from each owner returns correct value
