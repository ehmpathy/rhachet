# distill: domain objects and operations

## 1. usecases

### 1.1 primary usecases

| usecase | actor | action | outcome |
|:--------|:------|:-------|:--------|
| UC1 | developer | invoke brain.atom.ask for single-turn inference | structured output matching schema |
| UC2 | developer | invoke brain.repl.ask for readonly agentic analysis | structured output from tool-using agent (no writes) |
| UC3 | developer | invoke brain.repl.act for read+write agentic work | structured output from tool-using agent (with writes) |
| UC4 | system | convert zod schema to JSON schema for native enforcement | reduced token waste on validation retries |
| UC5 | developer | configure repl with custom toolboxes, memory, access | extensible agentic workloads |

### 1.2 envisioned contract usage

```typescript
// UC1: atom.ask - single-turn inference (renamed from imagine)
const analysis = await context.brain.atom.ask({
  brain: { repo: 'anthropic', slug: 'claude/opus/v4.5' },
  plugs: { /* optional */ },
  role: { briefs: roleBriefs },
  prompt: "Analyze this code for issues",
  schema: { output: AnalysisSchema }
});

// UC2: repl.ask - readonly agentic analysis
const research = await context.brain.repl.ask({
  brain: { repo: 'anthropic', slug: 'claude/code' },
  plugs: { /* optional */ },
  role: { briefs: roleBriefs },
  prompt: "Research the authentication patterns in this codebase",
  schema: { output: ResearchSchema }
});

// UC3: repl.act - read+write agentic work
const result = await context.brain.repl.act({
  brain: { repo: 'anthropic', slug: 'claude/code' },
  plugs: { /* optional */ },
  role: { briefs: roleBriefs },
  prompt: "Fix the authentication bug in auth.ts",
  schema: { output: FixResultSchema }
});
```

---

## 2. domain objects

### 2.1 treestruct

```
domain.objects/
├── BrainAtom.ts           # updated: imagine -> ask
├── BrainAtomPlugs.ts      # new: placeholder for atom plugins
├── BrainRepl.ts           # updated: imagine -> ask + act
├── BrainReplPlugs.ts      # new: placeholder for repl plugins
├── BrainReplMode.ts       # new: literal for ask vs act
└── ContextBrain.ts        # updated: imagine -> ask/act
```

### 2.2 BrainAtomPlugs (new - literal)

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = configuration plugs for BrainAtom instances
 * .why = enables extensible configuration for single-turn inference
 *   without coupling to specific SDK implementations
 *
 * .note = placeholder interface; actual configuration TBD
 */
export interface BrainAtomPlugs {
  /**
   * .what = structured output configuration
   * .why = enables native JSON schema enforcement for reduced token waste
   */
  output?: never; // todo: allow configuration
  // output?: { enforceSchema?: boolean };
}
export class BrainAtomPlugs
  extends DomainLiteral<BrainAtomPlugs>
  implements BrainAtomPlugs {}
```

### 2.3 BrainReplPlugs (new - literal)

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = configuration plugs for BrainRepl instances
 * .why = enables extensible tooling, memory management, and access control
 *   for agentic workloads without coupling to specific SDK implementations
 */
export interface BrainReplPlugs {
  /**
   * .what = additional tool providers beyond built-in tools
   * .why = enables domain-specific tooling (databases, browsers, APIs)
   *   via MCP servers or custom tool definitions
   *
   * .example = playwright browser, postgres database, custom APIs
   */
  toolboxes?: never; // todo: allow configuration
  // toolboxes?: BrainActorToolbox[];

  /**
   * .what = memory and context management strategy
   * .why = enables custom context compression, session persistence,
   *   and artifact management for long-running workflows
   *
   * .example = session resume, context compaction hooks
   */
  memory?: never; // todo: allow configuration
  // memory?: BrainActorMemory;

  /**
   * .what = permission guard and access control
   * .why = enables custom authorization logic, audit logging,
   *   and tool-level access policies beyond SDK defaults
   *
   * .example = canUseTool callbacks, preToolUse hooks
   */
  access?: never; // todo: allow configuration
  // access?: BrainActorAccess;
}
export class BrainReplPlugs
  extends DomainLiteral<BrainReplPlugs>
  implements BrainReplPlugs {}
```

### 2.4 BrainReplMode (new - literal)

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = execution mode for brain repl operations
 * .why = distinguishes between readonly analysis and read+write actions
 *
 * .note = maps to SDK permission configurations:
 *   - ask: disallowedTools=["Edit","Write","Bash"] / sandbox=read-only
 *   - act: allowedTools=["Read","Edit","Write","Bash",...] / sandbox=workspace-write
 */
export type BrainReplModeSlug = 'ask' | 'act';

export interface BrainReplMode {
  /**
   * .what = the mode slug
   */
  slug: BrainReplModeSlug;

  /**
   * .what = human-readable description of the mode
   */
  description: string;
}
export class BrainReplMode
  extends DomainLiteral<BrainReplMode>
  implements BrainReplMode {}

/**
 * .what = predefined repl modes
 */
export const BRAIN_REPL_MODES = {
  ask: new BrainReplMode({
    slug: 'ask',
    description: 'readonly analysis - no file edits or shell commands',
  }),
  act: new BrainReplMode({
    slug: 'act',
    description: 'read+write actions - can edit files and run commands',
  }),
} as const;
```

### 2.5 BrainAtom (updated)

```typescript
import { DomainEntity } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';
import type { Empty } from 'type-fns';
import type { z } from 'zod';

import type { BrainAtomPlugs } from './BrainAtomPlugs';

/**
 * .what = an LLM inference endpoint capable of creative language imagination
 * .why =
 *   - enables registration of pluggable LLM atoms (e.g., claude, gpt, llama)
 *   - provides a standardized contract for single-turn or multi-turn inference
 *   - enables dynamic swapping of models at runtime
 */
export interface BrainAtom {
  /**
   * .what = identifier for the plugin package that provides this atom
   * .example = "anthropic", "openai", "ollama"
   */
  repo: string;

  /**
   * .what = unique identifier for this specific atom within the repo
   * .example = "claude/opus/v4.5", "gpt/4o", "llama/3/70b"
   */
  slug: string;

  /**
   * .what = human-readable description of this atom's capabilities
   * .why = helps developers understand what this atom is best suited for
   */
  description: string;

  /**
   * .what = the ask operation contract (renamed from imagine)
   * .why = standardizes how all atoms are invoked, regardless of provider
   *
   * .note = plugin is responsible for handling role.briefs appropriately.
   *   this design maximizes leverage of each brain's unique capabilities:
   *   - context window optimization (e.g., claude's 200k vs gpt's 128k)
   *   - provider-specific caching (e.g., anthropic prompt caching)
   *   - finetuned behaviors (e.g., system prompt placement, formatting)
   *   - native JSON schema enforcement for structured outputs
   */
  ask: <TOutput>(
    input: {
      plugs?: BrainAtomPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
}
export class BrainAtom extends DomainEntity<BrainAtom> implements BrainAtom {
  public static unique = ['repo', 'slug'] as const;
}
```

### 2.6 BrainRepl (updated)

```typescript
import { DomainEntity } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';
import type { Empty } from 'type-fns';
import type { z } from 'zod';

import type { BrainReplPlugs } from './BrainReplPlugs';

/**
 * .what = a brain.atom operating behind a REPL (read-execute-print-loop)
 * .why =
 *   - enables registration of pluggable agentic repls (e.g., claude-code, codex)
 *   - provides a standardized contract for agentic tool-using inference
 *   - enables dynamic swapping of agentic systems at runtime
 *
 * .note = repls differ from atoms in that they execute iterative agentic loops
 *   with tool use, rather than single-turn inference
 */
export interface BrainRepl {
  /**
   * .what = identifier for the plugin package that provides this repl
   * .example = "anthropic", "openai"
   */
  repo: string;

  /**
   * .what = unique identifier for this specific repl within the repo
   * .example = "claude/code", "codex"
   */
  slug: string;

  /**
   * .what = human-readable description of this repl's capabilities
   * .why = helps developers understand what this repl is best suited for
   */
  description: string;

  /**
   * .what = readonly imagination operation (analysis, research, queries)
   * .why = provides safe, non-mutating agent interactions
   *   with only read access to filesystem and tools
   *
   * .sdk.mapping =
   *   - claude-agent-sdk: disallowedTools=["Edit","Write","Bash","NotebookEdit"]
   *   - codex-sdk: --sandbox read-only --ask-for-approval never
   */
  ask: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;

  /**
   * .what = read+write imagination operation (code changes, file edits)
   * .why = provides full agentic capabilities with write access
   *   for tasks that require modifying the codebase
   *
   * .sdk.mapping =
   *   - claude-agent-sdk: allowedTools=["Read","Edit","Write","Bash","Glob","Grep"]
   *   - codex-sdk: --sandbox workspace-write --ask-for-approval on-failure
   */
  act: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
}
export class BrainRepl extends DomainEntity<BrainRepl> implements BrainRepl {
  public static unique = ['repo', 'slug'] as const;
}
```

### 2.7 ContextBrain (updated)

```typescript
import { DomainLiteral, type RefByUnique } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';
import type { z } from 'zod';

import type { BrainAtom } from './BrainAtom';
import type { BrainAtomPlugs } from './BrainAtomPlugs';
import type { BrainRepl } from './BrainRepl';
import type { BrainReplPlugs } from './BrainReplPlugs';

/**
 * .what = runtime context providing unified access to brain atoms and repls
 * .why =
 *   - provides a clean interface for invoking brains by reference
 *   - handles lookup, role embedding, and delegation transparently
 *   - enables dynamic brain swapping without caller changes
 */
export interface ContextBrain {
  /**
   * .what = interface for invoking brain atoms and repls
   */
  brain: {
    atom: {
      /**
       * .what = lookup and invoke a brain atom for single-turn inference
       * .why = provides ergonomic access to atoms with automatic lookup
       */
      ask: <TOutput>(input: {
        brain: RefByUnique<typeof BrainAtom>;
        plugs?: BrainAtomPlugs;
        role: { briefs?: Artifact<typeof GitFile>[] };
        prompt: string;
        schema: { output: z.Schema<TOutput> };
      }) => Promise<TOutput>;
    };

    repl: {
      /**
       * .what = lookup and invoke a brain repl for readonly analysis
       * .why = provides safe agentic analysis without file modifications
       */
      ask: <TOutput>(input: {
        brain: RefByUnique<typeof BrainRepl>;
        plugs?: BrainReplPlugs;
        role: { briefs?: Artifact<typeof GitFile>[] };
        prompt: string;
        schema: { output: z.Schema<TOutput> };
      }) => Promise<TOutput>;

      /**
       * .what = lookup and invoke a brain repl for read+write actions
       * .why = provides full agentic capabilities with file modifications
       */
      act: <TOutput>(input: {
        brain: RefByUnique<typeof BrainRepl>;
        plugs?: BrainReplPlugs;
        role: { briefs?: Artifact<typeof GitFile>[] };
        prompt: string;
        schema: { output: z.Schema<TOutput> };
      }) => Promise<TOutput>;
    };
  };
}
export class ContextBrain
  extends DomainLiteral<ContextBrain>
  implements ContextBrain {}
```

---

## 3. domain operations

### 3.1 treestruct

```
domain.operations/
├── brainAtom/
│   └── askViaBrainAtom.ts        # renamed from imagineViaBrainAtom
├── brainRepl/
│   ├── askViaBrainRepl.ts        # new: readonly mode
│   └── actViaBrainRepl.ts        # new: read+write mode
└── schema/
    └── castZodToJsonSchema.ts  # utility for native schema enforcement
```

### 3.2 askViaBrainAtom (renamed)

```typescript
/**
 * .what = invoke a brain atom for single-turn inference
 * .why = provides the core operation for atom-based imagination
 *   with automatic role brief embedding and schema enforcement
 */
export const askViaBrainAtom = async <TOutput>(
  input: {
    atom: BrainAtom;
    plugs?: BrainAtomPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
): Promise<TOutput> => {
  // delegate to the atom's ask implementation
  return input.atom.ask(
    {
      plugs: input.plugs,
      role: input.role,
      prompt: input.prompt,
      schema: input.schema,
    },
    context,
  );
};
```

### 3.3 askViaBrainRepl (new)

```typescript
/**
 * .what = invoke a brain repl for readonly agentic analysis
 * .why = provides safe, non-mutating agent interactions for research,
 *   code analysis, and information gathering tasks
 *
 * .sdk.implementation =
 *   - claude-agent-sdk: query() with disallowedTools=["Edit","Write","Bash"]
 *   - codex-sdk: thread.run() with sandbox=read-only
 */
export const askViaBrainRepl = async <TOutput>(
  input: {
    repl: BrainRepl;
    plugs?: BrainReplPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
): Promise<TOutput> => {
  // delegate to the repl's ask implementation
  return input.repl.ask(
    {
      plugs: input.plugs,
      role: input.role,
      prompt: input.prompt,
      schema: input.schema,
    },
    context,
  );
};
```

### 3.4 actViaBrainRepl (new)

```typescript
/**
 * .what = invoke a brain repl for read+write agentic actions
 * .why = provides full agentic capabilities for code changes,
 *   file edits, and command execution tasks
 *
 * .sdk.implementation =
 *   - claude-agent-sdk: query() with allowedTools=["Read","Edit","Write","Bash",...]
 *   - codex-sdk: thread.run() with sandbox=workspace-write
 */
export const actViaBrainRepl = async <TOutput>(
  input: {
    repl: BrainRepl;
    plugs?: BrainReplPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
): Promise<TOutput> => {
  // delegate to the repl's act implementation
  return input.repl.act(
    {
      plugs: input.plugs,
      role: input.role,
      prompt: input.prompt,
      schema: input.schema,
    },
    context,
  );
};
```

### 3.5 castZodToJsonSchema (new utility)

```typescript
import { zodToJsonSchema } from 'zod-to-json-schema';
import type { z } from 'zod';

/**
 * .what = convert a zod schema to JSON schema for native SDK enforcement
 * .why = enables native structured output support in SDKs, reducing
 *   token waste on validation retries
 *
 * .note = different SDKs require different conversion options:
 *   - claude-agent-sdk: { $refStrategy: 'root' }
 *   - codex-sdk: { target: 'openAi' }
 */
export const castZodToJsonSchema = (
  input: {
    schema: z.ZodSchema;
    target: 'claude' | 'openai';
  },
): object => {
  // convert based on target SDK
  if (input.target === 'claude') {
    return zodToJsonSchema(input.schema, { $refStrategy: 'root' });
  }

  // openai target
  return zodToJsonSchema(input.schema, { target: 'openAi' });
};
```

---

## 4. access layer (SDK adapters)

### 4.1 treestruct

```
src/_topublish/
├── rhachet-brain-anthropic/
│   ├── src/
│   │   ├── atoms/
│   │   │   └── brainAtomClaude.ts         # updated: use structured outputs
│   │   └── repls/
│   │       └── brainReplClaudeCode.ts     # updated: use @anthropic-ai/claude-agent-sdk
│   └── package.json                        # add @anthropic-ai/claude-agent-sdk
│
└── rhachet-brain-openai/
    ├── src/
    │   ├── atoms/
    │   │   └── brainAtomGpt.ts            # updated: use structured outputs
    │   └── repls/
    │       └── brainReplCodex.ts          # updated: use @openai/codex-sdk
    └── package.json                        # add @openai/codex-sdk
```

### 4.2 brainReplClaudeCode (updated implementation)

```typescript
import { query } from '@anthropic-ai/claude-agent-sdk';
import { zodToJsonSchema } from 'zod-to-json-schema';

import { BrainRepl } from 'rhachet';

/**
 * .what = claude code repl implementation using the claude agent sdk
 * .why = provides agentic tool-using inference via claude code
 */
export const brainReplClaudeCode = new BrainRepl({
  repo: 'anthropic',
  slug: 'claude/code',
  description: 'claude code agentic repl with tool use',

  ask: async (input, _context) => {
    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      $refStrategy: 'root',
    });

    // build system prompt from briefs
    const systemPrompt = await buildSystemPromptFromBriefs(input.role.briefs);

    // execute query in readonly mode
    for await (const message of query({
      prompt: input.prompt,
      options: {
        systemPrompt,
        disallowedTools: ['Edit', 'Write', 'Bash', 'NotebookEdit'],
        permissionMode: 'bypassPermissions',
        allowDangerouslySkipPermissions: true,
        outputFormat: { type: 'json_schema', schema: jsonSchema },
      },
    })) {
      if (message.type === 'result' && message.subtype === 'success') {
        return input.schema.output.parse(message.structured_output);
      }
    }

    throw new UnexpectedCodePathError('no result from claude code query');
  },

  act: async (input, _context) => {
    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      $refStrategy: 'root',
    });

    // build system prompt from briefs
    const systemPrompt = await buildSystemPromptFromBriefs(input.role.briefs);

    // execute query in read+write mode
    for await (const message of query({
      prompt: input.prompt,
      options: {
        systemPrompt,
        allowedTools: ['Read', 'Edit', 'Write', 'Bash', 'Glob', 'Grep'],
        permissionMode: 'bypassPermissions',
        allowDangerouslySkipPermissions: true,
        outputFormat: { type: 'json_schema', schema: jsonSchema },
      },
    })) {
      if (message.type === 'result' && message.subtype === 'success') {
        return input.schema.output.parse(message.structured_output);
      }
    }

    throw new UnexpectedCodePathError('no result from claude code query');
  },
});
```

### 4.3 brainReplCodex (updated implementation)

```typescript
import { Codex } from '@openai/codex-sdk';
import { zodToJsonSchema } from 'zod-to-json-schema';

import { BrainRepl } from 'rhachet';

/**
 * .what = codex repl implementation using the codex sdk
 * .why = provides agentic tool-using inference via openai codex
 */
export const brainReplCodex = new BrainRepl({
  repo: 'openai',
  slug: 'codex',
  description: 'openai codex agentic repl with tool use',

  ask: async (input, _context) => {
    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      target: 'openAi',
    });

    // build prompt with role briefs prepended
    const promptWithBriefs = await buildPromptWithBriefs(
      input.prompt,
      input.role.briefs,
    );

    // execute in readonly mode
    const codex = new Codex();
    const thread = codex.startThread({
      outputSchema: jsonSchema,
      // SDK equivalent of --sandbox read-only
    });
    const turn = await thread.run(promptWithBriefs);

    // parse and return
    return input.schema.output.parse(JSON.parse(turn.finalResponse));
  },

  act: async (input, _context) => {
    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      target: 'openAi',
    });

    // build prompt with role briefs prepended
    const promptWithBriefs = await buildPromptWithBriefs(
      input.prompt,
      input.role.briefs,
    );

    // execute in read+write mode
    const codex = new Codex();
    const thread = codex.startThread({
      outputSchema: jsonSchema,
      // SDK equivalent of --sandbox workspace-write --ask-for-approval on-failure
    });
    const turn = await thread.run(promptWithBriefs);

    // parse and return
    return input.schema.output.parse(JSON.parse(turn.finalResponse));
  },
});
```

---

## 5. summary of changes

### 5.1 domain objects

| file | change | description |
|:-----|:-------|:------------|
| `BrainAtomPlugs.ts` | **new** | placeholder for atom plugin configuration |
| `BrainReplPlugs.ts` | **new** | placeholder for repl plugin configuration (toolboxes, memory, access) |
| `BrainReplMode.ts` | **new** | literal for ask vs act mode |
| `BrainAtom.ts` | **update** | rename `imagine` -> `ask`, add `plugs` parameter |
| `BrainRepl.ts` | **update** | replace `imagine` with `ask` + `act`, add `plugs` parameter |
| `ContextBrain.ts` | **update** | replace `imagine` with `ask` + `act` on both atom and repl |

### 5.2 domain operations

| file | change | description |
|:-----|:-------|:------------|
| `askViaBrainAtom.ts` | **rename** | from `imagineViaBrainAtom`, add plugs support |
| `askViaBrainRepl.ts` | **new** | readonly agentic operation |
| `actViaBrainRepl.ts` | **new** | read+write agentic operation |
| `castZodToJsonSchema.ts` | **new** | utility for native schema enforcement |

### 5.3 access layer (SDK adapters)

| file | change | description |
|:-----|:-------|:------------|
| `brainReplClaudeCode.ts` | **update** | use `@anthropic-ai/claude-agent-sdk`, implement `ask` + `act` |
| `brainReplCodex.ts` | **update** | use `@openai/codex-sdk`, implement `ask` + `act` |
| `brainAtomClaude.ts` | **update** | add structured output support |
| `brainAtomGpt.ts` | **update** | add structured output support |

### 5.4 dependencies to add

| package | location |
|:--------|:---------|
| `@anthropic-ai/claude-agent-sdk` | rhachet-brain-anthropic |
| `@openai/codex-sdk` | rhachet-brain-openai |
| `zod-to-json-schema` | both packages (if not present) |
