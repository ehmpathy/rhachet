# blueprint: sdk-brain-repl-examples

## overview

this blueprint describes the implementation plan for transforming `brainReplClaudeCode` and `brainReplCodex` from basic chat completion wrappers to proper agentic SDK integrations.

**current state:**
- `brainReplClaudeCode.ts` uses `@anthropic-ai/sdk` for basic message completion
- `brainReplCodex.ts` uses `openai` sdk for basic chat completion
- both expose a single `imagine()` method

**target state:**
- `brainReplClaudeCode.ts` uses `@anthropic-ai/claude-agent-sdk` with `query()` for agentic tool use
- `brainReplCodex.ts` uses `@openai/codex-sdk` with `Codex.startThread().run()` for agentic tool use
- both expose `ask()` (readonly) and `act()` (read+write) methods
- both support native JSON schema enforcement via `zod-to-json-schema`
- `BrainReplPlugs` placeholder interface added for future extensibility

---

## phase 0: dependencies

### 0.1 add new dependencies

**rhachet-brain-anthropic/package.json:**
```json
{
  "dependencies": {
    "@anthropic-ai/claude-agent-sdk": "^2.0.0",
    "zod-to-json-schema": "^3.23.0"
  }
}
```

**rhachet-brain-openai/package.json:**
```json
{
  "dependencies": {
    "@openai/codex-sdk": "^0.77.0",
    "zod-to-json-schema": "^3.23.0"
  }
}
```

**root package.json (shared utility):**
```json
{
  "dependencies": {
    "zod-to-json-schema": "^3.23.0"
  }
}
```

### 0.2 cli runtime requirements

**note:** the claude agent sdk requires the claude-code CLI as runtime:
```bash
npm install -g @anthropic-ai/claude-code
```

**note:** the codex sdk bundles its own binary, no additional CLI needed.

---

## phase 1: domain objects

### 1.1 create BrainAtomPlugs.ts (new)

**path:** `src/domain.objects/BrainAtomPlugs.ts`

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = configuration plugs for BrainAtom instances
 * .why = enables extensible configuration for single-turn inference
 *   without coupling to specific SDK implementations
 *
 * .note = placeholder interface; actual configuration TBD
 */
export interface BrainAtomPlugs {
  /**
   * .what = structured output configuration
   * .why = enables native JSON schema enforcement for reduced token waste
   */
  output?: never; // todo: allow configuration
  // output?: { enforceSchema?: boolean };
}
export class BrainAtomPlugs
  extends DomainLiteral<BrainAtomPlugs>
  implements BrainAtomPlugs {}
```

### 1.2 create BrainReplPlugs.ts (new)

**path:** `src/domain.objects/BrainReplPlugs.ts`

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = configuration plugs for BrainRepl instances
 * .why = enables extensible tooling, memory management, and access control
 *   for agentic workloads without coupling to specific SDK implementations
 */
export interface BrainReplPlugs {
  /**
   * .what = additional tool providers beyond built-in tools
   * .why = enables domain-specific tooling (databases, browsers, APIs)
   *   via MCP servers or custom tool definitions
   *
   * .example = playwright browser, postgres database, custom APIs
   */
  toolboxes?: never; // todo: allow configuration
  // toolboxes?: BrainActorToolbox[];

  /**
   * .what = memory and context management strategy
   * .why = enables custom context compression, session persistence,
   *   and artifact management for long-running workflows
   *
   * .example = session resume, context compaction hooks
   */
  memory?: never; // todo: allow configuration
  // memory?: BrainActorMemory;

  /**
   * .what = permission guard and access control
   * .why = enables custom authorization logic, audit logging,
   *   and tool-level access policies beyond SDK defaults
   *
   * .example = canUseTool callbacks, preToolUse hooks
   */
  access?: never; // todo: allow configuration
  // access?: BrainActorAccess;
}
export class BrainReplPlugs
  extends DomainLiteral<BrainReplPlugs>
  implements BrainReplPlugs {}
```

### 1.3 update BrainAtom.ts

**path:** `src/domain.objects/BrainAtom.ts`

**changes:**
- rename `imagine` → `ask`
- add optional `plugs?: BrainAtomPlugs` parameter

```typescript
import { DomainEntity } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';
import type { Empty } from 'type-fns';
import type { z } from 'zod';

import type { BrainAtomPlugs } from './BrainAtomPlugs';

/**
 * .what = an LLM inference endpoint capable of creative language imagination
 * .why =
 *   - enables registration of pluggable LLM atoms (e.g., claude, gpt, llama)
 *   - provides a standardized contract for single-turn or multi-turn inference
 *   - enables dynamic swapping of models at runtime
 */
export interface BrainAtom {
  repo: string;
  slug: string;
  description: string;

  /**
   * .what = the ask operation contract (renamed from imagine)
   * .why = standardizes how all atoms are invoked, regardless of provider
   */
  ask: <TOutput>(
    input: {
      plugs?: BrainAtomPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
}
export class BrainAtom extends DomainEntity<BrainAtom> implements BrainAtom {
  public static unique = ['repo', 'slug'] as const;
}
```

### 1.4 update BrainRepl.ts

**path:** `src/domain.objects/BrainRepl.ts`

**changes:**
- replace `imagine` with `ask` (readonly) and `act` (read+write)
- add optional `plugs?: BrainReplPlugs` parameter to both methods

```typescript
import { DomainEntity } from 'domain-objects';
import type { Artifact } from 'rhachet-artifact';
import type { GitFile } from 'rhachet-artifact-git';
import type { Empty } from 'type-fns';
import type { z } from 'zod';

import type { BrainReplPlugs } from './BrainReplPlugs';

/**
 * .what = a brain.atom operating behind a REPL (read-execute-print-loop)
 * .why =
 *   - enables registration of pluggable agentic repls (e.g., claude-code, codex)
 *   - provides a standardized contract for agentic tool-using inference
 *   - enables dynamic swapping of agentic systems at runtime
 */
export interface BrainRepl {
  repo: string;
  slug: string;
  description: string;

  /**
   * .what = readonly analysis operation (research, queries, code review)
   * .why = provides safe, non-mutating agent interactions
   *   with only read access to filesystem and tools
   *
   * .sdk.mapping =
   *   - claude-agent-sdk: disallowedTools=["Edit","Write","Bash","NotebookEdit"]
   *   - codex-sdk: --sandbox read-only
   */
  ask: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;

  /**
   * .what = read+write action operation (code changes, file edits)
   * .why = provides full agentic capabilities with write access
   *   for tasks that require modifying the codebase
   *
   * .sdk.mapping =
   *   - claude-agent-sdk: allowedTools=["Read","Edit","Write","Bash","Glob","Grep"]
   *   - codex-sdk: --sandbox workspace-write
   */
  act: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
}
export class BrainRepl extends DomainEntity<BrainRepl> implements BrainRepl {
  public static unique = ['repo', 'slug'] as const;
}
```

### 1.5 update ContextBrain.ts

**path:** `src/domain.objects/ContextBrain.ts`

**changes:**
- update `brain.atom.imagine` → `brain.atom.ask`
- update `brain.repl.imagine` → `brain.repl.ask` + `brain.repl.act`

---

## phase 2: domain operations

### 2.1 create castZodToJsonSchema.ts (new utility)

**path:** `src/domain.operations/schema/castZodToJsonSchema.ts`

```typescript
import { zodToJsonSchema } from 'zod-to-json-schema';
import type { z } from 'zod';

/**
 * .what = convert a zod schema to JSON schema for native SDK enforcement
 * .why = enables native structured output support in SDKs, reducing
 *   token waste on validation retries
 *
 * .note = different SDKs require different conversion options:
 *   - claude-agent-sdk: { $refStrategy: 'root' }
 *   - codex-sdk: { target: 'openAi' }
 */
export const castZodToJsonSchema = (
  input: {
    schema: z.ZodSchema;
    target: 'claude' | 'openai';
  },
): object => {
  // convert based on target SDK
  if (input.target === 'claude') {
    return zodToJsonSchema(input.schema, { $refStrategy: 'root' });
  }

  // openai target
  return zodToJsonSchema(input.schema, { target: 'openAi' });
};
```

### 2.2 rename imagineViaBrainAtom → askViaBrainAtom

**path:** `src/domain.operations/brainAtom/askViaBrainAtom.ts` (rename from imagineViaBrainAtom.ts)

**changes:**
- rename file and operation
- add `plugs` parameter

### 2.3 create askViaBrainRepl.ts (new)

**path:** `src/domain.operations/brainRepl/askViaBrainRepl.ts`

```typescript
/**
 * .what = invoke a brain repl for readonly agentic analysis
 * .why = provides safe, non-mutating agent interactions for research,
 *   code analysis, and information gathering tasks
 */
export const askViaBrainRepl = async <TOutput>(
  input: {
    repl: BrainRepl;
    plugs?: BrainReplPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
): Promise<TOutput> => {
  return input.repl.ask(
    {
      plugs: input.plugs,
      role: input.role,
      prompt: input.prompt,
      schema: input.schema,
    },
    context,
  );
};
```

### 2.4 create actViaBrainRepl.ts (new)

**path:** `src/domain.operations/brainRepl/actViaBrainRepl.ts`

```typescript
/**
 * .what = invoke a brain repl for read+write agentic actions
 * .why = provides full agentic capabilities for code changes,
 *   file edits, and command execution tasks
 */
export const actViaBrainRepl = async <TOutput>(
  input: {
    repl: BrainRepl;
    plugs?: BrainReplPlugs;
    role: { briefs?: Artifact<typeof GitFile>[] };
    prompt: string;
    schema: { output: z.Schema<TOutput> };
  },
  context?: Empty,
): Promise<TOutput> => {
  return input.repl.act(
    {
      plugs: input.plugs,
      role: input.role,
      prompt: input.prompt,
      schema: input.schema,
    },
    context,
  );
};
```

---

## phase 3: SDK adapters

### 3.1 update brainReplClaudeCode.ts

**path:** `src/_topublish/rhachet-brain-anthropic/src/repls/brainReplClaudeCode.ts`

**changes:**
- replace `@anthropic-ai/sdk` with `@anthropic-ai/claude-agent-sdk`
- replace `imagine` with `ask` and `act`
- use `query()` function with proper tool configuration
- add native JSON schema enforcement via `outputFormat`

```typescript
import { query } from '@anthropic-ai/claude-agent-sdk';
import { UnexpectedCodePathError } from 'helpful-errors';
import { zodToJsonSchema } from 'zod-to-json-schema';

import { BrainRepl } from '@src/domain.objects/BrainRepl';
import { castBriefsToPrompt } from '@src/domain.operations/role/briefs/castBriefsToPrompt';

/**
 * .what = brain repl for claude code using the claude agent sdk
 * .why = provides anthropic's agentic coding assistant with tool use
 */
export const brainReplClaudeCode = new BrainRepl({
  repo: 'anthropic',
  slug: 'claude-code',
  description: 'claude code - agentic coding assistant with tool use',

  ask: async (input, _context) => {
    // compose system prompt from briefs
    const systemPrompt = input.role.briefs
      ? await castBriefsToPrompt({ briefs: input.role.briefs })
      : undefined;

    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      $refStrategy: 'root',
    });

    // execute query in readonly mode
    for await (const message of query({
      prompt: input.prompt,
      options: {
        systemPrompt,
        disallowedTools: ['Edit', 'Write', 'Bash', 'NotebookEdit'],
        permissionMode: 'bypassPermissions',
        allowDangerouslySkipPermissions: true,
        outputFormat: { type: 'json_schema', schema: jsonSchema },
      },
    })) {
      if (message.type === 'result' && message.subtype === 'success') {
        // prefer structured_output, fallback to parsing result
        const output = message.structured_output ?? JSON.parse(message.result);
        return input.schema.output.parse(output);
      }
    }

    throw new UnexpectedCodePathError('no result from claude code query');
  },

  act: async (input, _context) => {
    // compose system prompt from briefs
    const systemPrompt = input.role.briefs
      ? await castBriefsToPrompt({ briefs: input.role.briefs })
      : undefined;

    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      $refStrategy: 'root',
    });

    // execute query in read+write mode
    for await (const message of query({
      prompt: input.prompt,
      options: {
        systemPrompt,
        allowedTools: ['Read', 'Edit', 'Write', 'Bash', 'Glob', 'Grep'],
        permissionMode: 'bypassPermissions',
        allowDangerouslySkipPermissions: true,
        outputFormat: { type: 'json_schema', schema: jsonSchema },
      },
    })) {
      if (message.type === 'result' && message.subtype === 'success') {
        // prefer structured_output, fallback to parsing result
        const output = message.structured_output ?? JSON.parse(message.result);
        return input.schema.output.parse(output);
      }
    }

    throw new UnexpectedCodePathError('no result from claude code query');
  },
});
```

### 3.2 update brainReplCodex.ts

**path:** `src/_topublish/rhachet-brain-openai/src/repls/brainReplCodex.ts`

**changes:**
- replace `openai` with `@openai/codex-sdk`
- replace `imagine` with `ask` and `act`
- use `Codex.startThread().run()` for agentic execution
- add native JSON schema enforcement via `outputSchema`

```typescript
import { Codex } from '@openai/codex-sdk';
import { UnexpectedCodePathError } from 'helpful-errors';
import { zodToJsonSchema } from 'zod-to-json-schema';

import { BrainRepl } from '@src/domain.objects/BrainRepl';
import { castBriefsToPrompt } from '@src/domain.operations/role/briefs/castBriefsToPrompt';

/**
 * .what = brain repl for openai codex using the codex sdk
 * .why = provides openai's agentic coding assistant with tool use
 */
export const brainReplCodex = new BrainRepl({
  repo: 'openai',
  slug: 'codex',
  description: 'codex - agentic coding assistant with tool use',

  ask: async (input, _context) => {
    // compose prompt with briefs prepended
    const briefsPrompt = input.role.briefs
      ? await castBriefsToPrompt({ briefs: input.role.briefs })
      : '';
    const promptWithBriefs = briefsPrompt
      ? `${briefsPrompt}\n\n${input.prompt}`
      : input.prompt;

    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      target: 'openAi',
    });

    // execute in readonly mode
    const codex = new Codex();
    const thread = codex.startThread({
      outputSchema: jsonSchema,
      // todo: configure sandbox=read-only equivalent when sdk supports it
    });
    const turn = await thread.run(promptWithBriefs);

    // sanity check response
    if (!turn.finalResponse) {
      throw new UnexpectedCodePathError('no finalResponse from codex');
    }

    // parse and return
    return input.schema.output.parse(JSON.parse(turn.finalResponse));
  },

  act: async (input, _context) => {
    // compose prompt with briefs prepended
    const briefsPrompt = input.role.briefs
      ? await castBriefsToPrompt({ briefs: input.role.briefs })
      : '';
    const promptWithBriefs = briefsPrompt
      ? `${briefsPrompt}\n\n${input.prompt}`
      : input.prompt;

    // convert zod schema to JSON schema for native enforcement
    const jsonSchema = zodToJsonSchema(input.schema.output, {
      target: 'openAi',
    });

    // execute in read+write mode
    const codex = new Codex();
    const thread = codex.startThread({
      outputSchema: jsonSchema,
      // todo: configure sandbox=workspace-write equivalent when sdk supports it
    });
    const turn = await thread.run(promptWithBriefs);

    // sanity check response
    if (!turn.finalResponse) {
      throw new UnexpectedCodePathError('no finalResponse from codex');
    }

    // parse and return
    return input.schema.output.parse(JSON.parse(turn.finalResponse));
  },
});
```

### 3.3 update brainAtom implementations

**paths:**
- `src/_topublish/rhachet-brain-anthropic/src/atoms/brainAtomClaude*.ts`
- `src/_topublish/rhachet-brain-openai/src/atoms/brainAtomGpt*.ts`

**changes:**
- rename `imagine` → `ask`
- add `plugs` parameter (optional, placeholder)
- consider adding native JSON schema enforcement for structured outputs

---

## phase 4: update callers

### 4.1 find all usages of `.imagine()`

```bash
# find all callers
grep -r "\.imagine(" src/
grep -r "brain\.atom\.imagine" src/
grep -r "brain\.repl\.imagine" src/
```

### 4.2 update each caller

**for atom callers:**
- rename `.imagine(` → `.ask(`

**for repl callers:**
- determine if readonly or read+write
- rename `.imagine(` → `.ask(` for readonly operations
- rename `.imagine(` → `.act(` for read+write operations

---

## phase 5: tests

### 5.1 unit tests

**new test files:**
- `src/domain.objects/BrainAtomPlugs.test.ts`
- `src/domain.objects/BrainReplPlugs.test.ts`
- `src/domain.operations/schema/castZodToJsonSchema.test.ts`
- `src/domain.operations/brainRepl/askViaBrainRepl.test.ts`
- `src/domain.operations/brainRepl/actViaBrainRepl.test.ts`

### 5.2 integration tests

**update existing:**
- `src/_topublish/rhachet-brain-anthropic/src/repls/brainReplClaudeCode.integration.test.ts`
- `src/_topublish/rhachet-brain-openai/src/repls/brainReplCodex.integration.test.ts`

**test cases:**

```typescript
import { given, when, then, useBeforeAll } from 'test-fns';
import { z } from 'zod';

describe('brainReplClaudeCode', () => {
  given('[case1] a simple analysis request', () => {
    const schema = z.object({
      summary: z.string(),
      issues: z.array(z.string()),
    });

    when('[t0] ask() is called', () => {
      then('returns structured output matching schema', async () => {
        const result = await brainReplClaudeCode.ask({
          role: {},
          prompt: 'Analyze this code for issues',
          schema: { output: schema },
        });
        expect(result.summary).toBeDefined();
        expect(Array.isArray(result.issues)).toBe(true);
      });
    });
  });

  given('[case2] a code modification request', () => {
    const schema = z.object({
      filesModified: z.array(z.string()),
      summary: z.string(),
    });

    when('[t0] act() is called', () => {
      then('returns structured output matching schema', async () => {
        const result = await brainReplClaudeCode.act({
          role: {},
          prompt: 'Add a comment to file.ts',
          schema: { output: schema },
        });
        expect(result.filesModified).toBeDefined();
        expect(result.summary).toBeDefined();
      });
    });
  });
});
```

---

## phase 6: validation

### 6.1 type check

```bash
npm run test:types
```

### 6.2 lint check

```bash
npm run test:lint
```

### 6.3 unit tests

```bash
npm run test:unit
```

### 6.4 integration tests

```bash
source .agent/repo=.this/role=any/skills/use.apikeys.sh
npm run test:integration
```

---

## summary of changes

| phase | file | change |
|:------|:-----|:-------|
| 0 | package.json (multiple) | add `@anthropic-ai/claude-agent-sdk`, `@openai/codex-sdk`, `zod-to-json-schema` |
| 1 | `BrainAtomPlugs.ts` | **new** - placeholder for atom plugin configuration |
| 1 | `BrainReplPlugs.ts` | **new** - placeholder for repl plugin configuration |
| 1 | `BrainAtom.ts` | **update** - rename `imagine` → `ask`, add `plugs` |
| 1 | `BrainRepl.ts` | **update** - replace `imagine` with `ask` + `act`, add `plugs` |
| 1 | `ContextBrain.ts` | **update** - replace `imagine` with `ask` + `act` |
| 2 | `castZodToJsonSchema.ts` | **new** - utility for native schema enforcement |
| 2 | `askViaBrainAtom.ts` | **rename** - from `imagineViaBrainAtom.ts` |
| 2 | `askViaBrainRepl.ts` | **new** - readonly agentic operation |
| 2 | `actViaBrainRepl.ts` | **new** - read+write agentic operation |
| 3 | `brainReplClaudeCode.ts` | **update** - use `@anthropic-ai/claude-agent-sdk`, implement `ask` + `act` |
| 3 | `brainReplCodex.ts` | **update** - use `@openai/codex-sdk`, implement `ask` + `act` |
| 3 | `brainAtomClaude*.ts` | **update** - rename `imagine` → `ask` |
| 3 | `brainAtomGpt*.ts` | **update** - rename `imagine` → `ask` |
| 4 | all callers | **update** - rename `.imagine(` calls |
| 5 | test files | **new/update** - add tests for new operations |

---

## risks and mitigations

### risk 1: claude agent sdk requires CLI runtime

**mitigation:** document requirement in package README. the CLI is published as `@anthropic-ai/claude-code` and can be installed globally or as a dev dependency.

### risk 2: codex sdk sandbox mode configuration

**mitigation:** the current codex SDK may not expose programmatic control over sandbox modes. leave TODO comments and configure via environment or defaults until SDK adds support.

### risk 3: breaking change for existing callers

**mitigation:** this is an intentional breaking change. use `sedreplace.sh` to update all callers from `.imagine(` to `.ask(` or `.act(` as appropriate.

### risk 4: structured output schema compatibility

**mitigation:** test with various zod schema types (objects, arrays, enums, nested) to ensure `zod-to-json-schema` produces valid schemas for both SDKs.

---

## execution order

1. **phase 0** - install dependencies
2. **phase 1** - update domain objects (contracts first)
3. **phase 2** - create domain operations
4. **phase 3** - update SDK adapters
5. **phase 4** - update all callers
6. **phase 5** - add/update tests
7. **phase 6** - validate (types, lint, tests)
