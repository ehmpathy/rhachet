# domain research: sdk-brain-repl-examples

## summary

the wish is to fix `brainReplClaudeCode` and `brainReplCodex` implementations to actually use their respective agentic SDKs rather than just basic chat completions.

current state:
- `brainReplClaudeCode.ts` uses `@anthropic-ai/sdk` for basic message completion
- `brainReplCodex.ts` uses `openai` sdk for basic chat completion

desired state:
- `brainReplClaudeCode.ts` should use `@anthropic-ai/claude-agent-sdk` for agentic tool-using tasks
- `brainReplCodex.ts` should use `@openai/codex-sdk` for agentic tool-using tasks

---

## 1. claude agent sdk (@anthropic-ai/claude-agent-sdk)

### 1.1 overview

> "The Claude Code SDK has been renamed to the Claude Agent SDK. [...] Build AI agents that autonomously read files, run commands, search the web, edit code, and more. The Agent SDK gives you the same tools, agent loop, and context management that power Claude Code, programmable in Python and TypeScript." [1]

### 1.2 installation

```bash
npm install @anthropic-ai/claude-agent-sdk
```

requires Claude Code CLI as runtime:
```bash
npm install -g @anthropic-ai/claude-code
```

### 1.3 core api - `query()` function

```typescript
import { query } from "@anthropic-ai/claude-agent-sdk";

function query({
  prompt,
  options
}: {
  prompt: string | AsyncIterable<SDKUserMessage>;
  options?: Options;
}): Query
```

> "The primary function for interacting with Claude Code. Creates an async generator that streams messages as they arrive." [2]

### 1.4 domain objects

#### 1.4.1 Options (literal)

key configuration properties [2]:

| Property | Type | Description |
|:---------|:-----|:------------|
| `allowedTools` | `string[]` | list of allowed tool names (Read, Edit, Bash, Glob, Grep, etc) |
| `systemPrompt` | `string \| { type: 'preset'; preset: 'claude_code'; append?: string }` | system prompt configuration |
| `permissionMode` | `PermissionMode` | permission mode: 'default', 'acceptEdits', 'bypassPermissions', 'plan' |
| `agents` | `Record<string, AgentDefinition>` | programmatically define subagents |
| `mcpServers` | `Record<string, McpServerConfig>` | MCP server configurations |
| `cwd` | `string` | current working directory |
| `resume` | `string` | session ID to resume |
| `hooks` | `Partial<Record<HookEvent, HookCallbackMatcher[]>>` | hook callbacks for events |
| `model` | `string` | claude model to use |

#### 1.4.2 Query (entity)

```typescript
interface Query extends AsyncGenerator<SDKMessage, void> {
  interrupt(): Promise<void>;
  rewindFiles(userMessageUuid: string): Promise<void>;
  setPermissionMode(mode: PermissionMode): Promise<void>;
  setModel(model?: string): Promise<void>;
  supportedCommands(): Promise<SlashCommand[]>;
  supportedModels(): Promise<ModelInfo[]>;
  mcpServerStatus(): Promise<McpServerStatus[]>;
  accountInfo(): Promise<AccountInfo>;
}
```

> "Interface returned by the query() function." [2]

#### 1.4.3 SDKMessage (union type)

```typescript
type SDKMessage =
  | SDKAssistantMessage
  | SDKUserMessage
  | SDKResultMessage
  | SDKSystemMessage
  | SDKPartialAssistantMessage
  | SDKCompactBoundaryMessage;
```

#### 1.4.4 SDKResultMessage (event)

```typescript
type SDKResultMessage = {
  type: 'result';
  subtype: 'success';
  uuid: UUID;
  session_id: string;
  duration_ms: number;
  is_error: boolean;
  num_turns: number;
  result: string;  // <-- the final text result
  total_cost_usd: number;
  usage: NonNullableUsage;
  structured_output?: unknown;
}
```

### 1.5 built-in tools [2]

| Tool | What it does |
|------|--------------|
| **Read** | read any file in the working directory |
| **Write** | create new files |
| **Edit** | make precise edits to existing files |
| **Bash** | run terminal commands, scripts, git operations |
| **Glob** | find files by pattern |
| **Grep** | search file contents with regex |
| **WebSearch** | search the web for current information |
| **WebFetch** | fetch and parse web page content |

### 1.6 usage example

```typescript
import { query } from "@anthropic-ai/claude-agent-sdk";

for await (const message of query({
  prompt: "Find and fix the bug in auth.py",
  options: { allowedTools: ["Read", "Edit", "Bash"] }
})) {
  if ("result" in message) console.log(message.result);
}
```

---

## 2. openai codex sdk (@openai/codex-sdk)

### 2.1 overview

> "The TypeScript SDK wraps the bundled codex binary. It spawns the CLI and exchanges JSONL events over stdin/stdout." [3]

> "Use the SDK when you need to: Control Codex as part of your CI/CD pipeline, create your own agent that can engage with Codex to perform complex engineering tasks, build Codex into your own internal tools and workflows, or integrate Codex within your own application." [3]

### 2.2 installation

```bash
npm install @openai/codex-sdk
```

requires Node.js 18+

### 2.3 core api

```typescript
import { Codex } from "@openai/codex-sdk";

const codex = new Codex();
const thread = codex.startThread();
const result = await thread.run("Make a plan to diagnose and fix the CI failures");
```

### 2.4 domain objects

#### 2.4.1 Codex (entity - client)

```typescript
const codex = new Codex({
  env?: Record<string, string>  // environment variables passed to CLI
});
```

#### 2.4.2 Thread (entity)

```typescript
const thread = codex.startThread({
  workingDirectory?: string,   // execution location (defaults to cwd)
  skipGitRepoCheck?: boolean,  // bypasses Git repo validation
  outputSchema?: JSONSchema    // defines JSON schema for structured responses
});
```

methods:
- `thread.run(prompt, options?)` - executes a single turn, buffering until completion
- `thread.runStreamed(prompt, options?)` - returns async generator of structured events
- `codex.resumeThread(threadId)` - reconstructs a persisted thread from `~/.codex/sessions`

#### 2.4.3 Turn (literal - response)

```typescript
interface Turn {
  finalResponse: string;       // agent's concluding message
  items: TurnItem[];           // intermediate results
  usage: UsageMetrics;         // token consumption metrics
}
```

#### 2.4.4 Input Types

> "The SDK accepts flexible input formats: Simple strings for text prompts, Array of structured entries: `{ type: "text", text: "..." }` and `{ type: "local_image", path: "..." }`" [4]

#### 2.4.5 Streaming Events

- `"item.completed"` - tool execution or response segment finished
- `"turn.completed"` - turn finished with usage data

### 2.5 usage example

```typescript
import { Codex } from "@openai/codex-sdk";

const codex = new Codex();
const thread = codex.startThread();
const result = await thread.run("Make a plan to diagnose and fix the CI failures");
console.log(result.finalResponse);

// resume later
const thread2 = codex.resumeThread("<thread-id>");
const result2 = await thread2.run("Pick up where you left off");
```

---

## 3. domain relationships

### 3.1 treestruct of domain objects

```
BrainRepl (rhachet interface)
├── repo: string (e.g., "anthropic", "openai")
├── slug: string (e.g., "claude-code", "codex")
├── description: string
└── imagine: <TOutput>(input, context?) => Promise<TOutput>
    ├── input.role.briefs: Artifact<GitFile>[]
    ├── input.prompt: string
    └── input.schema.output: z.Schema<TOutput>

@anthropic-ai/claude-agent-sdk
├── query() => AsyncGenerator<SDKMessage>
│   ├── Options
│   │   ├── prompt: string
│   │   ├── allowedTools: string[]
│   │   ├── systemPrompt: string
│   │   ├── permissionMode: PermissionMode
│   │   └── ...
│   └── SDKMessage (streamed)
│       ├── SDKAssistantMessage
│       ├── SDKResultMessage { result: string }
│       └── ...

@openai/codex-sdk
├── Codex (client)
│   └── startThread() => Thread
│       └── run(prompt) => Turn
│           ├── finalResponse: string
│           └── usage: UsageMetrics
└── resumeThread(id) => Thread
```

### 3.2 mapping to BrainRepl.imagine()

both SDKs need to be adapted to the `BrainRepl.imagine()` contract:

| BrainRepl.imagine | Claude Agent SDK | Codex SDK |
|:------------------|:-----------------|:----------|
| `input.prompt` | `query({ prompt })` | `thread.run(prompt)` |
| `input.role.briefs` | `options.systemPrompt` | prepend to prompt |
| `input.schema.output` | `options.outputFormat`? | `options.outputSchema` |
| return value | `message.result` from SDKResultMessage | `turn.finalResponse` |

### 3.3 key differences from current implementation

**current (basic chat completion):**
- single-turn message/response
- no tool use
- no agentic loop

**desired (agentic SDK):**
- multi-turn agentic loop with tool use
- built-in tools (Read, Edit, Bash, Glob, Grep, etc)
- session management for context persistence

---

## 4. how domain objects compose to support wish

### 4.1 brainReplClaudeCode transformation

```typescript
// current (basic completion)
const anthropic = new Anthropic();
const response = await anthropic.messages.create({...});

// desired (agentic sdk)
import { query } from "@anthropic-ai/claude-agent-sdk";

for await (const message of query({
  prompt: input.prompt,
  options: {
    systemPrompt: systemPromptFromBriefs,
    allowedTools: ["Read", "Edit", "Bash", "Glob", "Grep"],
    permissionMode: "bypassPermissions"
  }
})) {
  if (message.type === 'result' && message.subtype === 'success') {
    return input.schema.output.parse({ content: message.result });
  }
}
```

### 4.2 brainReplCodex transformation

```typescript
// current (basic completion)
const openai = new OpenAI();
const response = await openai.chat.completions.create({...});

// desired (agentic sdk)
import { Codex } from "@openai/codex-sdk";

const codex = new Codex();
const thread = codex.startThread();
const turn = await thread.run(promptWithBriefs);
return input.schema.output.parse({ content: turn.finalResponse });
```

### 4.3 considerations

1. **authentication**: both SDKs require API keys
   - claude agent sdk: `ANTHROPIC_API_KEY`
   - codex sdk: openai account or api key

2. **permissions**: claude agent sdk has explicit permission modes
   - use `bypassPermissions` for automated/programmatic use
   - or implement `canUseTool` for custom permission logic

3. **tool configuration**: may want to expose tool selection via context
   - default to safe read-only tools (Read, Glob, Grep)
   - allow Edit, Write, Bash when explicitly enabled

4. **schema output**: both SDKs support structured output
   - claude: `options.outputFormat`
   - codex: `options.outputSchema` (supports zod via zod-to-json-schema)

---

## 5. native json schema enforcement for outputs

both SDKs support native JSON schema enforcement, which guarantees structured output matching a defined schema. this is critical for the `BrainRepl.imagine()` contract which expects `input.schema.output: z.Schema<TOutput>`.

### 5.1 claude agent sdk - structured outputs

> "Structured outputs provide reliable, type-safe integration with your applications: Validated structure - Always receive valid JSON matching your schema. Simplified integration - No parsing or validation code needed. Type safety - Use with TypeScript or Python type hints for end-to-end safety." [7]

#### 5.1.1 configuration

```typescript
import { query } from '@anthropic-ai/claude-agent-sdk';

const schema = {
  type: 'object',
  properties: {
    company_name: { type: 'string' },
    founded_year: { type: 'number' }
  },
  required: ['company_name']
};

for await (const message of query({
  prompt: 'Research Anthropic',
  options: {
    outputFormat: {
      type: 'json_schema',
      schema: schema
    }
  }
})) {
  if (message.type === 'result' && message.structured_output) {
    console.log(message.structured_output);
    // { company_name: "Anthropic", founded_year: 2021 }
  }
}
```

#### 5.1.2 zod integration

> "For TypeScript projects, use Zod for type-safe schema definition and validation" [7]

```typescript
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

const AnalysisResult = z.object({
  summary: z.string(),
  issues: z.array(z.object({
    severity: z.enum(['low', 'medium', 'high']),
    description: z.string()
  })),
  score: z.number().min(0).max(100)
});

// convert to JSON Schema
const schema = zodToJsonSchema(AnalysisResult, { $refStrategy: 'root' });

for await (const message of query({
  prompt: 'Analyze the codebase',
  options: {
    outputFormat: { type: 'json_schema', schema }
  }
})) {
  if (message.type === 'result' && message.structured_output) {
    const parsed = AnalysisResult.safeParse(message.structured_output);
    if (parsed.success) {
      // fully typed: parsed.data.score, parsed.data.issues, etc
    }
  }
}
```

#### 5.1.3 result access

- `message.structured_output` - parsed JSON object matching schema
- `message.result` - string representation (fallback)
- `message.subtype === 'error_max_structured_output_retries'` - schema validation failed

#### 5.1.4 supported json schema features [7]

- all basic types: object, array, string, integer, number, boolean, null
- `enum`, `const`, `required`, `additionalProperties` (must be `false`)
- string formats: `date-time`, `date`, `email`, `uri`, `uuid`, etc.
- `$ref`, `$def`, and `definitions`

### 5.2 codex sdk - structured outputs

> "The Codex SDK allows you to define a JSON schema for structured output. [...] You can also create a JSON schema from a Zod schema using the `zod-to-json-schema` package and setting the target to 'openAi'." [8]

#### 5.2.1 configuration

```typescript
import { Codex } from "@openai/codex-sdk";

const schema = {
  type: 'object',
  properties: {
    summary: { type: 'string' },
    status: { type: 'string', enum: ['ok', 'action_required'] }
  },
  required: ['summary', 'status'],
  additionalProperties: false
};

const codex = new Codex();
const thread = codex.startThread({ outputSchema: schema });
const turn = await thread.run("Summarize repository status");
// turn.finalResponse contains JSON matching schema
```

#### 5.2.2 zod integration

```typescript
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

const schema = z.object({
  summary: z.string(),
  status: z.enum(['ok', 'action_required'])
});

const thread = codex.startThread({
  outputSchema: zodToJsonSchema(schema, { target: 'openAi' })
});

const turn = await thread.run("Summarize repository status");
const parsed = schema.parse(JSON.parse(turn.finalResponse));
```

#### 5.2.3 cli / action usage

```bash
# CLI
codex exec "Review my pull request!" --output-schema codex-output-schema.json

# GitHub Action
- uses: openai/codex-action@main
  with:
    output-schema-file: codex-output-schema.json
    output-file: codex-output.json
```

### 5.3 comparison for BrainRepl integration

| Feature | Claude Agent SDK | Codex SDK |
|:--------|:-----------------|:----------|
| **option name** | `outputFormat` | `outputSchema` |
| **schema format** | `{ type: 'json_schema', schema }` | direct JSON Schema |
| **zod support** | via `zod-to-json-schema` | via `zod-to-json-schema` with `target: 'openAi'` |
| **result access** | `message.structured_output` | `turn.finalResponse` (parse JSON) |
| **error handling** | `subtype === 'error_max_structured_output_retries'` | exception on parse failure |
| **beta status** | public beta (Nov 2025) | GA |

### 5.4 integration with BrainRepl.imagine()

the `input.schema.output: z.Schema<TOutput>` can be converted to JSON Schema for native enforcement:

```typescript
// brainReplClaudeCode
import { zodToJsonSchema } from 'zod-to-json-schema';

const jsonSchema = zodToJsonSchema(input.schema.output, { $refStrategy: 'root' });

for await (const message of query({
  prompt: input.prompt,
  options: {
    outputFormat: { type: 'json_schema', schema: jsonSchema }
  }
})) {
  if (message.type === 'result' && message.structured_output) {
    return input.schema.output.parse(message.structured_output);
  }
}
```

```typescript
// brainReplCodex
import { zodToJsonSchema } from 'zod-to-json-schema';

const jsonSchema = zodToJsonSchema(input.schema.output, { target: 'openAi' });
const thread = codex.startThread({ outputSchema: jsonSchema });
const turn = await thread.run(promptWithBriefs);
return input.schema.output.parse(JSON.parse(turn.finalResponse));
```

---

## 6. ask vs act pattern (readonly vs read+write)

both SDKs have native support for distinguishing between readonly operations (analysis, research) and read+write operations (code changes, file edits). this maps cleanly to a `BrainRepl.ask()` vs `BrainRepl.act()` interface.

### 6.1 claude agent sdk - permission modes

> "The SDK supports four permission modes, each with different behavior: `default` (standard permission behavior), `plan` (planning mode - no execution), `acceptEdits` (auto-accept file edits), `bypassPermissions` (bypass all permission checks)." [10]

#### 6.1.1 readonly configuration (ask)

```typescript
// readonly: only allow analysis tools
for await (const message of query({
  prompt: input.prompt,
  options: {
    allowedTools: ["Read", "Glob", "Grep", "WebSearch", "WebFetch"],
    disallowedTools: ["Edit", "Write", "Bash", "NotebookEdit"],
    permissionMode: "bypassPermissions",
    allowDangerouslySkipPermissions: true
  }
})) { ... }
```

> "The ability to whitelist tools is critical for the Principle of Least Privilege: only provide the minimum tools needed for a task. Read-only environments need to prevent any modifications when only analysis is required." [11]

**note**: there's a known issue where `allowedTools` may be ignored in `bypassPermissions` mode. workaround is to use `disallowedTools` to explicitly block write operations [11].

#### 6.1.2 read+write configuration (act)

```typescript
// read+write: full tool access
for await (const message of query({
  prompt: input.prompt,
  options: {
    allowedTools: ["Read", "Edit", "Write", "Bash", "Glob", "Grep"],
    permissionMode: "bypassPermissions",
    allowDangerouslySkipPermissions: true
  }
})) { ... }
```

### 6.2 codex sdk - approval & sandbox modes

> "Approval modes define how much Codex can do without stopping for confirmation. [...] There are three main approval modes: Auto, Read-only, Full Access." [12]

#### 6.2.1 sandbox modes

| Mode | Description |
|:-----|:------------|
| `read-only` | only permits reading files |
| `workspace-write` | permits reading + editing in cwd and writable_roots |
| `danger-full-access` | no filesystem sandboxing |

#### 6.2.2 approval modes

| Mode | Description |
|:-----|:------------|
| `untrusted` | maximum approval requirements |
| `on-failure` | only pause on errors |
| `on-request` | pause when user requests |
| `never` | run without any approval |

#### 6.2.3 readonly configuration (ask)

```typescript
const thread = codex.startThread({
  // SDK equivalent of --sandbox read-only --ask-for-approval never
});
```

**cli equivalent**: `codex --sandbox read-only --ask-for-approval never`

#### 6.2.4 read+write configuration (act)

```typescript
const thread = codex.startThread({
  // SDK equivalent of --sandbox workspace-write --ask-for-approval on-failure
});
// or use --full-auto flag equivalent
```

**cli equivalent**: `codex --full-auto` (sets `--sandbox workspace-write --ask-for-approval on-failure`)

### 6.3 mapping to BrainRepl interface

| Mode | Claude Agent SDK | Codex SDK |
|:-----|:-----------------|:----------|
| **ask (readonly)** | `disallowedTools: ["Edit", "Write", "Bash"]` | `--sandbox read-only` |
| **act (read+write)** | `allowedTools: ["Read", "Edit", "Write", "Bash", ...]` | `--sandbox workspace-write` |

---

## 7. BrainReplPlugs: toolboxes, memory, and access

the agentic SDKs support extensible plugin systems for tools, memory management, and permission control. this maps to a `BrainReplPlugs` interface.

### 7.1 toolboxes (tool configuration)

#### 7.1.1 claude agent sdk - MCP servers

> "Connect to external systems via the Model Context Protocol: databases, browsers, APIs, and hundreds more." [1]

```typescript
const result = query({
  prompt: "...",
  options: {
    mcpServers: {
      playwright: { command: "npx", args: ["@playwright/mcp@latest"] },
      database: { command: "npx", args: ["@modelcontextprotocol/server-postgres"] }
    },
    allowedTools: ["Read", "Glob", "mcp__playwright__*", "mcp__database__*"]
  }
});
```

#### 7.1.2 codex sdk - MCP integration

codex also supports MCP servers via configuration. tools are defined via JSON schema.

### 7.2 memory management (context compression)

#### 7.2.1 claude agent sdk - sessions and compaction

> "The Agent SDK includes context management capabilities such as compaction, which enables agents to work on tasks without exhausting the context window." [13]

```typescript
// session resume for context continuity
const q1 = query({ prompt: "Read the auth module", options: { allowedTools: ["Read", "Glob"] } });
let sessionId: string;
for await (const msg of q1) {
  if (msg.type === 'system' && msg.subtype === 'init') sessionId = msg.session_id;
}

// resume with full context
const q2 = query({ prompt: "Now find all callers", options: { resume: sessionId } });
```

> "Compaction summarizes older turns to preserve intent, decisions, and open threads. Keep raw tool outputs out of history. Keep short, precise summaries in." [13]

features:
- automatic context compaction when approaching limits
- session persistence via `resume` option
- `PreCompact` hook for custom compression logic

#### 7.2.2 codex sdk - session persistence

```typescript
// resume a previous thread
const thread = codex.resumeThread("<thread-id>");
const result = await thread.run("Continue where we left off");
```

sessions stored in `~/.codex/sessions/`.

### 7.3 access control (permission guards)

#### 7.3.1 claude agent sdk - canUseTool callback

> "The `canUseTool` callback is passed as an option when calling the `query` function. It receives the tool name and input parameters, and must return a decision - either allow or deny." [10]

```typescript
const result = query({
  prompt: "...",
  options: {
    canUseTool: async (toolName, input, { signal }) => {
      // custom permission logic
      if (toolName === "Bash" && input.command.includes("rm -rf")) {
        return { behavior: "deny", message: "Dangerous command blocked" };
      }
      return { behavior: "allow", updatedInput: input };
    }
  }
});
```

#### 7.3.2 claude agent sdk - hooks

> "Run custom code at key points in the agent lifecycle. SDK hooks use callback functions to validate, log, block, or transform agent behavior." [1]

available hooks: `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `Notification`, `UserPromptSubmit`, `SessionStart`, `SessionEnd`, `Stop`, `SubagentStart`, `SubagentStop`, `PreCompact`, `PermissionRequest`

```typescript
const result = query({
  prompt: "...",
  options: {
    hooks: {
      PreToolUse: [{
        matcher: "Edit|Write",
        hooks: [async (input, toolUseId, { signal }) => {
          console.log(`Editing file: ${input.tool_input?.file_path}`);
          return {}; // allow
        }]
      }]
    }
  }
});
```

### 7.4 proposed BrainReplPlugs interface

```typescript
/**
 * .what = configuration plugs for BrainRepl instances
 * .why = enables extensible tooling, memory management, and access control
 *   for agentic workloads without coupling to specific SDK implementations
 */
interface BrainReplPlugs {
  /**
   * .what = additional tool providers beyond built-in tools
   * .why = enables domain-specific tooling (databases, browsers, APIs)
   *   via MCP servers or custom tool definitions
   */
  toolboxes?: never; // todo: allow configuration
  // toolboxes?: BrainActorToolbox[];

  /**
   * .what = memory and context management strategy
   * .why = enables custom context compression, session persistence,
   *   and artifact management for long-running workflows
   */
  memory?: never; // todo: allow configuration
  // memory?: BrainActorMemory;

  /**
   * .what = permission guard and access control
   * .why = enables custom authorization logic, audit logging,
   *   and tool-level access policies beyond SDK defaults
   */
  access?: never; // todo: allow configuration
  // access?: BrainActorAccess;
}
```

### 7.5 proposed BrainRepl interface update

```typescript
interface BrainRepl {
  repo: string;
  slug: string;
  description: string;

  /**
   * .what = readonly imagination operation (analysis, research, queries)
   * .why = provides safe, non-mutating agent interactions
   *   with only read access to filesystem and tools
   */
  ask: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;

  /**
   * .what = read+write imagination operation (code changes, file edits)
   * .why = provides full agentic capabilities with write access
   *   for tasks that require modifying the codebase
   */
  act: <TOutput>(
    input: {
      plugs?: BrainReplPlugs;
      role: { briefs?: Artifact<typeof GitFile>[] };
      prompt: string;
      schema: { output: z.Schema<TOutput> };
    },
    context?: Empty,
  ) => Promise<TOutput>;
}
```

### 7.6 usage examples

```typescript
// readonly analysis
const analysis = await context.brain.repl.ask({
  brain: { repo: 'anthropic', slug: 'claude/code' },
  plugs: { /* optional overrides */ },
  role: { briefs: roleBriefs },
  prompt: "Analyze this codebase for security issues",
  schema: { output: AnalysisResultSchema }
});

// read+write implementation
const result = await context.brain.repl.act({
  brain: { repo: 'anthropic', slug: 'claude/code' },
  plugs: { /* optional overrides */ },
  role: { briefs: roleBriefs },
  prompt: "Fix the authentication bug in auth.ts",
  schema: { output: FixResultSchema }
});
```

---

## citations

[1] Agent SDK overview - Claude Docs
https://platform.claude.com/docs/en/agent-sdk/overview
> "Build AI agents that autonomously read files, run commands, search the web, edit code, and more."

[2] Agent SDK reference - TypeScript - Claude Docs
https://platform.claude.com/docs/en/agent-sdk/typescript
> Complete API reference including query(), Options, SDKMessage types

[3] Codex SDK - OpenAI Developers
https://developers.openai.com/codex/sdk/
> "The TypeScript SDK wraps the bundled codex binary."

[4] Codex SDK README - GitHub
https://github.com/openai/codex (sdk/typescript/README.md)
> Thread management, run(), runStreamed(), input types

[5] @anthropic-ai/claude-agent-sdk - npm
https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk
> Package information, version 2.0.x

[6] @openai/codex-sdk - npm
https://www.npmjs.com/package/@openai/codex-sdk
> Package information, version 0.77.0

[7] Structured outputs in the SDK - Claude Docs
https://platform.claude.com/docs/en/agent-sdk/structured-outputs
> "Structured outputs provide reliable, type-safe integration with your applications: Validated structure - Always receive valid JSON matching your schema."

[8] Build Code Review with the Codex SDK - OpenAI Cookbook
https://cookbook.openai.com/examples/codex/build_code_review_with_codex_sdk
> "You can also create a JSON schema from a Zod schema using the `zod-to-json-schema` package and setting the target to 'openAi'."

[9] Structured model outputs - OpenAI API
https://platform.openai.com/docs/guides/structured-outputs
> "Supplying a schema for tools or as a response format is as easy as supplying a Pydantic or Zod object, and the SDKs will handle converting the data type to a supported JSON schema"

[10] Handling Permissions - Claude Docs
https://platform.claude.com/docs/en/agent-sdk/permissions
> "The SDK supports four permission modes, each with different behavior: default, plan, acceptEdits, bypassPermissions"

[11] allowedTools does not restrict built-in tools - GitHub Issue
https://github.com/anthropics/claude-agent-sdk-typescript/issues/115
> "The ability to whitelist tools is critical for the Principle of Least Privilege: only provide the minimum tools needed for a task."

[12] Codex CLI approval modes explained - Vladimir Siedykh
https://vladimirsiedykh.com/blog/codex-cli-approval-modes-2025
> "Approval modes define how much Codex can do without stopping for confirmation. There are three main approval modes: Auto, Read-only, Full Access."

[13] Effective harnesses for long-running agents - Anthropic Engineering
https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents
> "The Agent SDK includes context management capabilities such as compaction, which enables agents to work on tasks without exhausting the context window."

[14] Codex CLI reference - OpenAI Developers
https://developers.openai.com/codex/cli/reference/
> "--sandbox: read-only | workspace-write | danger-full-access; --ask-for-approval: untrusted | on-failure | on-request | never"
