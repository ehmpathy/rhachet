# Demo: Invoking Claude Code via TypeScript

This demo shows various ways to programmatically invoke Claude Code from TypeScript using Node.js child process APIs.

## Prerequisites

```bash
# Ensure Claude Code is installed
which claude  # Should output: /home/vlad/.local/bin/claude (or similar)

# Ensure you're authenticated
claude --help  # Should work without errors
```

## Approach 1: Simple Synchronous Execution

Use `execSync` for simple, blocking operations:

```typescript
import { execSync } from 'child_process';

// Simple prompt execution
const result = execSync('claude --print "What is 2+2?"', {
  encoding: 'utf-8',
  maxBuffer: 10 * 1024 * 1024, // 10MB buffer for larger responses
});

console.log('Response:', result);
```

## Approach 2: Asynchronous Execution with Promises

Use `exec` wrapped in a promise for non-blocking operations:

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function askClaude(prompt: string): Promise<string> {
  const { stdout, stderr } = await execAsync(
    `claude --print "${prompt.replace(/"/g, '\\"')}"`,
    {
      maxBuffer: 10 * 1024 * 1024,
    }
  );

  if (stderr) {
    console.error('Warnings/Errors:', stderr);
  }

  return stdout;
}

// Usage
const answer = await askClaude('Explain TypeScript generics in one sentence');
console.log(answer);
```

## Approach 3: JSON Output Format

Use `--output-format json` for structured responses:

```typescript
import { execSync } from 'child_process';

interface ClaudeJsonResponse {
  content: Array<{
    type: string;
    text?: string;
  }>;
  stop_reason: string;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

function askClaudeJson(prompt: string): ClaudeJsonResponse {
  const result = execSync(
    `claude --print --output-format json "${prompt.replace(/"/g, '\\"')}"`,
    {
      encoding: 'utf-8',
      maxBuffer: 10 * 1024 * 1024,
    }
  );

  return JSON.parse(result);
}

// Usage
const response = askClaudeJson('What is TypeScript?');
console.log('Text:', response.content[0].text);
console.log('Tokens used:', response.usage.output_tokens);
```

## Approach 4: Streaming with Spawn

Use `spawn` for real-time streaming of responses:

```typescript
import { spawn } from 'child_process';

function askClaudeStreaming(prompt: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const claude = spawn('claude', [
      '--print',
      '--output-format',
      'stream-json',
      prompt
    ]);

    let fullResponse = '';
    let buffer = '';

    claude.stdout.on('data', (chunk) => {
      buffer += chunk.toString();

      // Process line by line
      const lines = buffer.split('\n');
      buffer = lines.pop() || ''; // Keep incomplete line in buffer

      for (const line of lines) {
        if (line.trim()) {
          try {
            const parsed = JSON.parse(line);
            if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
              fullResponse += parsed.delta.text;
              process.stdout.write(parsed.delta.text); // Stream to console
            }
          } catch (e) {
            // Skip malformed JSON
          }
        }
      }
    });

    claude.stderr.on('data', (data) => {
      console.error('Error:', data.toString());
    });

    claude.on('close', (code) => {
      if (code === 0) {
        resolve(fullResponse);
      } else {
        reject(new Error(`Claude exited with code ${code}`));
      }
    });
  });
}

// Usage
console.log('Asking Claude...');
const answer = await askClaudeStreaming('Explain async/await in TypeScript');
console.log('\n\nFull response:', answer);
```

## Approach 5: Multi-turn Conversation with Session Management

Use `--continue` or `--session-id` for multi-turn conversations:

```typescript
import { execSync } from 'child_process';
import { randomUUID } from 'crypto';

class ClaudeSession {
  private sessionId: string;

  constructor() {
    this.sessionId = randomUUID();
  }

  ask(prompt: string): string {
    return execSync(
      `claude --print --session-id ${this.sessionId} "${prompt.replace(/"/g, '\\"')}"`,
      {
        encoding: 'utf-8',
        maxBuffer: 10 * 1024 * 1024,
      }
    );
  }

  getSessionId(): string {
    return this.sessionId;
  }
}

// Usage - maintain context across multiple questions
const session = new ClaudeSession();
console.log('Session ID:', session.getSessionId());

const firstResponse = session.ask('My favorite color is blue');
console.log('First:', firstResponse);

const secondResponse = session.ask('What is my favorite color?');
console.log('Second:', secondResponse); // Should remember "blue"
```

## Approach 6: Piping Input via stdin

For complex prompts or file content:

```typescript
import { spawn } from 'child_process';

function askClaudeWithStdin(prompt: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const claude = spawn('claude', ['--print']);

    let output = '';

    claude.stdout.on('data', (data) => {
      output += data.toString();
    });

    claude.stderr.on('data', (data) => {
      console.error('Error:', data.toString());
    });

    claude.on('close', (code) => {
      if (code === 0) {
        resolve(output);
      } else {
        reject(new Error(`Process exited with code ${code}`));
      }
    });

    // Write prompt to stdin
    claude.stdin.write(prompt);
    claude.stdin.end();
  });
}

// Usage
const longPrompt = `
Analyze this code and suggest improvements:

\`\`\`typescript
function add(a, b) {
  return a + b;
}
\`\`\`
`;

const analysis = await askClaudeWithStdin(longPrompt);
console.log(analysis);
```

## Approach 7: Limiting Tools and Customizing Behavior

Control which tools Claude can use:

```typescript
import { execSync } from 'child_process';

function askClaudeRestricted(prompt: string, allowedTools: string[] = []): string {
  const toolsArg = allowedTools.length > 0
    ? `--allowed-tools ${allowedTools.join(' ')}`
    : '--tools ""'; // Disable all tools

  return execSync(
    `claude --print ${toolsArg} "${prompt.replace(/"/g, '\\"')}"`,
    {
      encoding: 'utf-8',
      maxBuffer: 10 * 1024 * 1024,
    }
  );
}

// Usage - allow only specific tools
const response = askClaudeRestricted(
  'List files in current directory',
  ['Bash(ls:*)']
);
console.log(response);

// Usage - disable all tools (pure text response)
const pureTextResponse = askClaudeRestricted(
  'What is the capital of France?',
  []
);
console.log(pureTextResponse);
```

## Complete Example: TypeScript Module

```typescript
// claude-client.ts
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface ClaudeOptions {
  model?: 'sonnet' | 'opus' | 'haiku';
  outputFormat?: 'text' | 'json' | 'stream-json';
  allowedTools?: string[];
  sessionId?: string;
  maxTokens?: number;
}

export class ClaudeClient {
  private defaultOptions: ClaudeOptions;

  constructor(defaultOptions: ClaudeOptions = {}) {
    this.defaultOptions = defaultOptions;
  }

  async ask(prompt: string, options?: ClaudeOptions): Promise<string> {
    const opts = { ...this.defaultOptions, ...options };

    const args = ['--print'];

    if (opts.model) {
      args.push('--model', opts.model);
    }

    if (opts.outputFormat) {
      args.push('--output-format', opts.outputFormat);
    }

    if (opts.allowedTools && opts.allowedTools.length > 0) {
      args.push('--allowed-tools', ...opts.allowedTools);
    }

    if (opts.sessionId) {
      args.push('--session-id', opts.sessionId);
    }

    const command = `claude ${args.join(' ')} "${prompt.replace(/"/g, '\\"')}"`;

    try {
      const { stdout } = await execAsync(command, {
        maxBuffer: 10 * 1024 * 1024,
      });

      return stdout;
    } catch (error) {
      throw new Error(`Claude invocation failed: ${error}`);
    }
  }
}

// Usage
const client = new ClaudeClient({ model: 'sonnet' });
const response = await client.ask('Hello, Claude!');
console.log(response);
```

## Testing Your Integration

```typescript
// test-claude-integration.ts
import { ClaudeClient } from './claude-client';

async function testClaudeIntegration() {
  const client = new ClaudeClient();

  console.log('Test 1: Simple question');
  const test1 = await client.ask('What is 2+2? Answer with just the number.');
  console.log('Answer:', test1.trim());

  console.log('\nTest 2: Code generation');
  const test2 = await client.ask(
    'Write a TypeScript function that reverses a string. Just show the code.'
  );
  console.log('Code:', test2);

  console.log('\nTest 3: JSON output');
  const test3 = await client.ask('List 3 colors', { outputFormat: 'json' });
  const parsed = JSON.parse(test3);
  console.log('Structured response:', parsed.content[0].text);

  console.log('\nAll tests completed!');
}

testClaudeIntegration().catch(console.error);
```

## Key Considerations

1. **Error Handling**: Always handle potential errors from child process execution
2. **Buffer Size**: Set appropriate `maxBuffer` for large responses
3. **Escaping**: Properly escape quotes and special characters in prompts
4. **Timeouts**: Consider adding timeouts for long-running operations
5. **Rate Limiting**: Implement rate limiting if making many requests
6. **Authentication**: Ensure Claude Code is authenticated before programmatic use
7. **Environment**: Claude Code respects environment variables and config files

## Security Notes

- Never pass unsanitized user input directly to `claude` command
- Use `--dangerously-skip-permissions` only in sandboxed environments
- Be cautious with `--allowed-tools` when running untrusted code
- Validate and sanitize all inputs before passing to Claude

## Performance Tips

- Use `--output-format stream-json` for large responses to get incremental updates
- Use `--tools ""` to disable tools when you only need text responses
- Reuse session IDs for multi-turn conversations to maintain context
- Consider caching responses for repeated queries
