# blueprint: fix writable for self-referenced repo dist directories

## .summary

when a `rhachet-roles-*` package references itself via `"package-name": "file:."` in its package.json, the `roles link` command should NOT make the linked source directories readonly, because they are part of the repo's own `/dist` directory which must remain writable for subsequent build and install operations.

## .root cause

in `symlinkResourceDirectories.ts`, the `setDirectoryReadonlyExecutable` function (line 112) changes the SOURCE directory permissions to `0o555` (readonly + executable). this is correct for external packages in `node_modules/`, but when the package references itself:

```json
{
  "dependencies": {
    "rhachet-roles-ehmpathy": "file:."
  }
}
```

the source path resolves to within the current repo (e.g., `/path/to/repo/dist/...`), and the readonly permissions break subsequent `npm install` or build operations:

```
ERR_PNPM_EACCES  EACCES: permission denied, rmdir '.../dist/domain.roles/mechanic/briefs/.archive'
```

## .solution

use `ContextCli.gitroot` to detect when the source path is within the git repository and skip the readonly chmod operation for those paths. using `gitroot` is more accurate than `cwd` because:

1. `cwd` could be a subdirectory of the repo
2. `gitroot` is the actual repository boundary

### detection logic

```ts
import type { ContextCli } from '@src/domain.objects/ContextCli';

/**
 * .what = checks if a resolved path is within the git repo root
 * .why = to avoid readonly for the repo's own directories when self-referenced
 */
const isPathWithinGitroot = (
  input: { path: string },
  context: ContextCli,
): boolean => {
  const normalizedPath = resolve(input.path);
  const normalizedGitroot = resolve(context.gitroot);

  // check if path starts with gitroot (is inside the repo)
  return (
    normalizedPath.startsWith(normalizedGitroot + '/') ||
    normalizedPath === normalizedGitroot
  );
};
```

### modification points

#### 1. thread `ContextCli` through the call chain

- `invokeRolesLink.ts` → `execRoleLink.ts` → `symlinkResourceDirectories.ts`
- pass `context: ContextCli` to functions that need it

#### 2. in `linkSourceToTarget`, conditionally skip `setDirectoryReadonlyExecutable`:

```ts
const linkSourceToTarget = (
  input: {
    sourcePath: string;
    targetPath: string;
  },
  context: ContextCli,
): { fileCount: number; result: LinkResult } => {
  // ... prior logic ...

  symlinkSync(relativeSource, targetPath, 'dir');

  // only set readonly for external sources (not within current repo)
  const sourceIsWithinRepo = isPathWithinGitroot(
    { path: sourcePath },
    context,
  );
  if (!sourceIsWithinRepo) {
    setDirectoryReadonlyExecutable({ dirPath: sourcePath });
  }

  const fileCount = countFilesInDirectory({ dirPath: sourcePath });
  // ... rest of function ...
};
```

---

## .files to modify

| file | change |
|------|--------|
| `src/domain.operations/invoke/link/isPathWithinGitroot.ts` | new file: detection function with `(input: { path }, context: ContextCli)` signature |
| `src/domain.operations/invoke/link/symlinkResourceDirectories.ts` | add `context: ContextCli` param, guard around `setDirectoryReadonlyExecutable` |
| `src/domain.operations/invoke/link/execRoleLink.ts` | add `context: ContextCli` param, pass to `symlinkResourceDirectories` |
| `src/contract/cli/invokeRolesLink.ts` | pass `ContextCli` to `execRoleLink` |

---

## .test coverage

### unit tests (new file: `isPathWithinGitroot.test.ts`)

| case | description |
|------|-------------|
| `[case1]` | returns true for path inside gitroot |
| `[case2]` | returns false for path outside gitroot (e.g., `/tmp/node_modules/...`) |
| `[case3]` | returns false for path with similar prefix but different root (e.g., `/repo-other/...` vs `/repo/...`) |
| `[case4]` | handles edge case where path equals gitroot exactly |

### integration tests (extend: `invokeRolesLink.integration.test.ts`)

| case | description |
|------|-------------|
| `[case-self-ref]` | when source dir is within gitroot, files remain writable (mode `0o755`) |
| `[case-external]` | when source dir is outside gitroot (external), files are set to readonly (mode `0o555`) |

### acceptance tests (new case in: `accept.blackbox/cli/roles.link.acceptance.test.ts` if present, or create)

| case | description |
|------|-------------|
| `[case-self-ref-repo]` | simulate a roles package that references itself, verify `/dist` remains writable after link |

---

## .implementation phases

### phase 0: unit tests for detection logic

1. create `src/domain.operations/invoke/link/isPathWithinGitroot.ts` with the detection function
2. create `src/domain.operations/invoke/link/isPathWithinGitroot.test.ts` with unit tests
3. verify all unit tests pass

### phase 1: thread context through call chain

1. update `symlinkResourceDirectories.ts` to accept `context: ContextCli`
2. update `execRoleLink.ts` to accept and pass `context: ContextCli`
3. update `invokeRolesLink.ts` to pass `ContextCli` instance
4. verify prior integration tests still pass (they may need mock context updates)

### phase 2: add guard around setDirectoryReadonlyExecutable

1. import `isPathWithinGitroot` into `symlinkResourceDirectories.ts`
2. add guard around `setDirectoryReadonlyExecutable` call
3. verify the readonly behavior is preserved for external sources

### phase 3: add integration test for self-referenced scenario

1. extend `invokeRolesLink.integration.test.ts` with a new `given` block
2. create a scenario where the source path is within gitroot
3. assert that files remain writable (mode `0o755` or `0o644`)

### phase 4: acceptance test (optional, if time permits)

1. create acceptance test that simulates the full scenario
2. use a temp repo with `"package-name": "file:."` pattern
3. invoke `rhachet roles link` and verify dist remains writable

---

## .verification criteria

### must-have

- [ ] `npm install` succeeds after `roles link` in a self-referenced repo
- [ ] external packages in `node_modules/` still get readonly permissions (security preserved)
- [ ] all prior tests pass
- [ ] new unit tests cover the detection logic
- [ ] new integration test covers the self-referenced scenario

### nice-to-have

- [ ] acceptance test for end-to-end verification
- [ ] log message indicates when readonly was skipped (for observability)

---

## .risks and mitigations

| risk | mitigation |
|------|------------|
| false positive detection (path appears to be in gitroot but shouldn't be protected) | use `path.resolve()` to normalize paths and strict `startsWith` check with trailing `/` |
| false negative detection (symlink targets outside gitroot are incorrectly protected) | resolve the actual source path before the check, not the symlink target |
| regression in readonly security for external packages | explicit test case that verifies external packages still get readonly permissions |
| `ContextCli` not available in call chain | thread `ContextCli` through from cli entry point to all link functions via `(input, context)` pattern |

---

## .references

- wish: `.behavior/v2026_01_19.fix-writable-if-this-dist/0.wish.md`
- core file: `src/domain.operations/invoke/link/symlinkResourceDirectories.ts`
- context: `src/domain.objects/ContextCli.ts` (provides `gitroot`)
- test file: `src/contract/cli/invokeRolesLink.integration.test.ts`
