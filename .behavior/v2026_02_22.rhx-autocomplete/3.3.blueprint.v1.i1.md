# blueprint: rhx autocomplete v1

## overview

implement tab completion, `rhx list`, and `rhx search` commands for the rhachet CLI.

**approach**: `--setup` writes completion code directly to `~/.zshrc` (no rhachet completion --setupwrapper, no shell startup cost). the completion function uses **dynamic completion** â€” runs `rhachet completion --list` on each tab press (~35ms via bun) to ensure cwd-awareness across repos.

---

## filediff treestruct

```
src/
  domain.objects/
    [+] RoleSkillLinked.ts                       # skill + description for completion (domain object)

  domain.operations/
    completion/
      [+] getSkillWhatLine.ts                      # includes try/catch error guard
      [+] getSkillWhatLine.test.ts
      [+] getAllRoleSkillsLinked.ts              # returns RoleSkillLinked[]
      [+] getAllRoleSkillsLinked.test.ts
      [+] genZshCompletionCode.ts                  # emits rhx + rhachet with dynamic completion
      [+] genZshCompletionCode.test.ts
      [+] getSkillsMatchedByQuery.ts              # takes RoleSkillLinked[], uses get verb (gap.16/31 fix)
      [+] getSkillsMatchedByQuery.test.ts
      [+] getAllSkillsForList.ts                   # orchestrates: discover + enrich
      [+] getAllSkillsForList.test.ts
      [+] getAllSkillsForSearch.ts                 # orchestrates: discover + enrich + filter
      [+] getAllSkillsForSearch.test.ts
    invoke/
      [â—‹] discoverSkillExecutables.ts              # reuse
      [â—‹] discoverSkillExecutables.integration.test.ts

  contract/
    cli/
      [~] invoke.ts                                # add invokeCompletions, replace invokeList, add invokeSearch
      [+] invokeCompletions.ts
      [+] invokeCompletions.integration.test.ts
      [~] invokeList.ts                            # replace config-based with .agent/-based
      [+] invokeList.integration.test.ts
      [+] invokeSearch.ts                          # search repos/roles/skills from .agent/
      [+] invokeSearch.integration.test.ts
      [+] formatSkillList.ts                       # output format (tree/json, validation inlined)
      [+] formatSkillList.test.ts
      [+] formatAsTree.ts                          # tree format helper
      [+] formatAsTree.test.ts
      [+] formatAsJson.ts                          # json format helper
      [+] formatAsJson.test.ts

  .test/
    infra/
      [~] invokeRhachetCli.ts                      # add invokeRhachetCompletions, invokeRhachetList, invokeRhachetSearch

accept.blackbox/
  cli/
    [+] completion.acceptance.test.ts             # zsh interface contract; cwd-aware behavior
  .test/
    assets/
      [+] with-skill-a/                            # fixture: repo with skill-a for cwd-aware test
      [+] with-skill-b/                            # fixture: repo with skill-b for cwd-aware test

bin/
  [~] run                                          # add completion, list, search cases â†’ bun path (gap.41 fix)
  [~] run.bun                                      # add completion, list, search cases â†’ rhachet-roles.bc (gap.41 fix)
  [~] rhx                                          # add completion, list, search cases â†’ proxy to rhachet (gap.40 fix)

  contract/cli/
    [~] invoke.bun.entry.roles.ts                  # add invokeCompletions, invokeList, invokeSearch (gap.41 fix)
```

**legend:**
- `[+]` create â€” file to create
- `[~]` update â€” file to update
- `[â—‹]` retain â€” file to retain unchanged

---

## codepath treestruct

### usecase.1 = `rhachet completion` (gap.39 cwd-aware fix)

```
[+] invokeCompletions({ program })
    â”‚
    â”‚   program.command('completion')
    â”‚          .option('--list')
    â”‚          .option('--setup')
    â”‚          .action(async (opts) => ...)
    â”‚
    â”œâ”€â”€ if --list (used by dynamic completion on each tab press):
    â”‚   â”œâ”€â”€ [â†] discoverSkillExecutables({ })
    â”‚   â”‚       â””â”€â”€ scans .agent/repo=*/role=*/skills/ in current cwd
    â”‚   â”‚
    â”‚   â”œâ”€â”€ [+] getAllRoleSkillsLinked({ skills })
    â”‚   â”‚       â””â”€â”€ for each skill:
    â”‚   â”‚           â””â”€â”€ [+] getSkillWhatLine({ path })
    â”‚   â”‚
    â”‚   â””â”€â”€ outputs "name:description" lines to stdout
    â”‚
    â”œâ”€â”€ if --setup:
    â”‚   â”œâ”€â”€ verify `rhachet` in PATH (error if not)
    â”‚   â”œâ”€â”€ detect shell from $SHELL (zsh only, error on bash/fish/other)
    â”‚   â”œâ”€â”€ upsert completion block (uses markers for replacement):
    â”‚   â”‚   â”œâ”€â”€ markers: `# rhachet.mark.top` and `# rhachet.mark.bot`
    â”‚   â”‚   â”œâ”€â”€ if markers found: replace block between them
    â”‚   â”‚   â””â”€â”€ if markers not found: append new block
    â”‚   â””â”€â”€ print success message
    â”‚
    â””â”€â”€ default (no flags):
        â””â”€â”€ [+] genZshCompletionCode()
                â”œâ”€â”€ outputs completion code to stdout
                â””â”€â”€ user can redirect: `rhx completion >> ~/.zshrc`
```

### usecase.2 = `rhachet list` (replaces config-based invokeList)

```
[~] invokeList({ program })              # contract layer: validate, dispatch, format
    â”‚
    â”‚   program.command('list')
    â”‚          .option('--repo')
    â”‚          .option('--role')
    â”‚          .option('--output')
    â”‚          .action((opts) => ...)
    â”‚
    â”œâ”€â”€ inline validation                        # validate --output
    â”‚
    â”œâ”€â”€ [+] getAllSkillsForList({ ... })         # dispatch to domain
    â”‚       â”‚
    â”‚       â”œâ”€â”€ [â†] discoverSkillExecutables({ slugRepo, slugRole })
    â”‚       â”‚
    â”‚       â””â”€â”€ [+] getAllRoleSkillsLinked({ skills })
    â”‚
    â””â”€â”€ [+] formatSkillList({ items, format })   # format output
            â”œâ”€â”€ [+] formatAsTree({ ... })
            â””â”€â”€ [+] formatAsJson({ ... })
```

### usecase.3 = `rhachet search`

```
[+] invokeSearch({ program })            # contract layer: validate, dispatch, format
    â”‚
    â”‚   program.command('search')
    â”‚          .argument('[query]')
    â”‚          .option('--output')
    â”‚          .action((query, opts) => ...)
    â”‚
    â”œâ”€â”€ inline validation                        # validate --output
    â”‚
    â”œâ”€â”€ [+] getAllSkillsForSearch({ query })     # dispatch to domain
    â”‚       â”‚
    â”‚       â”œâ”€â”€ [â†] discoverSkillExecutables({ })
    â”‚       â”‚
    â”‚       â”œâ”€â”€ [+] getAllRoleSkillsLinked({ skills })
    â”‚       â”‚
    â”‚       â””â”€â”€ [+] getSkillsMatchedByQuery({ items, query })
    â”‚
    â””â”€â”€ [+] formatSkillList({ items, format, header })  # format output
            â”œâ”€â”€ [+] formatAsTree({ ... })
            â””â”€â”€ [+] formatAsJson({ ... })
```

### bin dispatcher updates

```
bin/run:
  [~] add cases for "completion", "list", "search":
      # route to bun for fast execution (~70ms vs ~300ms jit)
      # all read .agent/ directly (like roles boot), no npm imports needed
      case "$1" in
        completion|list|search)
          exec "$SCRIPT_DIR/run.bun" "$@"
          ;;
      esac

bin/run.bun:
  [~] add cases for "completion", "list", "search":
      # route to rhachet-roles.bc (same binary as roles boot/cost)
      # all are implicitly role operations â€” read from .agent/ directly
      case "$1" in
        completion|list|search)
          exec "$SCRIPT_DIR/run.bun.rhachet-roles.bc" "$@"
          ;;
      esac

bin/rhx:
  [~] add cases for "completion", "list", and "search" (gap.40 fix):
      case "$1" in
        completion)
          shift
          exec "$SCRIPT_DIR/run" completion "$@"
          ;;
        list)
          shift
          exec "$SCRIPT_DIR/run" list "$@"
          ;;
        search)
          shift
          exec "$SCRIPT_DIR/run" search "$@"
          ;;
        *)
          exec "$SCRIPT_DIR/run" run --skill "$@"
          ;;
      esac
```

**legend:**
- `[+]` create â€” codepath to create
- `[~]` update â€” codepath to update
- `[â†]` reuse â€” codepath to reuse from elsewhere

---

## types

```typescript
// src/domain.objects/RoleSkillLinked.ts
import { DomainLiteral } from 'domain-objects';

/**
 * .what = skill registered with its description for completion
 * .why = domain object that pairs skill executable with .what description (gap.16/17 fix)
 * .note = name comes from skill.slug, no need for separate candidate object
 */
export interface RoleSkillLinked {
  skill: RoleSkillExecutable;
  description: string;
}

export class RoleSkillLinked
  extends DomainLiteral<RoleSkillLinked>
  implements RoleSkillLinked {}
```

---

## contracts

### invokeCompletions (gap.39 cwd-aware fix)

```typescript
/**
 * .what = registers `rhachet completion` command
 * .why = enables shell completion output and auto-setup
 * .note = --list mode outputs "name:description" per line for zsh _describe (gap.39 fix)
 */
export const invokeCompletions = ({ program }: { program: Command }): void => {
  program
    .command('completion')
    .option('--list', 'output skill completion as name:description lines (for dynamic completion)')
    .option('--setup', 'auto-install completion to shell rc file (detects shell from $SHELL)')
    .description('output shell completion code or install to rc file')
    .action((opts: { list?: boolean; setup?: boolean }) => {
      // --list mode: output name:description lines for dynamic completion
      if (opts.list) {
        const skills = discoverSkillExecutables({});
        const items = getAllRoleSkillsLinked({ skills });
        const lines = items.map(({ skill, description }) =>
          `${skill.slug}:${description.replace(/:/g, '\\:')}`
        );
        console.log(lines.join('\n'));
        return;
      }

      // --setup mode: auto-install to rc file based on $SHELL
      if (opts.setup) {
        // verify rhachet is globally available
        const rhachetInPath = execSync('which rhachet 2>/dev/null || true', { encoding: 'utf-8' }).trim();
        if (!rhachetInPath) {
          throw new BadRequestError(
            'rhachet not found in PATH. install globally first: npm install -g rhachet',
            {},
          );
        }

        // detect shell from $SHELL (zsh only)
        const shell = process.env.SHELL ?? '';
        if (!shell.includes('zsh')) {
          throw new BadRequestError(
            `unsupported shell: ${shell}. supported: zsh`,
            { shell },
          );
        }

        const rcPath = join(homedir(), '.zshrc');
        const markerTop = '# rhachet.mark.top';
        const markerBot = '# rhachet.mark.bot';

        // generate completion block with markers
        const code = genZshCompletionCode();
        const block = `${markerTop}\n${code}\n${markerBot}`;

        // upsert: replace if markers found, append if not
        const rcContent = existsSync(rcPath) ? readFileSync(rcPath, 'utf-8') : '';
        const hasMarkers = rcContent.includes(markerTop) && rcContent.includes(markerBot);

        if (hasMarkers) {
          // replace block between markers
          const pattern = new RegExp(
            `${escapeRegExp(markerTop)}[\\s\\S]*?${escapeRegExp(markerBot)}`,
            'g'
          );
          const rcContentUpdated = rcContent.replace(pattern, block);
          writeFileSync(rcPath, rcContentUpdated);
          console.log(`completion updated in ${rcPath}`);
        } else {
          // append new block
          appendFileSync(rcPath, `\n${block}\n`);
          console.log(`completion installed to ${rcPath}`);
        }

        console.log(`run: source ${rcPath}`);
        return;
      }

      // default: output completion code to stdout (for >> redirect)
      const code = genZshCompletionCode();
      console.log(code);
    });
};
```

### invokeList (replaces config-based version)

```typescript
/**
 * .what = registers `rhachet list` command
 * .why = contract layer â€” validates input, dispatches to domain, formats output
 */
export const invokeList = ({ program }: { program: Command }): void => {
  program
    .command('list')
    .description('list repos, roles, and skills from .agent/')
    .option('--repo <slug>', 'filter to specific repo')
    .option('--role <slug>', 'filter to specific role')
    .option('--output <format>', 'output format: tree, json', 'tree')
    .action((opts: { repo?: string; role?: string; output?: string }) => {
      // validate --output
      if (opts.output && !['tree', 'json'].includes(opts.output)) {
        throw new BadRequestError(`invalid --output: '${opts.output}'. valid: tree, json`, { output: opts.output });
      }

      // dispatch to domain operation
      const items = getAllSkillsForList({
        slugRepo: opts.repo ?? null,
        slugRole: opts.role ?? null,
      });

      // handle empty state
      if (items.length === 0) {
        console.log('no skills found in .agent/');
        return;
      }

      // format output
      const output = formatSkillList({ items, format: opts.output });
      console.log(output);
    });
};
```

### invokeSearch

```typescript
/**
 * .what = registers `rhachet search` command
 * .why = contract layer â€” validates input, dispatches to domain, formats output
 */
export const invokeSearch = ({ program }: { program: Command }): void => {
  program
    .command('search')
    .description('search repos, roles, and skills from .agent/')
    .argument('[query]', 'search term (optional, empty shows all)')
    .option('--output <format>', 'output format: tree, json', 'tree')
    .action((query: string | undefined, opts: { output?: string }) => {
      // validate --output
      if (opts.output && !['tree', 'json'].includes(opts.output)) {
        throw new BadRequestError(`invalid --output: '${opts.output}'. valid: tree, json`, { output: opts.output });
      }

      // dispatch to domain operation
      const items = getAllSkillsForSearch({ query: query ?? null });

      // handle empty state
      if (items.length === 0) {
        console.log('no skills found in .agent/');
        return;
      }

      // handle no matches
      if (query && items.length === 0) {
        console.log(`no matches for '${query}'`);
        return;
      }

      // format output
      const header = query ? `ğŸ” skills: ${query}` : undefined;
      const output = formatSkillList({ items, format: opts.output, header });
      console.log(output);
    });
};
```

### formatSkillList (contract layer)

```typescript
/**
 * .what = formats skill list for output
 * .why = output format belongs in contract layer
 */
export const formatSkillList = (input: {
  items: RoleSkillLinked[];
  format?: string;
  header?: string;
}): string => {
  const { items, header } = input;

  switch (input.format) {
    case 'json':
      return formatAsJson({
        items,
        transform: ({ skill, description }) => ({
          slug: skill.slug,
          repo: skill.slugRepo,
          role: skill.slugRole,
          path: skill.path,
          description,
        }),
      });

    case 'tree':
    default:
      return formatAsTree({
        items,
        header: header ?? 'ğŸ” skills',
        getGroupKey: ({ skill }) => `repo=${skill.slugRepo}/role=${skill.slugRole}`,
        getLabel: ({ skill }) => skill.slug,
        getDescription: ({ description }) => description,
      });
  }
};
```

---

## domain.operations

### getSkillWhatLine (gap.20 fix)

```typescript
/**
 * .what = extracts .what line from skill file header
 * .why = provides description for completion entries
 * .note = includes try/catch to handle file read errors gracefully (gap.20 fix)
 */
export const getSkillWhatLine = (input: {
  path: string;
}): string | null => {
  // guard: file may be deleted or unreadable between discovery and read
  // note: let required for try/catch assignment pattern (gap.38 fix)
  let content: string;
  try {
    content = readFileSync(input.path, 'utf-8');
  } catch {
    return null;  // file unreadable, treat as no description
  }

  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();

    // match ".what = description" or "# .what = description"
    const match = trimmed.match(/^#?\s*\.what\s*=\s*(.+)$/);
    if (match) return match[1].trim();

    // stop at first non-comment, non-empty line (except shebang)
    if (
      trimmed !== '' &&
      !trimmed.startsWith('#') &&
      !trimmed.startsWith('//')
    ) {
      break;
    }
  }

  return null;
};
```

### getAllRoleSkillsLinked (gap.16/17 fix)

```typescript
/**
 * .what = transforms skills to RoleSkillLinked objects
 * .why = avoids fragile parallel array patterns (gap.16/17 fix)
 */
export const getAllRoleSkillsLinked = (input: {
  skills: RoleSkillExecutable[];
}): RoleSkillLinked[] => {
  return input.skills.map((skill) => new RoleSkillLinked({
    skill,
    description: getSkillWhatLine({ path: skill.path }) ?? '(no description)',
  }));
};
```

### genZshCompletionCode (gap.18 + gap.39 cwd-aware fix)

```typescript
/**
 * .what = generates zsh completion function code for rhx AND rhachet
 * .why = enables tab completion via rhachet completion --setupfor both commands
 * .note = uses dynamic completion to ensure cwd-awareness (gap.39 fix)
 * .note = runs `rhachet completion --list` on each tab press
 */
export const genZshCompletionCode = (): string => {
  // dynamic completion: runs rhachet completion --list on each tab press
  // ensures cwd-awareness â€” completion reflect current repo's skills
  return `# dynamic completion for rhx <skill>
# runs rhachet completion --list on each tab press for cwd-awareness
_rhx() {
  local completion
  completion=("\${(@f)\$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completion
}
compdef _rhx rhx

# dynamic completion for rhachet run --skill <skill>
_rhachet_run_skill() {
  local completion
  completion=("\${(@f)\$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completion
}
compdef _rhachet_run_skill 'rhachet run --skill'`;
};
```

### getSkillsMatchedByQuery (gap.16 + gap.31 + gap.32 fix)

```typescript
/**
 * .what = gets skills matched by query on name or description
 * .why = enables search functionality
 * .note = renamed from filterSkillsByQuery to use get verb (gap.31 fix)
 * .note = takes combined RoleSkillLinked[] to avoid parallel arrays (gap.16 fix)
 */
export const getSkillsMatchedByQuery = (input: {
  items: RoleSkillLinked[];
  query: string;
}): RoleSkillLinked[] => {
  // empty query returns all skills
  if (!input.query.trim()) {
    return input.items;
  }

  const queryLowercased = input.query.toLowerCase();

  return input.items.filter(({ skill, description }) =>
    skill.slug.toLowerCase().includes(queryLowercased) ||
    description.toLowerCase().includes(queryLowercased)
  );
};
```

### formatAsTree (gap.30 fix)

```typescript
/**
 * .what = formats items as box-draw tree grouped by key
 * .why = provides readable tree output for list and search
 * .note = uses reduce for functional composition (gap.30 fix)
 */
export const formatAsTree = <T>(input: {
  items: T[];
  getGroupKey: (item: T) => string;
  getLabel: (item: T) => string;
  getDescription: (item: T) => string;
  header?: string;
}): string => {
  const { items, getGroupKey, getLabel, getDescription, header } = input;

  // group by key via reduce (no mutation)
  const groups = items.reduce<Map<string, T[]>>((acc, item) => {
    const key = getGroupKey(item);
    const extant = acc.get(key);
    return new Map([...acc, [key, extant ? [...extant, item] : [item]]]);
  }, new Map());

  // build header lines
  const headerLines = header ? [header, ''] : [];

  // build group lines via flatMap (no mutation)
  const groupLines = [...groups.entries()].flatMap(([groupKey, groupItems]) => {
    const itemLines = groupItems.map((item, i) => {
      const isLast = i === groupItems.length - 1;
      const prefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
      const label = getLabel(item).padEnd(20);
      return `${prefix}${label}${getDescription(item)}`;
    });
    return [groupKey, ...itemLines, ''];
  });

  return [...headerLines, ...groupLines].join('\n').trimEnd();
};
```

### formatAsJson (gap.35 exception)

```typescript
/**
 * .what = formats items as JSON array
 * .why = provides machine-readable output
 * .note = "format" verb exception: self-evident for output transforms (gap.35)
 */
export const formatAsJson = <T>(input: {
  items: T[];
  transform: (item: T) => Record<string, unknown>;
}): string => {
  return JSON.stringify(input.items.map(input.transform), null, 2);
};
```

### getAllSkillsForList

```typescript
/**
 * .what = orchestrates list: discover + enrich
 * .why = domain operation returns data, contract layer formats output
 */
export const getAllSkillsForList = (input: {
  slugRepo: string | null;
  slugRole: string | null;
}): RoleSkillLinked[] => {
  // discover skills
  const skillsFound = discoverSkillExecutables({
    slugRepo: input.slugRepo ?? undefined,
    slugRole: input.slugRole ?? undefined,
  });

  // enrich with descriptions
  return getAllRoleSkillsLinked({ skills: skillsFound });
};
```

### getAllSkillsForSearch

```typescript
/**
 * .what = orchestrates search: discover + enrich + filter
 * .why = domain operation returns data, contract layer formats output
 */
export const getAllSkillsForSearch = (input: {
  query: string | null;
}): RoleSkillLinked[] => {
  // discover skills
  const skillsFound = discoverSkillExecutables({});

  // enrich with descriptions
  const items = getAllRoleSkillsLinked({ skills: skillsFound });

  // filter by query
  return getSkillsMatchedByQuery({ items, query: input.query ?? '' });
};
```

---

## test coverage

### unit tests

**domain.operations:**

| file | tests |
|------|-------|
| `getSkillWhatLine.test.ts` | extracts .what line; handles absent .what; handles no comments; handles various formats; handles file read errors (gap.20 fix) |
| `getAllRoleSkillsLinked.test.ts` | transforms skills to digests; uses fallback description; returns RoleSkillLinked[] (gap.16/17 fix) |
| `genZshCompletionCode.test.ts` | generates valid zsh code; uses dynamic completion via rhachet completion --list; includes rhx completion; includes rhachet run --skill completion (gap.39 cwd-aware fix) |
| `getSkillsMatchedByQuery.test.ts` | matches by name; matches by description; case insensitive; no matches returns empty; empty query returns all; takes RoleSkillLinked[] (gap.16/31 fix) |
| `getAllSkillsForList.test.ts` | orchestrates discover + enrich; filters by repo/role |
| `getAllSkillsForSearch.test.ts` | orchestrates discover + enrich + filter; handles empty query |

**contract/cli:**

| file | tests |
|------|-------|
| `formatAsTree.test.ts` | groups by key; box-draw prefixes; handles header |
| `formatAsJson.test.ts` | valid JSON output; transforms items |
| `formatSkillList.test.ts` | tree format; json format; handles header |

### integration tests

| file | tests |
|------|-------|
| `invokeCompletions.integration.test.ts` | outputs zsh code; code is eval-able; --list outputs name:description lines; --list reflects cwd skills (gap.39 cwd-aware fix); includes rhachet run --skill completion |
| `invokeList.integration.test.ts` | list: all skills, filters by repo, filters by role, outputs tree/json, empty state, invalid --output error |
| `invokeSearch.integration.test.ts` | search: finds by name, finds by description, no matches message, empty query shows all, outputs tree/json |

### acceptance tests (blackbox)

| file | tests |
|------|-------|
| `completion.acceptance.test.ts` | zsh interface contract; cwd-aware behavior |

**zsh interface contract tests:**

```typescript
given('[case1] repo with skills', () => {
  const repo = useBeforeAll(() => genTestTempRepo({ fixture: 'with-skills' }));

  when('[t0] rhachet completion', () => {
    const result = useThen('outputs valid zsh', async () =>
      invokeRhachetCliBinary({ args: ['completion'], cwd: repo.path })
    );

    then('exits with status 0', () => {
      expect(result.status).toEqual(0);
    });

    then('outputs compdef _rhx rhx', () => {
      expect(result.stdout).toContain('compdef _rhx rhx');
    });

    then('outputs _rhx function', () => {
      expect(result.stdout).toContain('_rhx()');
    });

    then('calls rhachet completion --list', () => {
      expect(result.stdout).toContain('rhachet completion --list');
    });

    then('uses _describe for zsh completion', () => {
      expect(result.stdout).toContain("_describe 'skill' completion");
    });
  });

  when('[t1] rhachet completion --list', () => {
    const result = useThen('outputs skill list', async () =>
      invokeRhachetCliBinary({ args: ['completion', '--list'], cwd: repo.path })
    );

    then('exits with status 0', () => {
      expect(result.status).toEqual(0);
    });

    then('outputs name:description format', () => {
      // each line should match "name:description" pattern
      const lines = result.stdout.trim().split('\n');
      for (const line of lines) {
        expect(line).toMatch(/^[^:]+:.+$/);
      }
    });

    then('includes discovered skills', () => {
      expect(result.stdout).toContain('say-hello:');
    });
  });
});

given('[case2] cwd-aware completion', () => {
  const repoA = useBeforeAll(() => genTestTempRepo({ fixture: 'with-skill-a' }));
  const repoB = useBeforeAll(() => genTestTempRepo({ fixture: 'with-skill-b' }));

  when('[t0] completion in repoA', () => {
    const result = useThen('lists repoA skills', async () =>
      invokeRhachetCliBinary({ args: ['completion', '--list'], cwd: repoA.path })
    );

    then('shows skill-a', () => {
      expect(result.stdout).toContain('skill-a:');
    });

    then('does not show skill-b', () => {
      expect(result.stdout).not.toContain('skill-b:');
    });
  });

  when('[t1] completion in repoB', () => {
    const result = useThen('lists repoB skills', async () =>
      invokeRhachetCliBinary({ args: ['completion', '--list'], cwd: repoB.path })
    );

    then('shows skill-b', () => {
      expect(result.stdout).toContain('skill-b:');
    });

    then('does not show skill-a', () => {
      expect(result.stdout).not.toContain('skill-a:');
    });
  });
});
```

### test fixtures needed

```typescript
// skill with .what header
const skillWithWhat = `#!/usr/bin/env bash
######################################################################
# .what = create git commit as seaturtle[bot]
# .why = mechanics commit under their own identity
######################################################################
echo "hello"`;

// skill without .what
const skillWithoutWhat = `#!/usr/bin/env bash
echo "hello"`;

// skill with multiline header
const skillWithMultiline = `#!/usr/bin/env bash
######################################################################
# .what = measure CLI execution time
# .why = enables performance test
# .how = runs command with hyperfine
######################################################################`;
```

**acceptance test fixtures for cwd-aware tests:**

| fixture | structure | purpose |
|---------|-----------|---------|
| `with-skill-a` | `.agent/repo=.this/role=any/skills/skill-a.sh` | proves completion reflect repoA skills |
| `with-skill-b` | `.agent/repo=.this/role=any/skills/skill-b.sh` | proves completion reflect repoB skills |

```
# with-skill-a/.agent/repo=.this/role=any/skills/skill-a.sh
#!/usr/bin/env bash
# .what = skill A for cwd-aware test
echo "skill-a"

# with-skill-b/.agent/repo=.this/role=any/skills/skill-b.sh
#!/usr/bin/env bash
# .what = skill B for cwd-aware test
echo "skill-b"
```

---

## execution phases

### phase.1 = core domain operations

1. create `RoleSkillLinked.ts` in domain.objects/ (domain object with skill + description)
2. create `getSkillWhatLine.ts` + unit tests (with try/catch error guard, gap.20 fix)
3. create `getAllRoleSkillsLinked.ts` + unit tests (returns RoleSkillLinked[], gap.16/17 fix)
4. create `genZshCompletionCode.ts` + unit tests (dynamic completion, gap.39 fix)

### phase.2 = completion command

1. create `invokeCompletions.ts`
2. update `invoke.ts` to register invokeCompletions
3. update `invoke.bun.entry.roles.ts` to include invokeCompletions (gap.41 fix)
4. add integration tests
5. update `bin/run` and `bin/run.bun` to route `completion` to `rhachet-roles.bc` (gap.41 fix)

### phase.3 = domain orchestration

1. create `getSkillsMatchedByQuery.ts` + unit tests (takes RoleSkillLinked[], gap.16/31 fix)
2. create `getAllSkillsForList.ts` + unit tests (orchestrates discover + enrich)
3. create `getAllSkillsForSearch.ts` + unit tests (orchestrates discover + enrich + filter)

### phase.4 = contract layer (format)

1. create `formatAsTree.ts` + unit tests (tree output)
2. create `formatAsJson.ts` + unit tests (json output)
3. create `formatSkillList.ts` + unit tests (composes format functions)
4. replace `invokeList.ts` (config-based â†’ .agent/-based, validation inlined)
5. create `invokeSearch.ts` (validation inlined)
6. update `invoke.ts` to register invokeList (replaced) and invokeSearch
7. add integration tests for both
8. update `bin/run` and `bin/run.bun` to route `list` and `search` to rhachet-roles.bc
9. update `bin/rhx` to proxy `completion`, `list`, and `search` to rhachet (gap.40 fix)

---

## output examples

### `rhachet completion`

```zsh
# dynamic completion for rhx <skill>
# runs rhachet completion --list on each tab press for cwd-awareness
_rhx() {
  local completion
  completion=("${(@f)$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completion
}
compdef _rhx rhx

# dynamic completion for rhachet run --skill <skill>
_rhachet_run_skill() {
  local completion
  completion=("${(@f)$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completion
}
compdef _rhachet_run_skill 'rhachet run --skill'
```

### `rhachet completion --list`

```
git.commit.set:create git commit as seaturtle[bot]
git.commit.push:push HEAD commit to origin
git.commit.uses:manage git commit quota
perf.test:measure CLI execution time
say-hello:test fixture skill
```

### `rhachet list` / `rhx list`

```
ğŸ” skills

repo=.this/role=any
â”œâ”€â”€ git.commit.bind     bind commit level constraint
â”œâ”€â”€ git.commit.push     push HEAD commit to origin
â”œâ”€â”€ git.commit.set      create git commit as seaturtle[bot]
â”œâ”€â”€ git.commit.uses     manage git commit quota
â”œâ”€â”€ perf.test           measure CLI execution time
â””â”€â”€ say-hello           test fixture skill

repo=ehmpathy/role=mechanic
â”œâ”€â”€ cpsafe              safe file copy within repo
â”œâ”€â”€ mvsafe              safe file move within repo
â”œâ”€â”€ rmsafe              safe file removal within repo
â””â”€â”€ symlink             safe symlink creation
```

### `rhachet search commit` / `rhx search commit`

```
ğŸ” skills: commit

repo=.this/role=any
â”œâ”€â”€ git.commit.bind     bind commit level constraint
â”œâ”€â”€ git.commit.push     push HEAD commit to origin
â”œâ”€â”€ git.commit.set      create git commit as seaturtle[bot]
â””â”€â”€ git.commit.uses     manage git commit quota
```

### `rhachet list --output invalid`

```
BadRequestError: invalid --output value: 'invalid'. valid options: tree, json
```

### `rhachet search` (empty query)

```
ğŸ” skills

[all skills listed in tree format]
```

---

## summary

| component | files | lines (est) |
|-----------|-------|-------------|
| domain.objects | 1 new | ~20 |
| domain.operations (impl) | 6 new | ~200 |
| domain.operations (unit tests) | 6 new | ~200 |
| contract/cli (impl) | 5 new + 2 updates | ~220 |
| contract/cli (unit tests) | 3 new | ~120 |
| integration tests | 3 new | ~200 |
| acceptance tests | 1 new + 2 fixtures | ~150 |
| .test/infra | 1 update | ~30 |
| bin updates | 4 updates | ~50 |
| **total** | **25 new + 7 updates = 32 files** | **~1170 lines** |

**gap fixes included:**
- gap.15: removed â€” validation inlined (2 usages, no abstraction needed)
- gap.16/17: replaced parallel arrays with combined `RoleSkillLinked[]`
- gap.20: added try/catch error guard for file read in `getSkillWhatLine`
- gap.30: refactored array mutations to flatMap in `formatAsTree`
- gap.31: renamed operations to use get verb (`getSkillsMatchedByQuery`)
- gap.32: renamed `queryLower` â†’ `queryLowercased`
- gap.34: added .why to all type declarations
- gap.35: format functions documented as self-evident exception (output transforms)
- gap.38: added deliberate mutation comments for let declarations in try/catch patterns
- gap.39: **cwd-aware completion** â€” dynamic completion via `rhachet completion --list` on each tab press
- gap.40: **rhx proxy** â€” `rhx list` â†’ `rhachet list`, `rhx search` â†’ `rhachet search`
- gap.41: **fast role operations** â€” route `completion`, `list`, `search` to `rhachet-roles.bc` (~70ms, reads `.agent/`)
- gap.42: **simplified commands** â€” replaced config-based `invokeList` with `.agent/`-based (no config needed)

**timeline**: 4 phases, ~3-4 hours implementation
