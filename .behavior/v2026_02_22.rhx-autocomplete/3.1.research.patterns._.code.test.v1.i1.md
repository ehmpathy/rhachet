# research: test codepath patterns

## summary

the rhx autocomplete feature requires these test codepaths:
1. BDD-style given/when/then from `test-fns`
2. temp directory management via `genTestTempDir`
3. CLI invocation via `invokeRhachetCli`
4. `.agent/` fixture creation inline in tests
5. mock/fixture generators via `genMock*` pattern

most patterns can be **reused** directly. the new commands (`rhx list`, `rhx search`, `rhachet completion`) will follow the same integration test patterns.

---

## pattern.1 = BDD-style given/when/then from test-fns

### what

all integration tests use `given`, `when`, `then` from `test-fns` for behavior-driven structure.

### citation

source: `src/contract/cli/invokeRun.integration.test.ts`

```typescript
import { getError, given, then, when } from 'test-fns';

describe('invokeRun (integration)', () => {
  given('a CLI program with invokeRun registered', () => {
    // ...
    when('skill exists in repo=.this/role=any', () => {
      then(
        'run --skill say-hello discovers and executes skill from .this repo',
        async () => {
          await program.parseAsync(['run', '--skill', 'say-hello'], {
            from: 'user',
          });
          expect(logSpy).toHaveBeenCalledWith(
            expect.stringContaining('run solid skill repo=.this/role=any/skill=say-hello'),
          );
        },
      );
    });
  });
});
```

### relation to wish

`rhx list`, `rhx search`, and `rhachet completion` tests will follow this exact structure.

### verdict: [REUSE]

use `given`, `when`, `then` from `test-fns` for all new integration tests.

---

## pattern.2 = temp directory management via genTestTempDir

### what

`genTestTempDir` creates isolated test directories under `.temp/` with setup/teardown helpers.

### citation

source: `src/.test/infra/genTestTempDir.ts`

```typescript
export const genTestTempDir = (input: {
  /** base directory (typically __dirname) */
  base: string;
  /** subdirectory name under .temp */
  name: string;
}): {
  /** absolute path to the test directory */
  path: string;
  /** call in beforeAll to setup directory and switch cwd */
  setup: () => void;
  /** call in afterAll to restore original cwd */
  teardown: () => void;
  /** call to remove a file or directory within the test dir */
  rm: (relativePath: string) => void;
} => {
  const testDir = path.join(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,
    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },
    teardown: () => {
      process.chdir(originalCwd);
    },
    rm: (relativePath: string) => {
      rmSync(path.join(testDir, relativePath), { force: true, recursive: true });
    },
  };
};
```

### relation to wish

tests for `rhx list`, `rhx search`, and `rhachet completion` need isolated temp directories to create `.agent/` fixtures.

### verdict: [REUSE]

use `genTestTempDir` for new integration tests, or the inline pattern shown in `invokeRun.integration.test.ts`.

---

## pattern.3 = CLI invocation via invokeRhachetCli

### what

`invokeRhachetCli` invokes the rhachet CLI as a subprocess using `tsx`, enabling true blackbox integration tests.

### citation

source: `src/.test/infra/invokeRhachetCli.ts`

```typescript
const RHACHET_BIN = path.join(__dirname, 'runRhachetCli.ts');

export const invokeRhachetCli = (input: {
  /** CLI args after 'rhachet' (e.g., ['run', '--skill', 'foo']) */
  args: string[];
  /** working directory for the command */
  cwd: string;
  /** optional stdin data to pipe */
  stdin?: string;
  /** whether to log output on failure (default: true) */
  logOnError?: boolean;
}): SpawnSyncReturns<string> => {
  const result = spawnSync('npx', ['tsx', RHACHET_BIN, ...input.args], {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
    env: process.env,
  });

  // log output for debug on failure
  const shouldLog = input.logOnError ?? true;
  if (shouldLog && result.status !== 0) {
    console.error('stderr:', result.stderr);
    console.error('stdout:', result.stdout);
  }

  return result;
};
```

### citation

source: `src/.test/infra/invokeRhachetCli.ts`

```typescript
export const invokeRhachetRun = (input: {
  skill: string;
  cwd: string;
  stdin?: string;
  repo?: string;
  role?: string;
}): SpawnSyncReturns<string> => {
  const args = ['run', '--skill', input.skill];
  if (input.repo) args.push('--repo', input.repo);
  if (input.role) args.push('--role', input.role);

  return invokeRhachetCli({
    args,
    cwd: input.cwd,
    stdin: input.stdin,
  });
};
```

### relation to wish

- `invokeRhachetCli` can test `rhachet completion` output
- new `invokeRhachetList` and `invokeRhachetSearch` helpers can follow `invokeRhachetRun` pattern

### verdict: [EXTEND]

add helper functions:
- `invokeRhachetList({ cwd, repo?, role?, output? })`
- `invokeRhachetSearch({ cwd, query, scope?, output? })`
- `invokeRhachetCompletions({ cwd, shell: 'zsh' })`

---

## pattern.4 = .agent/ fixture creation inline

### what

integration tests create `.agent/` directory structures inline using `mkdirSync`, `writeFileSync`, `chmodSync`.

### citation

source: `src/contract/cli/invokeRun.integration.test.ts`

```typescript
when('skill exists in repo=.this/role=any', () => {
  beforeAll(() => {
    // clean up first
    const cleanAgentDir = path.join(testDir, '.agent');
    if (existsSync(cleanAgentDir)) {
      rmSync(cleanAgentDir, { recursive: true, force: true });
    }

    // create .agent/repo=.this/role=any/skills/say-hello.sh
    const skillsDir = path.join(testDir, '.agent/repo=.this/role=any/skills');
    mkdirSync(skillsDir, { recursive: true });

    const skillPath = path.join(skillsDir, 'say-hello.sh');
    writeFileSync(
      skillPath,
      '#!/usr/bin/env bash\necho "hello ${1:-stranger}"',
    );
    chmodSync(skillPath, '755');
  });
```

### citation

source: `src/domain.operations/invoke/discoverSkillExecutables.integration.test.ts`

```typescript
given('broken symlink in skills directory', () => {
  beforeEach(() => {
    const skillsDir = path.join(testDir, '.agent/repo=.this/role=any/skills');
    mkdirSync(skillsDir, { recursive: true });

    // create a valid skill
    writeFileSync(
      path.join(skillsDir, 'valid-skill.sh'),
      '#!/usr/bin/env bash\necho valid',
    );
    chmodSync(path.join(skillsDir, 'valid-skill.sh'), '755');

    // create a broken symlink (points to nonexistent target)
    symlinkSync(
      path.join(skillsDir, 'nonexistent-target.sh'),
      path.join(skillsDir, 'broken-link.sh'),
    );
  });
```

### relation to wish

tests for `rhx list`, `rhx search`, and `rhachet completion` need fixtures with:
- skills with `.what` header comments (for description extraction)
- skills across multiple repos and roles (for tree grouping)
- edge cases: no skills, one skill, many skills

### verdict: [REUSE]

use inline fixture creation pattern. consider extracting a helper like `genTestAgentDir({ skills: [...] })` if repeated often.

---

## pattern.5 = mock/fixture generators via genMock* pattern

### what

shared test fixtures use `genMock*` or `genSample*` naming convention for reusable test data generators.

### citation

source: `src/.test/assets/genMockMechAdapter.ts`

```typescript
/**
 * .what = generates a mock mechanism adapter for tests
 * .why = enables isolated unit tests without real mechanism logic
 */
export const genMockMechAdapter = (input?: {
  /** always valid if true, always invalid if false (default: true) */
  valid?: boolean;
  /** reason string when invalid */
  invalidReason?: string;
  /** transform function for translate (default: identity) */
  transform?: (value: string) => string;
  /** expiresAt to return from translate (default: undefined) */
  expiresAt?: IsoTimeStamp;
}): KeyrackGrantMechanismAdapter => {
  const valid = input?.valid ?? true;
  // ...
  return {
    validate: () =>
      valid ? { valid: true } : { valid: false, reason: invalidReason },
    translate: async ({ secret }) => ({
      secret: transform(secret),
      expiresAt,
    }),
  };
};
```

### relation to wish

for unit tests of `getSkillWhatLine`, `getAllCompletionEntries`, etc., mock fixtures may be useful:
- `genMockRoleSkillExecutable({ slug, repo, role, path })`
- `genMockSkillFileContent({ what, why })`

### verdict: [REUSE]

use `genMock*` pattern for shared test fixtures if needed. most tests can use inline fixtures.

---

## pattern.6 = commander program parsing in tests

### what

integration tests register commands on a `Command` instance and use `program.parseAsync()` to invoke them.

### citation

source: `src/contract/cli/invokeRun.integration.test.ts`

```typescript
const program = new Command();
const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

beforeEach(() => {
  logSpy.mockClear();
});

// command-mode only (actor-mode is not supported)
invokeRun({ program });

// ...

then('run --skill say-hello discovers and executes skill', async () => {
  await program.parseAsync(['run', '--skill', 'say-hello'], {
    from: 'user',
  });

  expect(logSpy).toHaveBeenCalledWith(
    expect.stringContaining('run solid skill repo=.this/role=any/skill=say-hello'),
  );
});
```

### relation to wish

tests for `invokeList`, `invokeSearch`, `invokeCompletions` will follow this exact pattern:
1. create `Command` instance
2. register command via `invokeX({ program })`
3. invoke via `program.parseAsync([...args], { from: 'user' })`
4. assert on console output or return values

### verdict: [REUSE]

use commander `parseAsync` pattern for testing CLI command registration.

---

## pattern.7 = error testing via getError

### what

`getError` from `test-fns` captures thrown errors for assertion.

### citation

source: `src/contract/cli/invokeRun.integration.test.ts`

```typescript
then('run --skill nonexistent throws error', async () => {
  const error = await getError(() =>
    program.parseAsync(['run', '--skill', 'nonexistent'], {
      from: 'user',
    }),
  );

  expect(error?.message).toContain('no skill "nonexistent" found');
});
```

### citation

source: `src/contract/cli/invokeRun.integration.test.ts`

```typescript
then(
  'run --skill dupe throws error with disambiguation hint',
  async () => {
    const error = await getError(() =>
      program.parseAsync(['run', '--skill', 'dupe'], {
        from: 'user',
      }),
    );

    expect(error?.message).toContain('multiple skills found');
    expect(error?.message).toContain('mechanic');
    expect(error?.message).toContain('designer');
    expect(error?.message).toContain('--role');
  },
);
```

### relation to wish

tests for `rhx list`, `rhx search`, `rhachet completion` need error case coverage:
- no skills in `.agent/` → friendly message
- invalid `--output` option → error with valid options
- invalid `--scope` option → error with valid options

### verdict: [REUSE]

use `getError` from `test-fns` for all error case tests.

---

## pattern.8 = process.cwd switching for cwd-aware tests

### what

tests save `originalCwd` and use `process.chdir()` to simulate different working directories.

### citation

source: `src/domain.operations/invoke/discoverSkillExecutables.integration.test.ts`

```typescript
describe('discoverSkillExecutables.integration', () => {
  const testDir = path.join(
    __dirname,
    './.temp/discoverSkillExecutables.integration',
  );
  const originalCwd = process.cwd();

  beforeAll(() => {
    mkdirSync(testDir, { recursive: true });
    process.chdir(testDir);
  });

  afterAll(() => {
    process.chdir(originalCwd);
  });
```

### relation to wish

cwd-aware completion tests need this pattern to verify:
- completions reflect skills in current repo
- different repos have different completions
- `cd` to another repo shows different skills

### verdict: [REUSE]

use `process.chdir()` pattern for cwd-aware completion tests. `genTestTempDir` encapsulates this.

---

## summary: pattern verdicts

| pattern | verdict | reason |
|---------|---------|--------|
| BDD given/when/then | **[REUSE]** | standard test structure |
| genTestTempDir | **[REUSE]** | encapsulates temp dir management |
| invokeRhachetCli | **[EXTEND]** | add helpers for list, search, completions |
| .agent/ fixture creation | **[REUSE]** | inline fixtures for skill setup |
| genMock* fixtures | **[REUSE]** | shared fixtures if needed |
| commander parseAsync | **[REUSE]** | standard CLI test pattern |
| getError for error cases | **[REUSE]** | captures errors for assertion |
| process.cwd switching | **[REUSE]** | cwd-aware test setup |

---

## new test code needed

| component | type | pattern to follow |
|-----------|------|-------------------|
| `invokeList.integration.test.ts` | new file | follow `invokeRun.integration.test.ts` |
| `invokeSearch.integration.test.ts` | new file | follow `invokeRun.integration.test.ts` |
| `invokeCompletions.integration.test.ts` | new file | follow `invokeRun.integration.test.ts` |
| `invokeRhachetList` helper | new function | follow `invokeRhachetRun` pattern |
| `invokeRhachetSearch` helper | new function | follow `invokeRhachetRun` pattern |
| `invokeRhachetCompletions` helper | new function | follow `invokeRhachetRun` pattern |
| `getSkillWhatLine.test.ts` | new file | unit test with inline fixtures |
| `getAllCompletionEntries.test.ts` | new file | unit test with mock skills |

---

## test case coverage needed

### rhx list

| case | test |
|------|------|
| list all skills | shows tree with repo/role grouping |
| list --repo .this | filters to .this repo |
| list --role mechanic | filters to mechanic role |
| list --output flat | outputs flat list |
| list --output json | outputs valid JSON |
| no skills | shows "no skills found" message |

### rhx search

| case | test |
|------|------|
| search by name | finds skills with matching name |
| search by description | finds skills with matching .what |
| search --scope skills | searches skills only |
| search --scope briefs | searches briefs only |
| no matches | shows "no matches" message |

### rhachet completion

| case | test |
|------|------|
| `rhachet completion` | outputs valid zsh completion code |
| completion code can be eval'd | no syntax errors |
| completions include all skills | all discovered skills in output |
| completions include descriptions | .what lines in completion descriptions |
