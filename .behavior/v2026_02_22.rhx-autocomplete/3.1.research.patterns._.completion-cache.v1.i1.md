# research: completion cache best practices

## summary

three cache strategies exist for shell completion:

1. **no cache (dynamic)** — generate on every tab press (~35-100ms per tab)
2. **session cache** — generate on shell startup, cache for session (~100ms once)
3. **persistent cache** — generate once, store on disk, refresh on schedule (0ms startup, 0ms tab)

recommendation: **dynamic completion via `rhachet completion --list`** for cwd-awareness, with fast execution via bun binary (~35ms per tab).

---

## strategy.1 = no cache (dynamic)

### what

generate completion on every tab press by calling the cli tool.

### how

```zsh
_rhx() {
  local completion
  completion=("${(@f)$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completion
}
```

zsh calls `rhachet completion --list` on each tab press.

### performance

| metric | value |
|--------|-------|
| shell startup | 0ms |
| per-tab cost | ~35-100ms (depends on tool) |
| freshness | always current |

### pros

- always reflects current cwd (repo-aware)
- no cache invalidation needed
- no stale completion

### cons

- latency on each tab press
- must be fast enough to feel instant (<100ms threshold)

### when to use

- when cwd-awareness is required (different repos have different skills)
- when tool is fast enough (<100ms)

### verdict

**[ADOPT]** — required for cwd-aware completion. bun binary (~35ms) is fast enough.

---

## strategy.2 = session cache (eval on startup)

### what

generate completion once at shell startup via `eval "$(tool completion)"`.

### how

```zsh
# ~/.zshrc (old pattern - we now use rhachet completion --setup instead)
eval "$(rhachet completion)"
```

### performance

| metric | value |
|--------|-------|
| shell startup | ~100-300ms per tool |
| per-tab cost | 0ms |
| freshness | current at shell start |

### pros

- instant tab completion after startup
- simple setup (one line in .zshrc)

### cons

- slows shell startup (accumulates with many tools)
- completion stale until next shell session
- security concern: man-in-middle on rhachet completion --setup[1]

> "this command executes the CLI tool, generates the completion code, and evaluates it **every single time** you open a new terminal tab." [1]

### when to use

- when tool is slow and completion rarely change
- when cwd-awareness is not needed

### verdict

**[SKIP]** — not cwd-aware, slows startup, security concern with eval.

---

## strategy.3 = persistent cache (disk)

### what

generate completion once, store on disk, refresh on schedule (e.g., weekly).

### how

```zsh
cache_completion() {
    local tool=$1
    local cache_file="$CACHE_DIR/$tool.zsh"

    # regenerate if missing or older than 7 days
    if [[ ! -f "$cache_file" || -n $(find "$cache_file" -mtime +7) ]]; then
        $tool completion zsh > "$cache_file" 2>/dev/null
    fi
    source "$cache_file"
}

cache_completion rhachet
```

### performance

| metric | value |
|--------|-------|
| shell startup | ~1-5ms (source cached file) |
| per-tab cost | 0ms |
| freshness | stale until refresh |

### pros

- fastest startup (source static file)
- fastest tab completion (pre-loaded)
- npm's documented approach [2]

### cons

- not cwd-aware (cached globally)
- stale completion until cache refresh
- user must manage cache invalidation

### when to use

- when completion are global (not repo-specific)
- when startup time is critical
- when completion rarely change

### verdict

**[SKIP]** — not cwd-aware. rhx skills vary per repo.

---

## strategy comparison

| strategy | startup | tab cost | cwd-aware | freshness |
|----------|---------|----------|-----------|-----------|
| dynamic | 0ms | ~35-100ms | ✅ yes | ✅ always |
| session rhachet completion --setup| ~100-300ms | 0ms | ❌ no | ⚠️ session |
| persistent cache | ~1-5ms | 0ms | ❌ no | ❌ scheduled |

---

## why dynamic is right for rhx

### requirement: cwd-awareness

> "each repo has different skills" — from vision.md

completion must reflect the current repo's `.agent/` directory:

```sh
# in repoA
$ rhx deploy.<tab>
deploy.prod  # skill from repoA

# cd to repoB
$ rhx deploy.<tab>
deploy.dev   # skill from repoB
```

only **dynamic completion** achieves this — it runs `rhachet completion --list` on each tab press with the current cwd.

### performance is acceptable

bun-compiled binary (~35ms) is well under the 100ms "instant" threshold:

| approach | per-tab cost | feel |
|----------|--------------|------|
| jit (tsx) | ~300ms | slow, noticeable |
| bun binary | ~35ms | instant |

### no cache invalidation complexity

dynamic completion eliminates cache invalidation questions:
- when to refresh?
- what if user adds a skill?
- what if user cd's to different repo?

the answer is: completion are always fresh.

---

## zsh compinit cache (orthogonal)

zsh has its own completion system cache (`.zcompdump`). this is separate from tool-specific caching.

### the optimization

> "speed up zsh compinit by only checking cache once a day" [3]

```zsh
autoload -Uz compinit
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
  compinit;
else
  compinit -C;  # load from cache
fi;
```

### performance

- one user reported: **1.33-1.55s → 0.78-1.21s** [3]
- another: **cut initial load time in half** [3]

### relevance to rhx

this is zsh's internal completion system cache, not rhx's responsibility. users can apply this optimization independently.

---

## tabtab cache (for reference)

tabtab (pnpm's fork) uses a different caching strategy:

> "completion results are cached by default for a duration of 5 minutes, and caching is based on the value of the full command being completed (data.line)" [4]

this is a **memory cache** for expensive completion (e.g., http requests for package versions). not applicable to rhx — our completion are fast filesystem reads.

---

## consideration: hybrid cache in .agent/

### idea

cache completion in `.agent/` directory, keyed by pnpm-lock.json hash:

```
.agent/.cache/completion.txt  # cached name:description lines
.agent/.cache/completion.hash # hash of pnpm-lock.json
```

on each tab press:
1. check if cache exists and hash matches pnpm-lock.json
2. if yes: read cached completion (~1ms)
3. if no: glob + read + write cache (~35ms)

### analysis

**time breakdown of current ~35ms**:

| step | cost |
|------|------|
| bun binary startup | ~20-25ms (fixed) |
| glob `.agent/repo=*/role=*/skills/*.sh` | ~2-5ms |
| read `.what` from N files | ~0.1ms × N |
| format output | ~1ms |

for a repo with 20 skills, glob + read is ~5-7ms. **most time is bun startup** — cache wouldn't help there.

**savings from cache**: ~5-7ms → ~1ms = **~5ms saved** (35ms → 30ms)

### fatal flaw: invalid cache key

pnpm-lock.json doesn't capture all completion changes:

| change | pnpm-lock changes? | completion change? |
|--------|-------------------|---------------------|
| add native skill to `.agent/repo=.this/` | ❌ no | ✅ yes |
| edit skill's `.what` header | ❌ no | ✅ yes |
| run `roles link` (symlinks change) | ❌ no | ✅ yes |
| upgrade rhachet-roles-ehmpathy | ✅ yes | ✅ yes |

only the last case is captured by pnpm-lock.

better cache keys would require a scan of `.agent/` anyway (mtime, file list hash) — this defeats the purpose.

### verdict

**overkill** — ~5ms savings not worth the complexity and incorrect invalidation.

---

## recommendation for rhx

### chosen approach: dynamic completion

```zsh
_rhx() {
  local completion
  completion=("${(@f)$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completion
}
```

### why

1. **cwd-aware** — completion reflect current repo's skills
2. **always fresh** — no stale completion, no cache invalidation
3. **fast enough** — bun binary ~35ms, well under 100ms threshold
4. **simple** — no cache management complexity

### tradeoff accepted

~35ms latency per tab press is acceptable for:
- guaranteed cwd-awareness
- zero cache complexity
- always-fresh completion

### mitigation if needed

if latency becomes a concern, we could add a **hybrid approach**:
- cache per-repo (keyed by repo root path)
- invalidate on `.agent/` changes (via mtime check)
- refresh on `npx rhachet init`

but this adds complexity. start simple, optimize if needed.

---

## citations

[1] speed up your shell startup: the case for completion caching
- source: https://raoulcoutard.com/posts/2026-02-04-shell-completion-caching-en/
- accessed: 2026-02-26

[2] npm completion documentation
- source: https://docs.npmjs.com/cli/v7/commands/npm-completion/
- accessed: 2026-02-26

[3] speed up zsh compinit by only checking cache once a day
- source: https://gist.github.com/ctechols/ca1035271ad134841284
- accessed: 2026-02-26

[4] @pnpm/tabtab npm package
- source: https://www.npmjs.com/package/@pnpm/tabtab
- accessed: 2026-02-26

---

## summary: strategy verdicts

| strategy | verdict | reason |
|----------|---------|--------|
| dynamic (no cache) | **[ADOPT]** | cwd-aware, always fresh, fast enough |
| session rhachet completion --setup| **[SKIP]** | not cwd-aware, slows startup |
| persistent cache | **[SKIP]** | not cwd-aware, stale completion |
| tabtab memory cache | **[SKIP]** | for http requests, not filesystem |

**final recommendation**: use dynamic completion via `rhachet completion --list` on each tab press. bun binary (~35ms) makes this viable.
