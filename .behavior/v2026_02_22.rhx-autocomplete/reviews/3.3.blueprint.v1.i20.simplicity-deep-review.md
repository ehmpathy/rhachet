# simplicity deep review: blueprint v1

a slow, methodical review of each file in the blueprint, one by one.

---

## each file examined

### types.ts (5 types)

| type | needed? | could merge? |
|------|---------|--------------|
| CompletionEntry | ✅ yes - zsh _describe needs name:description | no |
| SkillWithEntry | ✅ yes - avoids parallel arrays | no |
| SkillMatch | ⚠️ alias for SkillWithEntry | could remove, use SkillWithEntry directly |
| BriefFile | ✅ yes - brief search needs path + slugs | no |
| BriefMatch | ✅ yes - pairs brief with snippet | no |

**potential simplification**: remove SkillMatch type alias, use SkillWithEntry directly. saves ~5 lines but reduces semantic clarity. **verdict: keep** - the alias documents intent (matched vs all).

### getSkillWhatLine.ts

extracts .what line from skill file. simple, focused. no simplification needed.

### getAllSkillsWithEntries.ts

transforms skills to SkillWithEntry[]. simple map. no simplification needed.

### genZshCompletionCode.ts

emits zsh completion code. must match zsh completion interface exactly. no simplification possible.

### getSkillsMatchedByQuery.ts

filters skills by query. simple filter. no simplification needed.

### getAllMdFilesRecursive.ts

**reviewed carefully**: could this be inlined into getAllBriefFiles?

```
// inline version would be:
const getMdFiles = (dir: string): string[] =>
  readdirSync(dir, { withFileTypes: true })
    .flatMap(e => e.isDirectory()
      ? getMdFiles(path.join(dir, e.name))
      : e.name.endsWith('.md') ? [path.join(dir, e.name)] : []);
```

the extracted version is testable in isolation. **verdict: keep extracted** - testability matters.

### getAllBriefFiles.ts

scans .agent/ for briefs. uses getAllMdFilesRecursive. no simplification needed.

### getBriefsMatchedByQuery.ts

filters briefs by query. parallel to getSkillsMatchedByQuery. no simplification needed.

### formatAsTree.ts

**reviewed carefully**: could this be inlined into formatSkillList and formatSearchResults?

the function is generic (takes getGroupKey, getLabel, getDescription). inlined code would duplicate ~30 lines in two places. **verdict: keep extracted** - reduces duplication.

### formatAsFlat.ts

**reviewed carefully**: this is 5 lines:

```
export const formatAsFlat = <T>(input: { items: T[]; getLine: (item: T) => string }): string =>
  input.items.map(input.getLine).join('\n');
```

could inline. but formatSkillList switch would become less readable. **verdict: keep** - consistency with formatAsTree/Json.

### formatAsJson.ts

**reviewed carefully**: this is 5 lines. same analysis as formatAsFlat. **verdict: keep** - consistency.

### formatSkillList.ts

composes format functions based on --output option. switch statement. no simplification needed.

### formatSearchResults.ts

composes format functions for search results. no simplification needed.

### assertValidOption.ts

single validation helper. used in 2 places. without it, validation code duplicates. **verdict: keep**.

---

## command structure

### could we merge invokeCompletions and invokeSkillsSubcommand?

no - they register different commands:
- completions: top-level `rhachet completion`
- skills: parent `rhachet skills` with list/search children

to merge would violate single responsibility.

### could we merge list and search commands?

no - different contracts:
- list: no query, shows all
- search: query arg, matches

---

## bin dispatcher

already minimal - adds cases to extant switch statements.

---

## final analysis

| category | files reviewed | simplifications found |
|----------|----------------|----------------------|
| types | 1 | 0 (alias provides semantic value) |
| domain ops | 10 | 0 (each justified by single responsibility or reuse) |
| format | 3 | 0 (consistency, avoid duplication) |
| validation | 1 | 0 (avoids duplication) |
| contracts | 2 | 0 (different commands) |

---

## conclusion

after slow, methodical review of each file:

**no simplifications found that wouldn't violate single responsibility or increase duplication.**

the blueprint is at minimum viable complexity.

ready to promise all-simple-junior.
