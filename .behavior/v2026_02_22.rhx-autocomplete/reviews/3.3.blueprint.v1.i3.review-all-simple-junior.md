# review: all-simple-junior for blueprint v1 (iteration 3) — POST-FIX

## review method

critical examination of each component for:
- single responsibility
- appropriate decomposition
- code duplication
- fragile patterns
- complexity that can be simplified

---

## status

**all 7 gaps found have been fixed in blueprint v1.i1.md**

see `3.3.blueprint.v1.i3.gap-report.md` for full fix documentation.

---

## gaps found (all fixed)

### gap.15 = assertValidOutputFormat and assertValidScope are duplicate code

**issue**: these two functions are nearly identical:

```typescript
// assertValidOutputFormat
export const assertValidOutputFormat = (input: {
  format: string | undefined;
  valid: string[];
}): void => {
  if (input.format && !input.valid.includes(input.format)) {
    throw new BadRequestError(
      `invalid --output value: '${input.format}'. valid options: ${input.valid.join(', ')}`,
      { format: input.format, valid: input.valid },
    );
  }
};

// assertValidScope — same pattern, different field names
export const assertValidScope = (input: {
  scope: string;
  valid: string[];
}): void => {
  if (!input.valid.includes(input.scope)) {
    throw new BadRequestError(
      `invalid --scope value: '${input.scope}'. valid options: ${input.valid.join(', ')}`,
      { scope: input.scope, valid: input.valid },
    );
  }
};
```

**why it matters**: violates DRY, forces maintenance in two places

**fix**: single generic function:
```typescript
export const assertValidOption = (input: {
  value: string | undefined;
  field: string;
  valid: string[];
}): void => {
  if (input.value && !input.valid.includes(input.value)) {
    throw new BadRequestError(
      `invalid --${input.field} value: '${input.value}'. valid options: ${input.valid.join(', ')}`,
      { [input.field]: input.value, valid: input.valid },
    );
  }
};

// usage:
assertValidOption({ value: opts.output, field: 'output', valid: ['tree', 'flat', 'json'] });
assertValidOption({ value: opts.scope, field: 'scope', valid: ['skills', 'briefs', 'all'] });
```

**severity**: nitpick (code works, but duplicated)

---

### gap.16 = parallel arrays in filterSkillsByQuery

**issue**: filterSkillsByQuery takes `skills` and `entries` as separate arrays and joins by index:

```typescript
export const filterSkillsByQuery = (input: {
  skills: RoleSkillExecutable[];
  entries: CompletionEntry[];  // ← parallel array
  query: string;
}): SkillMatch[] => {
  return input.skills
    .map((skill, i) => ({ skill, entry: input.entries[i]! }))  // ← fragile index join
    .filter(...);
};
```

**why it matters**:
- caller must ensure arrays are aligned
- no compile-time guarantee arrays have same length
- `input.entries[i]!` uses non-null assertion (code smell)

**fix option A**: take pre-combined items:
```typescript
export const filterSkillsByQuery = (input: {
  items: SkillMatch[];
  query: string;
}): SkillMatch[] => { ... };
```

**fix option B**: compute entries internally:
```typescript
export const filterSkillsByQuery = (input: {
  skills: RoleSkillExecutable[];
  query: string;
}): SkillMatch[] => {
  const items = input.skills.map((skill) => ({
    skill,
    entry: { name: skill.slug, description: getSkillWhatLine({ path: skill.path }) ?? '(no description)' },
  }));
  // filter items...
};
```

**severity**: blocker (fragile pattern)

---

### gap.17 = formatSkillList has same parallel array issue

**issue**: same pattern as gap.16:

```typescript
export const formatSkillList = (input: {
  skills: RoleSkillExecutable[];
  entries: CompletionEntry[];  // ← parallel array
  format?: string;
}): string => {
  const items = input.skills.map((skill, i) => ({
    skill,
    entry: input.entries[i]!,  // ← fragile index join
  }));
```

**fix**: same as gap.16 — either take pre-combined items or compute internally

**severity**: blocker (fragile pattern)

---

### gap.18 = genZshCompletionCode duplicates skills array in output

**issue**: the generated zsh code duplicates the skills array:

```typescript
return `#compdef rhx

_rhx() {
  local -a skills
  skills=(
${skillLines}  // ← skills array here
  )
  _describe 'skill' skills
}

_rhx "$@"

_rhachet_run_skill() {
  local -a skills
  skills=(
${skillLines}  // ← same skills array duplicated here
  )
  _describe 'skill' skills
}
```

**why it matters**: output is larger than necessary, skills defined twice

**fix**: use shared variable in zsh:

```zsh
#compdef rhx

# shared skills array
local -a _rhachet_skills
_rhachet_skills=(
  ${skillLines}
)

_rhx() {
  _describe 'skill' _rhachet_skills
}

_rhx "$@"

_rhachet_run_skill() {
  _describe 'skill' _rhachet_skills
}

compdef '_rhachet_run_skill' 'rhachet run --skill'
```

**severity**: nitpick (output works, just larger than needed)

---

### gap.19 = inline nested function in discoverBriefFiles

**issue**: `getAllMdFiles` is defined inside the for loop:

```typescript
for (const roleEntry of roleEntries) {
  // ...

  // recursive readdir inline (no external helper needed)
  const getAllMdFiles = (dir: string): string[] => {  // ← re-created each iteration
    const entries = readdirSync(dir, { withFileTypes: true });
    // ...
  };

  const mdFiles = getAllMdFiles(briefsDir);
```

**why it matters**:
- function is re-created on each repo/role iteration
- harder to test in isolation
- violates single responsibility (discoverBriefFiles does two things)

**fix**: extract to module-level helper or separate file:

```typescript
// in same file, outside the function
const getAllMdFilesRecursive = (dir: string): string[] => {
  const entries = readdirSync(dir, { withFileTypes: true });
  const files: string[] = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...getAllMdFilesRecursive(fullPath));
    } else if (entry.isFile() && entry.name.endsWith('.md')) {
      files.push(fullPath);
    }
  }
  return files;
};

// or in separate file: getAllMdFilesRecursive.ts
```

**severity**: nitpick (works, but suboptimal structure)

---

### gap.20 = getSkillWhatLine lacks error handler

**issue**: readFileSync can throw but no guard:

```typescript
export const getSkillWhatLine = (input: {
  path: string;
}): string | null => {
  const content = readFileSync(input.path, 'utf-8');  // ← can throw ENOENT, EACCES, etc
  // ...
};
```

**why it matters**: if skill file is deleted or unreadable between discovery and read, entire command fails

**fix**: wrap with try/catch and return null:

```typescript
export const getSkillWhatLine = (input: {
  path: string;
}): string | null => {
  let content: string;
  try {
    content = readFileSync(input.path, 'utf-8');
  } catch {
    return null;  // file unreadable, treat as no description
  }
  // ...
};
```

**severity**: blocker (runtime failure without graceful guard)

---

### gap.21 = filterBriefsByQuery lacks error handler

**issue**: same pattern as gap.20:

```typescript
return input.briefs
  .map((brief) => {
    const content = readFileSync(brief.path, 'utf-8');  // ← can throw
    // ...
  })
```

**fix**: same as gap.20 — wrap with try/catch

**severity**: blocker (runtime failure without graceful guard)

---

## summary

| gap | issue | severity | status |
|-----|-------|----------|--------|
| gap.15 | duplicate validation functions | nitpick | ✅ fixed |
| gap.16 | parallel arrays in filterSkillsByQuery | blocker | ✅ fixed |
| gap.17 | parallel arrays in formatSkillList | blocker | ✅ fixed |
| gap.18 | duplicated skills array in zsh output | nitpick | ✅ fixed |
| gap.19 | inline nested function in discoverBriefFiles | nitpick | ✅ fixed |
| gap.20 | no error guard in getSkillWhatLine | blocker | ✅ fixed |
| gap.21 | no error guard in filterBriefsByQuery | blocker | ✅ fixed |

**blockers found**: 4 → **all fixed**
**nitpicks found**: 3 → **all fixed**

**verdict**: ✅ passes simplification review (post-fix)

---

## fixes applied

### for blockers

1. **gap.16 + gap.17**: refactored to use combined `SkillWithEntry` type
   - added `SkillWithEntry` interface to types.ts
   - renamed `getAllCompletionEntries` to `getAllSkillsWithEntries`
   - updated `filterSkillsByQuery` and `formatSkillList` signatures

2. **gap.20 + gap.21**: added try/catch error guards for file reads
   - `getSkillWhatLine` returns null on file read error
   - `filterBriefsByQuery` skips briefs on file read error

### for nitpicks

3. **gap.15**: consolidated into single `assertValidOption` function
4. **gap.18**: zsh output uses shared `_rhachet_skills` variable
5. **gap.19**: extracted `getAllMdFilesRecursive` to separate file

---

## verification

all fixes documented in `3.3.blueprint.v1.i3.gap-report.md`
