# review: mechanic standards for blueprint v1 (iteration 4) — POST-FIX

## review method

critical examination against mechanic briefs:
- rule.require.immutable-vars
- rule.require.input-context-pattern
- rule.forbid.positional-args
- rule.require.order.noun_adj
- rule.require.what-why-headers
- rule.require.narrative-flow
- rule.require.fail-fast

---

## status

**all 8 gaps found have been fixed in blueprint v1.i1.md**

---

## gaps found (all fixed)

### gap.22 = `let` mutation violates immutability rule

**issue**: `skillMatches` and `briefMatches` use `let` with reassignment

**location**: invokeSkillsSubcommand.ts (lines 324-331, 325-337)

```typescript
let skillMatches: SkillMatch[] = [];
let briefMatches: BriefMatch[] = [];

// search skills if scope includes them
if (scope === 'skills' || scope === 'all') {
  const skillsFound = discoverSkillExecutables({});
  const items = getAllSkillsWithEntries({ skills: skillsFound });
  skillMatches = filterSkillsByQuery({ items, query: query ?? '' });  // ← mutation
}
```

**brief violated**: `rule.require.immutable-vars` — "require immutable variables; mutation is blocker"

**fix**: refactor to use const with conditional expression or early composition

```typescript
// compute in one pass, no mutation
const skillMatches = (scope === 'skills' || scope === 'all')
  ? filterSkillsByQuery({
      items: getAllSkillsWithEntries({ skills: discoverSkillExecutables({}) }),
      query: query ?? '',
    })
  : [];

const briefMatches = (scope === 'briefs' || scope === 'all')
  ? filterBriefsByQuery({ briefs: discoverBriefFiles({}), query: query ?? '' })
  : [];
```

**severity**: blocker

---

### gap.23 = escapeZshString violates input pattern

**issue**: helper function uses positional arg instead of input object

**location**: genZshCompletionCode.ts (line 457)

```typescript
const escapeZshString = (s: string): string =>
  s.replace(/'/g, "''").replace(/:/g, '\\:');
```

**brief violated**: `rule.require.input-context-pattern` — "enforce procedure args: (input, context?)"

**fix**: use input object pattern

```typescript
const escapeZshString = (input: { value: string }): string =>
  input.value.replace(/'/g, "''").replace(/:/g, '\\:');

// usage
.map((e) => `    '${e.name}:${escapeZshString({ value: e.description })}'`)
```

**severity**: blocker

---

### gap.24 = non-null assertions without guards

**issue**: uses `!` assertions instead of proper guards

**locations**:
- formatAsTree.ts line 667: `groups.get(key)!.push(item);`
- formatAsTree.ts line 678: `const item = groupItems[i]!;`
- filterBriefsByQuery.ts line 635: `lines[matchLine]!.trim();`

**brief violated**: `rule.require.fail-fast` — assertions hide potential errors

**fix**: add explicit guards or use safe access patterns

```typescript
// instead of: groups.get(key)!.push(item);
const group = groups.get(key);
if (!group) UnexpectedCodePathError.throw('group not found after set', { key });
group.push(item);

// instead of: const item = groupItems[i]!;
const item = groupItems[i];
if (!item) continue;

// instead of: lines[matchLine]!.trim();
const line = lines[matchLine];
if (line) snippet = line.trim();
```

**severity**: blocker

---

### gap.25 = absent .why in jsdoc comments

**issue**: several operations have .what but no .why

**locations**:
- formatSearchResults (line 770-773)
- formatAsFlat (line 694-697)
- formatAsJson (line 709-712)

```typescript
/**
 * .what = formats search results for output
 * .why = composes format functions based on --output option  // ← .why should explain purpose
 */
```

**brief violated**: `rule.require.what-why-headers` — "require jsdoc .what and .why for every named procedure"

**fix**: add meaningful .why explanations

```typescript
/**
 * .what = formats search results for output
 * .why = enables consistent output across skills and briefs sections for user readability
 */
```

**severity**: nitpick

---

### gap.26 = variable name: matchLine should be lineMatched

**issue**: uses verb-noun order instead of noun-adj

**location**: filterBriefsByQuery.ts (line 634)

```typescript
const matchLine = lines.findIndex((l) => l.toLowerCase().includes(queryLower));
```

**brief violated**: `rule.require.order.noun_adj` — "use [noun][state/adjective] order"

**fix**: rename to noun-first pattern

```typescript
const lineIndexMatched = lines.findIndex((l) => l.toLowerCase().includes(queryLower));
```

**severity**: nitpick

---

### gap.27 = for-let loop could be forEach/map

**issue**: uses mutable index loop instead of functional iteration

**location**: formatAsTree.ts (line 677)

```typescript
for (let i = 0; i < groupItems.length; i++) {
  const item = groupItems[i]!;
  const isLast = i === groupItems.length - 1;
```

**brief violated**: `rule.require.immutable-vars` — prefer functional patterns

**fix**: use forEach or map with index

```typescript
groupItems.forEach((item, i) => {
  const isLast = i === groupItems.length - 1;
  const prefix = isLast ? '└── ' : '├── ';
  const label = getLabel(item).padEnd(20);
  lines.push(`${prefix}${label}${getDescription(item)}`);
});
```

**severity**: nitpick

---

### gap.28 = let snippet could be const with ternary

**issue**: uses let with reassignment for snippet extraction

**location**: filterBriefsByQuery.ts (lines 630-636)

```typescript
let snippet: string | null = null;
if (contentMatch) {
  const lines = content.split('\n');
  const matchLine = lines.findIndex((l) => l.toLowerCase().includes(queryLower));
  if (matchLine >= 0) {
    snippet = lines[matchLine]!.trim();
  }
}
```

**brief violated**: `rule.require.immutable-vars`

**fix**: extract to helper or use const

```typescript
const snippet = contentMatch
  ? (() => {
      const lines = content.split('\n');
      const lineIndexMatched = lines.findIndex((l) => l.toLowerCase().includes(queryLower));
      return lineIndexMatched >= 0 ? lines[lineIndexMatched]?.trim() ?? null : null;
    })()
  : null;
```

or better — extract to separate function:

```typescript
const extractSnippet = (input: { content: string; query: string }): string | null => {
  const lines = input.content.split('\n');
  const lineIndexMatched = lines.findIndex((l) => l.toLowerCase().includes(input.query.toLowerCase()));
  if (lineIndexMatched < 0) return null;
  return lines[lineIndexMatched]?.trim() ?? null;
};

// usage
const snippet = contentMatch ? extractSnippet({ content, query: input.query }) : null;
```

**severity**: nitpick

---

### gap.29 = silent error swallow in try/catch

**issue**: try/catch blocks swallow errors without any log or context

**locations**:
- getSkillWhatLine.ts (lines 400-402)
- filterBriefsByQuery.ts (lines 618-622)

```typescript
try {
  content = readFileSync(input.path, 'utf-8');
} catch {
  return null;  // file unreadable, treat as no description
}
```

**brief consideration**: while graceful degradation is good, silent error capture makes debug hard

**fix**: add comment for why error is expected (not a block, just a note)

```typescript
try {
  content = readFileSync(input.path, 'utf-8');
} catch (error) {
  // note: file unreadable between discovery and read — expected race condition
  return null;
}
```

**severity**: nitpick (comment that documents why is sufficient)

---

## summary

| gap | issue | severity | status |
|-----|-------|----------|--------|
| gap.22 | let mutation for skillMatches/briefMatches | blocker | ✅ fixed |
| gap.23 | escapeZshString positional arg | blocker | ✅ fixed |
| gap.24 | non-null assertions without guards | blocker | ✅ fixed |
| gap.25 | absent .why in jsdoc | nitpick | ✅ fixed |
| gap.26 | matchLine name order | nitpick | ✅ fixed |
| gap.27 | for-let loop | nitpick | ✅ fixed |
| gap.28 | let snippet mutation | nitpick | ✅ fixed |
| gap.29 | silent error capture | nitpick | ✅ fixed |

**blockers found**: 3 → **all fixed**
**nitpicks found**: 5 → **all fixed**

**verdict**: ✅ passes mechanic standards review (post-fix)

---

## fixes applied

### for blockers

1. **gap.22**: refactored to const with ternary expressions (invokeSkillsSubcommand lines 325-334)
2. **gap.23**: changed `escapeZshString(s)` to `escapeZshString({ value })` (genZshCompletionCode lines 457-458)
3. **gap.24**: replaced `!` assertions with:
   - formatAsTree: uses if/else pattern for groups.get() (lines 682-687)
   - formatAsTree: uses forEach instead of for-let (lines 697-701)
   - filterBriefsByQuery: uses optional chain `?.trim() ?? null` (line 612)

### for nitpicks

4. **gap.25**: all format functions have .what and .why headers
5. **gap.26**: renamed matchLine to lineIndexMatched (extractSnippetFromContent line 608)
6. **gap.27**: replaced for-let with forEach in formatAsTree (lines 697-701)
7. **gap.28**: extracted snippet logic to `extractSnippetFromContent` helper (lines 603-613)
8. **gap.29**: added explanatory comments for expected race conditions (lines 393, 637-638)

---

## verification

all fixes documented in blueprint v1.i1.md:
- [x] gap.22: const with ternary in invokeSkillsSubcommand
- [x] gap.23: escapeZshString uses input object pattern
- [x] gap.24: no non-null assertions, uses guards and optional chain
- [x] gap.25: .what and .why present on all format functions
- [x] gap.26: lineIndexMatched naming
- [x] gap.27: forEach instead of for-let
- [x] gap.28: extractSnippetFromContent helper extracted
- [x] gap.29: comments document expected race condition
