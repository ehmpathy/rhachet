# review: mechanic standards comprehensive for blueprint v1 (iteration 6) â€” POST-FIX

## review method

exhaustive line-by-line examination against mechanic briefs:
- rule.require.immutable-vars
- rule.require.get-set-gen-verbs
- rule.require.order.noun_adj
- rule.require.what-why-headers
- rule.forbid.gerunds
- rule.require.narrative-flow
- rule.require.input-context-pattern

---

## status

**all 2 gaps found have been fixed in blueprint v1.i1.md**

---

## gaps found (all fixed)

### gap.37 = formatSearchResults uses array mutation via push()

**issue**: `formatSearchResults` uses `const lines = []; lines.push(...)` pattern

**location**: formatSearchResults.ts (lines 816-836)

```typescript
// tree format (default)
const lines: string[] = ['ðŸ”Ž matched'];

if (input.skillMatches.length > 0) {
  lines.push('', 'skills:');
  for (const { skill, entry } of input.skillMatches) {
    lines.push(`  ${skill.slug.padEnd(20)}${entry.description}`);
  }
}

if (input.briefMatches.length > 0) {
  lines.push('', 'briefs:');
  for (const { brief, snippet } of input.briefMatches) {
    lines.push(`  ${brief.relativePath}`);
    if (snippet) {
      lines.push(`    â†’ mentions: ${snippet.slice(0, 50)}${snippet.length > 50 ? '...' : ''}`);
    }
  }
}

return lines.join('\n');
```

**brief violated**: `rule.require.immutable-vars` â€” "use spread + map/filter/reduce for arrays"

**fix**: use functional composition with spread and flatMap

```typescript
// tree format (default)
const skillLines = input.skillMatches.length > 0
  ? [
      '',
      'skills:',
      ...input.skillMatches.map(({ skill, entry }) =>
        `  ${skill.slug.padEnd(20)}${entry.description}`
      ),
    ]
  : [];

const briefLines = input.briefMatches.length > 0
  ? [
      '',
      'briefs:',
      ...input.briefMatches.flatMap(({ brief, snippet }) => [
        `  ${brief.relativePath}`,
        ...(snippet
          ? [`    â†’ mentions: ${snippet.slice(0, 50)}${snippet.length > 50 ? '...' : ''}`]
          : []),
      ]),
    ]
  : [];

return ['ðŸ”Ž matched', ...skillLines, ...briefLines].join('\n');
```

**severity**: blocker

---

### gap.38 = let declarations in try/catch lack deliberate mutation comment

**issue**: `let content` declarations inside try/catch blocks lack `.note` that explains why mutation is necessary

**locations**:
- getSkillWhatLine.ts (line 398): `let content: string;`
- getBriefsMatchedByQuery.ts (line 642): `let content: string;`

**brief reference**: `rule.require.immutable-vars` â€” "isolate unavoidable mutation in scoped zones with .note = deliberate mutation comment"

**current**:
```typescript
let content: string;
try {
  content = readFileSync(input.path, 'utf-8');
} catch {
  return null;
}
```

**fix**: add deliberate mutation comment

```typescript
// note: let required for try/catch assignment pattern
let content: string;
try {
  content = readFileSync(input.path, 'utf-8');
} catch {
  return null;
}
```

**severity**: nitpick

---

### gap.39 = for-of loops in formatSearchResults can be flatMap

**issue**: `for...of` loops used for iteration instead of functional patterns

**location**: formatSearchResults.ts (lines 821-833)

```typescript
for (const { skill, entry } of input.skillMatches) {
  lines.push(`  ${skill.slug.padEnd(20)}${entry.description}`);
}
```

**brief violated**: `rule.require.immutable-vars` â€” prefer functional patterns

**fix**: subsumes under gap.37 fix â€” use map/flatMap

**severity**: blocker (part of gap.37)

---

## summary

| gap | issue | severity | status |
|-----|-------|----------|--------|
| gap.37 | array mutation via push() in formatSearchResults | blocker | âœ… fixed |
| gap.38 | let declarations lack deliberate mutation comment | nitpick | âœ… fixed |
| gap.39 | for-of loops instead of functional patterns | blocker | âœ… fixed (subsumes under gap.37) |

**blockers found**: 1 â†’ **all fixed**
**nitpicks found**: 1 â†’ **all fixed**

**verdict**: âœ… passes mechanic standards comprehensive review (post-fix)

---

## additional review notes

### verified as correct

- gap.30 fix: `getAllMdFilesRecursive` correctly uses flatMap âœ…
- gap.30 fix: `formatAsTree` correctly uses reduce + flatMap âœ…
- gap.31 fix: all operations renamed to use get verb âœ…
- gap.32 fix: `queryLowercased` name correct âœ…
- gap.33 fix: `pathMatched`/`contentMatched` names correct âœ…
- gap.34 fix: all types have .why âœ…
- gap.35: format functions documented as exception âœ…
- gap.36 fix: `getAllBriefFiles` uses nested flatMap âœ…

### patterns that pass review

- `input.items.map(...)` â€” functional, no mutation
- `items.reduce<Map<...>>((acc, item) => new Map([...acc, ...]))` â€” functional reduce
- `entries.flatMap(...)` â€” functional composition
- `[...headerLines, ...groupLines].join('\n')` â€” spread composition

---

## fixes applied

### for blockers

1. **gap.37**: refactored `formatSearchResults` to use functional composition
   - replaced `const lines = []; lines.push(...)` with spread composition
   - replaced `for...of` loops with `.map()` and `.flatMap()`
   - result: `['ðŸ”Ž matched', ...skillLines, ...briefLines].join('\n')`

### for nitpicks

2. **gap.38**: added deliberate mutation comments for let declarations
   - `getSkillWhatLine.ts`: added `// note: let required for try/catch assignment pattern`
   - `getBriefsMatchedByQuery.ts`: added same comment

---

## verification

all fixes documented in blueprint v1.i1.md:
- [x] gap.37: formatSearchResults uses functional composition (spread + map + flatMap)
- [x] gap.38: let declarations have deliberate mutation comments
