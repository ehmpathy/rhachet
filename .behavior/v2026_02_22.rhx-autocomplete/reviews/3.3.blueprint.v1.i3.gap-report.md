# gap report: blueprint v1 simplification review (iteration 3)

## summary

| gap | issue | severity | fix applied |
|-----|-------|----------|-------------|
| gap.15 | duplicate validation functions | nitpick | consolidated into single `assertValidOption` |
| gap.16 | parallel arrays in filterSkillsByQuery | blocker | takes combined `SkillWithEntry[]` |
| gap.17 | parallel arrays in formatSkillList | blocker | takes combined `SkillWithEntry[]` |
| gap.18 | duplicated skills array in zsh output | nitpick | shared `_rhachet_skills` variable |
| gap.19 | inline nested function in discoverBriefFiles | nitpick | extracted `getAllMdFilesRecursive` helper |
| gap.20 | no error guard in getSkillWhatLine | blocker | added try/catch for file read |
| gap.21 | no error guard in filterBriefsByQuery | blocker | added try/catch for file read |

**blockers found**: 4
**nitpicks found**: 3
**all fixed**: yes

---

## gap.15 = duplicate validation functions

**issue**: `assertValidOutputFormat` and `assertValidScope` were nearly identical

**before**:
```typescript
export const assertValidOutputFormat = (input: {
  format: string | undefined;
  valid: string[];
}): void => { ... };

export const assertValidScope = (input: {
  scope: string;
  valid: string[];
}): void => { ... };
```

**fix**: single generic function
```typescript
export const assertValidOption = (input: {
  value: string | undefined;
  field: string;
  valid: string[];
}): void => {
  if (input.value && !input.valid.includes(input.value)) {
    throw new BadRequestError(
      `invalid --${input.field} value: '${input.value}'. valid options: ${input.valid.join(', ')}`,
      { [input.field]: input.value, valid: input.valid },
    );
  }
};
```

**files changed**:
- removed: `assertValidOutputFormat.ts`, `assertValidScope.ts`
- added: `assertValidOption.ts`

---

## gap.16 = parallel arrays in filterSkillsByQuery

**issue**: `skills` and `entries` were separate arrays joined by index

**before**:
```typescript
export const filterSkillsByQuery = (input: {
  skills: RoleSkillExecutable[];
  entries: CompletionEntry[];  // ← parallel array
  query: string;
}): SkillMatch[] => {
  return input.skills
    .map((skill, i) => ({ skill, entry: input.entries[i]! }))  // ← fragile
    .filter(...);
};
```

**fix**: takes pre-combined items
```typescript
export const filterSkillsByQuery = (input: {
  items: SkillWithEntry[];
  query: string;
}): SkillMatch[] => {
  if (!input.query.trim()) return input.items;
  return input.items.filter(({ skill, entry }) => ...);
};
```

**files changed**:
- `filterSkillsByQuery.ts`: signature updated
- `invokeSkillsSubcommand.ts`: calls `getAllSkillsWithEntries` first

---

## gap.17 = parallel arrays in formatSkillList

**issue**: same pattern as gap.16

**fix**: same approach — takes combined `SkillWithEntry[]`

```typescript
export const formatSkillList = (input: {
  items: SkillWithEntry[];
  format?: string;
}): string => { ... };
```

---

## gap.18 = duplicated skills array in zsh output

**issue**: skills array was defined twice in generated zsh code

**before**:
```zsh
_rhx() {
  local -a skills
  skills=(${skillLines})  # ← defined here
  _describe 'skill' skills
}

_rhachet_run_skill() {
  local -a skills
  skills=(${skillLines})  # ← duplicated here
  _describe 'skill' skills
}
```

**fix**: shared variable
```zsh
_rhachet_skills=(${skillLines})

_rhx() {
  _describe 'skill' _rhachet_skills
}

_rhachet_run_skill() {
  _describe 'skill' _rhachet_skills
}
```

---

## gap.19 = inline nested function in discoverBriefFiles

**issue**: `getAllMdFiles` was defined inside for loop

**before**:
```typescript
for (const roleEntry of roleEntries) {
  const getAllMdFiles = (dir: string): string[] => {
    // re-created each iteration
  };
  const mdFiles = getAllMdFiles(briefsDir);
}
```

**fix**: extracted to module level
```typescript
// getAllMdFilesRecursive.ts
export const getAllMdFilesRecursive = (input: { dir: string }): string[] => {
  const entries = readdirSync(input.dir, { withFileTypes: true });
  const files: string[] = [];
  for (const entry of entries) {
    const fullPath = path.join(input.dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...getAllMdFilesRecursive({ dir: fullPath }));
    } else if (entry.isFile() && entry.name.endsWith('.md')) {
      files.push(fullPath);
    }
  }
  return files;
};
```

**files added**: `getAllMdFilesRecursive.ts`, `getAllMdFilesRecursive.test.ts`

---

## gap.20 = no error guard in getSkillWhatLine

**issue**: `readFileSync` can throw but no guard

**before**:
```typescript
export const getSkillWhatLine = (input: { path: string }): string | null => {
  const content = readFileSync(input.path, 'utf-8');  // ← can throw
  // ...
};
```

**fix**: wrap with try/catch
```typescript
export const getSkillWhatLine = (input: { path: string }): string | null => {
  let content: string;
  try {
    content = readFileSync(input.path, 'utf-8');
  } catch {
    return null;  // file unreadable, treat as no description
  }
  // ...
};
```

---

## gap.21 = no error guard in filterBriefsByQuery

**issue**: same pattern as gap.20

**fix**: same approach — wrap with try/catch
```typescript
return input.briefs
  .map((brief) => {
    let content: string;
    try {
      content = readFileSync(brief.path, 'utf-8');
    } catch {
      return null;  // file unreadable, skip this brief
    }
    // ...
  })
  .filter((m): m is BriefMatch => m !== null);
```

---

## types added for gap.16/17

```typescript
export interface SkillWithEntry {
  skill: RoleSkillExecutable;
  entry: CompletionEntry;
}

export type SkillMatch = SkillWithEntry;
```

---

## new function for gap.16/17

```typescript
export const getAllSkillsWithEntries = (input: {
  skills: RoleSkillExecutable[];
}): SkillWithEntry[] => {
  return input.skills.map((skill) => ({
    skill,
    entry: {
      name: skill.slug,
      description: getSkillWhatLine({ path: skill.path }) ?? '(no description)',
    },
  }));
};
```

---

## verification

all gaps have been addressed in blueprint v1.i1.md:
- [x] gap.15: `assertValidOption.ts` in filediff and implementation
- [x] gap.16: `filterSkillsByQuery` takes `SkillWithEntry[]`
- [x] gap.17: `formatSkillList` takes `SkillWithEntry[]`
- [x] gap.18: zsh output uses shared `_rhachet_skills`
- [x] gap.19: `getAllMdFilesRecursive` extracted and tested
- [x] gap.20: `getSkillWhatLine` has try/catch
- [x] gap.21: `filterBriefsByQuery` has try/catch
