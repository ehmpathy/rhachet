# research: production codepath patterns

## summary

the rhx autocomplete feature requires these production codepaths:
1. skill discovery from `.agent/` directories
2. CLI command registration via commander
3. shell dispatcher (bin/run, bin/rhx)
4. output format (tree structures, stats)

most patterns can be **reused** directly. the new `completions` command is an **extension** of the CLI registration pattern.

---

## pattern.1 = skill discovery via .agent/ scan

### what

`discoverSkillExecutables` recursively scans `.agent/repo=*/role=*/skills/` directories to find executable skill files.

### citation

source: `src/domain.operations/invoke/discoverSkillExecutables.ts`

```typescript
export const discoverSkillExecutables = (input: {
  slugRepo?: string;
  slugRole?: string;
  slugSkill?: string;
}): RoleSkillExecutable[] => {
  const agentDir = path.join(process.cwd(), '.agent');

  // skip if .agent directory does not exist
  if (!existsSync(agentDir)) return [];

  // discover repo directories
  const repoEntries = readdirSync(agentDir).filter((entry) =>
    entry.startsWith('repo='),
  );
  // ...
}
```

### relation to wish

this pattern **directly enables** the autocomplete feature:
- tab completion needs list of all skill names
- `rhx list` needs tree of all skills
- `rhx search` needs skill names + descriptions

### verdict: [REUSE]

use `discoverSkillExecutables` directly for:
- `rhachet completion` — get all skills for current repo
- `rhx list` — get all skills with descriptions
- `rhx search` — filter skills by name/description match

---

## pattern.2 = unique skill lookup

### what

`findUniqueSkillExecutable` wraps discovery with error messages and disambiguation hints.

### citation

source: `src/domain.operations/invoke/findUniqueSkillExecutable.ts`

```typescript
export const findUniqueSkillExecutable = (input: {
  slugRepo?: string;
  slugRole?: string;
  slugSkill: string;
}): RoleSkillExecutable => {
  // discover skills with filters
  const matches = discoverSkillExecutables({
    slugRepo: input.slugRepo,
    slugRole: input.slugRole,
    slugSkill: input.slugSkill,
  });

  // handle no matches
  if (matches.length === 0) {
    // ... friendly error with suggestions
  }

  // handle multiple matches
  if (matches.length > 1) {
    // ... disambiguate error
  }

  return matches[0]!;
}
```

### relation to wish

for autocomplete, we do **not** need unique lookup — we want **all** matches. but the error message patterns are useful for `rhx list` empty state.

### verdict: [REUSE]

use the discovery function, but not the unique lookup. adopt error message style for empty `rhx list` output.

---

## pattern.3 = RoleSkillExecutable domain object

### what

`RoleSkillExecutable` represents a discovered skill with slug, path, and provenance (repo/role).

### citation

source: `src/domain.objects/RoleSkillExecutable.ts`

```typescript
export interface RoleSkillExecutable {
  slug: string;        // e.g., "git.commit.set"
  path: string;        // absolute path to executable
  slugRepo: string;    // e.g., "ehmpathy", ".this"
  slugRole: string;    // e.g., "mechanic"
}
```

### relation to wish

this domain object has exactly the data needed for:
- completion entry: `slug` + description (from file content)
- tree view: grouped by `slugRepo`/`slugRole`

### verdict: [REUSE]

use `RoleSkillExecutable` directly. it already has all required fields.

---

## pattern.4 = CLI command registration via commander

### what

CLI commands are registered via `invokeX` functions that add subcommands to the main program.

### citation

source: `src/contract/cli/invoke.ts`

```typescript
const _invoke = async (input: { args: string[] }): Promise<void> => {
  const cwd = process.cwd();
  const context = await genContextConfigOfUsage({ args: input.args, cwd });
  const program = new Command();

  // register all commands unconditionally
  invokeInit({ program });
  invokeRoles({ program }, context);
  invokeList({ program }, context);
  invokeRun({ program });
  // ...
}
```

### citation

source: `src/contract/cli/invokeList.ts`

```typescript
export const invokeList = (
  { program }: { program: Command },
  context: ContextConfigOfUsage,
): void => {
  program
    .command('list')
    .description('list available roles or skills under a role')
    .option('--repo <slug>', 'list roles under this repo')
    .option('--role <slug>', 'list skills under this role (repo optional)')
    .action(async (opts: { repo?: string; role?: string }) => {
      // ...
    });
};
```

### relation to wish

new command `rhachet completion` should follow this exact pattern.

### verdict: [EXTEND]

create `invokeCompletions.ts` with same pattern:
1. define function `invokeCompletions({ program })`
2. add subcommand `completion` (no shell arg - zsh only for v1)
3. output completion code to stdout

---

## pattern.5 = shell dispatcher (bin/run, bin/rhx)

### what

shell dispatchers route commands to bun (fast) or jit (flexible) paths.

### citation

source: `bin/run`

```bash
case "$1" in
  run)
    # fast path: dispatch to bun
    exec "$SCRIPT_DIR/run.bun" "$@"
    ;;
  roles)
    case "$2" in
      boot|cost)
        exec "$SCRIPT_DIR/run.bun" "$@"
        ;;
      *)
        exec "$SCRIPT_DIR/run.jit" "$@"
        ;;
    esac
    ;;
  *)
    exec "$SCRIPT_DIR/run.jit" "$@"
    ;;
esac
```

### citation

source: `bin/rhx`

```bash
# short-circuit keyrack commands (via jit path)
if [ "$1" = "keyrack" ]; then
  shift
  exec "$SCRIPT_DIR/run.jit" keyrack "$@"
fi

# default: proxy to run --skill
exec "$SCRIPT_DIR/run" run --skill "$@"
```

### relation to wish

`rhachet completion` should use the **jit path** — it's a one-time generation, not performance-critical.

the `rhx list` and `rhx search` commands are new top-level commands that should proxy through bin/rhx to rhachet.

### verdict: [EXTEND]

1. add `completions` case to bin/run → route to jit
2. add `list` and `search` cases to bin/rhx → route to rhachet

---

## pattern.6 = tree output format

### what

tree output uses box-draw characters for hierarchy.

### citation

source: `src/contract/cli/invokeList.ts`

```typescript
for (let i = 0; i < roles.length; i++) {
  const isLast = i === roles.length - 1;
  const prefix = isLast ? '└── ' : '├── ';
  console.log(`${prefix}${roles[i]!.slug}: ${roles[i]!.purpose}`);
}
```

### citation

source: `src/domain.operations/invoke/bootRoleResources.ts`

```typescript
console.log('quant');
console.log(`  ├── files = ${relevantFiles.length}`);
console.log(`  │   ├── briefs = ${briefsSayCount}`);
console.log(`  │   └── skills = ${skillsSayCount}`);
```

### relation to wish

`rhx list` needs tree output grouped by repo/role. same pattern applies.

### verdict: [REUSE]

apply same tree-draw pattern for `rhx list` output.

---

## pattern.7 = skill documentation extraction

### what

`extractSkillDocumentation` parses skill files to extract `.what` and other header comments.

### citation

source: `src/domain.operations/role/extractSkillDocumentation.ts`

```typescript
export const extractSkillDocumentationFromContent = (
  content: string,
): string => {
  const lines = content.split('\n');
  const docLines: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // include shebang
    if (trimmed.startsWith('#!')) {
      docLines.push(line);
      continue;
    }

    // include comment lines
    if (trimmed.startsWith('#') || trimmed.startsWith('//')) {
      docLines.push(line);
      continue;
    }

    // stop at first non-comment line
    if (trimmed !== '') break;
  }
  // ...
}
```

### relation to wish

for `rhx list` and tab completion descriptions, we need to extract the `.what` line specifically — not all documentation.

### verdict: [EXTEND]

create `getSkillWhatLine()` that:
1. reads skill file
2. finds line with `.what =`
3. returns the description after `=`

---

## pattern.8 = getAllFilesFromDir utility

### what

shared utility that recursively collects files, handles symlinks gracefully.

### citation

source: `src/infra/filesystem/getAllFilesFromDir.ts`

```typescript
export const getAllFilesFromDir = (dir: string): string[] => {
  if (!existsSync(dir)) return [];

  const entries = readdirSync(dir);
  const files: string[] = [];

  for (const entry of entries) {
    const fullPath = path.join(dir, entry);

    // skip broken symlinks gracefully
    try {
      stats = statSync(fullPath);
    } catch (error: unknown) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') continue;
      throw error;
    }

    if (stats.isDirectory()) {
      files.push(...getAllFilesFromDir(fullPath));
    } else if (stats.isFile()) {
      files.push(fullPath);
    }
  }

  return files;
}
```

### relation to wish

already used by `discoverSkillExecutables`. no change needed.

### verdict: [REUSE]

use via `discoverSkillExecutables` — already handles symlinked roles.

---

## pattern.9 = invokeRun context-free design

### what

`invokeRun` operates without needing `rhachet.use.ts` config — it discovers skills directly from filesystem.

### citation

source: `src/contract/cli/invoke.ts`

```typescript
invokeRun({ program }); // filesystem only, no context needed
```

### relation to wish

`rhachet completion` should follow this pattern — filesystem-only discovery, no config required.

### verdict: [REUSE]

follow `invokeRun` pattern: context-free, filesystem-only.

---

## summary: pattern verdicts

| pattern | verdict | reason |
|---------|---------|--------|
| skill discovery (`discoverSkillExecutables`) | **[REUSE]** | provides all needed data |
| unique lookup (`findUniqueSkillExecutable`) | **[REUSE]** | error message style |
| domain object (`RoleSkillExecutable`) | **[REUSE]** | has slug, path, provenance |
| CLI registration (`invokeX` pattern) | **[EXTEND]** | add `invokeCompletions` |
| shell dispatcher (bin/run, bin/rhx) | **[EXTEND]** | add completions, list, search routes |
| tree output format | **[REUSE]** | same pattern for `rhx list` |
| skill docs extraction | **[EXTEND]** | add `.what` line extraction |
| filesystem utility | **[REUSE]** | via `discoverSkillExecutables` |
| context-free design | **[REUSE]** | follow `invokeRun` pattern |

---

## new code needed

| component | type | pattern to follow |
|-----------|------|-------------------|
| `invokeCompletions.ts` | new file | follow `invokeRun.ts` |
| `getSkillWhatLine.ts` | new file | follow `extractSkillDocumentation.ts` |
| `getAllCompletionEntries.ts` | new file | transform skills to `name:description` pairs |
| bin/run update | edit | add `completions` case |
| bin/rhx update | edit | add `list`, `search` cases |
