# distill: domain for rhx autocomplete

## usecases and contracts

### usecase.1 = rhachet completion

**contract**:
```typescript
// invocation
rhachet completion

// output
// zsh completion code to stdout
```

**flow**:
```
input: cwd (implicit from process.cwd())
output: zsh completion code (string to stdout)

1. discoverSkillExecutables({ })
2. getAllRoleSkillsLinked({ skills })
3. genZshCompletionCode()  # emits dynamic completion code
4. console.log(code)
```

### usecase.2 = rhx list

**contract**:
```typescript
// invocation
rhx list [--repo <slug>] [--role <slug>] [--output tree|flat|json]

// output
// formatted list to stdout
```

**flow**:
```
input: { repo?: string, role?: string, output?: 'tree' | 'flat' | 'json' }
output: formatted list to stdout

1. discoverSkillExecutables({ slugRepo: input.repo, slugRole: input.role })
2. getAllRoleSkillsLinked({ skills })
3. formatSkillList({ items, format: input.output })
4. console.log(formatted)
```

### usecase.3 = rhx search

**contract**:
```typescript
// invocation
rhx search <query> [--output tree|flat|json]

// output
// matched skills to stdout
```

**flow**:
```
input: { query: string, output?: 'tree' | 'flat' | 'json' }
output: matched skills to stdout

1. discoverSkillExecutables({ })
2. getAllRoleSkillsLinked({ skills })
3. getSkillsMatchedByQuery({ items, query })
4. formatSkillList({ items: matches, format: input.output })
5. console.log(formatted)
```

---

## domain.objects

### entities

| entity | identity | unique | description |
|--------|----------|--------|-------------|
| `RoleSkillExecutable` | path | slug + slugRepo + slugRole | extant entity from rhachet |

**note**: `RoleSkillExecutable` already exists in `src/domain.objects/RoleSkillExecutable.ts`. no new entities needed.

### literals

| literal | shape | description |
|---------|-------|-------------|
| `RoleSkillLinked` | `{ skill: RoleSkillExecutable; description: string }` | skill with .what description for completion |
| `SkillListFormat` | `'tree' \| 'flat' \| 'json'` | output format for `rhx list` and `rhx search` |

### events

| event | trigger | data |
|-------|---------|------|
| `SkillsDiscovered` | skill scan complete | `{ skills: RoleSkillExecutable[] }` |
| `CompletionCodeGenerated` | zsh code emitted | `{ skillCount: number }` |

---

## domain.operations

### getOne (extant)

| operation | input | output | status |
|-----------|-------|--------|--------|
| `discoverSkillExecutables` | `{ slugRepo?, slugRole?, slugSkill? }` | `RoleSkillExecutable[]` | **[REUSE]** |
| `findUniqueSkillExecutable` | `{ slugRepo?, slugRole?, slugSkill }` | `RoleSkillExecutable` | **[REUSE]** |

### getOne (new)

| operation | input | output | status |
|-----------|-------|--------|--------|
| `getSkillWhatLine` | `{ path: string }` | `string \| null` | **[NEW]** |

**getSkillWhatLine implementation**:
```typescript
export const getSkillWhatLine = (input: {
  path: string;
}): string | null => {
  const content = readFileSync(input.path, 'utf-8');
  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();

    // match ".what = description" or "# .what = description"
    const match = trimmed.match(/^#?\s*\.what\s*=\s*(.+)$/);
    if (match) return match[1].trim();

    // stop at first non-comment, non-empty line
    if (trimmed !== '' && !trimmed.startsWith('#') && !trimmed.startsWith('//')) {
      break;
    }
  }

  return null;
};
```

### getAll (new)

| operation | input | output | status |
|-----------|-------|--------|--------|
| `getAllRoleSkillsLinked` | `{ skills: RoleSkillExecutable[] }` | `RoleSkillLinked[]` | **[NEW]** |

**getAllRoleSkillsLinked implementation**:
```typescript
export const getAllRoleSkillsLinked = (input: {
  skills: RoleSkillExecutable[];
}): RoleSkillLinked[] => {
  return input.skills.map((skill) => new RoleSkillLinked({
    skill,
    description: getSkillWhatLine({ path: skill.path }) ?? '(no description)',
  }));
};
```

### gen (new)

| operation | input | output | status |
|-----------|-------|--------|--------|
| `genZshCompletionCode` | (no input) | `string` | **[NEW]** |

**genZshCompletionCode implementation**:
```typescript
/**
 * .what = generates zsh completion code with dynamic completion
 * .why = cwd-aware completions via rhachet completion --list on each tab press
 */
export const genZshCompletionCode = (): string => {
  return `#compdef rhx

_rhx() {
  local completions
  completions=("\${(@f)\$(rhachet completion --list 2>/dev/null)}")
  _describe 'skill' completions
}

_rhx "$@"`;
};
```

### format (new)

| operation | input | output | status |
|-----------|-------|--------|--------|
| `formatSkillList` | `{ items: RoleSkillLinked[], format?: 'tree' \| 'flat' \| 'json' }` | `string` | **[NEW]** |
| `formatAsTree` | `{ items, getGroupKey, getLabel, getDescription, header? }` | `string` | **[NEW]** |
| `formatAsFlat` | `{ items, getLine }` | `string` | **[NEW]** |
| `formatAsJson` | `{ items, transform }` | `string` | **[NEW]** |

### filter (new)

| operation | input | output | status |
|-----------|-------|--------|--------|
| `getSkillsMatchedByQuery` | `{ items: RoleSkillLinked[], query: string }` | `RoleSkillLinked[]` | **[NEW]** |

---

## relationships

### treestruct: filesystem to domain

```
.agent/                              # scanned by discoverSkillExecutables
  repo={slugRepo}/                   # RoleSkillExecutable.slugRepo
    role={slugRole}/                 # RoleSkillExecutable.slugRole
      skills/
        {name}.sh                    # RoleSkillExecutable.slug, .path
          # .what = description      # SkillWhatLine (extracted)
```

### dependency graph

```
                    ┌─────────────────────────┐
                    │   CLI Entry Points      │
                    │  invokeCompletions      │
                    │  invokeSkillsSubcommand │
                    └──────────┬──────────────┘
                               │
               ┌───────────────┼───────────────┐
               ▼               ▼               ▼
    ┌──────────────────┐  ┌────────────────┐  ┌────────────────────┐
    │genZshCompletionCode│ │formatSkillList│  │getSkillsMatchedByQuery│
    └────────┬─────────┘  └───────┬────────┘  └─────────┬──────────┘
             │                    │                     │
             └────────────────────┼─────────────────────┘
                                  ▼
                       ┌──────────────────────┐
                       │ getAllRoleSkillsLinked │
                       └──────────┬───────────┘
                                  │
                                  ▼
                       ┌──────────────────────┐
                       │   getSkillWhatLine   │
                       └──────────┬───────────┘
                                  │
                                  ▼
                       ┌──────────────────────┐
                       │discoverSkillExecutables│  [EXTANT]
                       └──────────────────────┘
```

### composition for usecases

| usecase | operations composed |
|---------|---------------------|
| `rhachet completion` | genZshCompletionCode (emits dynamic code) |
| `rhachet completion --list` | discoverSkillExecutables → getAllRoleSkillsLinked |
| `rhx list` | discoverSkillExecutables → getAllRoleSkillsLinked → formatSkillList |
| `rhx search` | discoverSkillExecutables → getAllRoleSkillsLinked → getSkillsMatchedByQuery → formatSkillList |

---

## summary: new code needed

### domain.objects (new)

| file | type | description |
|------|------|-------------|
| `src/domain.objects/RoleSkillLinked.ts` | DomainLiteral | skill + description for completion |

### domain.operations (new)

| file | operation | type |
|------|-----------|------|
| `src/domain.operations/completions/getSkillWhatLine.ts` | getSkillWhatLine | getOne |
| `src/domain.operations/completions/getAllRoleSkillsLinked.ts` | getAllRoleSkillsLinked | getAll |
| `src/domain.operations/completions/genZshCompletionCode.ts` | genZshCompletionCode | gen |
| `src/domain.operations/completions/getSkillsMatchedByQuery.ts` | getSkillsMatchedByQuery | getAll |
| `src/domain.operations/completions/formatSkillList.ts` | formatSkillList | format |

### contract/cli (new)

| file | command | description |
|------|---------|-------------|
| `src/contract/cli/invokeCompletions.ts` | `completions [zsh] [--list]` | emit zsh code or skill list |
| `src/contract/cli/invokeSkillsSubcommand.ts` | `skills list/search` | list and search skills |

### bin updates (extend)

| file | change |
|------|--------|
| `bin/run` | add `completions` case → bun path |
| `bin/run.bun` | add `completions` case → rhachet-roles.bc |
| `bin/rhx` | add `completions`, `list`, `search` cases → proxy to rhachet |

---

## domain objects not needed

| considered | verdict | reason |
|------------|---------|--------|
| new Skill entity | skip | `RoleSkillExecutable` already exists |
| new Brief entity | skip | out of scope for v1 (skills only) |
| CompletionCache | skip | dynamic completion = no cache needed |

---

## access.daos not needed

all data comes from filesystem via `discoverSkillExecutables`. no database or external API access required.
