# research: claims

## zsh completion fundamentals

### [FACT] compadd is the core primitive
> "The key command in the new completion system is 'compadd', which is passed a list of completions and decides what to use to complete the word on the command line." [1]

### [FACT] _describe is easier than raw compadd
> "For very basic completions the _describe function should be adequate." [2]
> "The compadd builtin is the core function used to add completion words to the command line and control its behavior, though you often won't need to use it directly since utility functions like _arguments and _describe are easier to use." [2]

### [OPIN] always use descriptions
> "Always use descriptions - if you have written a compadd without descriptions (expl[@]), you have made an error." [3]

---

## completion caching

### [FACT] zsh has built-in cache-path style
> "The cache-path style defines the path where any cache files containing dumped completion data are stored." [4]
> "The completion cache is stored in the ${ZDOTDIR:-${HOME}}/.zcompcache directory by default." [4]

### [SUMP] static file is faster than dynamic generation
> "The solution for performance is to generate the completion code once and source the static file thereafter, only regenerating the cache when the tool is installed or updated." [5]

### [KHUE] how to make cache per-directory?
zsh's cache-path is global. for cwd-aware completions, options:
1. generate fresh on each completion (slower)
2. cache per repo root hash (faster, but needs invalidation)
3. embed repo detection in completion function (hybrid)

---

## node.js CLI completion libraries

### [FACT] tabtab is the most referenced library
> "tabtab - tab completion helpers for node CLI programs & others, inspired by npm completion" [6]

### [FACT] npm has built-in completion
> "npm completion - Tab Completion for npm" [7]

### [SUMP] tabtab generates shell code
the pattern: node.js CLI outputs shell code, user evals it in .zshrc

---

## cwd-aware completions

### [KHUE] how do other CLIs handle cwd-awareness?
- git: completions are git-aware (branches, remotes differ per repo)
- docker: completions are context-aware (containers, images)
- kubectl: completions are cluster-aware

### [SUMP] eval-on-demand works for cwd-awareness
if completion function runs `rhachet completion` on each tab, it always gets fresh results for current cwd. tradeoff: startup cost per tab.

### [OPIN] cache + invalidation is better
generate once per repo, store at `~/.zsh/completions/rhx-{repo-hash}`, invalidate on `rhachet init`.

---

## citations

[1] zsh Guide Chapter 6
- source: https://zsh.sourceforge.io/Guide/zshguide06.html
- accessed: 2026-02-23

[2] zsh-completions howto
- source: https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org
- accessed: 2026-02-23

[3] A Review of ZSH Completion
- source: http://zv.github.io/a-review-of-zsh-completion-utilities
- accessed: 2026-02-23

[4] zsh Completion System docs
- source: https://zsh.sourceforge.io/Doc/Release/Completion-System.html
- accessed: 2026-02-23

[5] Shell Completion Caching (2026)
- source: https://raoulcoutard.com/posts/2026-02-04-shell-completion-caching-en/
- accessed: 2026-02-23

[6] tabtab npm package
- source: https://github.com/mklabs/tabtab
- accessed: 2026-02-23

[7] npm completion docs
- source: https://docs.npmjs.com/cli/v7/commands/npm-completion/
- accessed: 2026-02-23

---

## summary

| claim type | count |
|------------|-------|
| [FACT] | 5 |
| [SUMP] | 3 |
| [KHUE] | 2 |
| [OPIN] | 2 |

key insight: zsh completion system is well-documented. the main open question is cwd-aware caching strategy. eval-on-demand is simplest but slower; per-repo cache is faster but needs invalidation.
