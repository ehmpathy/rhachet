# research: OSS levers for shell completion

## summary

several OSS tools can be leveraged for rhx autocomplete:

1. **tabtab** — most widely used Node.js shell completion library
2. **commander-completion** — commander.js-specific completion plugin
3. **oclif/plugin-autocomplete** — oclif framework autocomplete (heavyweight)
4. **native zsh _describe** — lightweight, direct zsh integration

recommendation: **native zsh approach** with lightweight TypeScript generation, following npm's own pattern.

---

## tool.1 = tabtab (@pnpm/tabtab)

### what

tabtab is the most referenced Node.js library for shell completion, with 377 stars. maintained by pnpm organization.

### how it works

> "tabtab is made possible using the same technique as npm, relying on a shell mechanism bridge to do the actual completion from node's land." [1]

the library uses a shell mechanism bridge that intercepts tab completion events. when triggered, it invokes the Node.js program with special environment variables (`COMP_CWORD`, `COMP_LINE`, `COMP_POINT`).

### usage pattern

```javascript
const tabtab = require('@pnpm/tabtab');
const env = tabtab.parseEnv(process.env);

if (!env.complete) return;

// provide completion suggestions
if (env.prev === '--loglevel') {
  tabtab.log(['error', 'warn', 'info', 'notice', 'verbose']);
}
```

> "completion items support descriptions using either object syntax `{ name, description }` or inline format `'command:description'`." [1]

### installation

> "`tabtab.install()` asks users which SHELL to use and adds a new line to either ~/.bashrc, ~/.zshrc or ~/.config/fish/config.fish to source the tabtab completion mechanism." [2]

### shell support

- bash
- zsh
- fish

### maintenance

| metric | value |
|--------|-------|
| stars | 377 |
| forks | 37 |
| commits | 268-328 |
| last commit | january 2023 |
| typescript | yes (tsconfig.common.json present) |

### adopters

> "The documentation mentions integration with **Yeoman (yo)** and references **yarn-completion** as motivation for the 3.0.0 rewrite." [1]

### pros

- battle-tested by pnpm
- supports descriptions with `name:description` format
- handles shell detection automatically
- typescript support

### cons

- adds runtime dependency
- requires shell bridge mechanism
- last commit january 2023 (may be stable, or may be stale)
- dynamic completion (runs node on each tab) = performance overhead

### verdict

**[CONSIDER]** — good option if dynamic completion is desired, but overhead for cwd-aware completion may be unnecessary.

---

## tool.2 = commander-completion-carapace

### what

> "Effortlessly add intelligent autocomplete support to your Commander.js CLI app using Carapace. Supports Bash, Zsh, Fish, Nushell and more" [3]

### shell support

- bash
- zsh
- fish
- nushell
- powershell
- more

### maintenance

relatively new project, fewer stars than tabtab.

### pros

- works directly with commander.js
- wide shell support via carapace
- typescript-first

### cons

- depends on carapace binary
- newer, less battle-tested
- external binary dependency

### verdict

**[SKIP]** — external binary dependency is heavyweight for this usecase.

---

## tool.3 = commander-completion (twolfson)

### what

> "The commander-completion module can be used to generate bash/zsh completion functions for a commander.js CLI." [4]

### usage

> "Running `npm run-command completion` generates a commands.sh file which is used by the completion function to get the options for the current CLI." [4]

### maintenance

older project, less active.

### pros

- generates static completion code
- no runtime dependency

### cons

- older project
- less active maintenance
- limited documentation

### verdict

**[SKIP]** — older project with limited maintenance.

---

## tool.4 = oclif/plugin-autocomplete

### what

official oclif framework autocomplete plugin with 92 stars and active maintenance.

### usage

> "Run `<cli> autocomplete` to generate the autocomplete files for your current shell." [5]

### shell support

- bash
- zsh
- powershell

### maintenance

| metric | value |
|--------|-------|
| stars | 92 |
| forks | 35 |
| releases | 125 |
| last release | january 22, 2026 |
| commits | 1,260 |

> "The most recent release (3.2.40) arrived on January 22, 2026, with 125 total releases since inception." [5]

### pros

- actively maintained
- powershell support
- handles topic separators (colon vs space)

### cons

- requires oclif framework (heavyweight)
- not compatible with commander.js directly
- overkill for simple completion needs

### verdict

**[SKIP]** — requires oclif framework, rhachet uses commander.js.

---

## tool.5 = npm completion (native pattern)

### what

npm's built-in completion command that outputs shell code.

### usage

> "The `npm completion` command outputs shell code, and you can make this work between shell/OS restarts by running `npm completion >> ~/.bashrc` (or `~/.zshrc`)." [6]

### how it works

1. `npm completion` outputs zsh/bash completion code to stdout
2. user adds `eval "$(npm completion)"` to shell config
3. shell sources the completion code on startup
4. completion work natively via shell mechanisms

### pros

- no runtime dependency
- instant completion (no node startup per tab)
- standard unix pattern
- battle-tested by npm itself

### cons

- must regenerate on command changes
- static (not dynamic based on cwd)
- requires manual shell config

### verdict

**[REUSE PATTERN]** — this is the pattern `rhachet completion` should follow.

---

## tool.6 = zsh native _describe

### what

zsh's built-in completion system using `_describe` function.

### usage

> "For very basic completion the _describe function should be adequate." [7]

```zsh
#compdef rhx

_rhx() {
  local -a skills
  skills=(
    'git.commit.set:create git commit'
    'perf.test:measure CLI time'
  )
  _describe 'skill' skills
}

_rhx "$@"
```

### how it works

> "The key command in the new completion system is 'compadd', which is passed a list of completion and decides what to use to complete the word on the command line." [8]

`_describe` is a higher-level wrapper that handles `name:description` pairs.

### best practice

> "Always use descriptions - if you have written a compadd without descriptions (expl[@]), you have made an error." [9]

### pros

- zero runtime dependencies
- instant completion (native shell)
- simple format (`name:description` pairs)
- follows zsh best practices

### cons

- zsh only (bash/fish need separate implementations)
- static (must regenerate on skill changes)

### verdict

**[ADOPT]** — lightweight, native, follows npm pattern.

---

## recommendation

### chosen approach: npm-style + zsh native

combine npm's `eval "$(cmd completion)"` pattern with zsh's native `_describe`:

1. `rhachet completion` outputs static zsh completion code
2. user runs `rhachet completion --setup` (writes directly to ~/.zshrc)
3. completion function uses `_describe` for `skill:description` pairs
4. completion are **fresh on every shell start** (not cached)

### why not dynamic (tabtab-style)?

| approach | startup cost | tab cost | cwd-aware |
|----------|--------------|----------|-----------|
| static (--setup) | ~100ms once | 0ms | yes (fresh each shell) |
| dynamic bridge | 0ms | ~35-100ms per tab | yes |

for cwd-aware completion, the static --setup approach is sufficient:
- completion are generated at shell startup
- user opens new shell when changing repos
- `cd` to different repo → completion reflect that repo's skills on next shell

### implementation plan

```typescript
// src/contract/cli/invokeCompletions.ts
export const invokeCompletions = ({ program }: { program: Command }) => {
  program
    .command('completion')
    .argument('<shell>', 'shell type (zsh)')
    .action((shell: string) => {
      if (shell !== 'zsh') {
        throw new Error('only zsh is supported');
      }

      // discover skills from .agent/
      const skills = discoverSkillExecutables({});

      // extract descriptions
      const entries = skills.map((skill) => ({
        name: skill.slug,
        description: getSkillWhatLine({ path: skill.path }),
      }));

      // emit zsh completion code
      console.log(genZshCompletionCode({ entries }));
    });
};
```

### zsh output format

```zsh
#compdef rhx

_rhx() {
  local -a skills
  skills=(
    'git.commit.set:create git commit as seaturtle[bot]'
    'perf.test:measure CLI execution time'
    'say-hello:test fixture skill'
  )
  _describe 'skill' skills
}

_rhx "$@"
```

---

## citations

[1] mklabs/tabtab GitHub repository
- source: https://github.com/mklabs/tabtab
- accessed: 2026-02-23

[2] tabtab npm package
- source: https://www.npmjs.com/package/tabtab
- accessed: 2026-02-23

[3] commander-completion-carapace GitHub repository
- source: https://github.com/gutenye/commander-completion-carapace
- accessed: 2026-02-23

[4] commander-completion npm package
- source: https://www.npmjs.com/package/commander-completion
- accessed: 2026-02-23

[5] oclif/plugin-autocomplete GitHub repository
- source: https://github.com/oclif/plugin-autocomplete
- accessed: 2026-02-23

[6] npm completion documentation
- source: https://docs.npmjs.com/cli/v7/commands/npm-completion/
- accessed: 2026-02-23

[7] zsh-completion howto
- source: https://github.com/zsh-users/zsh-completion/blob/master/zsh-completion-howto.org
- accessed: 2026-02-23

[8] zsh Guide Chapter 6
- source: https://zsh.sourceforge.io/Guide/zshguide06.html
- accessed: 2026-02-23

[9] A Review of ZSH Completion
- source: http://zv.github.io/a-review-of-zsh-completion-utilities
- accessed: 2026-02-23

---

## summary: tool verdicts

| tool | verdict | reason |
|------|---------|--------|
| @pnpm/tabtab | **[CONSIDER]** | good if dynamic needed, but overhead |
| commander-completion-carapace | **[SKIP]** | external binary dependency |
| commander-completion | **[SKIP]** | older, less maintained |
| oclif/plugin-autocomplete | **[SKIP]** | requires oclif framework |
| npm completion pattern | **[REUSE PATTERN]** | battle-tested, eval-based |
| zsh native _describe | **[ADOPT]** | lightweight, native, simple |

**final recommendation**: use `rhachet completion --setup` with native zsh `_describe` for skill completion.
