# vision: rhx autocomplete

> what if rhx commands were as discoverable as your filesystem?

---

## the outcome world

### before: guess and retry

```sh
$ rhx route... uh, what was it again?
$ rhx --help
# ... scrolls through wall of text ...
$ rhx route --help
# ... still no luck ...
$ rhx route.stone... was it set? update? apply?
```

you know the command exists. you've used it before. but the exact name? buried somewhere in memory or docs.

**friction compounds**: every hesitation breaks flow. every `--help` is a context switch. every typo is a retry.

### after: the flow state

```sh
$ rhx route.st<tab>
route.stone.get   route.stone.set   route.stone.status

$ rhx route.stone.s<tab><tab>
route.stone.set     route.stone.status

$ rhx route.stone.set<enter>
```

**zero friction**. type what you remember, tab completes the rest. your fingers stay on the keyboard, your mind stays on the task.

### the "aha" moment

you're mid-thought, need to run a skill. instead of a break to check docs:

```sh
$ rhx git.<tab>
git.commit.bind   git.commit.push   git.commit.set   git.commit.uses

$ rhx git.commit.<tab>
git.commit.bind   git.commit.push   git.commit.set   git.commit.uses
```

*"oh right, it's `git.commit.set`"* â€” and you already type the args.

---

## user experience

### usecase 1: discover available skills

**goal**: "what can i do with rhx?"

```sh
$ rhx list
ğŸ¢ rhx skills

repo=.this/role=any
â”œâ”€â”€ git.commit.bind     bind commit level constraint
â”œâ”€â”€ git.commit.push     push HEAD commit to origin
â”œâ”€â”€ git.commit.set      create git commit as seaturtle[bot]
â”œâ”€â”€ git.commit.uses     manage git commit quota
â”œâ”€â”€ perf.test           measure CLI execution time
â”œâ”€â”€ say-hello           test fixture skill
â”œâ”€â”€ sedreplace          safe find-and-replace
â””â”€â”€ show.gh.test.errors show test errors from workflow

repo=ehmpathy/role=mechanic
â”œâ”€â”€ cpsafe              safe file copy within repo
â”œâ”€â”€ mvsafe              safe file move within repo
â”œâ”€â”€ rmsafe              safe file removal within repo
â””â”€â”€ symlink             safe symlink creation
```

**output**: tree-structured by repo and role, with one-liner descriptions pulled from `.what` headers.

### usecase 2: search by keyword

**goal**: "which skill handles git commits?"

```sh
$ rhx search commit
ğŸ” matched "commit"

skills:
  git.commit.bind   bind commit level constraint for mechanics
  git.commit.push   push HEAD commit to origin and findsert pr
  git.commit.set    create git commit as seaturtle[bot]
  git.commit.uses   manage git commit quota for mechanics

briefs:
  practices/work.flow/tools/rule.prefer.allowlist-examples.md
    â†’ mentions: git.commit.set examples
```

**searches**: skill names, `.what` descriptions, and brief contents.

### usecase 3: tab completion as you type

**goal**: "i know it starts with `show.`"

```sh
$ rhx show.<tab>
show.bun.deps        show.claude.task.output   show.gh.action.logs   show.gh.test.errors
```

**behavior**:
- single `<tab>` â†’ completes to longest common prefix
- double `<tab><tab>` â†’ lists all options at current branch
- works for all skill names discovered from `.agent/`

### usecase 4: interactive fuzzy search (stretch)

**goal**: "i can't remember the exact name"

```sh
$ rhx search
ğŸ” type to search (â†‘â†“ to navigate, enter to select, esc to cancel)
> tes_

  perf.test           measure CLI execution time
  show.gh.test.errors show test errors from workflow
```

**live filter**: as you type, results narrow. arrow keys to select, enter to run.

---

## contracts

### `rhx list`

```
rhx list [options]

options:
  --repo <slug>     filter to specific repo (e.g., .this, ehmpathy)
  --role <slug>     filter to specific role (e.g., any, mechanic)
  --format <fmt>    output format: tree (default), flat, json

output:
  tree-structured list of skills with .what descriptions
```

### `rhx search`

```
rhx search [query] [options]

args:
  query             search term (optional; omit for interactive mode)

options:
  --scope <what>    search scope: all (default), skills, briefs
  --format <fmt>    output format: tree (default), flat, json
  --interactive     force interactive fuzzy search mode

output:
  matched skills and briefs with context snippets
```

### tab completion (zsh integration)

```sh
# install to ~/.zshrc
rhachet completion --setup
```

emits completion functions that:
- scan `.agent/` for skill names **relative to cwd**
- cache completions per-repo (keyed by repo root path)
- complete `rhx <partial>` with matched skills for current repo
- complete `rhachet run --skill <partial>` equivalently

---

## timelines

### first-time setup (~30 seconds)

```sh
# install completion (writes directly to ~/.zshrc)
rhachet completion --setup
source ~/.zshrc
```

### daily use (instant)

```sh
$ rhx per<tab>     â†’  $ rhx perf.test
$ rhx git.c<tab>   â†’  $ rhx git.commit.
$ rhx git.commit.<tab><tab>
git.commit.bind   git.commit.push   git.commit.set   git.commit.uses
```

no thought required. muscle memory develops naturally.

---

## mental model

### how users describe it

> "it's like tab completion for git commands, but for rhachet skills"

> "type what you remember, tab fills in the rest"

> "`rhx list` is like `ls` for your skills, `rhx search` is like `grep`"

### analogies that fit

| familiar concept | rhx equivalent |
|------------------|----------------|
| `git <tab>` | `rhx <tab>` |
| `ls` | `rhx list` |
| `grep` / `fzf` | `rhx search` |
| `man` | `rhx readme --skill <name>` (already exists) |

### terms alignment

| user says | we say | both mean |
|-----------|--------|-----------|
| "command" | "skill" | executable capability |
| "autocomplete" | "tab completion" | shell completes partial input |
| "search" | "search" | find by keyword |
| "list" | "list" | enumerate available options |

---

## evaluation

### how well does it solve the goals?

| goal | solution | score |
|------|----------|-------|
| discover skills quickly | `rhx list` tree view | âœ… |
| find skill by keyword | `rhx search <query>` | âœ… |
| complete partial names | shell tab completion | âœ… |
| reduce help-checking | inline descriptions | âœ… |
| stay in flow | zero context switches | âœ… |

### pros

- **zero ramp-up** â€” uses standard shell completion conventions
- **instant feedback** â€” tab shows options, no need to leave command line
- **discoverable** â€” new skills appear in completions automatically
- **composable** â€” works with current shell workflows (pipes, etc)
- **offline** â€” scans local `.agent/` directory, no network required

### cons

- **zsh only** â€” initial version supports zsh; bash/fish can follow later
- **setup required** â€” users must run `rhachet completion --setup`
- **stale completions** â€” `npx rhachet init` auto-refreshes cache; manual `rhx completion --refresh` also available

### edgecases and pit of success

| edgecase | how we handle it |
|----------|------------------|
| skill name with spaces | disallow spaces in skill names (already enforced) |
| very long skill names | tree truncates with ellipsis, full name in --format flat |
| 100+ skills | paginate or group by repo/role |
| no skills found | friendly message: "no skills found in .agent/" |
| search returns no matches | "no matches for '<query>'" with suggestions |
| typo in partial | closest matches shown via fuzzy search |

### awkward bits uncovered

1. **cwd-aware completions**: each repo has different skills
   - completions must detect repo root (via `.agent/` or `.git/`)
   - cache keyed by repo path, not global
   - when you `cd` into a different repo, completions reflect that repo's skills

2. **zsh cache integration**: completions go into zsh's completion cache
   - per-repo cache stored somewhere zsh can access (e.g., `~/.zsh/completions/rhx-{repo-hash}`)
   - `npx rhachet init` auto-refreshes cache for current repo

3. **performance**: zsh cache avoids repeated scans
   - completion list generated once per repo, stored in zsh cache
   - lookup: detect repo root â†’ load cached completions for that repo

---

## summary

```
before: "what was that command again?" â†’ --help â†’ scroll â†’ retry
after:  rhx git.<tab> â†’ done
```

tab completion transforms rhx from "tool you reference" to "extension of your fingers". `rhx list` and `rhx search` complete the discoverability story.

ğŸ¢ shell yeah, let's make it happen ğŸŒŠ
