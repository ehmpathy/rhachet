# vision: symmetric role+brain package discovery for upgrade

## the outcome world

### before

today, `npx rhachet upgrade` has an asymmetry:

```sh
# brains: discovers from package.json
npx rhachet upgrade --brains *
# → finds rhachet-brains-anthropic from package.json ✓
# → upgrades it even if never used yet ✓

# roles: discovers from .agent/ symlinks only
npx rhachet upgrade --roles *
# → only finds roles already linked in .agent/ ✗
# → misses rhachet-roles-ehmpathy if link was not run yet ✗
```

if you add a new `rhachet-roles-*` package to package.json but have not run `npx rhachet init --roles` yet, upgrade ignores it.

### after

```sh
# both discover from package.json
npx rhachet upgrade
# → finds all rhachet-brains-* packages ✓
# → finds all rhachet-roles-* packages ✓
# → upgrades all regardless of link state ✓
```

the upgrade command becomes **link-state-agnostic**. it sees what's in package.json and upgrades it. link state is orthogonal.

### the "aha" moment

> "oh, upgrade just finds all the rhachet packages in my package.json and updates them. i don't need to have linked roles first."

it's the same mental model as `npm update` — it updates dependencies you have installed, not dependencies you've used.

---

## user experience

### usecase 1: fresh project setup

```sh
# 1. install packages
npm install rhachet rhachet-roles-ehmpathy rhachet-brains-anthropic

# 2. upgrade all to latest (before first link)
npx rhachet upgrade
# → upgrades rhachet@latest
# → upgrades rhachet-roles-ehmpathy@latest
# → upgrades rhachet-brains-anthropic@latest

# 3. now init with latest versions
npx rhachet init --roles ehmpathy/mechanic
```

### usecase 2: add a new roles package

```sh
# 1. install new package
npm install rhachet-roles-bhuild

# 2. upgrade immediately catches it
npx rhachet upgrade
# → sees rhachet-roles-bhuild in package.json
# → upgrades to @latest (even though no roles linked yet)

# 3. then link specific roles
npx rhachet init --roles bhuild/behaver
```

### usecase 3: ci/cd pipeline

```yaml
# .github/workflows/upgrade.yml
- run: npx rhachet upgrade
  # upgrades all rhachet-* packages from package.json
  # no need to know which roles are linked
  # deterministic: package.json is source of truth
```

### contract

```ts
// current
expandRoleSpecs({ specs: ['*'] })
// → calls discoverLinkedRoles()
// → returns only linked roles from .agent/

// proposed
expandRoleSpecs({ specs: ['*'] })
// → calls discoverRolePackages()
// → returns all rhachet-roles-* from package.json
// → symmetric with resolveBrainsToPackages() pattern
```

---

## mental model

### how users describe it

> "upgrade finds all rhachet packages in my package.json and updates them to latest"

### analogy

it's like `npm outdated` + `npm update`:
- it looks at what's **installed** (package.json)
- not at what's **configured** (symlinks in .agent/)

### terms

| user term | our term |
|-----------|----------|
| "role packages" | `rhachet-roles-*` dependencies in package.json |
| "brain packages" | `rhachet-brains-*` dependencies in package.json |
| "linked roles" | symlinks in `.agent/repo=*/role=*/` |
| "upgrade" | `npm install <pkg>@latest` for all rhachet-* packages |

---

## evaluation

### how well it solves the goal

| goal | before | after |
|------|--------|-------|
| upgrade roles before link | ✗ must link first | ✓ package.json driven |
| symmetric with brains | ✗ different discovery | ✓ same pattern |
| ci/cd predictability | ✗ depends on .agent/ state | ✓ package.json is stable |

### pros

1. **symmetry** — roles and brains use the same discovery pattern
2. **predictability** — package.json is the source of truth, not filesystem state
3. **simplicity** — one mental model: "upgrade what's installed"
4. **ci/cd friendly** — no dependency on `.agent/` state

### cons

1. **subtle behavior change** — `*` now means "all installed" not "all linked"
   - mitigation: this is the expected behavior; aligns with brains

### edgecases

| edgecase | behavior |
|----------|----------|
| package in package.json but not installed | `npm install` will fetch it |
| package with `file:.` version | skip (prior behavior preserved) |
| package in devDependencies | include (same as dependencies) |
| multiple roles from one package | deduplicate to one package upgrade |

### pit of success

- users can't accidentally miss an upgrade of a roles package they installed
- the command does what users expect: upgrade my rhachet stuff
- explicit `--roles ehmpathy/mechanic` still works for granular control

---

## awkward areas uncovered

### role package slug = full package name

brains use a suffix slug: `BrainSupplierSlug = 'anthropic'` (extracted from `rhachet-brains-anthropic`).

for roles, we use the **full package name** as the slug: `rhachet-roles-ehmpathy`.

```ts
// brain pattern: suffix slug
type BrainSupplierSlug = 'anthropic' | 'openai' | ...
toBrainSupplierSlug('rhachet-brains-anthropic') // → 'anthropic'

// role pattern: full package name
type RolePackageSlug = 'rhachet-roles-ehmpathy' | 'rhachet-roles-bhuild' | ...
// no extraction needed — use package name directly
```

this is intentional asymmetry — role packages are referenced by their full npm name.

### discoverRolePackages already exists

`src/domain.operations/init/discoverRolePackages.ts` already does exactly what we need:

```ts
export const discoverRolePackages = async (context: ContextCli): Promise<string[]> => {
  // ... reads package.json
  return Object.keys(allDeps).filter((name) =>
    name.startsWith('rhachet-roles-'),
  );
};
```

the fix is to wire this into `expandRoleSpecs` instead of `discoverLinkedRoles`.
