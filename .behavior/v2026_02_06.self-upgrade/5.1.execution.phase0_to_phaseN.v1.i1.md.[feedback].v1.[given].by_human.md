emit your response to the feedback into
- .behavior/v2026_02_06.self-upgrade/5.1.execution.phase0_to_phaseN.v1.i1.md.[feedback].v1.[taken].by_robot.md

1. emit your response checklist
2. exec your response plan
3. emit your response checkoffs into the checklist

---

first, bootup your mechanics briefs again

npx rhachet roles boot --repo ehmpathy --role mechanic

---
---
---


# blocker.1

                                                                                                          ║
││  given('--roles ehmpathy/mechanic flag (explicit repo/role)', () => {                                                     ║
││  given('--roles rhachet-roles-ehmpathy flag (full package name)', () => {                                                 ║
││    when('execUpgrade is called', () => {                                                                                  ║
││      then('parses repo/role format correctly', async () => {                                                              ║
││        await execUpgrade({ roleSpecs: ['ehmpathy/mechanic'] }, context);                                                  ║
││      then('passes full package name to resolver', async () => {       

this is incoherent. 

we should support both --roles as ehmpathy/mechanic and ehmpathy/*

and by default, if not user prescribed, we fallback to all installed packages as ehmpathy/* ($rolePackage/*)

except we only INIT on fully specified roles

but we UPGRADE on all role pacakges



---

# blocker.2

                                                                                         ║
││  upgradedRoles: RoleLinkRef[];                                                                                            ║
││  upgradedRoles: string[];   

string[] => RoleSupplierSlug (shape `$repo/*` | `$repo/$role`

we'll probably want to bring back 

                                                                                                              ║
││const expandRoleSpecs = (                                                                                                  ║
││  input: { specs: string[] },                                                                                              ║
││  context: ContextCli,                                                                                                     ║
││): RoleLinkRef[] => {                                                                                                      ║
││  const roles: RoleLinkRef[] = [];                                                                                         ║
││¶                                                                                                                          █
││  for (const spec of input.specs) {                                                                                        ║
││    // wildcard: discover all linked roles                                                                                 ║
││    if (spec === '*') {                                                                                                    ║
││      const linkedRoles = discoverLinkedRoles({}, context);                                                                ║
││      roles.push(...linkedRoles);                                                                                          ║
││      continue;                                                                                                            ║
││    }                                                                                                                      ║
││¶                                                                                                                          ║
││    // explicit role: parse repo/role format                                                                               ║
││    const parts = spec.split('/');                                                                                         ║
││    const repo = parts[0] ?? spec;                                                                                         ║
││    const role = parts[1] ?? spec;                                                                                         ║
││    roles.push({ repo, role });                                                                                            ║
││  }                                                                                                                        ║
││¶                                                                                                                          ║
││  // deduplicate by repo+role                                                                                              ║
││  const seen = new Set<string>();                                                                                          ║
││  return roles.filter((r) => {                                                                                             ║
││    const key = `${r.repo}/${r.role}`;                                                                                     ║
││    if (seen.has(key)) return false;       


in the form of expandRoleSupplierSlugs

(separate file, own test coverage)

---

# blocker.3

i dont see clear guarantees that 
- we'll upgrade every RoleSupplierPackage that matches the input --roles RoleSupplierSlug 

where RoleSupplierSlug = $repo/* | $repo/$slug 

PLUS

- we'll only reinit the roles that are Linked!

cover that with integration and acceptance tests

this is the most important part of the contract
