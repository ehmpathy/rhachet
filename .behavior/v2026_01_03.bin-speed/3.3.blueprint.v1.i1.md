# blueprint v1: bin-speed

implementation plan to achieve <100ms CLI overhead via dispatcher pattern.

---

## summary

use bun-compiled dispatcher pattern with command-specific binaries:

```
bin/
  run                    # symlink → run.bun
  run.bun                # symlink → run.bun.dispatcher.bc
  run.jit                # JIT fallback (current bin/run renamed)
  run.bun.dispatcher.bc  # thin dispatcher (1 module, ~20ms)
  run.bun.rhachet-run.bc # run command only (151 modules, ~50ms)
  run.bun.rhachet-roles.bc # roles subcommands (681 modules, ~30ms)
  run.bun.rhachet-all.bc # all other commands (855 modules)
```

measured performance: **~80ms** for `run --skill` (under 100ms target ✅)

---

## phase 0: file structure setup

### 0.1 rename current bin/run to bin/run.jit

```bash
git mv bin/run bin/run.jit
```

this preserves JIT execution path for compatibility.

### 0.2 create bin/run symlink chain

```bash
# bin/run → bin/run.bun → bin/run.bun.dispatcher.bc
ln -sf run.bun bin/run
ln -sf run.bun.dispatcher.bc bin/run.bun
```

### 0.3 update .gitignore

add to `.gitignore`:
```
# bun compiled binaries (built artifacts)
*.bc
```

---

## phase 1: entrypoint files

### 1.1 invoke.bun.entry.dispatch.ts (already created)

location: `src/contract/cli/invoke.bun.entry.dispatch.ts`

routes commands to binaries:
- `run` → `run.bun.rhachet-run.bc`
- `roles` → `run.bun.rhachet-roles.bc`
- `*` → `run.bun.rhachet-all.bc`

### 1.2 invoke.bun.entry.run.ts (already created)

location: `src/contract/cli/invoke.bun.entry.run.ts`

minimal entrypoint for `run` command only:
- imports: commander, helpful-errors, skill discovery, skill execution
- does NOT load: registries, brains, hooks
- module count: 151

### 1.3 invoke.bun.entry.roles.ts (already created)

location: `src/contract/cli/invoke.bun.entry.roles.ts`

entrypoint for `roles` subcommands:
- imports: commander, registries loader, roles subcommands
- does NOT load: brains, hooks
- module count: 681

### 1.4 invoke.bun.entry.all.ts (already created)

location: `src/contract/cli/invoke.bun.entry.all.ts`

full CLI entrypoint for all other commands:
- imports: all modules
- module count: 855

---

## phase 2: build system

### 2.1 add build:bun script to package.json

```json
{
  "scripts": {
    "build:bun": "npm run build:bun:dispatcher && npm run build:bun:run && npm run build:bun:roles && npm run build:bun:all",
    "build:bun:dispatcher": "bun build ./src/contract/cli/invoke.bun.entry.dispatch.ts --compile --bytecode --outfile ./bin/run.bun.dispatcher.bc",
    "build:bun:run": "bun build ./src/contract/cli/invoke.bun.entry.run.ts --compile --bytecode --outfile ./bin/run.bun.rhachet-run.bc",
    "build:bun:roles": "bun build ./src/contract/cli/invoke.bun.entry.roles.ts --compile --bytecode --outfile ./bin/run.bun.rhachet-roles.bc",
    "build:bun:all": "bun build ./src/contract/cli/invoke.bun.entry.all.ts --compile --bytecode --outfile ./bin/run.bun.rhachet-all.bc"
  }
}
```

### 2.2 update build script

```json
{
  "scripts": {
    "build": "npm run build:clean && npm run build:compile && npm run build:bun && npm run build:complete --if-present"
  }
}
```

### 2.3 update package.json files array

```json
{
  "files": [
    "/bin",
    "/dist"
  ]
}
```

the `/bin` already includes all files. *.bc files will be built before publish.

---

## phase 3: dispatcher path resolution

### 3.1 update dispatcher to use run.bun.* file names

update `invoke.dispatch.entry.ts`:

```ts
const commandMap: Record<string, string> = {
  run: join(binDir, 'run.bun.rhachet-run.bc'),
  roles: join(binDir, 'run.bun.rhachet-roles.bc'),
};

const binary = commandMap[command ?? ''] ?? join(binDir, 'run.bun.rhachet-all.bc');
```

### 3.2 binary path resolution

dispatcher uses `process.execPath` to find its directory, then locates adjacent binaries:

```ts
const binDir = dirname(process.execPath);
```

this is cross-platform (linux, macos, windows).

---

## phase 4: acceptance tests

### 4.1 test setup

tests use `genTestTempRepo` pattern for fully isolated test instances:
1. creates temp repo in `os.tmpdir()`
2. runs `rhachet roles link` to symlink skills/inits into `.agent/`
3. measures CLI overhead only, not node_modules traversal

each test gets a fresh, isolated workspace per the accept.blackbox brief.

### 4.2 test targets

test both collocated (local) and published package sources:

| command | collocated (repo=.this) | published (rhachet-roles-ehmpathy) |
|---------|-------------------------|-----------------------------------|
| `run --skill` | perf.test | cpsafe |
| `roles boot` | role=any | repo=ehmpathy role=mechanic |
| `roles init` | - | claude.hooks/pretooluse.forbid-gerunds |

### 4.3 run --skill performance test

location: `src/accept.blackbox/cli/run.performance.acceptance.test.ts`

tests:
- `bin/run run --skill perf.test` (collocated)
- `bin/run run --skill cpsafe` (published)

each must average <100ms across 30 runs.

### 4.4 roles boot performance test

location: `src/accept.blackbox/cli/roles.boot.performance.acceptance.test.ts`

tests:
- `bin/run roles boot --role any --if-present` (collocated)
- `bin/run roles boot --repo ehmpathy --role mechanic` (published)

each must average <250ms across 30 runs.

### 4.5 roles init performance test

location: `src/accept.blackbox/cli/roles.init.performance.acceptance.test.ts`

tests:
- `bin/run roles init --repo ehmpathy --role mechanic --command claude.hooks/pretooluse.forbid-gerunds` (published)

must average <250ms across 30 runs.

---

## phase 5: backward compatibility

### 5.1 ensure bin/run.jit works

the renamed JIT entrypoint must still work for users who prefer/need it.

### 5.2 ensure all commands work through dispatcher

test that ask, act, list, readme, choose, init all route correctly to rhachet-all.

---

## implementation order

| step | task | files |
|------|------|-------|
| 1 | rename bin/run → bin/run.jit | bin/run.jit |
| 2 | create bin/run symlink → run.bun | bin/run |
| 3 | create bin/run.bun symlink → run.bun.dispatcher.bc | bin/run.bun |
| 4 | update .gitignore for *.bc | .gitignore |
| 5 | update dispatcher path resolution | invoke.bun.entry.dispatch.ts |
| 6 | add build:bun scripts to package.json | package.json |
| 7 | update build script to include build:bun | package.json |
| 8 | build all binaries | bin/*.bc |
| 9 | create performance acceptance tests | accept.blackbox/cli/*.ts |
| 10 | run tests and verify <100ms | - |

---

## measured performance (from prototype)

| binary | modules | startup |
|--------|---------|---------|
| dispatcher | 1 | ~20ms |
| rhachet-run | 151 | ~20ms |
| rhachet-roles | 681 | ~30ms |
| rhachet-all | 855 | ~80ms |

| command | total time | target |
|---------|------------|--------|
| `run --skill` | **~80ms** | 100ms ✅ |
| `roles boot` | **~144ms** | 200ms ✅ |
| other commands | ~170ms | no target |

note: roles boot requires registry load, target relaxed to 200ms. still provides 18x speedup over node (~2700ms).

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| *.bc files large (~57MB each) | accept for now; bun may support shared runtime later |
| cold start variance | test measures 30-run average, not individual runs |

---

## success criteria

- [ ] `bin/run run --skill` averages <100ms (30 runs)
- [ ] `bin/run roles boot` averages <250ms (30 runs)
- [ ] `bin/run roles init` averages <250ms (30 runs)
- [ ] all commands (ask, act, list, etc.) work correctly
- [ ] bin/run.jit fallback works
- [ ] acceptance tests pass in CI
