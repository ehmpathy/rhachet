# blueprint: simplify dispatcher via `run --init`

## problem

`roles init` has two modes with different module requirements:

| mode | command | needs module? | why |
|------|---------|---------------|-----|
| run-all | `roles init --role X` | **yes** | reads `Role.inits.exec` from registry |
| command | `roles init --command X` | no | runs script from `.agent/` directly |

the current dispatcher routes `roles init` to bun, but run-all mode fails without registry access.

## solution

move `--command` mode from `roles init` to `run --init`:

| before | after |
|--------|-------|
| `roles init --command X` | `run --init X` |
| `roles init --role X` | `roles init --role X` (unchanged) |

this makes the dispatcher pattern clean:
- **`run` command** = always reads from `.agent/` = always bun
- **`roles` command** = may need modules = routes by subcommand

## dispatcher after change

```bash
case "$1" in
  run)
    # run --skill AND run --init both read from .agent/
    exec "$SCRIPT_DIR/run.bun.rhachet-run.bc" "$@"
    ;;
  roles)
    case "$2" in
      boot|cost)
        # reads from .agent/ symlinks
        exec "$SCRIPT_DIR/run.bun.rhachet-roles.bc" "$@"
        ;;
      link|init|*)
        # needs module access
        exec "$SCRIPT_DIR/run.jit" "$@"
        ;;
    esac
    ;;
  *)
    exec "$SCRIPT_DIR/run.jit" "$@"
    ;;
esac
```

## changes required

### 1. update `invokeRun.ts`

add `--init` option alongside `--skill`:

```typescript
.option('-s, --skill <slug>', 'the skill to execute')
.option('-i, --init <slug>', 'the init script to execute')
```

add init execution path in action handler:

```typescript
// handle --init mode: run init script from .agent/
if (opts.init) {
  const init = findUniqueInitExecutable({
    slugRepo: opts.repo,
    slugRole: opts.role,
    slugInit: opts.init,
  });

  console.log(`ðŸ”§ run init repo=${init.slugRepo}/role=${init.slugRole}/init=${init.slug}`);

  const rawArgs = getRawArgsAfterRun();
  executeInit({ init, args: rawArgs });
  return;
}
```

### 2. update `invokeRolesInit.ts`

remove `--command` option and its handler. keep only run-all mode that uses registry.

### 3. update `bin/run.bun` dispatcher

route `roles init` to JIT (needs registry for run-all mode):

```bash
roles)
  case "$2" in
    boot|cost)
      exec "$SCRIPT_DIR/run.bun.rhachet-roles.bc" "$@"
      ;;
    link|init|*)
      exec "$SCRIPT_DIR/run.jit" "$@"
      ;;
  esac
  ;;
```

### 4. update briefs

update `.agent/repo=.this/role=any/briefs/bin.dispatcher.pattern.md`:
- remove `roles init` from bun path
- add `run --init` to bun path

### 5. update acceptance tests

create/update acceptance tests for full bun path coverage:

**bun path tests (fast, consistent):**
- `roles.boot.collocated.acceptance.test.ts` - collocated role via `--repo .this`
- `roles.boot.published.acceptance.test.ts` - published role after `roles link`
- `run.skill.collocated.acceptance.test.ts` - collocated skill via `--repo .this`
- `run.skill.published.acceptance.test.ts` - published skill after `roles link`
- `run.init.collocated.acceptance.test.ts` - collocated init via `--repo .this`
- `run.init.published.acceptance.test.ts` - published init after `roles link`

**JIT path tests (flexible, module access):**
- `roles.init.published.acceptance.test.ts` - run-all mode via `Role.inits.exec`
- `roles.link.published.acceptance.test.ts` - links published npm package

rename old tests:
- `roles.init.performance.*.ts` â†’ `run.init.*.ts`
- change command from `roles init --command` to `run --init`

## acceptance tests

### test: `roles boot` with collocated role (bun path)

```typescript
// file: accept.blackbox/cli/roles.boot.collocated.acceptance.test.ts

describe('roles boot (collocated)', () => {
  given('[case1] repo with collocated perf-role', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-perf-collocated' }),
    );

    when('[t0] roles boot --repo .this --role perf-role', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['roles', 'boot', '--repo', '.this', '--role', 'perf-role'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('outputs role context with briefs', () => {
        expect(result.stdout).toContain('perf.brief.md');
      });

      then('completes within 250ms threshold', () => {
        expect(result.duration).toBeLessThan(250);
      });
    });
  });
});
```

### test: `roles boot` with published role (bun path after link)

```typescript
// file: accept.blackbox/cli/roles.boot.published.acceptance.test.ts

describe('roles boot (published)', () => {
  given('[case1] repo with published role after link', () => {
    const repo = useBeforeAll(async () => {
      const r = genTestTempRepo({ fixture: 'with-perf-test' });
      // link the role first (JIT path)
      invokeRhachetCliBinary({
        args: ['roles', 'link', '--repo', 'perf-test', '--role', 'perf-role'],
        cwd: r.path,
      });
      return r;
    });

    when('[t0] roles boot --repo perf-test --role perf-role', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['roles', 'boot', '--repo', 'perf-test', '--role', 'perf-role'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('outputs role context from linked symlinks', () => {
        expect(result.stdout).toContain('perf.brief.md');
      });

      then('completes within 250ms threshold', () => {
        expect(result.duration).toBeLessThan(250);
      });
    });
  });
});
```

### test: `run --skill` with collocated role (bun path)

```typescript
// file: accept.blackbox/cli/run.skill.collocated.acceptance.test.ts

describe('run --skill (collocated)', () => {
  given('[case1] repo with collocated perf-role', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-perf-collocated' }),
    );

    when('[t0] run --skill perf.test --repo .this --role perf-role', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['run', '--skill', 'perf.test', '--repo', '.this', '--role', 'perf-role'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('outputs skill execution', () => {
        expect(result.stdout).toContain('run solid skill');
      });

      then('completes within 150ms threshold', () => {
        expect(result.duration).toBeLessThan(150);
      });
    });
  });
});
```

### test: `run --skill` with published role (bun path after link)

```typescript
// file: accept.blackbox/cli/run.skill.published.acceptance.test.ts

describe('run --skill (published)', () => {
  given('[case1] repo with published role after link', () => {
    const repo = useBeforeAll(async () => {
      const r = genTestTempRepo({ fixture: 'with-perf-test' });
      // link the role first (JIT path)
      invokeRhachetCliBinary({
        args: ['roles', 'link', '--repo', 'perf-test', '--role', 'perf-role'],
        cwd: r.path,
      });
      return r;
    });

    when('[t0] run --skill perf.test --repo perf-test --role perf-role', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['run', '--skill', 'perf.test', '--repo', 'perf-test', '--role', 'perf-role'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('completes within 150ms threshold', () => {
        expect(result.duration).toBeLessThan(150);
      });
    });
  });
});
```

### test: `run --init` with collocated role

```typescript
// file: accept.blackbox/cli/run.init.performance.collocated.acceptance.test.ts

describe('run --init performance (collocated)', () => {
  given('[case1] repo with collocated perf-role', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-perf-collocated' }),
    );

    when('[t0] run --init perf.init --repo .this --role perf-role', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['run', '--init', 'perf.init', '--repo', '.this', '--role', 'perf-role'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('outputs init execution', () => {
        expect(result.stdout).toContain('run init');
      });

      then('completes within 150ms threshold', () => {
        expect(result.duration).toBeLessThan(150);
      });
    });
  });
});
```

### test: `run --init` with published role

```typescript
// file: accept.blackbox/cli/run.init.performance.published.acceptance.test.ts

describe('run --init performance (published)', () => {
  given('[case1] repo with published rhachet-roles-ehmpathy', () => {
    const repo = useBeforeAll(async () => {
      const r = genTestTempRepo({ fixture: 'with-perf-test' });
      // link the role first
      invokeRhachetCliBinary({
        args: ['roles', 'link', '--repo', 'perf-test', '--role', 'perf-role'],
        cwd: r.path,
      });
      return r;
    });

    when('[t0] run --init perf.init --repo perf-test --role perf-role', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['run', '--init', 'perf.init', '--repo', 'perf-test', '--role', 'perf-role'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('completes within 150ms threshold', () => {
        expect(result.duration).toBeLessThan(150);
      });
    });
  });
});
```

### test: `roles init` still works via JIT

```typescript
// file: accept.blackbox/cli/roles.init.published.acceptance.test.ts

describe('roles init (run-all mode)', () => {
  given('[case1] repo with published role that has inits.exec', () => {
    const repo = useBeforeAll(async () => {
      const r = genTestTempRepo({ fixture: 'with-published-roles' });
      // link first
      invokeRhachetCliBinary({
        args: ['roles', 'link', '--repo', 'ehmpathy', '--role', 'mechanic'],
        cwd: r.path,
      });
      return r;
    });

    when('[t0] roles init --repo ehmpathy --role mechanic', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['roles', 'init', '--repo', 'ehmpathy', '--role', 'mechanic'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('executes Role.inits.exec commands', () => {
        expect(result.stdout).toContain('init complete');
      });
    });
  });
});
```

## migration

users with `roles init --command X` in scripts must update to `run --init X`.

deprecation path:
1. v1.20: add `run --init`, keep `roles init --command` with deprecation notice
2. v1.21: remove `roles init --command`

## summary

| command | binary | reads from |
|---------|--------|------------|
| `run --skill X` | bun | `.agent/` |
| `run --init X` | bun | `.agent/` |
| `roles boot` | bun | `.agent/` |
| `roles cost` | bun | `.agent/` |
| `roles link` | jit | npm packages |
| `roles init` | jit | npm packages (Role.inits.exec) |
| `act`, `ask` | jit | npm packages |

the `run` command becomes the fast path for all `.agent/`-based execution.
