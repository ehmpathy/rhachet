# research: production code patterns for keyrack unlock

> current patterns in the codebase relevant to the os.daemon vision

---

## summary

| pattern | classification | relation to vision |
|---------|----------------|-------------------|
| KeyrackHostVaultAdapter | [REUSE] | interface directly supports os.daemon |
| KeyrackGrantMechanismAdapter | [REUSE] | validation and translation remain unchanged |
| KeyrackKeyGrant | [EXTEND] | add `.grade` to enable degradation prevention |
| KeyrackGrantMechanism | [EXTEND] | prefix with duration (PERMANENT_VIA_*, EPHEMERAL_VIA_*) |
| KeyrackHostVault | [EXTEND] | add 'os.daemon' vault type |
| grant flow (getKeyrackKeyGrant) | [EXTEND] | replace os.direct cache with os.daemon |
| vaultAdapterOsSecure | [REUSE] | age encryption pattern for encrypted keys |
| vaultAdapterOsDirect | [REPLACE] | os.daemon replaces os.direct as session cache |
| sessionPassphrase pattern | [REUSE] | module-level state pattern for daemon session |
| TTL/expiry pattern | [REUSE] | expiresAt pattern for daemon TTL enforcement |

---

## pattern.1: KeyrackHostVaultAdapter interface

### [REUSE]

**what**: adapter interface for vault-specific operations with unlock/isUnlocked/get/set/del methods.

**citation [1]** (KeyrackHostVaultAdapter.ts:5-50):
```ts
export interface KeyrackHostVaultAdapter {
  unlock: (input: {}) => Promise<void>;
  isUnlocked: () => Promise<boolean>;
  get: (input: { slug: string; exid?: string | null }) => Promise<string | null>;
  set: (input: { slug: string; value: string; exid?: string | null; expiresAt?: string | null }) => Promise<void>;
  del: (input: { slug: string; exid?: string | null }) => Promise<void>;
}
```

**relation to vision**: the interface already supports exactly what os.daemon needs:
- `unlock` → connect to daemon, authenticate
- `isUnlocked` → check if daemon is reachable and session valid
- `get` → retrieve key from daemon by slug
- `set` → store key in daemon with optional TTL (via expiresAt)
- `del` → purge key from daemon

**verdict**: reuse directly; add `vaultAdapterOsDaemon` that implements this interface.

---

## pattern.2: KeyrackGrantMechanismAdapter interface

### [REUSE]

**what**: adapter interface for credential validation and translation.

**citation [2]** (KeyrackGrantMechanismAdapter.ts:7-28):
```ts
export interface KeyrackGrantMechanismAdapter {
  validate: (input: { source?: string; cached?: string }) => {
    valid: boolean;
    reason?: string;
  };
  translate: (input: { value: string }) => Promise<{ value: string; expiresAt?: IsoTimeStamp }>;
}
```

**relation to vision**: mechanism adapters are orthogonal to vault storage. the same validation/translation logic applies regardless of whether the source vault is os.secure, 1password, or the cache vault is os.daemon instead of os.direct.

**verdict**: reuse directly; no changes needed.

---

## pattern.3: KeyrackKeyGrant domain object

### [EXTEND]

**what**: the granted credential payload with slug, value, and source.

**citation [3]** (KeyrackKeyGrant.ts:13-34):
```ts
export interface KeyrackKeyGrant {
  slug: string;
  value: string;
  source: {
    vault: KeyrackHostVault;
    mech: KeyrackGrantMechanism;
  };
}
```

**relation to vision**: the vision requires grade metadata to prevent degradation:

```ts
// vision wants:
interface KeyrackKey {
  secret: KeyrackKeySecret;  // rename from 'value'
  grade: KeyrackKeyGrade;
}

interface KeyrackKeyGrade {
  protection: 'encrypted' | 'plaintext';
  duration: 'permanent' | 'ephemeral' | 'transient';
}
```

**extend with**:
1. rename `value` → `secret` for clarity
2. add `grade: KeyrackKeyGrade` to track security posture
3. enforce grade comparisons to prevent degradation

**verdict**: extend to add grade metadata; rename value → secret for semantic clarity.

---

## pattern.4: KeyrackGrantMechanism type

### [EXTEND]

**what**: enum of credential translation mechanisms.

**citation [4]** (KeyrackGrantMechanism.ts:10):
```ts
export type KeyrackGrantMechanism = 'REPLICA' | 'GITHUB_APP' | 'AWS_SSO';
```

**relation to vision**: the vision requires explicit duration in mechanism names:

```ts
// vision wants:
type KeyrackGrantMechanism =
  | 'PERMANENT_VIA_REPLICA'
  | 'EPHEMERAL_VIA_GITHUB_APP'
  | 'EPHEMERAL_VIA_AWS_SSO'
  | 'EPHEMERAL_VIA_GITHUB_OIDC'
  | 'EPHEMERAL_VIA_INSTANCE_ROLE';
```

**extend with**:
1. prefix with duration: PERMANENT_VIA_* or EPHEMERAL_VIA_*
2. add new mechanisms: GITHUB_OIDC, INSTANCE_ROLE
3. mechanism name implies grade.duration

**verdict**: extend with duration prefix; migration required for host manifests.

---

## pattern.5: KeyrackHostVault type

### [EXTEND]

**what**: enum of storage vault types.

**citation [5]** (KeyrackHostVault.ts:13-17):
```ts
export type KeyrackHostVault =
  | 'os.envvar'
  | 'os.direct'
  | 'os.secure'
  | '1password';
```

**relation to vision**: add os.daemon as the session-time credential cache.

**extend with**:
```ts
export type KeyrackHostVault =
  | 'os.envvar'
  | 'os.direct'
  | 'os.secure'
  | 'os.daemon'  // new: in-memory daemon for session cache
  | '1password';
```

**verdict**: extend by add of 'os.daemon' to the union.

---

## pattern.6: grant flow (getKeyrackKeyGrant)

### [EXTEND]

**what**: multi-stage credential resolution with fallthrough and cache.

**citation [6]** (getKeyrackKeyGrant.ts:42-72):
```ts
// check os.envvar first — passthrough for ci and local env
const envValue = await context.vaultAdapters['os.envvar'].get({ slug });
if (envValue !== null) {
  // value found in env — skip host manifest, skip vault unlock
  // apply mechanism validation (this is the firewall)
  const validation = mechAdapter.validate({ source: envValue });
  ...
}

// check os.direct second — ephemeral cache for translated values
const directValue = await context.vaultAdapters['os.direct'].get({ slug });
if (directValue !== null) {
  // validate cached value against mechanism (defense in depth)
  const validation = mechAdapter.validate({ cached: directValue });
  ...
}
```

**citation [7]** (getKeyrackKeyGrant.ts:166-173):
```ts
// cache to os.direct if ephemeral (has expiresAt)
if (translated.expiresAt) {
  await context.vaultAdapters['os.direct'].set({
    slug,
    value: translated.value,
    expiresAt: translated.expiresAt,
  });
}
```

**relation to vision**: replace os.direct cache with os.daemon:
1. os.envvar check remains first (ci passthrough)
2. os.daemon check replaces os.direct check
3. unlock sends keys to os.daemon instead of os.direct
4. TTL enforced by daemon (not file expiry convention)

**extend with**:
- check os.daemon instead of os.direct for cache
- remove cache-to-os.direct in grant flow
- os.direct becomes only a source vault, not a cache vault

**verdict**: extend flow to use os.daemon as cache; os.direct becomes source-only.

---

## pattern.7: vaultAdapterOsSecure (age encryption)

### [REUSE]

**what**: encrypted file storage with passphrase protection.

**citation [8]** (vaultAdapterOsSecure.ts:51-60):
```ts
let sessionPassphrase: string | null = null;

const getActivePassphrase = (): string | null => {
  return sessionPassphrase ?? process.env.KEYRACK_PASSPHRASE ?? null;
};
```

**relation to vision**: the passphrase pattern demonstrates session-level state held in module scope. os.daemon will use similar pattern for daemon connection state.

**verdict**: reuse pattern for os.daemon adapter state management.

---

## pattern.8: vaultAdapterOsDirect (plaintext cache)

### [REPLACE]

**what**: plaintext json storage with TTL-based cache invalidation.

**citation [9]** (vaultAdapterOsDirect.ts:71-74):
```ts
const isExpired = (entry: DirectStoreEntry): boolean => {
  if (!entry.expiresAt) return false;
  return new Date(entry.expiresAt) < new Date();
};
```

**citation [10]** (vaultAdapterOsDirect.ts:105-117):
```ts
get: async (input) => {
  const store = readDirectStore();
  const entry = store[input.slug];

  // not found
  if (!entry) return null;

  // check expiry
  if (isExpired(entry)) {
    delete store[input.slug];
    writeDirectStore(store);
    return null;
  }

  return entry.value;
},
```

**relation to vision**: os.direct as cache is the security problem:

> "casey's permanent, encrypted credential is now plaintext on disk. the grade degraded." (vision)

os.daemon replaces os.direct as the session cache:
- in-memory only (never on disk)
- daemon enforces TTL (not file expiry convention)
- daemon dies on logout (instant cleanup)

**verdict**: replace os.direct cache with os.daemon; os.direct becomes source-only vault.

---

## pattern.9: TTL/expiry pattern

### [REUSE]

**what**: expiresAt timestamp for credential expiration.

**citation [11]** (KeyrackHostVaultAdapter.ts:34):
```ts
set: (input: {
  slug: string;
  value: string;
  exid?: string | null;
  expiresAt?: string | null;  // ISO8601 — enables ephemeral cache
}) => Promise<void>;
```

**citation [12]** (KeyrackGrantMechanismAdapter.ts:25-27):
```ts
translate: (input: { value: string }) => Promise<{
  value: string;
  expiresAt?: IsoTimeStamp;  // if returned, can be cached
}>;
```

**relation to vision**: the expiresAt pattern is exactly what os.daemon needs for TTL enforcement. daemon stores each key with its expiration, refuses to return expired keys.

**verdict**: reuse expiresAt for daemon TTL; daemon enforces real TTL (not just convention).

---

## pattern.10: context assembly (genKeyrackGrantContext)

### [EXTEND]

**what**: assembles runtime context with all vault and mechanism adapters.

**citation [13]** (genKeyrackGrantContext.ts:50-56):
```ts
const vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter> = {
  'os.envvar': vaultAdapterOsEnvvar,
  'os.direct': vaultAdapterOsDirect,
  'os.secure': vaultAdapterOsSecure,
  '1password': vaultAdapter1Password,
};
```

**relation to vision**: add os.daemon to the adapter registry:

```ts
const vaultAdapters: Record<KeyrackHostVault, KeyrackHostVaultAdapter> = {
  'os.envvar': vaultAdapterOsEnvvar,
  'os.direct': vaultAdapterOsDirect,
  'os.secure': vaultAdapterOsSecure,
  'os.daemon': vaultAdapterOsDaemon,  // new
  '1password': vaultAdapter1Password,
};
```

**verdict**: extend to include os.daemon adapter.

---

## pattern.11: unlockKeyrackVault operation

### [EXTEND]

**what**: unlocks vaults for credential access.

**citation [14]** (unlockKeyrackVault.ts:41-57):
```ts
for (const vault of vaultsToUnlock) {
  const adapter = context.vaultAdapters[vault];
  if (!adapter) {
    throw new UnexpectedCodePathError('vault adapter not found', { vault });
  }

  // check if already unlocked
  const isUnlocked = await adapter.isUnlocked();
  if (!isUnlocked) {
    // unlock vault (pass passphrase if provided)
    await adapter.unlock({ passphrase: input.passphrase });
  }

  unlocked.push(vault);
}
```

**relation to vision**: the new `rhx keyrack unlock` command will:
1. findsert daemon (start if absent)
2. unlock source vaults (pattern reused)
3. retrieve keys from source vaults
4. send keys to daemon with TTL (new step)

**extend with**:
- `--duration` flag for TTL specification
- daemon findsert logic before source unlock
- key transmission to daemon after source unlock

**verdict**: extend to orchestrate full unlock → daemon cache flow.

---

## gaps identified

### gap.1: vaultAdapterOsDaemon

**needed**: new adapter that implements KeyrackHostVaultAdapter for unix domain socket communication with daemon.

**interfaces required**:
- unix socket connection management
- SO_PEERCRED authentication
- /proc/$PID/sessionid verification
- protocol: UNLOCK, GET, STATUS, RELOCK commands

### gap.2: daemon process management

**needed**: daemon lifecycle operations.

**operations required**:
- findsert (start if absent)
- health check (is daemon reachable)
- TTL timer management
- cleanup on relock/logout

### gap.3: grade metadata and degradation prevention

**needed**: KeyrackKeyGrade type and enforcement logic.

**operations required**:
- grade comparison function
- degradation check on vault operations
- error messages with fix suggestions

### gap.4: CLI unlock command separation

**needed**: separate `rhx keyrack unlock` from `rhx keyrack get --unlock`.

**current**: unlock is a flag on get
**vision**: unlock is a separate command that populates daemon

---

## citations

- [1] src/domain.objects/keyrack/KeyrackHostVaultAdapter.ts:5-50
- [2] src/domain.objects/keyrack/KeyrackGrantMechanismAdapter.ts:7-28
- [3] src/domain.objects/keyrack/KeyrackKeyGrant.ts:13-34
- [4] src/domain.objects/keyrack/KeyrackGrantMechanism.ts:10
- [5] src/domain.objects/keyrack/KeyrackHostVault.ts:13-17
- [6] src/domain.operations/keyrack/getKeyrackKeyGrant.ts:42-72
- [7] src/domain.operations/keyrack/getKeyrackKeyGrant.ts:166-173
- [8] src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsSecure.ts:51-60
- [9] src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsDirect.ts:71-74
- [10] src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsDirect.ts:105-117
- [11] src/domain.objects/keyrack/KeyrackHostVaultAdapter.ts:34
- [12] src/domain.objects/keyrack/KeyrackGrantMechanismAdapter.ts:25-27
- [13] src/domain.operations/keyrack/genKeyrackGrantContext.ts:50-56
- [14] src/domain.operations/keyrack/unlockKeyrackVault.ts:41-57
