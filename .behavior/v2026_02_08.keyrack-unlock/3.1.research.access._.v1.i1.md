# research: remote access interfaces for keyrack unlock

> interfaces required to fulfill the os.daemon vision

---

## summary

the keyrack unlock feature requires access to these remote interfaces:

| interface | purpose | status |
|-----------|---------|--------|
| unix domain socket (SO_PEERCRED) | daemon ipc with caller auth | **new** |
| /proc/self/sessionid | login session verification | **new** |
| XDG_RUNTIME_DIR | socket location (tmpfs) | **new** |
| age encryption | os.secure vault decrypt | existing |
| 1password cli | 1password vault access | existing |
| aws sso cli | aws sso credential fetch | existing |
| filesystem | os.direct vault read/write | existing |

---

## new interfaces required

### unix domain socket with SO_PEERCRED

**what**: unix domain sockets provide local ipc. SO_PEERCRED socket option retrieves peer credentials (uid, pid, gid) for auth.

**why**: daemon must verify caller is same user. SO_PEERCRED provides kernel-verified credentials without trust of user-provided data.

**contract**:

```ts
// node.js net module for unix sockets
import { createServer, Socket } from 'net';

// server binds to socket path
const server = createServer((socket: Socket) => {
  // SO_PEERCRED not directly exposed in node.js
  // must use native addon or child_process to `lsof` / `ss`
});
server.listen('/run/user/1000/keyrack.sock');

// client connects
const client = new Socket();
client.connect('/run/user/1000/keyrack.sock');
```

**citations**:

[1] unix(7) man page:
> "SCM_CREDENTIALS: Send or receive UNIX credentials. This can be used for authentication."

[2] socket(7) man page on SO_PEERCRED:
> "Return the credentials of the peer process connected to this socket. The returned credentials are those that were in effect at the time of the call to connect(2) or socketpair(2)."

[3] node.js does not expose SO_PEERCRED directly. options:
- use `lsof -p $PID` or `ss -xp` to map socket fd to peer pid
- use native addon like `unix-socket-credentials`
- use child_process to run `getpeereid` equivalent

**best practice**: for node.js daemon, use a native addon or shell out to verify peer credentials. the `unix-socket-credentials` npm package provides this.

---

### /proc/self/sessionid (linux audit session id)

**what**: linux audit subsystem assigns a session id at login. readable via `/proc/$PID/sessionid`. immutable for process lifetime.

**why**: daemon must verify caller is in same login session. sessionid is kernel-managed and unforgeable by user processes.

**contract**:

```ts
import { readFileSync } from 'fs';

// read own sessionid
const mySessionId = readFileSync('/proc/self/sessionid', 'utf8').trim();

// read peer's sessionid (after SO_PEERCRED gives us their pid)
const peerPid = 12345; // from SO_PEERCRED
const peerSessionId = readFileSync(`/proc/${peerPid}/sessionid`, 'utf8').trim();

// verify same session
if (mySessionId !== peerSessionId) {
  throw new Error('caller is in different login session');
}
```

**citations**:

[4] linux kernel documentation on audit sessionid:
> "The audit session ID is inherited across fork and exec, and is set when a user logs in. It can be read from /proc/[pid]/sessionid."

[5] proc(5) man page:
> "/proc/[pid]/sessionid: This read-only file contains the audit session ID of the process. It is set when the user logs in and is inherited by all processes started by the login session."

[6] kernel source (include/linux/sched.h):
> "sessionid is set once at login by the audit subsystem and never changes for the lifetime of the process tree."

**best practice**: compare `/proc/self/sessionid` with `/proc/$PEER_PID/sessionid`. if they differ, deny access. this is the kernel-enforced login session boundary.

**note**: sessionid is set by pam_loginuid.so module in the login process. if a system doesn't use this PAM module, sessionid may be unset (-1 or 4294967295).

---

### XDG_RUNTIME_DIR (/run/user/$UID/)

**what**: per-user tmpfs directory for runtime files (sockets, fifos, small state). cleared on logout. proper permissions (0700).

**why**: socket must be in a location that:
- dies on logout (tmpfs, not persisted)
- is per-user (other users can't access)
- has proper permissions by default

**contract**:

```ts
const runtimeDir = process.env.XDG_RUNTIME_DIR || `/run/user/${process.getuid()}`;
const socketPath = `${runtimeDir}/keyrack.${sessionId}.sock`;
```

**citations**:

[7] XDG Base Directory Specification:
> "XDG_RUNTIME_DIR: a single base directory relative to which user-specific non-essential runtime files and other file objects should be stored. The directory MUST be owned by the user, and the user MUST be the only one who has read and write access to it. Its Unix access mode MUST be 0700."

[8] systemd documentation on XDG_RUNTIME_DIR:
> "This directory is flushed at each reboot and when the user logs out. It is created by pam_systemd when the user logs in."

[9] freedesktop.org specification:
> "If XDG_RUNTIME_DIR is not set, applications should fall back to a replacement directory with similar properties. A common fallback is /tmp/runtime-$UID with mode 0700."

**best practice**: use `$XDG_RUNTIME_DIR` if set, else fall back to `/run/user/$UID/`. if neither exists, create `/tmp/runtime-$UID/` with mode 0700.

---

## existing interfaces (already implemented)

### age encryption (os.secure vault)

**what**: age is a modern file encryption tool. used for os.secure vault.

**contract**: see `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsSecure.ts`

```ts
import { Encrypter, Decrypter } from 'age-encryption';

// encrypt
const encrypter = new Encrypter();
encrypter.setPassphrase(passphrase);
const ciphertext = await encrypter.encrypt(plaintext);

// decrypt
const decrypter = new Decrypter();
decrypter.addPassphrase(passphrase);
const plaintext = await decrypter.decrypt(ciphertext);
```

**citations**:

[10] age-encryption npm package:
> "A TypeScript implementation of the age file encryption format."

[11] age specification (age-encryption.org):
> "age is a simple, modern and secure file encryption tool, format, and library."

---

### 1password cli (1password vault)

**what**: 1password cli (`op`) provides access to 1password items.

**contract**: see `src/domain.operations/keyrack/adapters/vaults/vaultAdapter1Password.ts`

```sh
# read a secret
op read "op://vault/item/field"

# sign in (if needed)
eval $(op signin)
```

**citations**:

[12] 1password cli documentation:
> "Use `op read` to get the value of a secret reference. Format: op://vault-name/item-name/field-name"

[13] 1password developer docs:
> "The 1Password CLI uses your system keychain to store session tokens. Sessions are valid for 30 minutes of inactivity."

---

### aws sso cli (aws sso mechanism)

**what**: aws cli provides sso login and credential export.

**contract**: see `src/domain.operations/keyrack/adapters/mechanisms/mechAdapterAwsSso.ts`

```sh
# login via browser
aws sso login --profile $PROFILE

# export credentials (env-no-export format)
aws configure export-credentials --profile $PROFILE --format env-no-export
```

**citations**:

[14] aws cli sso documentation:
> "aws sso login: Opens a browser window to complete the SSO login process."

[15] aws cli credential export:
> "aws configure export-credentials: Exports credentials in various formats. The env-no-export format outputs credentials as shell variable assignments without the export prefix."

---

### filesystem (os.direct vault)

**what**: os.direct stores keys as plaintext json on disk.

**contract**: standard node.js fs module

```ts
import { readFileSync, writeFileSync } from 'fs';

const path = `${homeDir}/.rhachet/keyrack.direct.json`;
const data = JSON.parse(readFileSync(path, 'utf8'));
```

**citations**:

[16] no external citation needed; standard filesystem access via node.js fs module.

---

## best practices summary

| interface | best practice |
|-----------|---------------|
| unix socket auth | use SO_PEERCRED via native addon; verify uid matches daemon uid |
| session verification | compare /proc/self/sessionid with /proc/$PEER_PID/sessionid |
| socket location | use XDG_RUNTIME_DIR; fall back to /run/user/$UID/ or /tmp/runtime-$UID/ |
| age encryption | use passphrase-based encryption; hold passphrase in memory only |
| 1password | use `op read` with secret references; let op handle session |
| aws sso | use `aws sso login` + `aws configure export-credentials` |
| filesystem | standard fs module; ensure proper permissions (0600 for secrets) |

---

## implementation notes

### node.js SO_PEERCRED limitation

node.js net module does not expose SO_PEERCRED. options:

1. **native addon**: use `unix-socket-credentials` or similar
2. **shell out**: use `lsof -p $PID` to find peer pid, then read /proc
3. **custom c++ addon**: call getsockopt(SO_PEERCRED) directly

recommendation: start with shell out (lsof/ss), migrate to native addon if performance matters.

### sessionid edge cases

some systems may not have audit sessionid set:

- containers without pam_loginuid
- minimal systems without audit subsystem
- ssh sessions without UsePAM

recommendation: check if sessionid is valid (not -1 or 4294967295). if invalid, fall back to uid-only verification with warning.

### socket path length

unix socket paths have a limit (typically 104-108 bytes). ensure socket path fits:

```
/run/user/1000/keyrack.1234567890.sock
```

recommendation: use short session id or hash if needed.
