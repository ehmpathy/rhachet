# blackbox criteria: coverage matrix

> distilled from 2.1.criteria.blackbox.md

---

## matrix.1: command × keyrack state

covers: usecase.1, usecase.5, usecase.12, edge.2

| ind: command | ind: keyrack state | ind: keyrack.yml | dep: outcome | dep: auth required |
|--------------|-------------------|------------------|--------------|-------------------|
| `unlock` | locked | present | keys sent to daemon | yes |
| `unlock` | locked | absent | error: no keyrack.yml | no |
| `unlock` | unlocked (valid TTL) | present | TTL extended/updated | no |
| `get --for repo` | locked | present | error: locked, lists keys needed | no |
| `get --for repo` | locked | absent | error: no keyrack.yml | no |
| `get --for repo` | unlocked (valid TTL) | present | keys exported to env | no |
| `get --for repo` | unlocked (expired TTL) | present | error: expired, re-unlock needed | no |

---

## matrix.2: cross-access scenarios

covers: usecase.2, usecase.3, usecase.6

| ind: login session | ind: worksite | ind: key declared in keyrack.yml | dep: get outcome |
|-------------------|---------------|----------------------------------|------------------|
| same | same | yes | granted |
| same | different | yes (both declare key) | granted (reuse) |
| same | different | no (target doesn't declare) | not granted |
| different | same | yes | denied (session mismatch) |
| different | different | yes | denied (session mismatch) |

note: "different login session" = attacker scenario; kernel-enforced boundary

---

## matrix.3: grade degradation

covers: usecase.7

| ind: source grade.protection | ind: target grade.protection | dep: allowed |
|-----------------------------|------------------------------|--------------|
| encrypted | encrypted | yes |
| encrypted | plaintext | **no** (blocked) |
| plaintext | encrypted | yes (upgrade) |
| plaintext | plaintext | yes |

| ind: source grade.duration | ind: target grade.duration | dep: allowed |
|---------------------------|---------------------------|--------------|
| transient | transient | yes |
| transient | ephemeral | yes (upgrade) |
| transient | permanent | yes (upgrade) |
| ephemeral | transient | **no** (blocked) |
| ephemeral | ephemeral | yes |
| ephemeral | permanent | yes (upgrade) |
| permanent | transient | **no** (blocked) |
| permanent | ephemeral | **no** (blocked) |
| permanent | permanent | yes |

---

## matrix.4: spec requirement × host provision

covers: usecase.7 (spec enforcement)

| ind: spec requirement | ind: host grade.protection | ind: host grade.duration | dep: get outcome |
|----------------------|---------------------------|-------------------------|------------------|
| `ephemeral` | any | transient | granted (exceeds) |
| `ephemeral` | any | ephemeral | granted (meets) |
| `ephemeral` | any | permanent | **blocked** (insufficient) |
| `encrypted` | encrypted | any | granted (meets) |
| `encrypted` | plaintext | any | **blocked** (insufficient) |
| `encrypted,ephemeral` | encrypted | transient | granted (exceeds) |
| `encrypted,ephemeral` | encrypted | ephemeral | granted (meets) |
| `encrypted,ephemeral` | encrypted | permanent | **blocked** (insufficient duration) |
| `encrypted,ephemeral` | plaintext | ephemeral | **blocked** (insufficient protection) |

---

## matrix.5: TTL behavior

covers: usecase.4, usecase.8, edge.3

| ind: current TTL state | ind: unlock --duration | dep: new TTL | dep: note to user |
|-----------------------|------------------------|--------------|-------------------|
| none (locked) | omitted | 9h (default) | — |
| none (locked) | 30m | 30m | — |
| none (locked) | 4h | 4h | — |
| 6h left | 1h | 1h | "shortened from 6h" |
| 1h left | 9h | 9h | "extended" |
| expired | any | new duration | — |

---

## matrix.6: relock scope

covers: usecase.10

| ind: relock command | ind: keys in daemon | dep: keys purged | dep: keys kept |
|---------------------|--------------------|--------------------|----------------|
| `relock` (all) | A, B, C | A, B, C | none |
| `relock --key A` | A, B, C | A | B, C |
| `relock --key D` | A, B, C | none | A, B, C |

---

## matrix.7: session termination

covers: usecase.11

| ind: termination type | dep: daemon state | dep: disk artifacts |
|----------------------|-------------------|---------------------|
| logout | dies | none |
| crash | dies | none |
| reboot | dies | none |
| explicit `relock` | alive (empty) | none |

---

## matrix.8: partial unlock

covers: edge.1

| ind: vault A auth | ind: vault B auth | ind: vault C auth | dep: A keys | dep: B keys | dep: C keys | dep: can proceed |
|------------------|------------------|------------------|-------------|-------------|-------------|------------------|
| success | success | success | unlocked | unlocked | unlocked | yes |
| success | success | fail | unlocked | unlocked | error shown | yes |
| success | fail | fail | unlocked | error shown | error shown | yes |
| fail | fail | fail | error shown | error shown | error shown | no |

---

## gaps identified

none — all meaningful combinations are covered by the blackbox criteria.

---

## decomposition notes

**matrix.3 (grade degradation)** has 2 sub-dimensions (protection × duration). these are independent and can be validated separately, which is reflected in the split tables.

**matrix.4 (spec × host)** approaches complexity limit but stays tractable because:
- spec requirements are a small enum (`ephemeral`, `encrypted`, `encrypted,ephemeral`)
- host grades follow clear hierarchy

no decomposition needed — all matrices are 2-3 dimensions with bounded value ranges.
