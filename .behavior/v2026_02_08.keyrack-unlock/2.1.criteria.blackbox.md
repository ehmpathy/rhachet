# blackbox criteria: keyrack unlock

> experience boundaries for keyrack key grades & os.daemon unlock

---

# usecase.1 = unlock then spawn robot

```
given('a worksite with keyrack.yml that declares keys')
  when('human runs `rhx keyrack unlock`')
    then('interactive auth prompts appear for each source vault')
      sothat('human authenticates once per vault type')
    then('output shows each key unlocked with TTL')
      sothat('human knows what keys are available and for how long')
    then('no env var is exported')
      sothat('session key leaks via /proc are eliminated')

  when('human spawns robot after unlock')
    when('robot tool runs `source rhx keyrack get --for repo`')
      then('keys declared in keyrack.yml are exported to env')
        sothat('tool has access to required credentials')
      then('output shows keys granted via os.daemon')
        sothat('tool knows where keys came from')
```

---

# usecase.2 = cross-terminal access

```
given('human unlocked keyrack in terminal A')
  when('human opens terminal B in same login session')
    when('human runs `source rhx keyrack get --for repo` in terminal B')
      then('keys are granted without re-auth')
        sothat('human avoids redundant sso prompts and password entries')
      then('no session key copy is required')
        sothat('clipboard-based leaks are eliminated')
```

---

# usecase.3 = cross-worksite key reuse

```
given('human unlocked keyrack in repo-api worksite')
  given('repo-api keyrack.yml declares AWS_SSO_PREP')
  given('repo-infra keyrack.yml also declares AWS_SSO_PREP')

  when('human navigates to repo-infra worksite')
    when('human runs `source rhx keyrack get --for repo`')
      then('AWS_SSO_PREP is granted without re-auth')
        sothat('human avoids redundant sso browser auth')
      then('output shows key already unlocked with time left')
        sothat('human knows they reuse a prior unlock')
```

---

# usecase.4 = custom duration

```
given('a worksite with keyrack.yml that declares keys')
  when('human runs `rhx keyrack unlock --duration 30m`')
    then('keys are unlocked with 30 minute TTL')
      sothat('blast radius is limited to the task duration')
    then('output shows expiration time per key')
      sothat('human knows when keys will expire')

  when('human runs `rhx keyrack unlock --duration 4h`')
    then('keys are unlocked with 4 hour TTL')
      sothat('human can work on extended tasks without re-auth')
```

---

# usecase.5 = mid-session unlock

```
given('robot was started before keyrack was unlocked')
  when('robot tool runs `source rhx keyrack get --for repo`')
    then('output shows keyrack is locked')
    then('output lists which keys are required but not in daemon')
    then('output provides fix instruction: run `rhx keyrack unlock` from any terminal')
      sothat('human knows exactly what to do')

  when('human runs `rhx keyrack unlock` from separate terminal')
    when('robot tool retries `source rhx keyrack get --for repo`')
      then('keys are now granted')
        sothat('robot does not need to be restarted')
```

---

# usecase.6 = attacker isolation (different login session)

```
given('human has unlocked keyrack in their login session')
  given('attacker spawns a new login session as same user')
    when('attacker attempts to connect to daemon socket')
      then('daemon denies the connection')
        sothat('attacker cannot access unlocked keys')

  given('attacker reads filesystem')
    when('attacker looks for vault files')
      then('no unlocked keys are found on disk')
        sothat('filesystem read attack is mitigated')
```

---

# usecase.7 = grade degradation blocked

```
given('a key stored in os.secure vault (grade: encrypted, permanent)')
  when('human attempts to set key into os.direct vault (grade: plaintext)')
    then('operation is blocked with error')
    then('error shows current grade vs target grade')
    then('error suggests alternative vault that preserves grade')
      sothat('human cannot accidentally degrade key security')

given('a key declared with spec requirement `encrypted`')
  when('host attempts to supply key from os.direct vault (plaintext)')
    then('get operation fails')
    then('error shows grade requirement not met')
      sothat('spec requirements are enforced')
```

---

# usecase.8 = TTL expiration

```
given('keys were unlocked with --duration 1h')
  given('1 hour has passed')
    when('tool runs `source rhx keyrack get --for repo`')
      then('expired keys are not returned')
      then('output shows keys have expired')
      then('output instructs human to re-unlock')
        sothat('stale credentials are not used')

given('keys were unlocked with --duration 8h')
  given('human runs `rhx keyrack unlock --duration 1h` for same keys')
    then('TTL is updated to new duration from now')
      sothat('human can extend or shorten session without full re-auth')
```

---

# usecase.9 = status check

```
given('some keys are unlocked in daemon')
  when('human runs `rhx keyrack status`')
    then('output lists each unlocked key with time left')
    then('output groups keys by source vault')
      sothat('human knows what is unlocked and when it expires')

given('no keys are unlocked')
  when('human runs `rhx keyrack status`')
    then('output shows daemon is empty')
      sothat('human knows they need to unlock')
```

---

# usecase.10 = explicit relock

```
given('keys are unlocked in daemon')
  when('human runs `rhx keyrack relock`')
    then('all keys are purged from daemon memory')
    then('subsequent get operations fail until re-unlock')
      sothat('human can explicitly end their session')

given('keys are unlocked in daemon')
  when('human runs `rhx keyrack relock --key AWS_SSO_PREP`')
    then('only AWS_SSO_PREP is purged')
    then('other keys stay accessible')
      sothat('human can selectively revoke access')
```

---

# usecase.11 = logout cleanup

```
given('keys are unlocked in daemon')
  when('human logs out of their session')
    then('daemon process dies')
    then('all unlocked keys are purged from memory')
      sothat('session-time credentials do not persist beyond session')

given('keys are unlocked in daemon')
  when('machine crashes or reboots')
    then('daemon memory is lost')
    then('no credential artifacts stay on disk')
      sothat('crash does not leave credential residue')
```

---

# usecase.12 = default TTL

```
given('a worksite with keyrack.yml that declares keys')
  when('human runs `rhx keyrack unlock` without --duration flag')
    then('keys are unlocked with 9 hour TTL')
      sothat('sensible default covers a typical workday')
```

---

# edge.1 = partial unlock

```
given('keyrack.yml declares 3 keys from different vaults')
  given('human has credentials for vault A and vault B but not vault C')
    when('human runs `rhx keyrack unlock`')
      then('keys from vault A and B are unlocked')
      then('vault C auth fails with clear error')
      then('human can still proceed with partial keys')
        sothat('one vault failure does not block all work')
```

---

# edge.2 = no keyrack.yml

```
given('worksite has no keyrack.yml')
  when('human runs `rhx keyrack unlock`')
    then('error indicates no keyrack.yml found')
      sothat('human knows they are in wrong directory or need to create spec')

  when('human runs `source rhx keyrack get --for repo`')
    then('error indicates no keyrack.yml found')
```

---

# edge.3 = daemon already has key with longer TTL

```
given('AWS_SSO_PREP was unlocked with --duration 9h (6h left)')
  when('human runs `rhx keyrack unlock --duration 1h`')
    then('TTL is updated to 1h from now')
      sothat('human can shorten session if desired')
    then('output notes that TTL was shortened from 6h left')
      sothat('human is aware of the change')
```
