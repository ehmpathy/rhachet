wish =

we want to better formalize the relationship between

- ephemeral - short lived duration, stored fornow
vs
- permanent - long lived duration, stored forever

and maybe even vs 
- transient - instant duration, never stored, only used once (e.g., to unlock)

---

also, the relationship between source | cached 

---

and better formalize thesecurity posture of --unlock

specifically

for ephemeral keys, --unlock into os.direct is less of a concern, since the blast radius is short lived

however

for permanent keys, --unlock into os.direct is a big no-no - since its a permanent blast radius

---

i.e., if someone wants to vault their key into os.direct from the start, then they are aware that its plaintext and vulnerable

however, if someone wants to vault their key into os.secure, 1password, etc - then under no circumstance can we degrade the security level of their key and expose it into plaintext via cache in os.secure


ideally, even for ephemeral keys that'd be true

---

so, 

1. we want to articulate the security grade treatment policy 
	- never degrade the secret of a key from hidden to visible

	- also, we should update all refs of `key.value` to `key.secret` and probably track its expected grade: { access: 'encrypted' | 'plaintext', duration: 'permanent' | 'ephemeral' }, to all users on the system


---

i.e., for each grant we should know

---

then, we should also upgrade the grant mechanisms to prescribe this too, i.e., what they produce

- PERMANENT_VIA_REPLICA (instaed of REPLICA)
- EPHEMERAL_VIA_AWS_SSO (instead of AWS_SSO)
- EPHEMERAL_VIA_GITHUB_APP (instead of GITHUB_APP)

that way its clearer in specs

---

also, we shuld remove the default grant mech from the keyrack. folks should beware and be forced to acknowledge if they have permanent keys. 

---


it'd be great to upgrade to have an explicit `KeyrackKey` common shape of `{ secret: KeyrackKeySecret (alias to string), grade: { protection: 'encrypted' | 'plaintext', duration: 'permanent' | 'ephemeral' | 'transient' } }`


expiresAt is metadata associated with the KeyrackKeyGrant , which itself should have a .key 

but this way, instead of a .value , we have a KeyrackKey , which self describes the key grade - which we can use to prevent degradation of the security of a key explicitly

-----


then, given we are forbidden from the degradation of a key (i.e., drop in key.grade.protection or key.grade.duration) 

then we are forbidden from the ability to cache an encrypted key in os.direct

e.g., if the key came from os.secure and has a grant.mech of PERMANENT_VIA_REPLICA, we're absolutely not allowed to cache it in os.direct

---

instead, we must explore alternative approaches for how we can secure these keys after --unlock, 

such that

1. robots who attempt to `rhx keyrack get --for repo` can still access the keys after the human has `--unlocked` them for the worksite + session 
2. robots or humans who attempt to `rhx keyrack get --for repo` outside the worksite or session can not access those unlocked keys (not via byhand os.direct lookup, not via rhx keyrack get --for repo commands, not via inspection of repo assets, etc)

the main question i have here is

- where could we vault the granted keys (PERMANENT_VIA_REPLICA, EPHEMERAL_VIA_AWS_SSO, etc) isomorphically in a way that they'll all be guaranteed secure and inaccessbile to anyone other than who the --unlock was intended for?

i.e.,
- how do we know who the --unlock was intended for?
- how do we give who the --unlock was intended for access to the --unlocked keys, subsequently, securely?

given
- the intended target will be some brain (robot, human) that runs on this machine and wants to execute commands that will need those keys, without having to refill the --unlock each time (e.g., doesn't want the AWS_SSO hoops to interfere, wants to use that unlocked session token instead)


i.e.,

1. human opens repo; spawns robot and asks them to 'write getWeatherApi and run integration tests'
2. robot tries to run integration tests, needs to run `rhx keyrack get --for repo` -> is blocked, keyrack says "ask a human to --unlock"
3. robot tells human to --unlock 
4. human runs `rhx keyrack get --for repo --unlock`, follows the aws sso prompts to unlock and grant aws key, follows the age-encryption prompts to unlock and grant age keys, the key grants are securely persisted (in what?) (scoped to who?)
5. robot runs `rhx keyrack get --for repo`, keyrack understands the unlocked session the caller is for, validates the caller has access to it, and re-grants those keys from the cache vault via PERMANENT_VIA_REPLICA

ultimately, it seems like the core mechanism that we need to distill is 
- how to identify, securely and secretly, 
  - which shared session the human and robot refer to
  - who is unlock that cache vault session, automatically (they shouldn't even have to know how to)

---

i.e., we dont want anyone to be able to just sniff all the open cache vault sessions and access all the keys in there 
- the keys must be encrypted at rest in that vault, so that keys that start w/ key.grade.protection=encrypted can stay key.grade.protection=encrypted
- the keys must be inaccessible to anyone they were not intended for, so that only the callers from the users session could access those keys

---

is there an identity that the robot can provide implicitly when they call their initial get, that the user can --unlock for? (i.e, a secret only they have in their memory?); i.e., it identifies the session and can be used as an encryption key?

is the only choice to have those encrypted at rest but have an ephemeral daemon that has the keys to the open sessions? (and we can distinguish sessions based on keyrack.yml?)

i.e., anyone active with access to that daemon can get the keys, but as soon as the machine is closed, it expires (and the daemon itself can set sessions to expire; i.e., ttl the durations ahead of time)

is there any way to get that daemon to only be live for the current caller user and their subprocesses? (e.g., if an attacker spawns a user on the machine, they wont have access)

better yet, what's the security posture of how to distinguish different login sessions? (hopefully one user can only be logged in exclusively into 1 session at a time on the same machine, so if its per user, and an attacker logs in as the user, new session -> no daemon)

---

also, is there anything better we can do?

i.e., each keyrack.yml is intended to be accessed per worksite (i.e., per repo:worktree)

so we should totally ask to unlock whenever repo:worktree changes

not sure if theres a non-theater way to do that though

since an attacker could easily navigate into a git repo and specify they're part of that worksite

---

ideally sessions would be identified via  transient secrets that are only available via terminals though; e.g.,
- the only way for a claude-code brain's sessions to inherit the keyrack session would be for the human to first 
  - npx rhachet keyrack get --for repo --unlock
and then, from the same terminal
  - claude-code 

or, from the same terminal, spawn a new terminal, which would inherit that env var that identifies the session

or, better yet 

npx rhachet keyrack get --for repo --unlock ; it itself could spawn a new escalated subterminal (then, the terminal could even be spawned with some env vars that tell the terminal GUI what severity level the keyrack was unlocked for. e.g., prod or prep, and it could colorcode itself to represent that (e.g., ptyxis))

---

we should evaluate each of these options

this only needs to apply to dev machines (local human, cloud ec2) where software developer brains will need keys to develop and test 

cicd already has it's solution via the idempotent get firewall

so this is the last step


-----


update;

lets make it clear that export is only if user wants to `source` the unlock; otherwise, for devexp, it'll open a new        
  terminal - if it detects it wasn't sourced; it'll invoke the `terminal` command and expect that to be set                   
                                                                                                                              
  actually, lets make it even more explicit;                                                                                  
                                                                                                                              
  if command detects `sourced`, --unlock is sourced, then the exported args will work fine, all good                          
                                                                                                                              
  if command detects not sourced, then --unlock $into variable is required ; the $into declares what the unlock will spawn    
  the env var into; we'll failfast if it isn't explicitly declared, that way the user can specify what terminal they want to  
  --unlock into                                                                                                               
                                                                                                                              
  when we fail fast, we should guide them to either                                                                           
                                                                                                                              
  source it                                                                                                                   
                                                                                                                              
  or                                                                                                                          
                                                                                                                              
  specify the into  


----

update: 

Â so, the only way that the sessino key would be useful si fi the robot was started without the session key already; e.g.,
  started without creds                                                                                                       
                                                                                                                            
  then, the robot could ask for a session key to --reuse $session ?

  ---  

  e.g.,                             

  human launched robot without creds                                                   
                                                                                                                              
  in separate terminal, --unlocks, then wants the robot to have acecss to that session? 


or better yet, --unlock $sessionKey -> leverage a previous session                                                      
                       
  and --unlock (empty) => trigger interactive unlock 

with the inherited flow vs imported flow distinguished

and lets specify that the reason we support session vaults at all is to minimize the frequency that source vault creds are
  required, since those are the most sensitive and their use should be most limited

----

update:

also, we should make it possible to --output session                                                                        
                                                      
  and --output exports
                                                                                                                              
   
  and default to --output session                                                                                             
                                                                                                                
  ---
     
  and when `--output session` or default is run
                                               
  it should do the full unlock
                              
  then tell the user, if they want themselves or their delegates to access those creds in their terminal, they need to
  source the creds via the session key                                                                                
                                      
  and if they wanted to source them from the start, in the future, they can --unlock without a session key
                                                                                                          
  e.g.,
       
  KEYRACK_SESSION_KEY=x
                       
  `source ... --unlock $KEYRACK_SESSION_KEY` (and show the session key in there, not the var)
                                                                                             
  `source ... --unlock` (for the future) 
                                        
      
  ---
                                                                                             
  that way, it just works out of the box, with zero friction - and keeps them safe by default
                                                                                                                          
  they've unlocked the session for subsequent use ; they can decide whether to escalate their current terminal session via
  source against the vault session OR whether to keep their current terminal safe and delegate that session key to the    
  robot`    


also, when sourced, --output exports is implied; no need to specify


----



based on convo:

Â so, if we want you to import a session key, how would you be able to reuse it - so that you only have to import it once?  
  (e.g., user forgot to start claude with the keys, they unlock, tell you the session key. how can you set it for future      
  access detemrinistically)                                                                                                   
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¯Â so the only way for claude code to be able to use a session key is to degrade it to ephemeral? and not only that, but
  accessible to all prcesses for the user?                                                                                    
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¯Â so..... either                               
                                                                                                                              
  claude is launched with a transient session key upfront

  or                                                                                                                        
                                                                                                    
  claude requires an ephemeral, user level session key?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


so if we lean hard into transient is required                
                                                                                                                              
  then,                                                                                                                       
                                                                                                                              
  --unlock $session still works for normal terminals (i.e., they can open a new terminal and reuse the session transitively;  
  the session key will be forwarded, then they can reopen claude in that window without re --unlock)                          
                                                                                                                              
  and,                                                                                                                        
                                                                                                                              
  we can have an                                                                                                              
                                                                                                                              
  `source rhachet keyrack unlock --for repo` command which _only_ exposes the KEYRACK_SESSION_KEY into the env                
                                                                                                                              
  so that                                                                                                                     
                                                                                                                              
  if we run                                                                                                                   
                                                                                                                              
  `source rhx unlock && claude`, then claude has the session key out of the box - but no access to the actual keys. they      
  still ahve to go to `get` each key or `get --for repo` to access them explicitly                                            
                                                                                                                              
  so that its possible to actually forbid via tooluse their capacity to run `rhx keyrack get`                                 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€



=================


â¯ what's teh advantage of --unlock? maybe we _should_ create friction and push humans to only ever unlock, but let their      
  tools do the gets, too; just like robots  


â— ğŸ¢ sharp
                                                                                                                              
  if we remove --unlock from get, the model becomes perfectly uniform:                                                        
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                                        
  â”‚  who  â”‚        unlock        â”‚        get        â”‚                                                                        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                                        
  â”‚ human â”‚ source rhx unlock    â”‚ their tools do it â”‚                                                                      
  â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                                      
  â”‚ robot â”‚ inherits session key â”‚ their tools do it â”‚                                                                
  â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  nobody runs get directly. humans and robots both access keys only through tools that internally invoke get.

  why this is better

  1. uniform access model -- no special human shortcut. same rules for everyone.
  2. humans don't need raw keys in their shell either -- when does a human actually need AWS_ACCESS_KEY_ID exported to their
  terminal? almost never. they run npm run test:integration or terraform plan -- tools that internally source the keys they
  need.
  3. less surface area -- get --unlock is one more codepath to maintain, test, and secure. removing it simplifies the
  contract.
  4. pit of success -- if a human wants raw keys in their shell, they have to be intentional about it (source rhx keyrack get
  --for repo). that friction is a feature, not a bug. it makes them pause and think "do i actually need these exported?"
  5. symmetry breeds trust -- when the human enforces the same constraints on themselves as on the robot, the security model
  is more credible. no "rules for thee but not for me."

  the only counterargument

  convenience for local dev iteration -- e.g., curl -H "Authorization: Bearer $API_KEY" ... directly in terminal. but even
  that could be wrapped in a tool.

  recommendation

  drop --unlock from get. the command surface becomes:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚               command               â”‚                          purpose                           â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ source rhx unlock                   â”‚ interactive auth, create session vault, export session key â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ source rhx unlock --reuse $key      â”‚ resume session, export session key                         â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ tools internally invoke keyrack get â”‚ access actual secrets                                      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  want me to update the docs?

â¯ for the case where they really do need it, humans can still run a `get` (if their admin allows it) just like the robot      
  (if their admin allows it)                                                                                                 
                                                                                                                              
  and yeah, exactly, no "rules for thee but not for me"                                                                       
                                                           

-----


read the full synthesis here

	new file:   .behavior/v2026_02_08.keyrack-unlock/.refs/session-key-transience.preview.md


===============


updates:


Â so, does the ENV and CMD vulerabilities mean that the SESSION_KEY is security theater? i.e., is there any way to make tat
  session key truely transient?                                                                                               
                                                                                                                           
  also, does that mean that any keys (even the permanent ones) that are ultimately exposed in env var are accessible to any
  processes under that user?         


Â so, given that there's no way to prevent against same-user processes, is there a point to try to scope SESSION_KEYs per    
  terminal session chain? or is it fundamentally really only possible to have a per user scoped session vault, and so the     
  SESSION_KEY is always a secret per USER ?   


also,                                                                                                                  
                                                                                                                          
  1. how to ensure that the session vault manages its own ttl? e.g., if someone gets the SESSION_KEY a few weeks later        
  after terminal sniff && a process exited early and forgot to remove it, how do we guarantee the vault wont still be         
  there?                                                                                                                      


====

so, 

- given that today, env-vars are leaked via proc/* per user 
  - an unavoidable contract from backwards compat

- then, all env vars are user-scoped (not session scoped) fundamentally
  - for any malicious actor

that's the security grade of their visibiilty; plaintext at envvar to all w/ same user 


---

still, per-session unlocks still provide security in that 
1. it adds isolation for bonintent usage (isolated unlocks, worksites cant accidentally use secrets unlocked for another)
2. it adds intention for malintent usage (malintent actors would have to explicitly search for the shared /proc/* session keys, just like they have access to the shared /proc/* granted keys)


so, makes it harder for bonintent users to do the wrong thing; by default, they're isolated

and, makes it easy to observe malintent users and how they can do the wrong thing; (and where the machine can be patched)

---

quesiton is, how long do those env-vars live? i.e., if each time they only live while the command that uses them uses them, then the rhachet keyrack get operation per tool keeps them short lived

so, it may be worth keyctl; especially for session key timeout




=============




â¯ so, could we replace the encrypted ephemeral session vault with an in memory daemon vault? (findserted per user, tracks 
   per worksite unlocks, manages ttl, dies on logout)                                                                     


in the daeamon approach, could eventually still support session scoped access

but for now, probably overkill

if an attacker has access to your user, you already have bigger issues, no? 

so again, its per user & cwd unlock
- brains (robots, humans) could change cwd to attack & access creds from a different workspace
- but that's a malintent usecase -> and only succeptible if they already are inside your user



------


yep, distilled here .behavior/v2026_02_08.keyrack-unlock/.refs/vault.os-daemon.md




and we'll eliminate the per-terminal-session concept due to this rationale

.behavior/v2026_02_08.keyrack-unlock/.refs/eval.login-session-vs-terminal-session.md

  per-terminal-session adds no real value because:                                                                            
   
  1. no kernel primitive exists â€” sessionid is per-login-session, PTY is forgeable, process groups are per-pipeline. there is 
  no unforgeable terminal-session boundary in the kernel.                                                                  
  2. every implementation option reintroduces eliminated problems â€” per-terminal daemons need env vars (back to /proc leak),
  PTY-based track is forgeable, env var tokens are literally the session key pattern os.daemon was designed to replace.  
  3. per-worksite isolation already covers the bonintent case â€” different repos get different keys via worksite hash. same  
  repo, different terminals = same worksite = no reason to isolate.                                                       
  4. the one real benefit (terminal compromise blast radius) can't be enforced â€” the attacker's process in terminal B has the
  same sessionid as terminal A, because both are in the same login session.

  os.daemon scope: per-login-session + per-worksite is the correct and strongest enforceable boundary.
                                                           


                                                           ---
----

â¯Â distinguish the enforced vs convened boundaries; per-login-session is enforced by the daemon & kernel; attackers can not
  forge this; secure against even malintent actors                                                                            
                                                                                                                  
  per worksite is a convened boundary; enforced only by folks who choose to go through rhachet; bonintent actors; malintent
  actors could easily call the daemon directly to access keys from different worksites, if they already have unrestricted
  access to the user's login session. (but if they do, the user has bigger problems)


---


Â now, lets discuss whether unlock should be at worksite grain or not. i.e., maybe its sufficient, given that its only        
  convened security, that if the keyrack.yml specifies this worksite has access to a key, if its already unlocked in daemon   
  by user w/ a given --duration, they can still reuse it (i.e., to limit how often a human needs to sso browser auth, or    
  1pass type their root pass) 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


---


