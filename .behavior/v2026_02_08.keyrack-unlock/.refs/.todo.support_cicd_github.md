# todo: support cicd github actions via `rhachet/keyrack` action

> what we'd need to change to support the unified keyrack action for github actions CI

---

## status: not started

---

## what we have today

- `mechAdapterGithubApp.ts` — fully implemented, exchanges JSON blob → `ghs_*` token via `@octokit/auth-app`
- `os.envvar` vault — passthrough that reads from `process.env` (handles built-in `GITHUB_TOKEN`)
- `keyrack.yml` spec — declares keys and grade requirements
- `keyrack get --for repo` — reads spec, grants keys from available vaults
- mechanism adapters parse self-described JSON blobs: `{ mech, appId, privateKey, installationId }`

---

## what we need to build

### 1. `rhachet/keyrack` github action (`action.yml`)

a github action that reads `keyrack.yml` and grants keys for CI jobs.

```yaml
# action.yml
name: rhachet/keyrack
description: grant keyrack keys for CI
inputs:
  secrets:
    description: 'key=value pairs of slug=secret_json, one per line'
    required: false
runs:
  using: 'node20'
  main: 'dist/action.js'
```

**scope**: new file. the action is a thin wrapper around the `keyrack get --for repo` logic, adapted for CI context.

### 2. action entrypoint (`action.ts` or `dist/action.js`)

the action entrypoint that:

1. reads `keyrack.yml` from the repo root
2. parses `secrets` input → `Map<slug, json_blob>`
3. for each key declared in spec:
   - if secret JSON provided → parse, read `mech` field, run mechanism adapter
   - if no secret provided → check `process.env` (os.envvar passthrough)
   - if absent from both → fail with clear error
4. validates grade: adapter output must meet spec grade requirement
5. exports each granted key via `core.exportVariable(slug, value)`

```
action.entrypoint
├─ read keyrack.yml → required keys + grade requirements
├─ parse secrets input → Map<slug, json_blob>
├─ for each required key:
│  ├─ has secret input? → parse JSON → read mech → run adapter → export
│  ├─ in process.env? → passthrough → export
│  └─ absent? → fail: "key $slug not provided and not in env"
├─ validate grades (spec requirement vs adapter output)
└─ done: all keys exported to env for subsequent steps
```

**scope**: new file. reuses mechanism adapters from keyrack core.

### 3. mechanism adapter registry for CI

the action needs to resolve `mech` field → adapter function. today, adapters are wired per vault in the host manifest flow. for CI, we need a direct lookup:

```ts
const mechAdapters: Record<string, MechAdapter> = {
  EPHEMERAL_VIA_GITHUB_APP: mechAdapterGithubApp,
  // future: EPHEMERAL_VIA_AWS_OIDC, etc
};
```

**scope**: minor refactor. extract adapter lookup from host-manifest-specific code into a shared registry that both dev and CI flows can use.

### 4. secret input parser

parse the `secrets` input format. each line is `SLUG=json_blob`:

```
GITHUB_TOKEN={"mech":"EPHEMERAL_VIA_GITHUB_APP","appId":"123","privateKey":"...","installationId":"456"}
```

**scope**: new parser. simple line-by-line split on first `=`, JSON parse the value.

### 5. grade validation in CI context

the action must validate that the adapter output meets the spec's grade requirement:

- spec says `ephemeral` → adapter must produce ephemeral or better
- spec says `encrypted` → adapter must produce encrypted or better
- spec says `encrypted,ephemeral` → both

this logic already exists for dev machine flow. needs to be reusable from the action.

**scope**: minor refactor. extract grade validation into shared utility.

---

## what we do NOT need to build

- **no host manifest support in CI** — the secret JSON blob self-describes its mechanism
- **no daemon in CI** — job-scoped, keys die with the job
- **no unlock in CI** — action inputs replace interactive auth
- **no new mechanism adapters** — reuse `mechAdapterGithubApp` as-is
- **no changes to `keyrack.yml` spec format** — same spec works in dev and CI

---

## changes by file

| file | change | scope |
|------|--------|-------|
| `action.yml` | new | github action definition |
| `action.ts` (or `dist/action.js`) | new | action entrypoint |
| mechanism adapter registry | refactor | extract from host-flow into shared module |
| grade validation | refactor | extract from host-flow into shared utility |
| `mechAdapterGithubApp.ts` | none | already works, reuse as-is |
| `keyrack.yml` parser | none | already works, reuse as-is |
| `os.envvar` vault | none | already works for passthrough |

---

## workflow example (end state)

```yaml
# .github/workflows/test.yml
name: test
on: [push]

permissions:
  contents: read

jobs:
  test:
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4

      - uses: rhachet/keyrack@v1
        with:
          secrets: |
            GITHUB_TOKEN=${{ secrets.RHACHET_GITHUB_APP_TOKEN }}
        # reads keyrack.yml → GITHUB_TOKEN: ephemeral
        # parses secret → { mech: EPHEMERAL_VIA_GITHUB_APP, ... }
        # runs mechAdapterGithubApp → ghs_* token
        # exports GITHUB_TOKEN to env

      - run: npm run test:integration
        # GITHUB_TOKEN is available in env
```

```yaml
# keyrack.yml (same file used on dev machines)
keys:
  GITHUB_TOKEN: ephemeral
```

---

## open questions

1. **action repository**: does `rhachet/keyrack` live in its own repo (standard for github actions) or as a subpath in the rhachet monorepo?
2. **multiple keys**: should the action support multiple secrets with different mechanisms in one step? (e.g., GITHUB_TOKEN via app + AWS creds via OIDC)
3. **OIDC integration**: should the action also handle OIDC token exchange for cloud credentials, or leave that to dedicated actions (aws-actions/configure-aws-credentials)?
4. **built-in token detection**: if no secret is provided for GITHUB_TOKEN but the built-in `GITHUB_TOKEN` is in env, should the action auto-detect and passthrough? (likely yes — os.envvar behavior)

---

## priority

low — dev machine unlock (os.daemon) is the primary focus of the current behavior. CI support can follow once the core grade + daemon model is solid. the mechanism adapters and spec format are shared, so CI support is additive.
