# todo: self-descriptive json blobs for grant mechanism keys

> every key that depends on a mechanism transform must store a self-descriptive json blob — the stored value declares its own mechanism via a `mech` field, so any consumer (dev machine, ci, daemon) can resolve the adapter without a host manifest lookup.

---

## status: not started

---

## what we have today

### mechanism adapter registry (host-manifest-coupled)

the mechanism adapter is resolved via the host manifest — `keyrack.host.yml` declares `vault` + `mech` per key. the stored value in the vault is opaque; only the host manifest knows which adapter to use.

```
today.flow
├─ keyrack.host.yml declares: { slug: GITHUB_APP_CREDS, vault: os.secure, mech: GITHUB_APP }
├─ vault stores: '{"appId":"123","privateKey":"...","installationId":"456"}'
│  └─ no mech field — value is NOT self-descriptive
├─ get flow: host manifest lookup → mech: GITHUB_APP → mechAdapterGithubApp → translate
└─ the value cannot be resolved without the host manifest
```

### current stored value shapes

| mechanism | source value shape | self-descriptive? |
|-----------|-------------------|-------------------|
| `REPLICA` | plain string (e.g., `sk-abc123`) | n/a — no transform needed |
| `GITHUB_APP` | `{"appId","privateKey","installationId"}` | no — lacks `mech` field |
| `AWS_SSO` | plain string (e.g., `ehmpathy.dev`) | no — just a profile name |

### the problem

1. **ci can't resolve mechanism without host manifest** — in ci, the secret json is provided directly via action inputs. without a `mech` field, the keyrack action can't know which adapter to use.

2. **daemon can't validate grants without host manifest** — when os.daemon caches a granted key, it stores the translated value. if the daemon needs to re-validate or re-translate (e.g., on ttl extend), it needs to know the mechanism.

3. **cross-worksite reuse requires mechanism awareness** — when a key unlocked in repo-api is reused in repo-infra, the daemon needs to know which mechanism produced it (for grade validation, ttl policy, etc).

4. **the host manifest is a lookup table that resolves to what the blob should already declare** — the host manifest maps slug → vault + mech. for keys that store json blobs, the mechanism should be embedded in the blob itself, so the lookup table is redundant for resolution.

---

## what we need to change

### 1. add `mech` field to all mechanism-transform json blobs

every key whose mechanism performs a transform (not passthrough) must store a json blob with a `mech` field that declares its mechanism.

#### github app credentials

```json
// before (no mech field)
{
  "appId": "123456",
  "privateKey": "-----BEGIN RSA PRIVATE KEY-----\n...",
  "installationId": "12345678"
}

// after (self-descriptive)
{
  "mech": "EPHEMERAL_VIA_GITHUB_APP",
  "appId": "123456",
  "privateKey": "-----BEGIN RSA PRIVATE KEY-----\n...",
  "installationId": "12345678"
}
```

**scope**: migration of stored values + adapter parse logic.

#### aws sso profile

today, aws sso stores a plain string (the profile name). to make it self-descriptive, it must become a json blob:

```json
// before (plain string)
"ehmpathy.dev"

// after (self-descriptive)
{
  "mech": "EPHEMERAL_VIA_AWS_SSO",
  "profile": "ehmpathy.dev"
}
```

**scope**: migration of stored values + adapter parse logic + vault write logic.

#### aws oidc (ci only, future)

```json
{
  "mech": "EPHEMERAL_VIA_AWS_OIDC",
  "roleArn": "arn:aws:iam::123456789012:role/deploy",
  "region": "us-east-1",
  "sessionDuration": 3600
}
```

**scope**: new adapter. already self-descriptive by design (from rhachet completion --setupdoc).

### 2. which mechanisms do NOT need self-descriptive blobs

| mechanism | needs blob? | why |
|-----------|------------|-----|
| `PERMANENT_VIA_REPLICA` | no | passthrough — no transform, value is used as-is |
| `EPHEMERAL_VIA_GITHUB_APP` | yes | transform: json creds → `ghs_*` token |
| `EPHEMERAL_VIA_AWS_SSO` | yes | transform: profile name → session credentials |
| `EPHEMERAL_VIA_AWS_OIDC` | yes | transform: role arn → temp aws credentials |
| `EPHEMERAL_VIA_INSTANCE_ROLE` | tbd | transform: imds → temp credentials (future) |

**the rule**: if a mechanism adapter's `.translate()` does work (not passthrough), the source value must be a self-descriptive json blob with `mech` field.

replica is the exception — it's passthrough, the value IS the credential, no resolution needed.

### 3. rename mechanism enum values

the mechanism names must encode their duration explicitly:

```ts
// before
type KeyrackGrantMechanism = 'REPLICA' | 'GITHUB_APP' | 'AWS_SSO';

// after
type KeyrackGrantMechanism =
  | 'PERMANENT_VIA_REPLICA'
  | 'EPHEMERAL_VIA_GITHUB_APP'
  | 'EPHEMERAL_VIA_AWS_SSO'
  | 'EPHEMERAL_VIA_AWS_OIDC'
  | 'EPHEMERAL_VIA_INSTANCE_ROLE';
```

**scope**: rename across all files. use `sedreplace` for bulk rename.

### 4. update mechanism adapter parse logic

each adapter that expects a json blob must:
1. parse the blob
2. validate that `mech` matches the expected mechanism
3. extract config fields from the blob

```ts
// mechAdapterGithubApp — updated parse
const parseGithubAppCredentials = (value: string) => {
  const parsed = JSON.parse(value);

  // validate mech field
  if (parsed.mech !== 'EPHEMERAL_VIA_GITHUB_APP')
    return { valid: false, reason: 'mech field must be EPHEMERAL_VIA_GITHUB_APP' };

  // validate config fields
  if (!parsed.appId && !parsed.app_id)
    return { valid: false, reason: 'json lacks appId field' };
  // ...
};
```

**scope**: update `mechAdapterGithubApp.ts`, `mechAdapterAwsSso.ts`. add `mechAdapterAwsOidc.ts` (new).

### 5. update host manifest to derive mech from blob

when the stored value is a self-descriptive blob, the host manifest's `mech` field becomes **derivable** from the blob. two options:

**option a: host manifest still declares mech (redundant but explicit)**
```yaml
keys:
  GITHUB_APP_CREDS:
    vault: os.secure
    mech: EPHEMERAL_VIA_GITHUB_APP  # explicit, matches blob.mech
```

**option b: host manifest omits mech for blob-based keys (inferred)**
```yaml
keys:
  GITHUB_APP_CREDS:
    vault: os.secure
    # mech: inferred from blob.mech at read time
```

**recommendation**: option a — keep explicit in host manifest for clarity. validate that host manifest mech matches blob mech at get time. fail fast on mismatch.

### 6. enable mechanism resolution without host manifest (ci path)

the self-descriptive blob enables ci to resolve mechanisms directly:

```
ci.flow (after)
├─ action receives secret input: '{"mech":"EPHEMERAL_VIA_GITHUB_APP","appId":"123",...}'
├─ parse json → read mech field → resolve adapter
├─ run adapter.translate() → ghs_* token
└─ export to env — no host manifest needed
```

**scope**: the `rhachet/keyrack` action (future) uses blob.mech to resolve the adapter. no host manifest in ci. the .todo.support_cicd_github.md already describes this flow — self-descriptive blobs are a prerequisite.

### 7. update daemon storage to preserve mech

when os.daemon caches a grant, it should preserve the source mechanism:

```ts
// daemon UnlockedKey (from vision doc)
interface UnlockedKey {
  slug: string;
  key: KeyrackKey;        // { secret, grade }
  source: {
    mech: KeyrackGrantMechanism;  // which adapter produced this
  };
  unlockedAt: IsoTimeStamp;
  expiresAt: IsoTimeStamp;
}
```

**scope**: the daemon data model must include source mech. this enables grade validation on get (verify mechanism's grade meets spec requirements).

---

## migration path

### step 1: rename mechanisms

rename `REPLICA` → `PERMANENT_VIA_REPLICA`, `GITHUB_APP` → `EPHEMERAL_VIA_GITHUB_APP`, `AWS_SSO` → `EPHEMERAL_VIA_AWS_SSO` across all code.

| file | change |
|------|--------|
| `KeyrackGrantMechanism.ts` | update type union |
| `genKeyrackGrantContext.ts` | update adapter registry keys |
| `mechAdapterReplica.ts` | no change (adapter logic same) |
| `mechAdapterGithubApp.ts` | no change (adapter logic same) |
| `mechAdapterAwsSso.ts` | no change (adapter logic same) |
| `KeyrackKeyHost.ts` | type change via mechanism type |
| `KeyrackKeyGrant.ts` | type change via mechanism type |
| all test files | update mechanism references |
| host manifest files on disk | migration needed |

### step 2: add `mech` field to github app blobs

update `mechAdapterGithubApp.ts` to:
1. accept blobs with `mech: 'EPHEMERAL_VIA_GITHUB_APP'` (new format)
2. still accept blobs without `mech` field (backwards compat, temporary)
3. warn on old format, guide to update

### step 3: convert aws sso from plain string to json blob

update `mechAdapterAwsSso.ts` to:
1. accept blobs with `mech: 'EPHEMERAL_VIA_AWS_SSO'` and `profile` field (new format)
2. still accept plain profile name strings (backwards compat, temporary)
3. update `setKeyrackKeyHost` flow to store as json blob

### step 4: deprecate backwards compat

after migration window:
1. remove plain string support from aws sso adapter
2. remove mech-less json support from github app adapter
3. require `mech` field on all transform blobs

---

## what we do NOT need to change

- **mechAdapterReplica** — passthrough, no transform, no blob needed. the value IS the credential.
- **keyrack.yml spec format** — spec declares grade requirements, not mechanisms. unchanged.
- **vault adapters** — vaults store opaque strings. they don't know or care about blob format.
- **os.envvar passthrough** — env var values are plain strings. no blob needed for passthrough.

---

## the principle

> **if a mechanism transforms, the source value must self-describe its mechanism.**
>
> passthrough mechanisms (replica) store plain values.
> transform mechanisms (github app, aws sso, aws oidc) store self-descriptive json blobs.
>
> the blob declares: "i am credentials for mechanism X. here are my config fields."
> any consumer can parse the blob, read `mech`, and resolve the adapter — without a host manifest.

this enables:
1. **ci without host manifest** — blob self-describes, action resolves adapter directly
2. **daemon with mechanism awareness** — daemon knows which adapter produced each grant
3. **cross-worksite reuse** — daemon can validate mechanism grade without host manifest lookup
4. **uniform resolution** — same adapter resolution path in dev, ci, and daemon contexts

---

## relationship to other todos

- **prerequisite for**: `.todo.support_cicd_github.md` — ci action needs self-descriptive blobs to resolve adapters without host manifest
- **prerequisite for**: os.daemon implementation — daemon needs to preserve source mech for grade validation
- **depends on**: mechanism rename (can be done in same changeset)
- **independent of**: keyrack key grades (KeyrackKey with grade) — grade is orthogonal to self-descriptive blobs

---

## open questions

1. **backwards compat duration** — how long do we support old format (mech-less blobs, plain strings) before hard cutover?
2. **host manifest mech validation** — should get fail fast if host manifest mech differs from blob mech, or warn?
3. **vault-side migration** — do we provide a migration command (`rhx keyrack migrate`) to rewrite stored values in-place, or require manual re-set?
