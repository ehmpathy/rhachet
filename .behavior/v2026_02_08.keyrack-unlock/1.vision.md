# vision: keyrack key grades & os.daemon unlock

> keys have grades. grades never degrade. unlock caches in daemon memory. get reads from daemon. no session keys. no files on disk. ğŸ”

---

## vault taxonomy

the keyrack supports multiple vault types. this section covers the **os-level vaults** â€” vaults that use os primitives directly. other vaults (1password, aws secrets manager, etc.) are covered elsewhere.

each os-level vault is a different tradeoff of security, durability, and convenience.

```
keyrack.vaults.os
â”œâ”€ os.direct
â”‚  â”œâ”€ what: plaintext json on disk (~/.rhachet/keyrack.direct.json)
â”‚  â”œâ”€ grade.protection: plaintext
â”‚  â”œâ”€ grade.duration: permanent (survives reboot, logout, crash)
â”‚  â”œâ”€ access: any process with filesystem read
â”‚  â””â”€ use: low-sensitivity keys where convenience > security
â”‚
â”œâ”€ os.secure
â”‚  â”œâ”€ what: age-encrypted file on disk (~/.rhachet/keyrack.secure.*.age)
â”‚  â”œâ”€ grade.protection: encrypted
â”‚  â”œâ”€ grade.duration: permanent (survives reboot, logout, crash)
â”‚  â”œâ”€ access: requires passphrase or identity key to decrypt
â”‚  â””â”€ use: high-sensitivity keys where security > convenience
â”‚
â””â”€ os.daemon
   â”œâ”€ what: in-memory daemon process (keyrack daemon via unix socket)
   â”œâ”€ grade.protection: in-memory (never on disk)
   â”œâ”€ grade.duration: transient (dies on logout, crash, reboot)
   â”œâ”€ access: same-login-session processes via unix domain socket
   â””â”€ use: session-time credential cache after unlock
```

os.daemon is the session-time vault. it holds credentials in memory so that tools can access them without re-auth.

os.daemon can be used for any purpose â€” a user may choose to `set` keys into os.daemon like any other vault. however, the keyrack specifically uses os.daemon as the **grant cache** after `unlock`, to prevent redundant auth prompts. this replaces any prior pattern of cache in os.direct (plaintext on disk).

```
source vault (os.secure, 1password, aws sso)
  â†’ unlock â†’ os.daemon (session cache, in memory)
  â†’ get    â†’ tool reads from os.daemon via socket
```

---

## key grades

every credential has a **grade** â€” its security posture:

```ts
interface KeyrackKey {
  secret: KeyrackKeySecret;  // the credential value (alias to string)
  grade: KeyrackKeyGrade;
}

interface KeyrackKeyGrade {
  protection: 'encrypted' | 'plaintext';
  duration: 'permanent' | 'ephemeral' | 'transient';
}
```

**protection** = how is the secret stored at rest?
- `encrypted` â†’ stored in os.secure, 1password, etc
- `plaintext` â†’ stored in os.direct (json on disk)

**duration** = how long does the secret live?
- `permanent` â†’ lives indefinitely (api keys, private keys)
- `ephemeral` â†’ lives for a bounded time (sso sessions, app tokens)
- `transient` â†’ lives only in memory, never persisted

### the grade ladder

grades form a hierarchy. you can only move **up** the ladder, never down:

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  encrypted + transient  â”‚  â† most secure
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  encrypted + ephemeral  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  encrypted + permanent  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  plaintext + ephemeral  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  plaintext + permanent  â”‚  â† least secure
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â†‘ allowed (upgrade)     â†“ forbidden (degradation)
```

the keyrack enforces this: you can promote a key to a higher grade, but never demote it.

---

## spec vs host: grade requirements vs mechanism

the **spec** (keyrack.yml in repo) declares **minimum grade requirements** â€” what security posture is required.

the **host** (keyrack.host.yml on machine) declares **mechanism** â€” how the key is provided.

### spec: grade shorthand

```yaml
# keyrack.yml (in repo)
keys:
  AWS_SSO_PREP: ephemeral           # requires grade.duration = ephemeral or better
  GITHUB_APP_TOKEN: ephemeral       # requires grade.duration = ephemeral or better
  XAI_API_KEY: encrypted            # requires grade.protection = encrypted
  SUPER_SECRET: encrypted,ephemeral # requires both
```

these are **minimums** â€” the host may always exceed them.

### host: mechanism (implies grade)

```yaml
# keyrack.host.yml (on machine)
keys:
  AWS_SSO_PREP:
    vault: aws.sso
    # mechanism: EPHEMERAL_VIA_AWS_SSO (implied by vault)
    # grade: { protection: encrypted, duration: ephemeral } âœ… meets spec
  XAI_API_KEY:
    vault: os.secure
    # mechanism: PERMANENT_VIA_REPLICA (implied by vault)
    # grade: { protection: encrypted, duration: permanent } âœ… meets spec
```

mechanism names encode their duration explicitly (`PERMANENT_VIA_*`, `EPHEMERAL_VIA_*`). the vault determines the mechanism, and the mechanism determines the grade.

```ts
type KeyrackGrantMechanism =
  | 'PERMANENT_VIA_REPLICA'
  | 'EPHEMERAL_VIA_GITHUB_APP'
  | 'EPHEMERAL_VIA_AWS_SSO'
  | 'EPHEMERAL_VIA_GITHUB_OIDC'
  | 'EPHEMERAL_VIA_INSTANCE_ROLE';
```

### why spec uses grade, not mechanism

different machines provide the same key via different mechanisms:

| machine     | key          | mechanism                    | grade              |
|-------------|--------------|------------------------------|--------------------|
| dev laptop  | AWS_SSO_PREP | EPHEMERAL_VIA_AWS_SSO        | encrypted,ephemeral |
| ci runner   | AWS_SSO_PREP | EPHEMERAL_VIA_GITHUB_OIDC    | encrypted,ephemeral |
| prod server | AWS_SSO_PREP | EPHEMERAL_VIA_INSTANCE_ROLE  | encrypted,ephemeral |

all meet the spec requirement `ephemeral`. the spec doesn't care HOW â€” only that the grade is met.

---

## the outcome world

### before: plaintext cache on disk

casey runs `rhx keyrack get --for repo --unlock`. the keyrack:

1. unlocks the os.secure vault (passphrase prompt)
2. retrieves the XAI_API_KEY (encrypted at rest, permanent storage)
3. **caches it in os.direct** for robots to access later
4. robot runs `rhx keyrack get --for repo`, reads from os.direct cache

the problem: casey's permanent, encrypted credential is now **plaintext on disk**. the grade degraded:

```
grade.protection: encrypted â†’ plaintext  âŒ
grade.duration:   permanent â†’ permanent  (unchanged, but now exposed)
```

any process can read `keyrack.direct.json`. the blast radius is permanent.

### after: daemon memory cache

casey runs `rhx keyrack unlock`. the keyrack:

1. findserts the daemon (starts if absent)
2. unlocks source vaults (passphrase prompt, sso auth, etc.)
3. retrieves credentials with their grades
4. **sends them to daemon memory** (never on disk)

```
grade.protection: encrypted â†’ in-memory  âœ… (never written to disk)
grade.duration:   permanent â†’ permanent  âœ… (unchanged)
```

robot runs `rhx keyrack get --for repo`. keyrack connects to daemon, retrieves keys, exports to tool's env. secrets only exist in daemon memory and tool's env â€” never on disk.

```
source vault (os.secure)
  â†’ unlock â†’ daemon memory (session cache)
  â†’ get    â†’ tool reads from daemon via socket
  â†’ done   â†’ tool exits, secrets gone from tool's env
```

### the "aha" moment

> "unlock sends keys to daemon memory. get reads from daemon. no session keys to manage. no files on disk. mid-session unlock just works."

---

## user experience

### usecase 1: unlock then spawn robot

```sh
# human unlocks (interactive auth)
$ rhx keyrack unlock
ğŸ”“ keyrack unlock
   â”œâ”€ findsert daemon...
   â”œâ”€ unlock os.secure vault...
   â”‚  â””â”€ passphrase: ********
   â”œâ”€ unlock aws sso...
   â”‚  â””â”€ browser auth complete
   â”œâ”€ send 3 keys to daemon...
   â”‚  â”œâ”€ AWS_SSO_PREP (expires in 9h)
   â”‚  â”œâ”€ GITHUB_APP_TOKEN (expires in 9h)
   â”‚  â””â”€ XAI_API_KEY (expires in 9h)
   â””â”€ âœ¨ 3 keys unlocked

# spawn robot (no special env vars needed)
$ claude

# robot's tool needs credentials
# (inside npm run test:integration or similar)
$ source rhx keyrack get --for repo
ğŸ” rhachet/keyrack
   â”œâ”€ connect to daemon...
   â”œâ”€ filter by keyrack.yml: 3 keys required
   â”œâ”€ export 3 keys to env...
   â””â”€ done. 3 granted via os.daemon.
```

no session key in env. robot accesses keys via daemon. tool exports secrets to its own env, secrets die when tool exits.

### usecase 2: cross-terminal (zero friction)

```sh
# terminal A: human unlocks in repo-api
$ cd ~/git/repo-api && rhx keyrack unlock
ğŸ”“ 3 keys unlocked (expires in 9h)

# terminal B: human or robot accesses keys (same login session)
$ cd ~/git/repo-api && source rhx keyrack get --for repo
ğŸ” done. 3 granted via os.daemon.
```

no session key to copy. no `--reuse`. no clipboard. all terminals in the same login session share the daemon.

### usecase 2b: cross-worksite (key reuse)

```sh
# terminal A: human unlocks in repo-api (which needs AWS_SSO_PREP)
$ cd ~/git/repo-api && rhx keyrack unlock
ğŸ”“ keyrack unlock
   â”œâ”€ AWS_SSO_PREP (expires in 9h)
   â””â”€ XAI_API_KEY (expires in 9h)

# terminal B: human works in repo-infra (which also needs AWS_SSO_PREP)
$ cd ~/git/repo-infra && source rhx keyrack get --for repo
ğŸ” rhachet/keyrack
   â”œâ”€ filter by keyrack.yml: AWS_SSO_PREP required
   â”œâ”€ AWS_SSO_PREP already unlocked (6h left)
   â””â”€ done. 1 granted via os.daemon.
```

keys are stored by slug. if repo-infra's keyrack.yml declares AWS_SSO_PREP, and it's already unlocked, no re-auth needed. reduces SSO browser prompts and 1password master password entries.

### usecase 2c: custom duration

```sh
# short session for quick task
$ rhx keyrack unlock --duration 30m
ğŸ”“ 3 keys unlocked (expires in 30m)

# longer session for extended work
$ rhx keyrack unlock --duration 4h
ğŸ”“ 3 keys unlocked (expires in 4h)
```

custom duration lets users scope the TTL to their task. shorter = smaller blast radius if session is compromised.

### usecase 3: robot started without unlock (mid-session unlock works)

```sh
# terminal A: robot started before unlock
$ claude
> run integration tests

# tool tries to get keys
$ source rhx keyrack get --for repo
ğŸ” rhachet/keyrack
   â””â”€ status: ğŸ”’ locked
      â”œâ”€ required keys not in daemon: AWS_SSO_PREP, XAI_API_KEY
      â””â”€ fix: run `rhx keyrack unlock` from any terminal

# terminal B: human unlocks (robot doesn't need restart)
$ rhx keyrack unlock
ğŸ”“ 2 keys unlocked (expires in 9h)

# back in terminal A: robot's tool retries
$ source rhx keyrack get --for repo
ğŸ” done. 2 granted via os.daemon.
```

mid-session unlock works. no robot restart needed. human unlocks from any terminal (or any worksite that has those keys), robot's next `get` succeeds.

### usecase 4: attacker can't read daemon

```sh
# attacker has read access to filesystem
$ cat ~/.rhachet/keyrack.direct.json
# â†’ only os.direct keys (low-sensitivity), no unlocked session keys

$ ls /run/user/$UID/
# â†’ keyrack.$SESSIONID.sock visible (attacker knows socket exists)

# attacker tries to connect
$ nc -U /run/user/$UID/keyrack.$SESSIONID.sock
# â†’ daemon checks /proc/$PID/sessionid
# â†’ attacker's process has different sessionid â†’ denied
```

daemon verifies caller's login session via `/proc/$PID/sessionid`. attacker in a different login session is denied.

### usecase 5: grade degradation blocked

```sh
# human tries to cache permanent encrypted key in os.direct (plaintext)
$ rhx keyrack set --key AWS_SSO_CREDS --vault os.direct
ğŸš« blocked: grade degradation forbidden
   â”œâ”€ current grade: { protection: encrypted, duration: permanent }
   â”œâ”€ target grade:  { protection: plaintext, duration: permanent }
   â””â”€ fix: use --vault os.secure to preserve grade
```

---

## daemon architecture

### process lifecycle

```
daemon.lifecycle
â”œâ”€ start: findserted on first `unlock`
â”‚  â”œâ”€ check if socket exists at /run/user/$UID/keyrack.$SESSIONID.sock
â”‚  â”œâ”€ if socket exists and daemon responds â†’ reuse
â”‚  â”œâ”€ if socket absent or unresponsive â†’ start new daemon
â”‚  â””â”€ daemon forks to background
â”‚
â”œâ”€ run: listens on unix domain socket
â”‚  â”œâ”€ accepts connections from same-login-session callers
â”‚  â”œâ”€ handles: unlock (add keys), get (return keys), status, relock
â”‚  â””â”€ manages TTL timers per key
â”‚
â””â”€ stop: dies on logout or explicit lock
   â”œâ”€ systemd user session: daemon dies with session
   â””â”€ or: explicit `rhx keyrack relock` kills daemon
```

### socket protocol

```
daemon.protocol
â”œâ”€ transport: unix domain socket at /run/user/$UID/keyrack.$SESSIONID.sock
â”‚  â””â”€ /run/user/$UID/ is tmpfs â†’ dies on reboot, per-user, proper permissions
â”‚
â”œâ”€ auth: SO_PEERCRED + /proc/$PID/sessionid
â”‚  â”œâ”€ kernel provides caller UID, PID on each connection
â”‚  â”œâ”€ daemon verifies caller UID matches daemon UID
â”‚  â””â”€ daemon verifies caller's login session via /proc/$PID/sessionid
â”‚
â”œâ”€ commands
â”‚  â”œâ”€ UNLOCK { keys[], duration } â†’ store keys with TTL
â”‚  â”œâ”€ GET { slugs[] } â†’ return keys by slug (if TTL valid)
â”‚  â”œâ”€ STATUS â†’ return list of unlocked keys and TTL left
â”‚  â””â”€ RELOCK { slugs[]? } â†’ purge keys by slug (or all)
â”‚
â””â”€ format: json over unix socket
```

### in-memory data model

```
daemon.memory
â”œâ”€ keys: Map<slug, UnlockedKey>
â”‚
â”‚  UnlockedKey
â”‚  â”œâ”€ slug: string
â”‚  â”œâ”€ key: KeyrackKey
â”‚  â”œâ”€ unlockedAt: timestamp
â”‚  â””â”€ expiresAt: timestamp
â”‚
â””â”€ lookup: `get --for repo`
   â”œâ”€ read keyrack.yml for this worksite â†’ required slugs
   â”œâ”€ for each slug: check if in daemon with valid TTL
   â””â”€ return keys that are both required AND unlocked
```

keys are stored by slug, not by worksite. any worksite whose keyrack.yml declares a key can access it (if unlocked with valid TTL). this reduces auth friction â€” unlock once, use across worksites.

### scope: per-login-session (enforced) + per-repo-spec (convened)

```
daemon.scope
â”œâ”€ per-login-session (ENFORCED â€” kernel + daemon)
â”‚  â”œâ”€ kernel-managed sessionid (set by setsid at login)
â”‚  â”œâ”€ daemon verifies caller's /proc/$PID/sessionid on every request
â”‚  â”œâ”€ all terminals in one login session share one daemon
â”‚  â”œâ”€ different login session (same user) â†’ denied
â”‚  â”œâ”€ unforgeable â€” kernel-managed, not user-settable
â”‚  â””â”€ secure against malintent actors (they cannot bypass this check)
â”‚
â””â”€ per-repo-spec (CONVENED â€” rhachet convention)
   â”œâ”€ daemon stores keys by slug (not by worksite)
   â”œâ”€ rhachet filters by keyrack.yml: only declared keys are accessible
   â”œâ”€ unlock in repo-api, access from repo-infra â†’ works if both declare same key
   â”œâ”€ reduces auth friction: unlock once, use across worksites
   â”œâ”€ enforced only for callers who go through rhachet
   â”œâ”€ malintent actor with login-session access could call daemon directly
   â”‚  â””â”€ they could request any key by slug (daemon doesn't filter by spec)
   â””â”€ but: if attacker has login-session access, user has bigger problems
```

**enforced vs convened:**

| boundary | enforced by | secure against |
|----------|-------------|----------------|
| per-login-session | kernel + daemon | malintent actors (unforgeable) |
| per-repo-spec (keyrack.yml) | rhachet convention | bonintent actors only |

per-repo-spec filter is defense-in-depth for bonintent usage â€” it prevents accidental access to keys not declared in this worksite's keyrack.yml. it does not protect against malintent actors who already have login-session access.

### TTL enforcement

```
daemon.ttl
â”œâ”€ each key has its own TTL timer
â”‚  â””â”€ set at unlock time via `unlock --duration 1h` (default 9h)
â”‚
â”œâ”€ duration formats: 1h, 30m, 4h, 8h, etc
â”‚
â”œâ”€ on GET: daemon checks expiresAt per key
â”‚  â”œâ”€ if valid â†’ return key
â”‚  â””â”€ if expired â†’ purge key from memory, omit from response
â”‚
â”œâ”€ unlock extends TTL: re-unlock a key â†’ new expiresAt
â”‚
â””â”€ enforcement is real, not convention
   â”œâ”€ no file to decrypt directly
   â””â”€ daemon refuses expired keys
```

---

## alternatives considered

### encrypted session vault (on-disk)

honorable mention: age-encrypted session vault file with session key in env.

```
encrypted.session.vault
â”œâ”€ approach
â”‚  â”œâ”€ unlock â†’ create encrypted vault file on disk
â”‚  â”œâ”€ export KEYRACK_SESSION_KEY to env
â”‚  â”œâ”€ get â†’ decrypt vault with session key from env
â”‚  â””â”€ cross-terminal: --reuse $sessionKey
â”‚
â”œâ”€ why not
â”‚  â”œâ”€ session key in env â†’ readable via /proc/$PID/environ by same-user processes
â”‚  â”œâ”€ vault file on disk â†’ disk forensics, stale file cleanup, swap exposure
â”‚  â”œâ”€ TTL is convention only â†’ adversary can decrypt file directly
â”‚  â”œâ”€ --reuse requires clipboard â†’ clipboard managers may persist it
â”‚  â”œâ”€ robot restart required â†’ mid-session unlock doesn't work
â”‚  â””â”€ two attack surfaces (disk file + env var) vs one (daemon memory)
â”‚
â””â”€ verdict: os.daemon eliminates session key leak and vault file entirely
```

### per-terminal-session scope

honorable mention: isolate keys per terminal chain, not per login session.

```
per.terminal.session
â”œâ”€ approach
â”‚  â”œâ”€ each terminal gets its own daemon or key partition
â”‚  â”œâ”€ terminal A unlocks â†’ only terminal A's descendants can access
â”‚  â””â”€ goal: narrower blast radius on terminal compromise
â”‚
â”œâ”€ why not
â”‚  â”œâ”€ no kernel primitive exists for per-terminal scope
â”‚  â”‚  â”œâ”€ sessionid = per-login-session (all terminals share it)
â”‚  â”‚  â”œâ”€ PTY = forgeable (process can open any PTY)
â”‚  â”‚  â””â”€ process group = per-pipeline, not per-terminal
â”‚  â”œâ”€ every implementation reintroduces eliminated problems
â”‚  â”‚  â”œâ”€ per-terminal daemon â†’ env var for socket path â†’ /proc leak
â”‚  â”‚  â”œâ”€ PTY-based track â†’ forgeable
â”‚  â”‚  â””â”€ token in env â†’ exactly the session key pattern
â”‚  â”œâ”€ theoretical benefits are marginal
â”‚  â”‚  â”œâ”€ same-worksite terminal isolation â†’ friction with no gain
â”‚  â”‚  â””â”€ terminal compromise blast radius â†’ can't enforce without kernel primitive
â”‚  â””â”€ per-repo-spec filter already handles the bonintent case
â”‚
â””â”€ verdict: per-login-session is the strongest enforceable boundary
```

---

## security model

### threat model

| threat | mitigation | boundary type |
|--------|------------|---------------|
| attacker reads filesystem | daemon memory only; no vault file on disk | enforced |
| attacker spawns new login session | different sessionid â†’ daemon denies | enforced |
| attacker in same login session | can connect to daemon (irreducible floor) | â€” |
| attacker in same session, different worksite | convened isolation via rhachet | convened |
| attacker reads env of tool process | actual secrets in env while tool runs (irreducible floor) | â€” |
| attacker compromises unlock terminal | game over (but scoped to that session) | â€” |

### what we protect against

**enforced boundaries (secure against malintent):**
âœ… **filesystem read** â€” no vault file on disk
âœ… **new login session** â€” daemon verifies sessionid (kernel-enforced, unforgeable)
âœ… **grade degradation** â€” keyrack refuses to demote
âœ… **stale files** â€” daemon death = instant cleanup
âœ… **TTL bypass** â€” daemon enforces TTL in memory (real, not convention)

**convened boundaries (secure against bonintent only):**
âœ… **per-repo-spec filter (via rhachet)** â€” only keys declared in keyrack.yml are accessible
âš ï¸ **direct daemon call** â€” malintent actor could bypass rhachet and request any key by slug

### what we don't protect against

âŒ **same-login-session process** â€” can connect to daemon (irreducible floor)
âŒ **same-login-session + direct daemon call** â€” can request keys for any worksite (convened boundary)
âŒ **actual secrets in tool env** â€” readable via /proc while tool runs (irreducible floor)
âŒ **compromised terminal** â€” if attacker owns the terminal, they're in the login session
âŒ **elevated privilege attack** â€” root can read daemon memory

### the irreducible floor

same-login-session processes can access the daemon, and actual secrets exist in tool env while tools run. os.daemon doesn't change this floor â€” it only eliminates the session key and vault file attack surfaces above the floor.

### why convened boundaries still matter

per-repo-spec filter is defense-in-depth for bonintent usage:
- prevents accidental access to keys not declared in keyrack.yml
- reduces blast radius of honest mistakes (only declared keys accessible)
- makes key access intentional (must be declared in worksite's spec)

it does not protect against malintent actors who already have login-session access â€” but if they do, the user has bigger problems (they can read `/proc/$PID/environ` of any process, attach debuggers, etc).

---

## domain objects

### spec-side (keyrack.yml in repo)

```ts
// grade requirement shorthand
type KeyrackKeyGradeRequirement =
  | 'ephemeral'           // requires grade.duration = ephemeral or better
  | 'encrypted'           // requires grade.protection = encrypted
  | 'encrypted,ephemeral' // requires both

interface KeyrackSpec {
  keys: Record<string, KeyrackKeyGradeRequirement>;
}
```

### host-side (keyrack.host.yml on machine)

```ts
interface KeyrackKey {
  secret: KeyrackKeySecret;  // alias to string
  grade: KeyrackKeyGrade;
}

interface KeyrackKeyGrade {
  protection: 'encrypted' | 'plaintext';
  duration: 'permanent' | 'ephemeral' | 'transient';
}

interface KeyrackKeyGrant {
  slug: string;
  key: KeyrackKey;
  source: {
    vault: KeyrackHostVault;
    mech: KeyrackGrantMechanism;  // implied by vault
  };
  expiresAt?: IsoTimeStamp;
}

type KeyrackHostVault = 'os.direct' | 'os.secure' | 'os.daemon' | '1password' | 'aws.sso' | ...;

type KeyrackGrantMechanism =
  | 'PERMANENT_VIA_REPLICA'
  | 'EPHEMERAL_VIA_GITHUB_APP'
  | 'EPHEMERAL_VIA_AWS_SSO'
  | 'EPHEMERAL_VIA_GITHUB_OIDC'
  | 'EPHEMERAL_VIA_INSTANCE_ROLE';
```

---

## command surface

```
commands
â”œâ”€ rhx keyrack unlock [--duration 9h]
â”‚  â”œâ”€ interactive auth (sso, passphrase, etc)
â”‚  â”œâ”€ findsert daemon
â”‚  â”œâ”€ send keys to daemon memory with TTL (default 9h)
â”‚  â”œâ”€ --duration 1h, --duration 30m, etc for custom TTL
â”‚  â””â”€ no env var exported (daemon IS the session)
â”‚
â”œâ”€ source rhx keyrack get --for repo
â”‚  â”œâ”€ connect to daemon via socket
â”‚  â”œâ”€ daemon returns keys for this worksite (if TTL valid)
â”‚  â””â”€ export actual secrets to current shell
â”‚
â”œâ”€ rhx keyrack status
â”‚  â””â”€ show unlocked worksites and TTL left
â”‚
â””â”€ rhx keyrack relock
   â””â”€ purge keys from daemon (all or per worksite)
```

---

## summary

`keyrack key grades` formalize the security posture of every credential:
- **protection**: encrypted or plaintext at rest
- **duration**: permanent, ephemeral, or transient
- grades never degrade

`keyrack os.daemon` provides session-time credential cache:
- secrets in daemon memory (never on disk)
- dies on logout (instant cleanup)
- real TTL enforcement per key (not convention)
- per-login-session scope (enforced â€” kernel + daemon, secure against malintent)
- per-repo-spec filter (convened â€” rhachet filters by keyrack.yml, secure against bonintent)
- keys stored by slug, reusable across worksites (reduces auth friction)
- mid-session unlock works (no robot restart)
- zero-friction cross-terminal (no session key to copy)

`keyrack spec` uses grade shorthand (minimums):
- `ephemeral` â€” requires grade.duration = ephemeral or better
- `encrypted` â€” requires grade.protection = encrypted
- `encrypted,ephemeral` â€” requires both

`keyrack host` uses mechanism names (which imply grades):
- `PERMANENT_VIA_REPLICA`, `EPHEMERAL_VIA_AWS_SSO`, `EPHEMERAL_VIA_GITHUB_OIDC`, etc.

> keys have grades. grades never degrade. unlock caches in daemon memory. get reads from daemon. no session keys. no files on disk. ğŸ”
