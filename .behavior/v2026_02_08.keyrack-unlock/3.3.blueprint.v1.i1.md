# blueprint: keyrack key grades & os.daemon unlock

> implementation plan for os.daemon vault, key grades, grade degradation prevention, and unlock/get separation

---

## filediffs treestruct

```
src/
├─ domain.objects/keyrack/
│  ├─ KeyrackKey.ts                          [CREATE] key + grade bundle
│  ├─ KeyrackKeyGrade.ts                     [CREATE] protection + duration
│  ├─ KeyrackKeySecret.ts                    [CREATE] alias to string
│  ├─ KeyrackKeyGrant.ts                     [UPDATE] value → key: KeyrackKey
│  ├─ KeyrackHostVault.ts                    [UPDATE] add 'os.daemon'
│  ├─ KeyrackGrantMechanism.ts               [UPDATE] prefix with PERMANENT_VIA_*, EPHEMERAL_VIA_*
│  └─ KeyrackDaemonCommand.ts                [CREATE] UNLOCK, GET, STATUS, RELOCK
│
├─ domain.operations/keyrack/
│  ├─ session/
│  │  ├─ unlockKeyrack.ts                    [CREATE] interactive auth → send keys to daemon
│  │  ├─ relockKeyrack.ts                    [CREATE] purge keys from daemon
│  │  └─ getKeyrackStatus.ts                 [CREATE] list unlocked keys with TTL left
│  ├─ vault/
│  │  └─ unlockKeyrackVault.ts               [MOVE] unlock vault adapters (passphrase, sso, etc)
│  ├─ getKeyrackKeyGrant.ts                  [UPDATE] check os.daemon instead of os.direct cache, remove cache-to-os.direct
│  ├─ grades/
│  │  ├─ inferKeyGrade.ts                    [CREATE] infer grade from vault + mechanism
│  │  ├─ detectKeyGradeChange.ts             [CREATE] compare source vs target grade
│  │  └─ assertKeyGradeProtected.ts          [CREATE] throw if degradation detected
│  │
│  ├─ adapters/vaults/
│  │  ├─ vaultAdapterOsDaemon.ts             [CREATE] unix socket adapter
│  │  └─ index.ts                            [UPDATE] export vaultAdapterOsDaemon
│  │
│  ├─ daemon/
│  │  ├─ infra/                                       # shared utilities (used by both svc and sdk)
│  │  │  ├─ getLoginSessionId.ts                      [CREATE] read /proc/$PID/sessionid
│  │  │  └─ getKeyrackDaemonSocketPath.ts             [CREATE] XDG_RUNTIME_DIR + sessionid
│  │  │
│  │  ├─ svc/                                         # the daemon service
│  │  │  ├─ index.ts                                  [CREATE] public contract: { start }
│  │  │  └─ src/
│  │  │     ├─ contract/
│  │  │     │  └─ startKeyrackDaemon.ts               [CREATE] fork daemon to background
│  │  │     ├─ domain.operations/
│  │  │     │  ├─ handleKeyrackDaemonConnection.ts    [CREATE] auth + dispatch commands
│  │  │     │  ├─ handleUnlockCommand.ts              [CREATE] store keys with TTL
│  │  │     │  ├─ handleGetCommand.ts                 [CREATE] return keys by slug
│  │  │     │  ├─ handleStatusCommand.ts              [CREATE] return keys with TTL left
│  │  │     │  ├─ handleRelockCommand.ts              [CREATE] purge keys
│  │  │     │  └─ verifyCallerLoginSession.ts         [CREATE] peer pid + sessionid check
│  │  │     ├─ domain.objects/
│  │  │     │  └─ daemonKeyStore.ts                   [CREATE] in-memory Map with TTL
│  │  │     └─ infra/
│  │  │        ├─ createKeyrackDaemonServer.ts        [CREATE] net.createServer for unix socket
│  │  │        └─ getSocketPeerPid.ts                 [CREATE] shell-based peer pid lookup via ss
│  │  │
│  │  └─ sdk/                                         # the client SDK
│  │     ├─ index.ts                                  [CREATE] public contract: { findsert, unlock, get, status, relock }
│  │     └─ src/
│  │        ├─ domain.operations/
│  │        │  ├─ findsertKeyrackDaemon.ts            [CREATE] start if absent, reuse if found
│  │        │  ├─ daemonAccessUnlock.ts               [CREATE] UNLOCK operation
│  │        │  ├─ daemonAccessGet.ts                  [CREATE] GET operation
│  │        │  ├─ daemonAccessStatus.ts               [CREATE] STATUS operation
│  │        │  └─ daemonAccessRelock.ts               [CREATE] RELOCK operation
│  │        └─ infra/
│  │           ├─ connectToKeyrackDaemon.ts           [CREATE] unix socket client
│  │           └─ sendKeyrackDaemonCommand.ts         [CREATE] send command, receive response
│  │
│  └─ genKeyrackGrantContext.ts              [UPDATE] add os.daemon adapter
│
├─ contract/
│  ├─ cli/keyrack/
│  │  ├─ unlock.ts                           [CREATE] rhx keyrack unlock command
│  │  ├─ relock.ts                           [CREATE] rhx keyrack relock command
│  │  ├─ status.ts                           [CREATE] rhx keyrack status command
│  │  └─ get.ts                              [UPDATE] remove --unlock flag
│  │
│  └─ cli/index.ts                           [UPDATE] register unlock, relock, status
│
└─ .test/
   ├─ assets/
   │  ├─ genMockedKeyrackDaemon.ts           [CREATE] mock daemon for unit tests
   │  └─ genSampleKeyrackKey.ts              [CREATE] sample key with grade
   │
   └─ integration/
      └─ keyrack/
         ├─ daemon.integration.test.ts       [CREATE] daemon lifecycle tests
         └─ unlock.integration.test.ts       [CREATE] unlock flow tests
```

---

## codepaths treestruct

### path.1: unlock flow

```
session/unlockKeyrack(input: { duration?: string }, context)
├─ daemon/sdk.findsert(context)                           # ensure daemon alive
│  └─ (internal to sdk)
│     ├─ daemon/infra/getKeyrackDaemonSocketPath(context)
│     │  ├─ daemon/infra/getLoginSessionId({ pid: process.pid })
│     │  │  └─ read /proc/$PID/sessionid
│     │  └─ return `${XDG_RUNTIME_DIR}/keyrack.${sessionId}.sock`
│     │
│     ├─ sdk/src/infra/connectToKeyrackDaemon({ socketPath })
│     │  └─ net.connect(socketPath) → test liveness
│     │
│     ├─ if liveness ok → return
│     └─ if liveness fail → svc/src/contract/startKeyrackDaemon(context)
│        ├─ daemonize()
│        ├─ svc/src/infra/createKeyrackDaemonServer({ socketPath })
│        │  └─ net.createServer().listen(socketPath)
│        └─ return
│
├─ read keyrack.yml → required slugs
│
├─ for each required slug:
│  ├─ read keyrack.host.yml → vault, mechanism
│  ├─ vault/unlockKeyrackVault({ vault }, context)
│  │  └─ prompt passphrase, sso auth, etc
│  ├─ get secret from vault
│  ├─ grade = inferKeyGrade({ vault, mechanism })
│  ├─ key = { secret, grade }                             # bundle into KeyrackKey
│  └─ collect { slug, key, expiresAt }                    # KeyrackKeyGrant shape
│
└─ daemon/sdk.unlock({ keys, duration }, context)         # send keys to daemon
   └─ (internal to sdk)
      ├─ sdk/src/infra/connectToKeyrackDaemon({ socketPath })
      └─ sdk/src/infra/sendKeyrackDaemonCommand({ command: 'UNLOCK', payload })
```

### path.2: get flow (via daemon)

```
getKeyrackKeyGrant(input: { slug }, context)
├─ check os.envvar first (ci passthrough)
│  └─ if found → validate → return grant
│
├─ check os.daemon second (session cache)
│  ├─ daemon/sdk.get({ slugs: [slug] }, context)
│  │  └─ (internal to sdk)
│  │     ├─ daemon/infra/getKeyrackDaemonSocketPath(context)
│  │     ├─ sdk/src/infra/connectToKeyrackDaemon({ socketPath })
│  │     │  └─ if connect fails → return null (daemon not found)
│  │     └─ sdk/src/infra/sendKeyrackDaemonCommand({ command: 'GET', payload })
│  ├─ if key found with valid TTL → validate → return grant
│  └─ if key absent or expired → fall through
│
├─ check host manifest (source vault)
│  ├─ read keyrack.host.yml → vault, mechanism
│  ├─ get key from source vault
│  ├─ translate if needed (sso, github app, etc)
│  ├─ inferKeyGrade({ vault, mechanism })
│  └─ return grant (do NOT cache to os.direct)
│
└─ if no key found → throw KeyNotFoundError
```

### path.3: daemon server request handler

```
svc/src/domain.operations/handleKeyrackDaemonConnection(socket, context)
├─ svc/src/domain.operations/verifyCallerLoginSession({ socket })
│  ├─ svc/src/infra/getSocketPeerPid({ socket })
│  │  ├─ inode = execSync(`readlink /proc/self/fd/${socket._handle.fd}`)
│  │  ├─ peerInfo = execSync(`ss -xp | grep ${inode}`)
│  │  └─ parse pid from peerInfo
│  ├─ daemon/infra/getLoginSessionId({ pid: callerPid })
│  ├─ daemon/infra/getLoginSessionId({ pid: process.pid })
│  └─ verify callerSessionId === daemonSessionId
│     └─ if mismatch → socket.end('denied: session mismatch')
│
├─ parse json request → { command, payload }
│
└─ dispatch by command
   ├─ UNLOCK → svc/src/domain.operations/handleUnlockCommand({ keys, duration })
   │  └─ for each key: keyStore.set(slug, { key, expiresAt })
   │
   ├─ GET → svc/src/domain.operations/handleGetCommand({ slugs })
   │  ├─ for each slug: keyStore.get(slug)
   │  ├─ filter out expired keys
   │  └─ return { keys: [...] }
   │
   ├─ STATUS → svc/src/domain.operations/handleStatusCommand()
   │  ├─ keyStore.entries()
   │  └─ return { keys: [{ slug, ttlLeft }...] }
   │
   └─ RELOCK → svc/src/domain.operations/handleRelockCommand({ slugs? })
      ├─ if slugs → keyStore.delete each
      └─ if !slugs → keyStore.clear()
```

### path.4: grade degradation check

```
assertKeyGradeProtected(input: { keyFound, targetVault })
├─ inferKeyGrade({ vault: keyFound.source.vault, mechanism: keyFound.source.mech })
│  └─ return { protection, duration }
│
├─ inferKeyGrade({ vault: targetVault, mechanism: 'PERMANENT_VIA_REPLICA' })
│  └─ return { protection, duration }
│
├─ detectKeyGradeChange({ source: sourceGrade, target: targetGrade })
│  ├─ if source.protection === 'encrypted' && target.protection === 'plaintext'
│  │  └─ return { degrades: true, reason: 'protection downgrade' }
│  ├─ if source.duration is more restrictive than target.duration
│  │  └─ return { degrades: true, reason: 'duration downgrade' }
│  └─ return { degrades: false }
│
└─ if degrades → throw GradeDegradationError({ source, target, reason })
```

---

## domain object decomposition

### new domain objects

```ts
// KeyrackKeySecret.ts
export type KeyrackKeySecret = string;

// KeyrackKeyGrade.ts
export interface KeyrackKeyGrade {
  protection: 'encrypted' | 'plaintext';
  duration: 'permanent' | 'ephemeral' | 'transient';
}

// KeyrackKey.ts
export interface KeyrackKey {
  secret: KeyrackKeySecret;
  grade: KeyrackKeyGrade;
}

// KeyrackDaemonCommand.ts
export type KeyrackDaemonCommand = 'UNLOCK' | 'GET' | 'STATUS' | 'RELOCK';

// note: request/response shapes are declared inline on daemon operations
// per rule.forbid.io-as-domain-objects — they are not domain concepts
```

### updated domain objects

```ts
// KeyrackHostVault.ts [UPDATE]
export type KeyrackHostVault =
  | 'os.envvar'
  | 'os.direct'
  | 'os.secure'
  | 'os.daemon'  // [ADD]
  | '1password';

// KeyrackGrantMechanism.ts [UPDATE]
export type KeyrackGrantMechanism =
  | 'PERMANENT_VIA_REPLICA'       // was: REPLICA
  | 'EPHEMERAL_VIA_GITHUB_APP'    // was: GITHUB_APP
  | 'EPHEMERAL_VIA_AWS_SSO'       // was: AWS_SSO
  | 'EPHEMERAL_VIA_GITHUB_OIDC';  // [ADD]

// KeyrackKeyGrant.ts [UPDATE]
export interface KeyrackKeyGrant {
  slug: string;
  key: KeyrackKey;  // was: value: string
  source: {
    vault: KeyrackHostVault;
    mech: KeyrackGrantMechanism;
  };
  expiresAt?: IsoTimeStamp;  // [ADD] for daemon TTL
}
```

---

## grade inference rules

```
grades/inferKeyGrade.rules
├─ vault → protection
│  ├─ os.envvar   → plaintext
│  ├─ os.direct   → plaintext
│  ├─ os.secure   → encrypted
│  ├─ os.daemon   → encrypted (in-memory, never on disk)
│  └─ 1password   → encrypted
│
├─ mechanism → duration
│  ├─ PERMANENT_VIA_REPLICA       → permanent
│  ├─ EPHEMERAL_VIA_GITHUB_APP    → ephemeral
│  ├─ EPHEMERAL_VIA_AWS_SSO       → ephemeral
│  └─ EPHEMERAL_VIA_GITHUB_OIDC   → ephemeral
│
└─ special cases
   ├─ os.daemon always has duration: transient (session-time only)
   └─ os.envvar inherits duration from mechanism (passthrough)
```

---

## dependencies

```
dependencies.new
├─ simple-in-memory-cache (v0.4.0)
│  ├─ what: in-memory TTL cache
│  ├─ why: daemon key storage with expiration
│  └─ note: ehmpathy package
│
├─ xdg-basedir (v4.0.0)
│  ├─ what: XDG path resolution
│  ├─ why: socket path in XDG_RUNTIME_DIR
│  └─ note: v4 is last CJS-compatible version
│
└─ daemonize-process (v4.1.1)
   ├─ what: fork to background
   ├─ why: daemon lifecycle
   └─ note: active maintenance (2025)
```

---

## test coverage

### unit tests

```
unit.tests
├─ grades/
│  ├─ inferKeyGrade.test.ts
│  │  ├─ vault os.secure → protection encrypted
│  │  ├─ vault os.direct → protection plaintext
│  │  ├─ mechanism PERMANENT_VIA_REPLICA → duration permanent
│  │  ├─ mechanism EPHEMERAL_VIA_AWS_SSO → duration ephemeral
│  │  └─ os.daemon → protection encrypted, duration transient
│  │
│  ├─ detectKeyGradeChange.test.ts
│  │  ├─ encrypted → plaintext = degrades
│  │  ├─ plaintext → encrypted = ok (upgrade)
│  │  ├─ permanent → ephemeral = degrades
│  │  ├─ ephemeral → permanent = ok (upgrade)
│  │  ├─ transient → ephemeral = ok (upgrade)
│  │  └─ ephemeral → transient = degrades
│  │
│  └─ assertKeyGradeProtected.test.ts
│     ├─ throws GradeDegradationError on degradation
│     └─ passes silently on upgrade or same grade
│
├─ daemon/infra/
│  ├─ getLoginSessionId.test.ts
│  │  └─ reads /proc/$PID/sessionid correctly
│  │
│  └─ getKeyrackDaemonSocketPath.test.ts
│     ├─ uses XDG_RUNTIME_DIR when set
│     └─ falls back to /run/user/$UID when unset
│
└─ daemon/svc/src/
   ├─ domain.objects/daemonKeyStore.test.ts
   │  ├─ stores keys with TTL
   │  ├─ returns null for expired keys
   │  ├─ deletes by slug
   │  └─ clears all
   │
   └─ infra/getSocketPeerPid.test.ts
      └─ parses pid from ss output correctly
```

### integration tests

```
integration.tests
├─ daemon.integration.test.ts
│  ├─ findsert creates daemon if absent
│  ├─ findsert reuses daemon if found
│  ├─ UNLOCK stores keys in daemon
│  ├─ GET returns keys with valid TTL
│  ├─ GET omits expired keys
│  ├─ STATUS lists keys with TTL left
│  ├─ RELOCK purges keys by slug
│  ├─ RELOCK purges all keys
│  └─ daemon denies caller from different login session (if testable)
│
├─ unlock.integration.test.ts
│  ├─ unlock populates daemon with keys
│  ├─ unlock with --duration sets custom TTL
│  ├─ unlock extends TTL on re-unlock
│  └─ unlock shortens TTL on re-unlock with shorter duration
│
├─ get.integration.test.ts
│  ├─ get reads from daemon after unlock
│  ├─ get falls through to source vault if not in daemon
│  ├─ get does NOT cache to os.direct
│  └─ get fails if key not in daemon and not in source
│
└─ grade.integration.test.ts
   ├─ set blocks degradation from encrypted to plaintext
   └─ set allows upgrade from plaintext to encrypted
```

### acceptance tests

```
acceptance.tests (blackbox via cli)
├─ unlock.acceptance.test.ts
│  ├─ [case1] unlock then get succeeds
│  ├─ [case2] cross-terminal get succeeds
│  ├─ [case3] custom duration sets TTL
│  ├─ [case4] mid-session unlock works (daemon persists)
│  └─ [case5] partial unlock reports failures per vault
│
├─ relock.acceptance.test.ts
│  ├─ [case1] relock purges all keys
│  └─ [case2] relock --key purges specific key
│
├─ status.acceptance.test.ts
│  ├─ [case1] status shows unlocked keys with TTL
│  └─ [case2] status shows empty when no keys unlocked
│
├─ grade.acceptance.test.ts
│  ├─ [case1] set --vault os.direct from os.secure → blocked
│  └─ [case2] get with spec requirement not met → blocked
│
└─ isolation.acceptance.test.ts
   └─ [case1] different login session → daemon denies (if testable)
```

---

## implementation phases

### phase 1: domain objects

```
phase.1.domain.objects
├─ create KeyrackKey, KeyrackKeyGrade, KeyrackKeySecret
├─ create KeyrackDaemonCommand
├─ update KeyrackHostVault (add os.daemon)
├─ update KeyrackGrantMechanism (add prefixes)
├─ update KeyrackKeyGrant (value → key)
└─ write unit tests for all domain objects
```

### phase 2: grade enforcement

```
phase.2.grade.enforcement
├─ create grades/ directory
│  ├─ inferKeyGrade
│  ├─ detectKeyGradeChange
│  └─ assertKeyGradeProtected
├─ integrate into vault operations
└─ write unit + integration tests
```

### phase 3: daemon infrastructure

```
phase.3.daemon.infrastructure
├─ create daemon/infra/                         # shared utilities
│  ├─ getLoginSessionId
│  └─ getKeyrackDaemonSocketPath
│
├─ create daemon/svc/                           # the daemon service
│  ├─ index.ts (public contract: { start })
│  └─ src/
│     ├─ contract/startKeyrackDaemon
│     ├─ domain.operations/
│     │  ├─ handleKeyrackDaemonConnection
│     │  ├─ handleUnlockCommand, handleGetCommand, handleStatusCommand, handleRelockCommand
│     │  └─ verifyCallerLoginSession
│     ├─ domain.objects/daemonKeyStore
│     └─ infra/
│        ├─ createKeyrackDaemonServer
│        └─ getSocketPeerPid (shell-based via ss)
│
├─ create daemon/sdk/                           # the client SDK
│  ├─ index.ts (public contract: { findsert, unlock, get, status, relock })
│  └─ src/
│     ├─ domain.operations/
│     │  ├─ findsertKeyrackDaemon
│     │  └─ daemonAccessUnlock, daemonAccessGet, daemonAccessStatus, daemonAccessRelock
│     └─ infra/
│        ├─ connectToKeyrackDaemon
│        └─ sendKeyrackDaemonCommand
│
├─ write unit + integration tests
└─ install dependencies (simple-in-memory-cache, xdg-basedir, daemonize-process)
```

### phase 4: cli commands

```
phase.4.session.operations.and.cli
├─ create session/ directory
│  ├─ unlockKeyrack
│  ├─ relockKeyrack
│  └─ getKeyrackStatus
├─ create vault/ directory
│  └─ move unlockKeyrackVault
├─ create cli commands (unlock, relock, status)
├─ update get command (remove --unlock flag)
├─ register commands in cli index
└─ write acceptance tests
```

### phase 5: integration + migration

```
phase.5.integration
├─ update getKeyrackKeyGrant (os.daemon check, remove os.direct cache)
├─ create vaultAdapterOsDaemon
├─ update genKeyrackGrantContext
├─ add migration warn for old mechanism names
└─ full integration + acceptance test suite
```

---

## sources

- `.behavior/v2026_02_08.keyrack-unlock/1.vision.md` — vision doc
- `.behavior/v2026_02_08.keyrack-unlock/2.1.criteria.blackbox.md` — blackbox criteria
- `.behavior/v2026_02_08.keyrack-unlock/2.1.criteria.blackbox.matrix.md` — coverage matrix
- `.behavior/v2026_02_08.keyrack-unlock/3.1.research.access._.v1.i1.md` — linux security interfaces
- `.behavior/v2026_02_08.keyrack-unlock/3.1.research.claims._.v1.i1.md` — security claims
- `.behavior/v2026_02_08.keyrack-unlock/3.1.research.patterns._.code.prod.v1.i1.md` — code patterns
- `.behavior/v2026_02_08.keyrack-unlock/3.1.research.patterns._.oss.levers.v1.i1.md` — oss dependencies
- `.behavior/v2026_02_08.keyrack-unlock/.refs/vault.os-daemon.md` — daemon architecture
- `.behavior/v2026_02_08.keyrack-unlock/.refs/eval.unlock-grain-worksite-vs-key.md` — per-key grain rationale
