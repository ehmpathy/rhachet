# research: claims for keyrack unlock

> facts, assumptions, questions, and opinions discovered via research

---

## legend

- **[FACT]** = indisputable, immutable truth
- **[SUMP]** = assumption (explicit or implicit)
- **[KHUE]** = open question to consider
- **[OPIN]** = subjective declaration to consider

---

## claims: SO_PEERCRED and unix socket auth

### [FACT] SO_PEERCRED returns kernel-verified credentials

> "SO_PEERCRED returns the credentials of the peer process connected to this socket. The returned credentials are those that were in effect at the time of the call to connect(2) or socketpair(2)." [1]

the kernel provides uid, pid, gid — impossible for client to spoof.

### [FACT] credentials are set at connect time, not request time

> "getsockopt(2) returns a struct ucred containing the pid, uid, and gid of the process on the other end. However, these are set at the time of the connect(2) syscall and can be changed by the process afterward through privilege dropping." [2]

if a process drops privileges after connect, the daemon sees the original privileges.

### [FACT] PID reuse attacks are a real concern

> "A significant security concern is 'PID Reuse Attacks,' where a process terminates after a connection is established and the PID is reassigned to a different process." [2]

mitigation: verify process is still alive via `/proc/$PID/` checks.

### [FACT] SO_PEERCRED is linux-specific

> "SO_PEERCRED is Linux-specific and will not work on macOS or Windows." [2]

keyrack daemon will be linux-only for now.

### [FACT] production databases use SO_PEERCRED for auth

> "The MySQL auth_socket authentication plugin authenticates clients connecting locally through Unix socket files by using the SO_PEERCRED socket option." [3]

> "MariaDB supports Unix socket authentication through SO_PEERCRED/uid matching." [4]

this is a proven pattern in production systems.

---

## claims: linux audit sessionid

### [FACT] sessionid is set at login and inherited

> "The audit session ID is inherited across fork and exec, and is set when a user logs in. It can be read from /proc/[pid]/sessionid." [5]

> "/proc/[pid]/sessionid: This read-only file contains the audit session ID of the process. It is set when the user logs in and is inherited by all processes started by the login session." [6]

all processes in a login session share the same sessionid.

### [FACT] sessionid is kernel-managed and immutable

> "sessionid is set once at login by the audit subsystem and never changes for the lifetime of the process tree." [7]

user processes cannot change their sessionid — kernel-enforced boundary.

### [FACT] sessionid interface was added in kernel 2.6.25

> "This interface was added on 2008-03-13 in kernel version 2.6.25-rc7." [8]

available on all modern linux systems.

### [SUMP] sessionid is always set correctly

systems without pam_loginuid.so may have unset sessionid (-1 or 4294967295). containers and minimal systems may not set it.

### [KHUE] how to handle systems without valid sessionid?

fallback to uid-only verification? warn user? refuse to run?

---

## claims: XDG_RUNTIME_DIR

### [FACT] XDG_RUNTIME_DIR is tmpfs and dies on logout

> "The user runtime directory /run/user/$UID is either created or mounted as a new 'tmpfs' file system with quota applied." [9]

> "If the last concurrent session of a user ends, the user runtime directory /run/user/$UID and all its contents are removed." [10]

instant cleanup on logout — no stale files.

### [FACT] XDG_RUNTIME_DIR has proper permissions by default

> "This directory shall be used for runtime file system objects such as AF_UNIX sockets, FIFOs, PID files and similar. It is guaranteed that this directory is local and offers the greatest possible file system feature set the OS provides." [11]

0700 permissions, owned by user, inaccessible to others.

### [FACT] multiple sessions share the same XDG_RUNTIME_DIR

> "If a user logs in twice at the same time, both sessions will see the same $XDG_RUNTIME_DIR and the same contents." [10]

this is consistent with per-login-session scope (not per-terminal).

### [FACT] files may be subject to periodic cleanup

> "Files in this directory may be subjected to periodic clean-up. To ensure that your files are not removed, they should have their access time timestamp modified at least once every 6 hours of monotonic time or the 'sticky' bit should be set on the file." [10]

daemon socket should touch its socket file periodically or use sticky bit.

---

## claims: /proc/pid/environ exposure

### [FACT] environment variables are readable by same user

> "Tools like ps e or /proc/<PID>/environ can read environment variables of active processes (if the user has permissions). This is a significant security risk because environment variables are used for database credentials (DB_PASSWORD) and API keys (API_KEY)." [12]

any process by the same user can read env vars of other processes.

### [FACT] /proc access is governed by ptrace permissions

> "Permission to access this file is governed by a ptrace access mode PTRACE_MODE_READ_FSCREDS check." [13]

but for same-uid processes, ptrace is typically allowed.

### [FACT] env vars persist in /proc for forensics

> "If an attacker cleans their IP address from the logs, chances are good that if they came in over SSH that the IP address they used is there on the process they started, ready to be grabbed." [14]

env vars are useful for forensics — but also for attackers.

### [SUMP] session keys in env vars are vulnerable to same-user attack

if KEYRACK_SESSION_KEY is in env, any same-user process can read it via /proc. this is why os.daemon avoids session keys entirely.

---

## claims: same-user process isolation (irreducible floor)

### [FACT] same-user processes can ptrace each other by default

> "In classic ptrace permissions mode: a process can PTRACE_ATTACH to any other process under the same uid, as long as it is dumpable." [15]

> "a single user is able to examine the memory and state of any of their processes." [16]

this is a fundamental linux security boundary.

### [FACT] ptrace scope can restrict this (yama)

> "The /proc/sys/kernel/yama/ptrace_scope file can be used to restrict the ability to trace a process with ptrace()." [17]

but this is not enabled by default on most systems.

### [FACT] same-user attack is a recognized threat model

> "If one application (e.g. Pidgin) was compromised, it would be possible for an attacker to attach to other active processes (e.g. Firefox, SSH sessions, GPG agent, etc) to extract additional credentials and continue to expand the scope of their attack." [16]

os.daemon does not claim to protect against same-login-session attackers.

### [OPIN] if attacker has login session access, user has bigger problems

same-user attack means the attacker is already inside the user's session. they can read all files, attach to all processes, and exfiltrate data. os.daemon protects against:
- different login sessions (enforced)
- filesystem reads (no files on disk)
- bonintent per-worksite isolation (convened)

---

## claims: ssh-agent and gpg-agent patterns

### [FACT] ssh-agent socket is vulnerable to same-user attack

> "Everyone who is able to connect to the ssh-agent socket also has access to the ssh-agent." [18]

> "The socket is accessible only to the current user, but is easily abused by root or another instance of the same user." [19]

ssh-agent has the same irreducible floor as os.daemon.

### [FACT] agent forward extends this vulnerability

> "When you forward ssh-agent's Unix domain socket to a remote host, it creates a security risk: anyone with root access on the remote host can discreetly access your local SSH agent through the socket and use your keys to impersonate you on other machines." [20]

os.daemon should not support forward.

### [FACT] gpg-agent uses self-test to detect socket theft

> "gpg-agent employs a periodic self-test to detect a stolen socket, which usually means a second instance of gpg-agent has taken over the socket." [21]

os.daemon could adopt similar patterns.

### [FACT] agents cache credentials to avoid repeated auth

> "An agent is a daemon process that can hold onto your passphrase (gpg-agent) or your private key (ssh-agent) so that you only need to enter your passphrase once within some period of time." [22]

this is exactly what os.daemon does for keyrack.

### [OPIN] gpg-agent design is more advanced than ssh-agent

> "gpg-agent is much more advanced than OpenSSH's ssh-agent. gpg will always ask gpg-agent to retrieve your passphrase when it's needed, so it will cache your passphrase on demand with no need to explicitly register with the agent." [22]

os.daemon follows a similar pattern: unlock populates cache, get reads from cache.

---

## claims: daemon vs file-based credentials

### [SUMP] daemon-based credential storage is more secure than files

daemon advantages:
- credentials in memory only (no disk exposure)
- real TTL enforcement (daemon refuses expired keys)
- instant cleanup on logout (daemon dies)
- no file forensics possible

file disadvantages:
- vulnerable to disk reads
- TTL is convention only (file can be read directly)
- stale files require cleanup
- backups may capture secrets

### [KHUE] is kernel key-store (keyctl) a better alternative?

kernel key-store provides in-kernel credential storage with TTL. but:
- requires keyctl syscalls
- less portable across systems
- daemon is simpler to implement and debug

---

## claims: grade degradation

### [SUMP] once a credential is encrypted, it should stay encrypted

> (no direct citation — this is a security principle)

if a user stored a key in os.secure (encrypted), to cache it in os.direct (plaintext) degrades its security posture. the keyrack should forbid this.

### [SUMP] duration should not degrade either

transient > ephemeral > permanent (in terms of blast radius). a permanent key should not become more accessible than it was at rest.

### [KHUE] how to prevent accidental degradation?

keyrack must track key.grade and refuse operations that would lower it. this requires grade metadata on every key.

---

## claims: TTL enforcement

### [SUMP] TTL is only real if enforced by a mechanism the caller cannot bypass

file-based TTL: caller can read file directly, ignore TTL metadata.
daemon-based TTL: daemon refuses expired keys. caller cannot bypass.

### [OPIN] 9 hours is a reasonable default TTL for workday

covers a typical workday. shorter TTL increases friction. longer TTL increases blast radius.

### [KHUE] should TTL be per-key or per-session?

per-key allows fine-grained control. per-session is simpler. the vision uses per-key.

---

## summary of irreducible floor

these are fundamental linux behaviors that os.daemon cannot change:

1. **same-login-session processes share the user** — can ptrace each other, read /proc, connect to sockets
2. **env vars are visible via /proc** — any same-user process can read them
3. **root can read all** — no protection against root

os.daemon protects against:
- ✅ different login sessions (kernel-enforced sessionid)
- ✅ filesystem reads (no files on disk)
- ✅ TTL bypass (daemon enforces in memory)
- ✅ grade degradation (keyrack refuses)
- ✅ stale credential residue (daemon dies on logout)

os.daemon does not protect against:
- ❌ same-login-session attacker (irreducible floor)
- ❌ root attacker (irreducible floor)
- ❌ memory forensics while daemon runs (irreducible floor)

---

## citations

[1] [socket(7) man page](https://man7.org/linux/man-pages/man7/socket.7.html)

[2] [Unix Sockets For Auth](https://mivehind.net/2017/05/21/unix-sockets-for-auth/)

[3] [MySQL Socket Peer-Credential Authentication](https://dev.mysql.com/doc/mysql-security-excerpt/8.0/en/socket-pluggable-authentication.html)

[4] [MariaDB Unix Socket Authentication](https://mariadb.com/docs/server/reference/plugins/authentication-plugins/authentication-plugin-unix-socket)

[5] [Linux kernel audit sessionid documentation](https://github.com/torvalds/linux/blob/master/Documentation/ABI/stable/procfs-audit_loginuid)

[6] [proc(5) man page](https://man7.org/linux/man-pages/man5/proc.5.html)

[7] [Kernel patch for /proc/PID/sessionid](https://www.mail-archive.com/linux-kernel@vger.kernel.org/msg2516610.html)

[8] [procfs-audit_loginuid kernel doc](https://www.kernel.org/doc/Documentation/ABI/stable/procfs-audit_loginuid)

[9] [pam_systemd(8) man page](https://www.man7.org/linux/man-pages/man8/pam_systemd.8.html)

[10] [pam_systemd freedesktop](https://www.freedesktop.org/software/systemd/man/latest/pam_systemd.html)

[11] [XDG Base Directory ArchWiki](https://wiki.archlinux.org/title/XDG_Base_Directory)

[12] [Linux: Environment Variable Security](https://linuxvox.com/blog/linux-securing-environment-variables/)

[13] [proc_pid_environ(5) man page](https://man7.org/linux/man-pages/man5/proc_pid_environ.5.html)

[14] [Sandfly Security: Linux Process Environment Variables](https://sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics)

[15] [ptrace(2) man page](https://man7.org/linux/man-pages/man2/ptrace.2.html)

[16] [Kernel Yama ptrace_scope](https://www.kernel.org/doc/Documentation/security/Yama.txt)

[17] [NSA: Limit ptrace on Production Linux Systems](https://media.defense.gov/2019/Jul/16/2002158062/-1/-1/0/CSI-LIMITING-PTRACE-ON-PRODUCTION-LINUX-SYSTEMS.PDF)

[18] [ssh-agent Wikipedia](https://en.wikipedia.org/wiki/Ssh-agent)

[19] [Pitfalls of ssh-agents](https://rabexc.org/posts/pitfalls-of-ssh-agents)

[20] [HackTricks: SSH Forward Agent exploitation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/ssh-forward-agent-exploitation)

[21] [gpg-agent(1) man page](https://linux.die.net/man/1/gpg-agent)

[22] [SSH and GPG Agents](https://nullprogram.com/blog/2012/06/08/)
