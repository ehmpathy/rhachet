wish =

formalize keyrack key security grades and replace os.direct cache with os.daemon for unlock sessions.

---

## 1. key grades

every credential must self-describe its security posture via a grade:

```
KeyrackKey { secret: KeyrackKeySecret, grade: { protection: 'encrypted' | 'plaintext', duration: 'permanent' | 'ephemeral' | 'transient' } }
```

- rename `key.value` → `key.secret`
- track grade on every key and grant
- grades never degrade (encrypted → plaintext = forbidden, permanent → ephemeral = forbidden)

## 2. grant mechanism names

encode duration explicitly in mechanism names:

- `REPLICA` → `PERMANENT_VIA_REPLICA`
- `AWS_SSO` → `EPHEMERAL_VIA_AWS_SSO`
- `GITHUB_APP` → `EPHEMERAL_VIA_GITHUB_APP`

remove default grant mechanism — force explicit acknowledgment of permanent keys.

## 3. os.daemon vault (replace os.direct cache)

the core problem: cache of encrypted keys into os.direct (plaintext on disk) degrades the grade. forbidden.

the solution: os.daemon — in-memory daemon process via unix domain socket.

- findserted per user on first `unlock`
- stores keys in memory (never on disk)
- manages TTL per key
- dies on logout (instant cleanup)
- scope: per-login-session (enforced via kernel sessionid) + per-worksite (convened via keyrack.yml)

## 4. separate unlock from get

uniform access model — same rules for humans and robots:

| who   | unlock                 | get                |
|-------|------------------------|--------------------|
| human | `rhx keyrack unlock`   | their tools do it  |
| robot | inherits session scope | their tools do it  |

- `unlock` = interactive auth → send keys to daemon with TTL
- `get` = read from daemon → export to env (no --unlock flag)
- no session keys in env vars (daemon IS the session)
- mid-session unlock works (no robot restart)

## 5. security boundaries

- per-login-session: enforced by kernel + daemon (secure against malintent)
- per-worksite: convened by rhachet (secure against bonintent only)
- per-terminal-session: eliminated (no kernel primitive, all implementations reintroduce /proc leak)

env vars are fundamentally user-scoped (readable via /proc/* by same-user processes). this is the irreducible floor. os.daemon eliminates the session key and vault file attack surfaces above this floor.

---

## refs

exploration and rationale distilled in:
- `.refs/session-key-transience.preview.md` — session key transience analysis
- `.refs/session-key-transience.threats.md` — threat model for session keys
- `.refs/session-vault.threats-and-guards.md` — vault threat analysis
- `.refs/vault.os-daemon.md` — daemon architecture rationale
- `.refs/eval.login-session-vs-terminal-session.md` — why per-terminal-session was eliminated
- `.refs/eval.unlock-grain-worksite-vs-key.md` — unlock grain analysis
- `0.wish.v0.md` — raw exploration log (30k chars → this distilled version)
