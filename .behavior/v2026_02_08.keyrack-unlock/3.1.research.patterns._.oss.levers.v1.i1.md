# research: oss levers for keyrack unlock

> open source tools available to implement the os.daemon vision

---

## summary

| lever | purpose | recommendation | maintenance |
|-------|---------|----------------|-------------|
| get-peercred | SO_PEERCRED unix socket auth | **consider** | moderate (2022) |
| node-cache | in-memory ttl cache | **consider** | active (2024) |
| xdg-basedir | XDG_RUNTIME_DIR resolution | **consider** | active (2023) |
| daemonize-process | fork to background | **consider** | active (2025) |
| ssh2 (agent pattern) | reference for socket protocol | **reference** | active (2025) |
| kernel keyring (keyctl) | alternative to daemon | **evaluate** | kernel native |
| keytar | os keychain access | **not recommended** | active (2025) |

---

## lever.1: get-peercred

### [CONSIDER]

**what**: native node.js addon to retrieve SO_PEERCRED from unix domain sockets.

**package details**:
- name: `get-peercred`
- version: 1.0.0
- last update: 2022-06-18
- license: CC0-1.0
- dependencies: nan@2.2.1

**citation [1]** (npm registry):
> "Get SO_PEERCRED from a connected UNIX domain socket"

**citation [2]** (socket(7) man page):
> "SO_PEERCRED returns the credentials of the peer process connected to this socket. The returned credentials are those that were in effect at the time of the call to connect(2)."

**usage pattern**:
```ts
import getCred from 'get-peercred';

server.on('connection', (socket) => {
  const { pid, uid, gid } = getCred(socket._handle.fd);
  // verify uid matches daemon uid
  // verify /proc/$pid/sessionid matches daemon sessionid
});
```

**pros**:
- kernel-verified credentials (unforgeable)
- simple api: returns { pid, uid, gid }
- no external dependencies beyond nan

**cons**:
- native addon (requires node-gyp build)
- last update 2022 (moderate maintenance)
- nan dependency may need updates for newer node versions

**alternatives**:
- `unix-socket-credentials` (v0.1.3, 2022) — similar but older
- `@joshiggins/unix-socket-credentials` (v0.2.0, 2022) — uses ffi instead of nan
- shell out to `lsof` or `ss` — no native addon but slower

**verdict**: recommended for SO_PEERCRED. native addon is acceptable tradeoff for kernel-verified auth.

---

## lever.2: node-cache

### [CONSIDER]

**what**: in-memory key-value cache with TTL support.

**package details**:
- name: `node-cache`
- version: 5.1.2
- last update: 2024-10-22
- license: MIT
- repository: github.com/node-cache/node-cache

**citation [3]** (npm registry):
> "Simple and fast NodeJS internal caching. Node internal in memory cache like memcached."

**citation [4]** (node-cache documentation):
> "Keys can have a timeout (ttl) after which they expire and are deleted from the cache. It supports a standard ttl as a number in seconds for every generated cache element."

**usage pattern**:
```ts
import NodeCache from 'node-cache';

const cache = new NodeCache({ stdTTL: 32400 }); // 9h default

// store key with custom TTL
cache.set(slug, keyData, ttlSeconds);

// retrieve (returns undefined if expired)
const keyData = cache.get(slug);

// check TTL left
const ttl = cache.getTtl(slug);
```

**pros**:
- active maintenance (updated 2024)
- widely adopted (memcached-like api)
- built-in TTL enforcement
- automatic cleanup of expired keys
- no external dependencies

**cons**:
- no persistence (memory only) — but this is desired for os.daemon
- single-process only — acceptable for daemon architecture

**alternatives**:
- `ttl-mem-cache` (v4.1.0, 2023) — stream support, similar TTL features
- `cache-manager` — more complex, multi-store support
- raw `Map` with `setTimeout` — simpler but manual TTL management

**verdict**: recommended for daemon key storage. active maintenance, TTL enforcement, memcached-like api.

---

## lever.3: xdg-basedir

### [CONSIDER]

**what**: resolve XDG Base Directory paths with XDG_RUNTIME_DIR.

**package details**:
- name: `xdg-basedir`
- version: 5.1.0
- last update: 2023-03-04
- license: MIT
- repository: github.com/sindresorhus/xdg-basedir
- author: sindresorhus (high-quality npm ecosystem contributor)

**citation [5]** (npm registry):
> "Get XDG Base Directory paths"

**citation [6]** (XDG Base Directory Specification):
> "XDG_RUNTIME_DIR: a single base directory relative to which user-specific non-essential runtime files and other file objects should be stored. The directory MUST be owned by the user, and the user MUST be the only one who has read and write access to it."

**usage pattern**:
```ts
import { xdgRuntime } from 'xdg-basedir';
import { join } from 'path';

const socketPath = join(
  xdgRuntime ?? `/run/user/${process.getuid()}`,
  `keyrack.${sessionId}.sock`
);
```

**pros**:
- authored by sindresorhus (trusted, high-quality)
- handles fallbacks for undefined XDG_RUNTIME_DIR
- pure javascript (no native dependencies)
- typed (typescript definitions included)

**cons**:
- esm-only in v5+ (may need import() for cjs projects)

**alternatives**:
- `xdg-portable` — similar functionality
- `@folder/xdg` — cross-platform (macos, windows)
- manual resolution: `process.env.XDG_RUNTIME_DIR ?? '/run/user/${uid}'`

**verdict**: recommended. high-quality package, handles edge cases, trusted author.

---

## lever.4: daemonize-process

### [CONSIDER]

**what**: fork current node.js process to background as daemon.

**package details**:
- name: `daemonize-process`
- version: 4.1.1
- last update: 2025-02-14
- license: MIT

**citation [7]** (npm registry):
> "Daemonize the current Node.js process"

**usage pattern**:
```ts
import daemonize from 'daemonize-process';

if (!process.env.DAEMON_STARTED) {
  daemonize(); // forks to background, parent exits
  process.env.DAEMON_STARTED = '1';
}

// daemon continues here
server.listen(socketPath);
```

**pros**:
- active maintenance (updated 2025)
- simple api: call and process forks
- handles setsid, stdin/stdout/stderr redirection

**cons**:
- daemon lifecycle management is still manual
- no built-in health check or restart

**alternatives**:
- `daemonize2` (v0.4.2, 2022) — older, systemv init.d focus
- `node-linux` — creates systemd/init.d service files
- `pm2` — full process manager (overkill for embedded daemon)
- manual `child_process.spawn` with detached:true

**verdict**: recommended for simple daemon fork. handles posix daemonization correctly.

---

## lever.5: ssh2 agent pattern (reference)

### [REFERENCE]

**what**: reference implementation for unix socket agent protocol.

**package details**:
- name: `ssh2`
- version: 1.17.0
- last update: 2025-10-13
- license: MIT
- repository: github.com/mscdex/ssh2
- author: mscdex (established node.js developer)

**citation [8]** (ssh2 documentation):
> "SSH2 client and server modules written in pure JavaScript for node.js"

**citation [9]** (ssh-agent pattern):
> "The ssh2 library has an OpenSSHAgent class implementation that communicates with OpenSSH agents over a UNIX socket. The ssh2 client can be configured with an agent parameter that specifies the path to ssh-agent's UNIX socket."

**relevance to os.daemon**:

the ssh-agent pattern demonstrates:
1. daemon listens on unix socket in XDG_RUNTIME_DIR
2. clients connect, send commands, receive responses
3. daemon holds secrets in memory (never on disk)
4. session scope via socket file lifecycle

keyrack daemon can follow similar pattern:
- `keyrack.$sessionid.sock` in XDG_RUNTIME_DIR
- commands: UNLOCK, GET, STATUS, RELOCK
- json protocol (simpler than ssh-agent binary protocol)

**verdict**: valuable reference for socket protocol design. not a direct dependency.

---

## lever.6: linux kernel keyring (keyctl)

### [EVALUATE]

**what**: kernel-native secret storage with session isolation and TTL.

**citation [10]** (Cloudflare blog):
> "The Linux Kernel Key Retention Service is a kernel subsystem that stores cryptographic keys and secrets outside process address space... the keys are stored outside the process address space... the keys lifecycle can be implicitly bound to the process lifecycle."

**citation [11]** (kernel documentation):
> "The service provides three process-level keyrings: Process Keyring (private to single process), Thread Keyring (isolated to individual threads), Session Keyring (shared across a process and its children)."

**citation [12]** (kernel.org):
> "/proc/$pid/sessionid: This read-only file contains the audit session ID of the process. It is set when the user logs in and is inherited by all processes started by the login session."

**pros**:
- kernel-native (no userspace daemon process)
- session keyring matches login session scope
- built-in TTL support
- keys never leave kernel space (higher security)
- automatic cleanup on session end

**cons**:
- requires libkeyutils syscall interface
- no maintained node.js bindings found
- less portable (linux-only, not available in containers without cap)
- more complex api than userspace daemon
- harder to debug and observe

**node.js access**:
- no direct npm package found
- would require: native addon or child_process to keyctl cli
- atom/node-keytar issue #7 suggests keyctl as alternative to gnome-keyring

**comparison to daemon**:

| aspect | kernel keyring | userspace daemon |
|--------|---------------|------------------|
| isolation | kernel-enforced | socket + sessionid check |
| TTL | kernel-enforced | daemon-enforced |
| portability | linux only, needs caps | any unix with sockets |
| observability | harder | easier (logs, debug) |
| implementation | native addon needed | pure node.js possible |

**verdict**: evaluate as future enhancement. daemon is simpler to implement and debug. kernel keyring could be future "hardened mode" for high-security environments.

---

## lever.7: keytar

### [NOT RECOMMENDED]

**what**: native bindings to os keychain (gnome-keyring on linux, keychain on macos).

**package details**:
- name: `keytar`
- version: 7.9.0
- last update: 2025-07-30
- license: MIT
- repository: github.com/atom/node-keytar

**citation [13]** (npm registry):
> "Bindings to native Mac/Linux/Windows password APIs"

**citation [14]** (keytar documentation):
> "A native Node module to get, add, replace, and delete passwords in system's keychain. On Linux it uses Gnome Keyring."

**why not recommended**:

1. **requires gnome-keyring daemon** — adds external dependency
2. **dbus dependency** — gnome-keyring uses dbus, another part to manage
3. **no session isolation** — keyring is per-user, not per-login-session
4. **persistent storage** — keys survive logout (violates os.daemon goal)
5. **native addon** — requires node-gyp, libsecret-dev

**citation [15]** (Secret Service overview):
> "The Secret Service backend uses the libsecret library and requires a secret service daemon (such as Gnome Keyring or KWallet), and uses D-Bus to communicate."

os.daemon is simpler:
- no external daemon dependency
- session-scoped by design
- dies on logout (no cleanup needed)
- no dbus complexity

**verdict**: not recommended. adds complexity without benefit. os.daemon achieves goals with simpler architecture.

---

## implementation path

based on the research, the recommended implementation path:

### phase 1: core daemon (node.js native)

```
dependencies
├─ node net module (unix socket server)
├─ node fs module (read /proc/$pid/sessionid)
├─ get-peercred (SO_PEERCRED for caller auth)
├─ node-cache (in-memory TTL storage)
├─ xdg-basedir (socket path resolution)
└─ daemonize-process (fork to background)
```

### phase 2: socket protocol

```
protocol (json over unix socket)
├─ UNLOCK { keys[], duration } → store keys with TTL
├─ GET { slugs[] } → return keys by slug
├─ STATUS → list keys with TTL left
└─ RELOCK { slugs[]? } → purge keys
```

### phase 3: security checks

```
auth flow
├─ SO_PEERCRED → get caller pid, uid
├─ verify uid === daemon uid
├─ read /proc/$caller_pid/sessionid
├─ verify sessionid === daemon sessionid
└─ if all pass → process command
```

### future: kernel keyring mode

```
hardened mode (future)
├─ use keyctl instead of userspace daemon
├─ keys never leave kernel
├─ requires native addon or cli wrapper
└─ higher security, lower portability
```

---

## gaps identified

### gap.1: /proc sessionid verification

no npm package found for read of /proc/$pid/sessionid. must implement:

```ts
import { readFileSync } from 'fs';

const getSessionId = (pid: number): string => {
  return readFileSync(`/proc/${pid}/sessionid`, 'utf8').trim();
};
```

### gap.2: socket path length

unix socket paths have ~108 byte limit. socket path must be short:

```
/run/user/1000/keyrack.123456.sock  // ~35 bytes, safe
```

### gap.3: daemon health check

need mechanism for clients to detect stale socket:
- attempt connect with timeout
- if socket exists but daemon dead → remove socket, restart

---

## citations

[1] npm: get-peercred — https://www.npmjs.com/package/get-peercred

[2] socket(7) man page — https://man7.org/linux/man-pages/man7/socket.7.html

[3] npm: node-cache — https://www.npmjs.com/package/node-cache

[4] node-cache github — https://github.com/node-cache/node-cache

[5] npm: xdg-basedir — https://www.npmjs.com/package/xdg-basedir

[6] XDG Base Directory Specification — https://wiki.archlinux.org/title/XDG_Base_Directory

[7] npm: daemonize-process — https://www.npmjs.com/package/daemonize-process

[8] ssh2 github — https://github.com/mscdex/ssh2

[9] ssh-agent unix socket pattern — https://www.npmjs.com/package/ssh-agent

[10] Cloudflare: Linux Kernel Key Retention Service — https://blog.cloudflare.com/the-linux-kernel-key-retention-service-and-why-you-should-use-it-in-your-next-application/

[11] kernel.org: procfs-audit_loginuid — https://www.kernel.org/doc/Documentation/ABI/stable/procfs-audit_loginuid

[12] proc(5) man page — https://man7.org/linux/man-pages/man5/proc.5.html

[13] npm: keytar — https://www.npmjs.com/package/keytar

[14] keytar github — https://github.com/atom/node-keytar

[15] Linux Secret Service / D-Bus — https://rtfm.co.ua/en/what-is-linux-keyring-gnome-keyring-secret-service-and-d-bus/

