# blackbox criteria: keyrack-sudo polish

## usecase.1 = sudo roundtrip journey (os.secure vault)

the core happy path: set a sudo key, verify it's locked by default, unlock it, get the value, relock, verify locked again.

```
given('a repo with keyrack init complete and ssh key available')
  when('set --key MY_SUDO_TOKEN --env sudo --vault os.secure with stdin value')
    then('key is stored in encrypted host manifest')
      sothat('sudo credentials stay invisible to the codebase')
    then('key does NOT appear in keyrack.yml')
      sothat('sudo keys are never leaked to plaintext config')

  when('list after set')
    then('output includes MY_SUDO_TOKEN with env: sudo and vault: os.secure')
      sothat('the human can verify the key was stored')

  when('get --key MY_SUDO_TOKEN --env sudo before unlock')
    then('status is "locked" with unlock hint')
      sothat('sudo keys are gated behind explicit unlock')
    then('no secret value is returned')

  when('unlock --env sudo --key MY_SUDO_TOKEN')
    then('reports "1 key unlocked" (not "0")')
      sothat('the human sees confirmation the unlock succeeded')

  when('get --key MY_SUDO_TOKEN --env sudo after unlock')
    then('status is "granted" and value matches what was set')
      sothat('roundtrip proves the secret was stored and retrieved correctly')

  when('relock')
    then('reports keys relocked')

  when('get --key MY_SUDO_TOKEN --env sudo after relock')
    then('status is "locked" again')
      sothat('relock actually purges the daemon cache')
```

## usecase.2 = sudo roundtrip journey (os.direct vault)

same flow but with os.direct vault — plaintext storage, still gated behind daemon for sudo env.

```
given('a repo with keyrack init complete')
  when('set --key MY_DIRECT_SUDO --env sudo --vault os.direct with stdin value')
    then('key is stored in host manifest')
    then('key does NOT appear in keyrack.yml')

  when('get --key MY_DIRECT_SUDO --env sudo before unlock')
    then('status is "locked"')
      sothat('even os.direct sudo keys require explicit unlock')

  when('unlock --env sudo --key MY_DIRECT_SUDO')
    then('reports "1 key unlocked"')

  when('get --key MY_DIRECT_SUDO --env sudo after unlock')
    then('value matches what was set')

  when('relock --env sudo')
    then('sudo keys relocked, regular keys untouched')
```

## usecase.3 = regular key roundtrip (os.direct vault)

regular (non-sudo) keys via os.direct — should work without unlock for direct vault access.

```
given('a repo with keyrack.yml and os.direct vault configured')
  when('set --key MY_API_KEY --vault os.direct with stdin value')
    then('key appears in both host manifest and keyrack.yml')

  when('get --key MY_API_KEY')
    then('value is returned directly (no unlock required)')
      sothat('regular keys via os.direct are always accessible')
```

## usecase.4 = regular key roundtrip (os.secure vault)

regular (non-sudo) keys via os.secure — requires vault unlock but not daemon unlock.

```
given('a repo with keyrack.yml and os.secure vault configured')
  when('set --key SECURE_KEY --vault os.secure with stdin value')
    then('key appears in host manifest and keyrack.yml')

  when('get --key SECURE_KEY before vault unlock')
    then('prompts for passphrase or uses session identity')

  when('unlock then get --key SECURE_KEY')
    then('value matches what was set')
```

## usecase.5 = stdin value piped into set (os.direct)

the 38 pre-extant failures: acceptance tests cannot pipe values into `keyrack set` for os.direct vault.

```
given('a repo with keyrack init complete')
  when('echo "my-secret" | keyrack set --key X --vault os.direct')
    then('value is stored from stdin')
      sothat('acceptance tests can automate set without interactive prompts')

  when('keyrack get --key X')
    then('value matches "my-secret"')
```

## usecase.6 = snapshot consistency

output format must match snapshots — the 4 pre-extant mismatches in cases 5, 6 (status/list output).

```
given('a repo with keys configured')
  when('keyrack status')
    then('output matches snapshot exactly')
      sothat('output format is stable and reviewable in prs')

  when('keyrack list')
    then('output matches snapshot exactly')
```

## usecase.7 = vault path structure

vaults persist at the symmetric path `~/.rhachet/keyrack/vault/{vault-type}/`.

```
given('a repo with keyrack init complete')
  when('set --vault os.secure stores a credential')
    then('encrypted .age file exists at ~/.rhachet/keyrack/vault/os.secure/{hash}.age')

  when('set --vault os.direct stores a credential')
    then('json store exists at ~/.rhachet/keyrack/vault/os.direct/keyrack.direct.json')
```
