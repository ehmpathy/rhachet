# vision: keyrack-sudo polish

## the outcome world

### before (now)

the keyrack sudo feature was implemented across phases 0-9 against the v2026_02_09 behavior. the core architecture is sound — encrypted host manifests, daemon-only grant path, per-owner isolation, TTL enforcement. but the last mile has gaps:

- `keyrack unlock --env sudo --key MY_SUDO_TOKEN` reports "0 keys unlocked" even though the key exists and the vault is accessible
- no roundtrip acceptance test proves set → unlock → get → relock works end-to-end
- the playtest runbook lacks get-after-set verification steps
- unclear whether the implementation matches the intended architecture (no post-execution review snapshot)

the human tried the feature, hit "0 keys unlocked", and lost confidence. the feature *looks* done but doesn't *feel* done.

### after (polished)

- the human runs `keyrack unlock --env sudo --key MY_SUDO_TOKEN` and sees "1 key unlocked"
- `keyrack get --key MY_SUDO_TOKEN --env sudo` returns the stored value
- a journey acceptance test replicates the exact playtest flow: init → set sudo key → set regular key → list → unlock → get → relock → get-returns-locked
- the architecture review confirms no leaky abstractions — sudo keys stay invisible in keyrack.yml, grant resolution stops at daemon for sudo, vault access is gated
- the human receives a clear "ready to playtest" signal with confidence

### the "aha" moment

the human runs the smoke test from the playtest runbook, every step succeeds, and the roundtrip acceptance test passes green. the feature that was 95% done crosses the finish line.

## user experience

### the journey (what the acceptance test replicates)

```
# 1. init keyrack — discovers ssh key, creates encrypted manifest
./bin/run keyrack init

# 2. set a sudo credential into os.secure vault
echo "s3cr3t-token" | ./bin/run keyrack set --key MY_SUDO_TOKEN --env sudo --vault os.secure

# 3. verify it's listed with env: sudo
./bin/run keyrack list
#   ├─ ehmpathy.sudo.MY_SUDO_TOKEN
#   │  ├─ env: sudo
#   │  └─ vault: os.secure

# 4. get without unlock → "locked" (not "granted", not error)
./bin/run keyrack get --key MY_SUDO_TOKEN --env sudo
#   status: locked
#   hint: run `keyrack unlock --env sudo --key MY_SUDO_TOKEN`

# 5. unlock the sudo key → "1 key unlocked" (not "0")
./bin/run keyrack unlock --env sudo --key MY_SUDO_TOKEN
#   done. 1 key unlocked.

# 6. get after unlock → returns value
./bin/run keyrack get --key MY_SUDO_TOKEN --env sudo
#   s3cr3t-token

# 7. relock → purges from daemon
./bin/run keyrack relock
#   done. keys relocked.

# 8. get after relock → "locked" again
./bin/run keyrack get --key MY_SUDO_TOKEN --env sudo
#   status: locked
```

### inputs & outputs

| operation | input | output |
|-----------|-------|--------|
| set sudo key | `--key X --env sudo --vault os.secure` + stdin value | stored in encrypted manifest only |
| unlock sudo key | `--env sudo --key X` | `N keys unlocked` (N > 0) |
| get locked sudo key | `--key X --env sudo` | status: locked + hint |
| get unlocked sudo key | `--key X --env sudo` | the secret value |
| relock | (no args) or `--env sudo` | keys purged from daemon |

## mental model

> "sudo keys are like a safe deposit box at a bank. the bank knows you have a box (it's in their encrypted records), but nobody can see what's inside from the outside (not in keyrack.yml). to access it, you show your key (ssh key), the banker opens the vault (unlock), and you get your item (get). when you leave (relock or TTL expires), the vault closes again."

the human would describe it as: "keyrack sudo lets me store sensitive tokens that are invisible to the codebase — they only exist in my encrypted host manifest, and i have to explicitly unlock them each session."

## evaluation

### what works well
- security model is sound: sudo keys never leak into keyrack.yml
- per-owner isolation means robots get their own encrypted manifests
- TTL enforcement caps exposure window (30m default for sudo)
- cipher-aware path handles both passwordless and passphrase-protected keys

### what needs repair
- **defect**: unlock reports "0 keys unlocked" — the core happy path is broken
- **defect**: 38 failures related to `keyrack set` stdin for os.direct vault — acceptance tests can't pipe values into set
- **defect**: 4 snapshot mismatches in cases 5, 6 — output format drifted from snapshots
- **gap**: no roundtrip acceptance test (set → get → unlock → get → relock → get)
- **gap**: playtest runbook not updated with get-after-set verification steps
- **gap**: no architecture review snapshot to confirm implementation matches blueprint

### what's out of scope (deferred)
- `--prikey` acceptance test — deferred due to test infrastructure complexity
- `--stanza ssh` prevention flow — deferred
