# research: prod codepath patterns

## pattern.1 â€” grant resolution order [REUSE]

the core grant resolution chain in `getKeyrackKeyGrant.ts` follows a strict order: envvar â†’ daemon â†’ vault (or locked for sudo).

**[1]** `src/domain.operations/keyrack/getKeyrackKeyGrant.ts:56-123`
```
resolution order: os.envvar (ci passthrough) â†’ os.daemon (session cache) â†’ host manifest vault
```

**[2]** `src/domain.operations/keyrack/getKeyrackKeyGrant.ts:155-164` â€” the sudo lock gate:
```ts
// sudo keys: daemon is the ONLY authorized grant path (after envvar passthrough)
// never fall through to direct vault access â€” must unlock first
if (isSudoKey) {
  return {
    status: 'locked',
    slug,
    message: `sudo credential '${slug}' is locked. unlock it first.`,
    fix: `run: rhx keyrack unlock --env sudo --key ${slug}`,
  };
}
```

**relation**: this pattern is the core of the roundtrip flow. the "0 keys unlocked" defect is NOT here â€” this path correctly returns `status: 'locked'`. the defect is in the unlock flow (pattern.2).

---

## pattern.2 â€” sudo unlock key resolution [EXTEND]

the unlock flow resolves sudo keys by name from the host manifest.

**[3]** `src/domain.operations/keyrack/session/unlockKeyrack.ts:58-94` â€” sudo key search:
```ts
if (env === 'sudo') {
  // ...
  slugsForEnv = Object.entries(context.hostManifest.hosts)
    .filter(([slug, hostConfig]) => {
      const parts = slug.split('.');
      const slugEnv = parts[1];
      const slugKey = parts.slice(2).join('.');
      if (isFullSlug) {
        return slug === keyInput && slugEnv === 'sudo';
      }
      return slugEnv === 'sudo' && slugKey === keyInput;
    })
    .map(([slug]) => slug);
```

**relation**: this is where the "0 keys unlocked" defect likely lives. if `slugsForEnv` comes back empty, zero keys are unlocked. need to verify the filter logic matches the slug format produced by `keyrack set --env sudo`.

---

## pattern.3 â€” vault path resolution [REUSE]

both vault adapters resolve paths via `process.env.HOME` (not `os.homedir()`) for test isolation.

**[4]** `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsSecure.ts:39-42`:
```ts
const getSecureVaultDir = (): string => {
  const home = getHomeDir();
  return join(home, '.rhachet', 'keyrack', 'vault', 'os.secure');
};
```

**[5]** `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsDirect.ts:38-48`:
```ts
const getDirectStorePath = (): string => {
  const home = getHomeDir();
  return join(home, '.rhachet', 'keyrack', 'vault', 'os.direct', 'keyrack.direct.json');
};
```

**relation**: already updated to the new symmetric path structure per the vault path refactor in this session. [REUSE] as-is.

---

## pattern.4 â€” credential file hash [REUSE]

os.secure uses truncated sha256 of the slug as the filename.

**[6]** `src/domain.operations/keyrack/adapters/vaults/vaultAdapterOsSecure.ts:48-51`:
```ts
const getCredentialPath = (slug: string): string => {
  const hash = asHashSha256Sync(slug).slice(0, 16);
  return join(getSecureVaultDir(), `${hash}.age`);
};
```

**relation**: no change needed. the hash is deterministic and stable.

---

## pattern.5 â€” stdin value input via promptHiddenInput [EXTEND]

`keyrack set` reads values via `promptHiddenInput` â€” this is the root cause of the 38 stdin failures.

**[7]** `src/contract/cli/invokeKeyrack.ts:509-519`:
```ts
let value: string | null = null;
const vaultsNeedValue: KeyrackHostVault[] = ['os.secure', 'os.direct'];
if (vaultsNeedValue.includes(opts.vault as KeyrackHostVault)) {
  value = await promptHiddenInput({
    prompt: `enter value for ${opts.key}: `,
  });
  if (!value) {
    throw new BadRequestError(`value required for vault ${opts.vault}`);
  }
}
```

**relation**: `promptHiddenInput` likely reads from tty, not stdin. acceptance tests pipe via `echo "val" |` which goes to stdin, not tty. need to check if `promptHiddenInput` can fall back to stdin when tty is unavailable, or if a `--value` flag / stdin detection is needed.

---

## pattern.6 â€” identity sync from manifest to vault [REUSE]

the grant context builder syncs the session identity (from manifest decryption) into the os.secure vault adapter.

**[8]** `src/domain.operations/keyrack/genKeyrackGrantContext.ts:57-62`:
```ts
// sync identity from manifest DAO to os.secure vault adapter
const manifestIdentity = daoKeyrackHostManifest.getSessionIdentity();
if (manifestIdentity) {
  setOsSecureSessionIdentity(manifestIdentity);
}
```

**relation**: this enables os.secure vault decryption without a separate passphrase â€” the identity from manifest decryption is reused. critical for the roundtrip flow where set + get both need vault access.

---

## pattern.7 â€” duration defaults by env [REUSE]

sudo keys default to 30m TTL, regular keys to 9h.

**[9]** `src/domain.operations/keyrack/session/unlockKeyrack.ts:44-46`:
```ts
const defaultDuration = input.env === 'sudo' ? '30m' : '9h';
const requestedDurationMs = parseDuration(input.duration ?? defaultDuration);
```

**[10]** `src/domain.operations/keyrack/session/unlockKeyrack.ts:168-179` â€” maxDuration cap:
```ts
let effectiveDurationMs = requestedDurationMs;
if (hostConfig.maxDuration) {
  const maxDurationMs = parseDuration(hostConfig.maxDuration);
  if (requestedDurationMs > maxDurationMs) {
    effectiveDurationMs = maxDurationMs;
    console.warn(`âš ï¸ duration capped to ${hostConfig.maxDuration} for key ${slug}`);
  }
}
```

**relation**: no change needed. behavior matches criteria.

---

## pattern.8 â€” CLI output tree format [REUSE]

all keyrack commands use a consistent tree format with unicode box-draw characters.

**[11]** `src/contract/cli/invokeKeyrack.ts:393-399` â€” locked output:
```ts
} else if (attempt.status === 'locked') {
  console.log(`   â””â”€ ${attempt.slug}`);
  console.log(`      â””â”€ status: locked ğŸ”’`);
  if (attempt.fix) {
    console.log(`         â””â”€ fix: ${attempt.fix}`);
  }
  console.log('done. 1 locked.');
```

**[12]** `src/contract/cli/invokeKeyrack.ts:687-695` â€” unlock output:
```ts
console.log(`${prefix} ${key.slug}`);
console.log(`${indent}â”œâ”€ env: ${key.env}`);
console.log(`${indent}â”œâ”€ org: ${key.org}`);
console.log(`${indent}â”œâ”€ vault: ${key.vault}`);
console.log(`${indent}â””â”€ expires in: ${expiresIn}m`);
```

**relation**: the 4 snapshot mismatches are likely due to new fields (env, org) added to status/list output that were absent from the snapshots. need to resnap after verified output is correct.

---

## summary

| # | pattern | disposition | why |
|---|---------|------------|-----|
| 1 | grant resolution order | [REUSE] | sudo lock gate works correctly |
| 2 | sudo unlock key resolution | [EXTEND] | likely root cause of "0 keys unlocked" defect |
| 3 | vault path resolution | [REUSE] | already updated to symmetric paths |
| 4 | credential file hash | [REUSE] | stable, deterministic |
| 5 | stdin value input | [EXTEND] | root cause of 38 acceptance test failures |
| 6 | identity sync manifest â†’ vault | [REUSE] | enables passphrase-free roundtrip |
| 7 | duration defaults by env | [REUSE] | 30m sudo, 9h regular |
| 8 | CLI output tree format | [REUSE] | snapshots need resnap after field additions |
