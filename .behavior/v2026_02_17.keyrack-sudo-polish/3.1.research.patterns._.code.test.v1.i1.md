# research: test codepath patterns

## pattern.1 — genTestTempRepo fixture setup [REUSE]

the primary mechanism for test isolation: creates a fresh temp repo from a fixture template with SSH keys, encrypted manifests, and git init.

**[1]** `accept.blackbox/.test/infra/genTestTempRepo.ts:67-122` — core function:
```ts
export const genTestTempRepo = async (input: {
  /** fixture template to use */
  fixture: TestRepoFixture;
  /** optional unique suffix for the repo name */
  suffix?: string;
  /** run pnpm install after copy (for fixtures with package.json) */
  install?: boolean;
}): Promise<{
  /** absolute path to the test repo */
  path: string;
}>
```

**[2]** `accept.blackbox/.test/infra/genTestTempRepo.ts:78-81` — unique temp dir:
```ts
const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
const suffix = input.suffix ? `-${input.suffix}` : '';
const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${suffix}`);
```

**[3]** `accept.blackbox/.test/infra/genTestTempRepo.ts:94-98` — key steps after fixture copy:
```ts
// setup .ssh directory with test key so findDefaultSshKey() works
setupTestSshKey({ repoPath });

// convert old manifest format to encrypted format if needed
await convertLegacyManifest({ repoPath });
```

**relation**: [REUSE] as-is. the roundtrip acceptance tests will call `genTestTempRepo({ fixture: 'with-keyrack-multi-env' })` for sudo scenarios and `genTestTempRepo({ fixture: 'with-vault-os-direct' })` or `with-vault-os-secure` for regular vault tests.

---

## pattern.2 — SSH key provision and age recipient [REUSE]

test SSH keys are copied into `$HOME/.ssh/` so auto-discovery works. the age recipient is pre-derived for manifest encryption.

**[4]** `accept.blackbox/.test/infra/genTestTempRepo.ts:23-36` — test key constants:
```ts
const TEST_SSH_KEY_DIR = resolve(__dirname, '../../../src/.test/assets/keyrack/ssh');

const TEST_SSH_PUBKEY = readFileSync(
  join(TEST_SSH_KEY_DIR, 'test_key_ed25519.pub'),
  'utf8',
).trim();
export const TEST_SSH_AGE_RECIPIENT = sshPubkeyToAgeRecipient({
  pubkey: TEST_SSH_PUBKEY,
});
```

**[5]** `accept.blackbox/.test/infra/genTestTempRepo.ts:267-283` — key copy into temp repo:
```ts
const setupTestSshKey = (input: { repoPath: string }): void => {
  const sshDir = join(input.repoPath, '.ssh');
  if (!existsSync(sshDir)) mkdirSync(sshDir, { mode: 0o700 });
  const prikeyDst = join(sshDir, 'id_ed25519');
  const pubkeyDst = join(sshDir, 'id_ed25519.pub');
  // ...copy + chmod
};
```

**relation**: [REUSE] as-is. test key provision is already correct — it supports identity-based decryption which the sudo roundtrip requires.

---

## pattern.3 — legacy manifest conversion [REUSE]

fixtures ship with old `keyrack.manifest.json`; genTestTempRepo converts them at setup time to encrypted `keyrack.host.age` with recipient-based encryption.

**[6]** `accept.blackbox/.test/infra/genTestTempRepo.ts:128-202` — conversion flow:
```ts
const convertLegacyManifest = async (input: { repoPath: string }): Promise<void> => {
  const oldPath = join(input.repoPath, '.rhachet', 'keyrack.manifest.json');
  const newDir = join(input.repoPath, '.rhachet', 'keyrack');
  const newPath = join(newDir, 'keyrack.host.age');
  // ...read old, convert format, encrypt to test recipient, write new, delete old
};
```

**[7]** `accept.blackbox/.test/infra/genTestTempRepo.ts:159-173` — slug parse during conversion:
```ts
for (const [slug, host] of Object.entries(oldManifest.hosts ?? {})) {
  const hostData = host as Record<string, unknown>;
  const parts = slug.split('.');
  const org = parts.length >= 3 ? parts[0] : 'unknown';
  const env = parts.length >= 3 ? parts[1] : 'all';
  newManifest.hosts[slug] = {
    ...hostData,
    env: (hostData.env as string) ?? env,
    org: (hostData.org as string) ?? org,
    vaultRecipient: null,
    maxDuration: null,
  };
}
```

**relation**: [REUSE] as-is. the conversion adds env and org fields which the sudo flow depends on. the roundtrip test can rely on converted manifests.

---

## pattern.4 — os.secure credential re-encryption [REUSE]

fixture `.age` files use passphrase encryption; conversion re-encrypts them to the test SSH recipient so identity-based decryption works.

**[8]** `accept.blackbox/.test/infra/genTestTempRepo.ts:209-241` — re-encryption:
```ts
const convertOsSecureCredentials = async (input: {
  repoPath: string;
  recipient: KeyrackKeyRecipient;
}): Promise<void> => {
  const secureDir = join(input.repoPath, '.rhachet', 'keyrack', 'vault', 'os.secure');
  // ...iterate .age files, match hash to known slug, re-encrypt with test recipient
};
```

**[9]** `accept.blackbox/.test/infra/genTestTempRepo.ts:43-45` — known values for re-encryption:
```ts
const KNOWN_OS_SECURE_VALUES: Record<string, string> = {
  'testorg.test.SECURE_API_KEY': 'portable-secure-value-xyz789',
};
```

**relation**: [EXTEND] — for the roundtrip to cover os.secure sudo keys, we need to either (a) add the sudo key slug to `KNOWN_OS_SECURE_VALUES`, or (b) create the os.secure entry via `keyrack set` in the test setup. option (b) is preferred since it tests the set flow too.

---

## pattern.5 — invokeRhachetCliBinary [EXTEND]

the core black-box invocation mechanism. spawns the compiled binary with `spawnSync` and `shell: '/bin/bash'`.

**[10]** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:36-67`:
```ts
export const invokeRhachetCliBinary = (input: {
  binary?: 'rhachet' | 'rhx';
  args: string[];
  cwd: string;
  stdin?: string;
  logOnError?: boolean;
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const binPath = input.binary === 'rhx' ? RHX_BIN : RHACHET_BIN;
  const result = spawnSync(binPath, input.args, {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
    env: { ...process.env, ...input.env },
  });
  // ...
};
```

**[11]** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:51-53` — stdin pipe:
```ts
const result = spawnSync(binPath, input.args, {
  // ...
  input: input.stdin,
```

**critical note**: `spawnSync` with `input:` pipes data to the child's stdin. however, the production code at `invokeKeyrack.ts:509-519` uses `promptHiddenInput` which reads from tty, NOT stdin. this mismatch is the root cause of the 38 acceptance test failures. the fix must be in prod code (to detect piped stdin) not in test infra.

**relation**: [EXTEND] — the `stdin` mechanism is already correct for test purposes. the fix is in prod code (`promptHiddenInput` must fall back to stdin when tty is unavailable). no change needed in test infra, but the roundtrip tests will rely on this stdin pipe for `keyrack set`.

---

## pattern.6 — invokeRhachetCliBinaryChain [REUSE]

chains multiple CLI commands with `&&`, redirects all but last to `/dev/null`.

**[12]** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:75-111`:
```ts
export const invokeRhachetCliBinaryChain = (input: {
  binary?: 'rhachet' | 'rhx';
  argsChain: string[][];
  cwd: string;
  logOnError?: boolean;
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const commands = input.argsChain.map((args, i) => {
    const cmd = `"${binPath}" ${args.map((a) => `"${a}"`).join(' ')}`;
    return i < input.argsChain.length - 1 ? `${cmd} > /dev/null` : cmd;
  });
  const chainedCommand = commands.join(' && ');
```

**relation**: [REUSE] for potential multi-step flows (set then list, unlock then get). but the roundtrip test is better served by individual `invokeRhachetCliBinary` calls since we need intermediate assertions.

---

## pattern.7 — asSnapshotSafe [REUSE]

strips machine-specific content from CLI output for stable snapshots.

**[13]** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:8-23`:
```ts
export const asSnapshotSafe = (output: string): string => {
  return (
    output
      .replace(/\[keyrack-daemon\] spawned background daemon \(pid: \d+\)\n?/g, '')
      .replace(/\/(?:home\/[^/]+|Users\/[^/]+|runner\/work)\/[^)\s]+/g, '/PATH_STRIPPED')
      .replace(/\/tmp\/rhachet-test-[a-z0-9-]+/g, '/TMP_REPO')
      .replace(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/g, '__TIMESTAMP__')
  );
};
```

**relation**: [REUSE] as-is. used for human-readable output snapshots.

---

## pattern.8 — writeDirectStoreEntry [REUSE]

pre-populates the os.direct vault store for tests that need values without a call to `keyrack set`.

**[14]** `accept.blackbox/.test/infra/writeDirectStoreEntry.ts:10-35`:
```ts
export const writeDirectStoreEntry = (input: {
  home: string;
  slug: string;
  value: string;
}): void => {
  const path = join(input.home, '.rhachet', 'keyrack', 'vault', 'os.direct', 'keyrack.direct.json');
  // ...read or create empty, add entry, write back
};
```

**relation**: [REUSE] for pre-seed of values in tests that need to verify get/unlock without a call to set first. the roundtrip test should NOT use this — it should test the real set flow.

---

## pattern.9 — killKeyrackDaemonForTests [REUSE]

cleanup mechanism that kills stale daemons before test suites.

**[15]** `accept.blackbox/.test/infra/killKeyrackDaemonForTests.ts:10-79`:
```ts
export const killKeyrackDaemonForTests = (input?: {
  owner?: string | null;
}): { killed: boolean; pid: number | null } => {
  const sessionidPath = `/proc/${process.pid}/sessionid`;
  // ...read session id, construct socket path, read pid file, kill process, cleanup files
};
```

**[16]** `accept.blackbox/cli/keyrack.sudo.acceptance.test.ts:18-20` — usage:
```ts
beforeAll(() => {
  killKeyrackDaemonForTests({ owner: null });
});
```

**relation**: [REUSE] — critical for the roundtrip test. the daemon must be killed before the test to ensure fresh state. the roundtrip test must also kill the daemon between relock and get-after-relock to verify cache purge.

---

## pattern.10 — sudo acceptance test structure [EXTEND]

the current sudo test file covers 15 cases but lacks a roundtrip journey. each case creates its own repo — no end-to-end flow.

**[17]** `accept.blackbox/cli/keyrack.sudo.acceptance.test.ts:25-28` — per-case repo creation:
```ts
given('[case1] sudo credential set', () => {
  const repo = useBeforeAll(async () =>
    genTestTempRepo({ fixture: 'with-keyrack-multi-env' }),
  );
```

**[18]** `accept.blackbox/cli/keyrack.sudo.acceptance.test.ts:800-828` — case10 setup with pre-populated store:
```ts
given('[case10] get sudo credential', () => {
  const repo = useBeforeAll(async () => {
    const r = await genTestTempRepo({ fixture: 'with-keyrack-multi-env' });
    writeDirectStoreEntry({
      home: r.path,
      slug: 'testorg.sudo.SUDO_GET_TEST',
      value: 'test-sudo-secret-value',
    });
    await invokeRhachetCliBinary({
      args: ['keyrack', 'set', '--key', 'SUDO_GET_TEST', '--env', 'sudo', '--mech', 'REPLICA', '--vault', 'os.direct'],
      cwd: r.path,
      env: { HOME: r.path },
      stdin: 'sudo-get-test-value\n',
    });
    return r;
  });
```

**[19]** `accept.blackbox/cli/keyrack.sudo.acceptance.test.ts:857-885` — unlock-then-get flow:
```ts
when('[t1] get --key after unlock (shows granted)', () => {
  const result = useBeforeAll(async () => {
    // first unlock the key
    await invokeRhachetCliBinary({
      args: ['keyrack', 'unlock', '--env', 'sudo', '--key', 'testorg.sudo.SUDO_GET_TEST'],
      cwd: repo.path,
      env: { HOME: repo.path },
    });
    // then get it
    return invokeRhachetCliBinary({
      args: ['keyrack', 'get', '--key', 'testorg.sudo.SUDO_GET_TEST', '--env', 'sudo'],
      cwd: repo.path,
      env: { HOME: repo.path },
    });
  });
```

**relation**: [EXTEND] — the test file has fragments of the roundtrip (set, unlock, get) but never in a single end-to-end flow from a single repo. the roundtrip test should be a new case that proves the full lifecycle: set → list → get-locked → unlock → get-granted → relock → get-locked-again.

---

## pattern.11 — os.direct vault acceptance test [REUSE]

tests regular (non-sudo) key access via os.direct vault without unlock.

**[20]** `accept.blackbox/cli/keyrack.vault.osDirect.acceptance.test.ts:11-57` — get --for repo:
```ts
given('[case1] repo with vault os.direct configured', () => {
  const repo = useBeforeAll(async () =>
    genTestTempRepo({ fixture: 'with-vault-os-direct' }),
  );

  when('[t0] keyrack get --for repo --json', () => {
    const result = useBeforeAll(async () =>
      invokeRhachetCliBinary({
        args: ['keyrack', 'get', '--for', 'repo', '--env', 'test', '--json'],
        cwd: repo.path,
        env: { HOME: repo.path },
      }),
    );

    then('grant value matches stored value', () => {
      const parsed = JSON.parse(result.stdout);
      const attempt = parsed.find(
        (a: { grant?: { slug: string } }) =>
          a.grant?.slug === 'testorg.test.DIRECT_TEST_KEY',
      );
      expect(attempt.grant.key.secret).toEqual('direct-test-key-abc123');
    });
  });
```

**relation**: [REUSE] — demonstrates the pattern for roundtrip value verification. the roundtrip test will follow this same pattern: parse json, find the attempt by slug, assert the value matches.

---

## pattern.12 — stdin pipe for keyrack set [EXTEND]

acceptance tests pipe values via `stdin` parameter on `invokeRhachetCliBinary`. the production `promptHiddenInput` reads from tty.

**[21]** `accept.blackbox/cli/keyrack.sudo.acceptance.test.ts:46-49` — set with stdin:
```ts
invokeRhachetCliBinary({
  args: ['keyrack', 'set', '--key', 'SUDO_TOKEN', '--env', 'sudo', '--mech', 'REPLICA', '--vault', 'os.direct', '--json'],
  cwd: repo.path,
  env: { HOME: repo.path },
  stdin: 'sudo-token-value\n',
})
```

**note**: this works for `--mech REPLICA` (which skips vault set) but fails for `--vault os.direct` or `--vault os.secure` without `--mech`, because `promptHiddenInput` tries to read from tty not stdin. the `--mech REPLICA` flag bypasses the promptHiddenInput call entirely, which is why case1 passes while 38 other tests fail.

**relation**: [EXTEND] — to fix the 38 failures, the production code must detect stdin pipe (`!process.stdin.isTTY`) and read from stdin directly. no test infra change is required — the test pattern is already correct.

---

## pattern.13 — snapshot redaction for json output [REUSE]

json output is parsed, timestamps redacted, then snapshot-matched.

**[22]** `accept.blackbox/cli/keyrack.sudo.acceptance.test.ts:72-78` — json snapshot:
```ts
then('stdout matches snapshot', () => {
  const parsed = JSON.parse(result.stdout);
  if (parsed.createdAt) parsed.createdAt = '__TIMESTAMP__';
  if (parsed.updatedAt) parsed.updatedAt = '__TIMESTAMP__';
  expect(parsed).toMatchSnapshot();
});
```

**relation**: [REUSE] — the roundtrip test should follow the same pattern for json output verification.

---

## pattern.14 — fixture with-keyrack-flat-keys [NEW]

a new fixture added for tests that need a flat key structure without multi-env complexity.

**[23]** `accept.blackbox/.test/assets/with-keyrack-flat-keys/` — contains:
```
.rhachet/keyrack.manifest.json  (legacy format, converted at setup)
```

**relation**: [REUSE] or ignore — the roundtrip test is better served by `with-keyrack-multi-env` which already has the env/org structure needed for sudo.

---

## summary

| # | pattern | disposition | why |
|---|---------|------------|-----|
| 1 | genTestTempRepo fixture setup | [REUSE] | creates isolated repos with SSH keys and manifests |
| 2 | SSH key provision | [REUSE] | identity-based decryption already supported |
| 3 | legacy manifest conversion | [REUSE] | adds env/org fields needed by sudo |
| 4 | os.secure credential re-encryption | [EXTEND] | may need new slug in KNOWN_OS_SECURE_VALUES or use set flow |
| 5 | invokeRhachetCliBinary | [EXTEND] | stdin pipe works; prod code needs stdin fallback fix |
| 6 | invokeRhachetCliBinaryChain | [REUSE] | available for multi-step flows |
| 7 | asSnapshotSafe | [REUSE] | strips machine-specific content |
| 8 | writeDirectStoreEntry | [REUSE] | pre-seeds os.direct store |
| 9 | killKeyrackDaemonForTests | [REUSE] | critical for fresh daemon state |
| 10 | sudo acceptance test structure | [EXTEND] | lacks end-to-end roundtrip case |
| 11 | os.direct vault acceptance test | [REUSE] | demonstrates value verification pattern |
| 12 | stdin pipe for keyrack set | [EXTEND] | works for REPLICA mech; prod needs stdin fallback |
| 13 | snapshot redaction for json | [REUSE] | timestamp redaction pattern |
| 14 | fixture with-keyrack-flat-keys | [REUSE] | available but not needed for roundtrip |
