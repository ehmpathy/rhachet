# blueprint: keyrack-sudo polish

## blackbox criteria satisfied

- usecase.1 = sudo roundtrip journey (os.secure vault) — **defect repair + acceptance test**
- usecase.2 = sudo roundtrip journey (os.direct vault) — **defect repair + acceptance test**
- usecase.3 = regular key roundtrip (os.direct vault) — **acceptance test**
- usecase.4 = regular key roundtrip (os.secure vault) — **acceptance test**
- usecase.5 = stdin value piped into set — **defect repair**
- usecase.6 = snapshot consistency — **resnap**
- usecase.7 = vault path structure — **already satisfied** (vault path refactor done)

---

## defect analysis

### defect.1 — "0 keys unlocked" in sudo unlock flow

**symptom**: `keyrack unlock --env sudo --key MY_SUDO_TOKEN` reports "done. 0 keys unlocked." despite key listed via `keyrack list`.

**root cause investigation**:

the slug filter at `unlockKeyrack.ts:73-88` appears correct. `slugsForEnv` resolves to the matched slug. the issue is downstream at line 157:

```ts
const secret = await adapter.get({ slug, exid: hostConfig.exid });
if (!secret) {
  // key not found in vault — skip
  continue;
}
```

`adapter.get()` returns null, which causes the key to be skipped. `keysToUnlock` ends up empty.

**hypothesis A** — vault file at wrong path: if the human ran `keyrack set` before the vault path refactor (old: `~/.rhachet/keyrack.secure/`), the encrypted file lives at the old path. the new code looks at `~/.rhachet/keyrack/vault/os.secure/`. the file is not found and `get()` returns null.

**hypothesis B** — identity/encryption mismatch: `vaultAdapterOsSecure.get()` tries identity-based decryption first (line 172-180). if the identity format from `daoKeyrackHostManifest.getSessionIdentity()` doesn't match the recipient used in `encryptToRecipients()` in the set flow, decryption fails silently and returns null (or throws, caught somewhere).

**hypothesis C** — `isUnlocked()` returns false, and `adapter.unlock({ passphrase: input.passphrase })` is called with undefined passphrase. if identity was NOT synced (e.g., `daoKeyrackHostManifest.getSessionIdentity()` returned null), then unlock falls through to interactive prompt, which may fail in non-TTY or return empty string.

**fix strategy**: bisection diagnosis at runtime.
1. add temporary debug output in `unlockKeyrack.ts` to trace: slug found? hostConfig found? vault adapter? isUnlocked? secret? — then reproduce with the human's scenario
2. once the exact failure point is identified, apply targeted fix
3. most likely fix: ensure identity is properly propagated from manifest decryption through to vault `get()`, OR handle the vault file migration from old path to new path

### defect.2 — 38 stdin failures in acceptance tests

**symptom**: acceptance tests that pipe values into `keyrack set --vault os.direct` via `stdin:` parameter fail.

**root cause investigation**:

`promptHiddenInput.ts` DOES handle non-TTY stdin correctly (line 14-35: checks `!process.stdin.isTTY` and reads via readline). so the initial hypothesis from prod research (pattern.5) was incorrect.

**hypothesis A** — stdin consumed by SSH passphrase prompt: if the test fixture uses a passphrase-protected SSH key, the manifest DAO calls `promptHiddenInput()` to read the SSH passphrase, which consumes the stdin buffer. then when `keyrack set` calls `promptHiddenInput()` for the value, stdin is already exhausted. BUT: test fixtures use passwordless keys (`mech: 'age'`), so this should not apply.

**hypothesis B** — `spawnSync` stdin buffer consumed before prompt: `invokeRhachetCliBinary` uses `spawnSync({ input: stdin })` which provides the full stdin buffer at process start. if the compiled binary does any stdin read before `promptHiddenInput` (e.g., the age decryption library reads stdin), the buffer may be partially consumed.

**hypothesis C** — the 38 failures are in tests that do NOT use `stdin:` at all. they may be tests that call `keyrack set` without piped stdin, which blocks on the interactive prompt and times out or fails with "value required".

**fix strategy**: run the actual test suite, capture the 38 failures, and classify them. if they all share a common pattern (e.g., all require `keyrack set` setup but don't pipe stdin), the fix is to add `stdin:` to those test invocations or use `writeDirectStoreEntry` to bypass the CLI.

### defect.3 — 4 snapshot mismatches

**symptom**: cases 5, 6 have snapshot mismatches for status/list output.

**root cause**: output format changed — added env, org, vault fields to status/list output. snapshots are stale.

**fix**: verify output is correct, then resnap.

---

## filediffs treestruct

```
src/
  domain.operations/keyrack/
    session/
      [~] unlockKeyrack.ts               — fix: ensure vault get() succeeds for sudo keys
    [~] getKeyrackKeyGrant.ts             — potential: improve locked status hint format
  contract/cli/
    [~] invokeKeyrack.ts                  — potential: fix stdin handle or add --value flag
  infra/
    [○] promptHiddenInput.ts              — retain: already handles non-TTY stdin

accept.blackbox/
  cli/
    [+] keyrack.roundtrip.acceptance.test.ts  — create: journey test for all 4 env x vault combos
    [~] keyrack.sudo.acceptance.test.ts       — update: extend with get-after-set verification
    [~] keyrack.vault.osDirect.acceptance.test.ts   — update: fix stdin failures
    [~] keyrack.vault.osSecure.acceptance.test.ts   — update: fix stdin failures
    [~] keyrack.envs.acceptance.test.ts              — update: fix stdin failures
    __snapshots__/
      [~] keyrack.cli.acceptance.test.ts.snap        — resnap
      [~] keyrack.vault.osDirect.acceptance.test.ts.snap  — resnap
      [~] keyrack.vault.osSecure.acceptance.test.ts.snap  — resnap
      [~] keyrack.envs.acceptance.test.ts.snap             — resnap
  .test/infra/
    [○] genTestTempRepo.ts                — retain
    [○] invokeRhachetCliBinary.ts         — retain
    [○] writeDirectStoreEntry.ts          — retain
    [○] killKeyrackDaemonForTests.ts      — retain

.behavior/v2026_02_17.keyrack-sudo-polish/
  [~] various artifacts                   — update as execution proceeds
```

---

## codepaths treestruct

### grant resolution (get flow)

```
invokeKeyrack.ts:keyrack get
  [○] genKeyrackGrantContext()
    [○] daoKeyrackHostManifest.get()      — decrypt manifest, capture identity
    [○] setOsSecureSessionIdentity()      — sync identity to vault adapter
    [○] daoKeyrackRepoManifest.get()      — load keyrack.yml
  [○] getKeyrackKeyGrant()
    [○] os.envvar check                   — ci passthrough
    [○] os.daemon check                   — session cache
    [○] sudo lock gate                    — return 'locked' for sudo keys
    [○] vault fallthrough                 — grant for regular keys
```

### set flow

```
invokeKeyrack.ts:keyrack set
  [○] promptHiddenInput()                 — read value from stdin (non-TTY) or tty (interactive)
  [○] genKeyrackGrantContext()            — loads manifest, syncs identity
  [○] genKeyrackHostContext()             — loads manifest, syncs identity (redundant but harmless)
  [○] setKeyrackKeyHost()
    [○] construct KeyrackKeyHost
    [○] daoKeyrackHostManifest.set()      — persist to encrypted manifest
    [○] vaultAdapterOsSecure.set()        — encrypt with recipients
    [○] vaultAdapterOsDirect.set()        — store plaintext json
    [○] daoKeyrackRepoManifest.set()      — write to keyrack.yml (non-sudo only)
```

### unlock flow (defect.1 lives here)

```
invokeKeyrack.ts:keyrack unlock
  [○] genKeyrackGrantContext()
    [○] daoKeyrackHostManifest.get()      — decrypt manifest, capture identity
    [○] setOsSecureSessionIdentity()      — sync identity to vault adapter
  [○] unlockKeyrack()
    [○] getKeyrackDaemonSocketPath()
    [○] findsertKeyrackDaemon()           — ensure daemon alive
    [○] parseDuration()                   — 30m for sudo, 9h for regular
    [○] slug filter (sudo path)           — match by env=sudo and key name
    for each matched slug:
      [○] lookup hostConfig
      [~] adapter.isUnlocked()            — check identity/passphrase state
      [~] adapter.unlock()                — FIX: pass identity when available, not just passphrase
      [~] adapter.get()                   — FIX: ensure credential file exists at correct path
      [○] inferKeyGrade()
      [○] duration cap with maxDuration
      [○] collect into keysToUnlock
    [○] daemonAccessUnlock()              — send keys to daemon
```

**key fix point**: the unlock flow at `unlockKeyrack.ts:150-161`:
```
[~] isUnlocked check → if false, unlock with identity (not just passphrase)
[~] adapter.get() → trace why it returns null; ensure file path matches set path
```

### relock flow

```
invokeKeyrack.ts:keyrack relock
  [○] daemonAccessRelock()                — purge keys from daemon
```

---

## contracts

### unlockKeyrack contract (domain operation)

```
given('unlockKeyrack called for sudo env')
  input: { env: 'sudo', key: 'MY_SUDO_TOKEN', owner: null }
  context: KeyrackGrantContext (with synced identity)

  then('finds matched slug in hostManifest by key name and env=sudo')
  then('retrieves secret from vault via adapter.get()')
  then('sends key to daemon with TTL')
  then('returns { unlocked: [{ slug, vault, env, org, expiresAt }] }')
```

### vaultAdapterOsSecure contract (vault adapter)

```
given('os.secure vault with synced identity')
  when('get called for credential encrypted with recipient-based encryption')
    then('decrypts with identity and returns plaintext value')
  when('get called for nonexistent slug')
    then('returns null (file not found)')
```

### promptHiddenInput contract (infra)

```
given('non-TTY stdin (piped)')
  when('called with prompt')
    then('reads first line from stdin')
    then('returns trimmed value')
given('TTY stdin (interactive)')
  when('called with prompt')
    then('prompts human with hidden input')
    then('returns entered value')
```

### roundtrip journey acceptance test contract

```
given('a repo with keyrack init complete and passwordless ssh key')

  # sudo + os.secure roundtrip
  when('set --key SUDO_SECURE_KEY --env sudo --vault os.secure with stdin value')
    then('exit 0')
  when('get --key SUDO_SECURE_KEY --env sudo --json')
    then('status is "locked"')
  when('unlock --env sudo --key SUDO_SECURE_KEY')
    then('"1 key unlocked"')
  when('get --key SUDO_SECURE_KEY --env sudo --json after unlock')
    then('status is "granted" and value matches')
  when('relock')
    then('"keys relocked"')
  when('get --key SUDO_SECURE_KEY --env sudo --json after relock')
    then('status is "locked"')

  # sudo + os.direct roundtrip
  when('set --key SUDO_DIRECT_KEY --env sudo --vault os.direct with stdin value')
    then('exit 0')
  when('get --key SUDO_DIRECT_KEY --env sudo --json before unlock')
    then('status is "locked"')
  when('unlock --env sudo --key SUDO_DIRECT_KEY')
    then('"1 key unlocked"')
  when('get --key SUDO_DIRECT_KEY --env sudo --json after unlock')
    then('status is "granted" and value matches')

  # regular + os.direct roundtrip (no unlock needed)
  when('set --key REGULAR_DIRECT_KEY --vault os.direct with stdin value')
    then('exit 0')
  when('get --key REGULAR_DIRECT_KEY --json')
    then('status is "granted" and value matches (no unlock needed)')
```

---

## domain decomposition

### boundaries

```
contract/cli (invokeKeyrack.ts)
  +-- reads: stdin (via promptHiddenInput)
  +-- calls: genKeyrackGrantContext, genKeyrackHostContext
  +-- calls: setKeyrackKeyHost, unlockKeyrack, getKeyrackKeyGrant
  +-- writes: stdout (human/json format)

domain.operations/keyrack (core logic)
  +-- unlockKeyrack           — slug resolution + vault get + daemon send
  +-- getKeyrackKeyGrant      — envvar -> daemon -> vault -> locked
  +-- setKeyrackKeyHost       — manifest upsert + vault store + keyrack.yml write
  +-- genKeyrackGrantContext   — manifest load + identity sync + adapter assembly

domain.operations/keyrack/adapters/vaults (storage backends)
  +-- vaultAdapterOsSecure    — age-encrypted .age files, identity or passphrase
  +-- vaultAdapterOsDirect    — plaintext json store
  +-- vaultAdapterOsDaemon    — daemon memory (session cache)
  +-- vaultAdapterOsEnvvar    — process.env passthrough

access/daos (persistence)
  +-- daoKeyrackHostManifest  — encrypted host manifest (per-owner)
  +-- daoKeyrackRepoManifest  — keyrack.yml (per-repo)
```

### data flow for sudo roundtrip

```
set:  stdin value -> promptHiddenInput -> setKeyrackKeyHost
        -> daoKeyrackHostManifest.set (manifest entry)
        -> vaultAdapterOsSecure.set (encrypted file with recipients)

get (before unlock):
      -> getKeyrackKeyGrant -> envvar miss -> daemon miss -> sudo lock gate -> 'locked'

unlock: -> unlockKeyrack
        -> slug filter (hostManifest entries where env=sudo)
        -> vaultAdapterOsSecure.get (decrypt with identity)  <-- DEFECT HERE
        -> daemonAccessUnlock (send to daemon with TTL)

get (after unlock):
      -> getKeyrackKeyGrant -> envvar miss -> daemon HIT -> 'granted' + value

relock: -> daemonAccessRelock -> purge from daemon

get (after relock):
      -> getKeyrackKeyGrant -> envvar miss -> daemon miss -> sudo lock gate -> 'locked'
```

---

## test coverage plan

### acceptance tests (blackbox)

| test | file | coverage |
|------|------|----------|
| sudo roundtrip os.secure | `keyrack.roundtrip.acceptance.test.ts` | usecase.1 |
| sudo roundtrip os.direct | `keyrack.roundtrip.acceptance.test.ts` | usecase.2 |
| regular roundtrip os.direct | `keyrack.roundtrip.acceptance.test.ts` | usecase.3 |
| regular roundtrip os.secure | `keyrack.roundtrip.acceptance.test.ts` | usecase.4 |
| stdin pipe into set | fix extant tests | usecase.5 |
| snapshot consistency | resnap after fix | usecase.6 |

### integration tests (retain)

| test | file | coverage |
|------|------|----------|
| os.secure vault roundtrip | `vaultAdapterOsSecure.integration.test.ts` | vault encrypt/decrypt |
| os.direct vault roundtrip | `vaultAdapterOsDirect.integration.test.ts` | vault store/retrieve |

### unit tests (retain)

| test | file | coverage |
|------|------|----------|
| slug filter logic | retain in `unlockKeyrack` (implicit via acceptance) | slug match |
| duration parse | retain in `unlockKeyrack` (implicit) | TTL parse |

---

## execution phases

### phase.0 — diagnose defects

1. run acceptance test suite, capture exact failures
2. reproduce "0 keys unlocked" defect with debug trace in `unlockKeyrack.ts`
3. classify the 38 stdin failures — are they all the same root cause?

### phase.1 — fix "0 keys unlocked" defect

1. fix the identified root cause (likely identity propagation or vault path)
2. verify roundtrip works manually: set -> unlock -> get -> relock -> get
3. add integration test if the fix is in a leaf function

### phase.2 — fix stdin failures

1. apply fix based on diagnosis from phase.0
2. verify acceptance tests that use `stdin:` pass

### phase.3 — add roundtrip acceptance test

1. create `keyrack.roundtrip.acceptance.test.ts`
2. cover all 4 env x vault combinations from matrix.1
3. each case: set -> list -> get-locked -> unlock -> get-granted -> relock -> get-locked

### phase.4 — resnap and verify

1. run full acceptance suite
2. resnap the 4 stale snapshots
3. verify all tests pass
4. signal ready for human playtest
