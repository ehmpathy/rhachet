# research: production code patterns

## pattern.1 = CLI command registration [REUSE]

**file:** `src/contract/cli/invoke.ts:25-56`

```typescript
const _invoke = async (input: { args: string[] }): Promise<void> => {
  const cwd = process.cwd();
  const context = await genContextConfigOfUsage({ args: input.args, cwd });

  const program = new Command();
  program
    .name('rhachet')
    .description('rhachet cli interface. weave threads üßµ of thought, stitched ü™° with a rhachet ‚öôÔ∏è')
    .option('-c, --config <path>', 'where to find the rhachet.use.ts config');

  // register all commands unconditionally
  invokeInit({ program });
  invokeRepoIntrospect({ program });
  invokeRoles({ program }, context);
  invokeList({ program }, context);
  invokeReadme({ program }, context);
  invokeRun({ program });
  invokeChoose({ program });
  invokeAsk({ program }, context);
  invokeAct({ program }, context);
```
[1]

**relevance:** upgrade command will be registered here as `invokeUpgrade({ program }, context)`

---

## pattern.2 = command with flags and async action [REUSE]

**file:** `src/contract/cli/invokeInit.ts:95-134`

```typescript
export const invokeInit = ({ program }: { program: Command }): void => {
  program
    .command('init')
    .description('initialize roles from packages or generate rhachet.use.ts')
    .option('--roles <roles...>', 'role specifiers to initialize')
    .option('--config', 'generate rhachet.use.ts config (legacy behavior)')
    .option('--mode <mode>', 'findsert (default) preserves prior, upsert overwrites', 'findsert')
    .action(async (options: { roles?: string[]; config?: boolean; mode: 'findsert' | 'upsert' }) => {
      const cwd = process.cwd();

      // route: --roles provided => init roles from packages
      if (options.roles && options.roles.length > 0) {
        await initRolesFromPackages({ specifiers: options.roles, from: cwd });
        return;
      }

      // route: --config provided => generate rhachet.use.ts
      if (options.config) {
        const root = await getGitRepoRoot({ from: input.from });
        await generateRhachetUseTs({ cwd, root, mode: options.mode });
        return;
      }

      // route: no flags => show usage instructions
      await showInitUsageInstructions({ from: cwd });
    });
};
```
[2]

**relevance:** upgrade command uses same pattern with `--self` and `--roles` flags, conditional routing

---

## pattern.3 = role package discovery from package.json [REUSE]

**file:** `src/domain.operations/init/discoverRolePackages.ts:11-21`

```typescript
export const discoverRolePackages = async (input: {
  from: string;
}): Promise<string[]> => {
  const root = await getGitRepoRoot({ from: input.from });
  const pkgPath = resolve(root, 'package.json');
  const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
  return Object.keys(allDeps).filter((name) =>
    name.startsWith('rhachet-roles-'),
  );
};
```
[3]

**relevance:** upgrade uses this to find which `rhachet-roles-*` packages are installed for `--roles *`

---

## pattern.4 = role manifest resolution via require.resolve [REUSE]

**file:** `src/domain.operations/config/getRegistriesByConfigImplicit.ts:19-60`

```typescript
export const getRegistriesByConfigImplicit = async (input: {
  from: string;
}): Promise<{ manifests: HasPackageRoot<RoleRegistryManifest>[]; errors: ... }> => {
  const packageNames = await discoverRolePackages({ from: input.from });

  const repoRoot = await getGitRepoRoot({ from: input.from });
  const require = createRequire(`${repoRoot}/package.json`);

  for (const packageName of packageNames) {
    try {
      const packageJsonPath = require.resolve(`${packageName}/package.json`);
      const packageRoot = dirname(packageJsonPath);
      const manifest = getRoleRegistryManifest({ packageRoot });
      manifests.push({ ...manifest, packageRoot });
    } catch (error) {
      if (error instanceof BadRequestError) {
        errors.push({ packageName, error });
        continue;
      }
      throw error;
    }
  }

  return { manifests, errors };
};
```
[4]

**relevance:** used to resolve role specifiers to package names for npm install

---

## pattern.5 = init roles from packages (link + init workflow) [REUSE]

**file:** `src/domain.operations/init/initRolesFromPackages.ts:27-136`

```typescript
export const initRolesFromPackages = async (input: {
  specifiers: RoleSpecifier[];
  from: string;
}): Promise<InitRolesResult> => {
  // Phase 1: Discover packages and manifests
  const { manifests, errors: packageErrors } =
    await getRegistriesByConfigImplicit({ from: input.from });

  // Fail fast if no packages found
  if (manifests.length === 0 && packageErrors.length === 0) {
    throw new BadRequestError('no rhachet-roles-* packages found. install a package first.');
  }

  // Phase 2: Resolve specifiers to roles
  const roles = getRolesFromManifests({ specifiers: input.specifiers, manifests });

  // Phase 3: Link and init each role sequentially
  for (const resolved of roles) {
    try {
      execRoleLink({ role: resolved.role, repo: resolved.repo });
      result.rolesLinked.push(...);
    } catch (error) {
      result.errors.push({ specifier, phase: 'link', error });
    }

    try {
      execRoleInits({ role: resolved.role, repo: resolved.repo });
      result.rolesInitialized.push(...);
    } catch (error) {
      result.errors.push({ specifier, phase: 'init', error });
    }
  }

  return result;
};
```
[5]

**relevance:** upgrade calls this AFTER npm install to re-link and re-init roles

---

## pattern.6 = shell command execution via spawnSync [REUSE]

**file:** `src/domain.operations/invoke/init/execRoleInits.ts:37-47`

```typescript
const result = spawnSync(cmd, [], {
  cwd: process.cwd(),
  stdio: [process.stdin, process.stdout, process.stderr],
  shell: '/bin/bash',
});

if (result.status !== 0) {
  throw new Error(`init command failed: ${cmd} (exit code ${result.status})`);
}
```
[6]

**relevance:** npm install will use same pattern: `spawnSync('npm install rhachet@latest ...', [], { shell: '/bin/bash' })`

---

## pattern.7 = .agent/ directory scanning for linked roles [REUSE]

**file:** `src/domain.operations/invoke/discoverInitExecutables.ts:27-87`

```typescript
export const discoverInitExecutables = (input: {
  slugRepo?: string;
  slugRole?: string;
  slugInit?: string;
}): RoleInitExecutable[] => {
  const agentDir = resolve(process.cwd(), '.agent');

  if (!existsSync(agentDir)) return [];

  const repoEntries = readdirSync(agentDir).filter((entry) =>
    entry.startsWith('repo='),
  );

  const inits: RoleInitExecutable[] = [];

  for (const repoEntry of repoEntries) {
    const slugRepo = repoEntry.replace('repo=', '');
    if (input.slugRepo && slugRepo !== input.slugRepo) continue;

    const repoDir = resolve(agentDir, repoEntry);
    const roleEntries = readdirSync(repoDir).filter((entry) =>
      entry.startsWith('role='),
    );

    for (const roleEntry of roleEntries) {
      const slugRole = roleEntry.replace('role=', '');
      if (input.slugRole && slugRole !== input.slugRole) continue;
      // ... discover init files
    }
  }

  return inits;
};
```
[7]

**relevance:** pattern for discovering already-linked roles from `.agent/repo={slug}/` where slug !== ".this"

---

## pattern.8 = error handling with HelpfulError [EXTEND]

**file:** `src/domain.operations/invoke/executeInit.ts:11-25`

```typescript
export class InitExecutionError extends HelpfulError {
  public readonly exitCode: number;

  constructor(
    message: string,
    metadata: { init: string; path: string; exitCode: number | null },
  ) {
    super(message, metadata);
    this.exitCode = metadata.exitCode ?? 1;
  }
}
```
[8]

**relevance:** create similar `UpgradeExecutionError` for npm install failures

---

## pattern.9 = role linking to .agent/ structure [REUSE]

**file:** `src/domain.operations/invoke/link/execRoleLink.ts:20-50`

```typescript
export const execRoleLink = (input: {
  role: RoleManifest;
  repo: RoleRegistryManifest;
  indent?: string;
}): { briefsCount: number; skillsCount: number; initsCount: number } => {
  // create .agent directory structure
  const agentDir = resolve(process.cwd(), '.agent');
  const repoDir = resolve(agentDir, `repo=${input.repo.slug}`);
  const repoRoleDir = resolve(repoDir, `role=${input.role.slug}`);

  mkdirSync(agentDir, { recursive: true });
  mkdirSync(repoDir, { recursive: true });
  mkdirSync(repoRoleDir, { recursive: true });

  // symlink resources
  const briefsCount = symlinkResourceDirectories({
    sourceDirs: input.role.briefs.dirs,
    targetDir: resolve(repoRoleDir, 'briefs'),
    resourceName: 'briefs',
  });
  // ...
```
[9]

**relevance:** called by `initRolesFromPackages` which upgrade invokes after npm install

---

## pattern.10 = specifier-to-role resolution with disambiguation [REUSE]

**file:** `src/domain.operations/init/getRolesFromManifests.ts` (inferred from initRolesFromPackages)

```typescript
const roles = getRolesFromManifests({ specifiers: input.specifiers, manifests });
```
[5]

**relevance:** handles `mechanic` vs `ehmpathy/mechanic` disambiguation, throws on ambiguity

---

## summary

| pattern | status | purpose for upgrade |
|---------|--------|---------------------|
| CLI command registration | [REUSE] | register `invokeUpgrade` |
| command with flags | [REUSE] | `--self`, `--roles` flags |
| role package discovery | [REUSE] | find installed `rhachet-roles-*` |
| manifest resolution | [REUSE] | resolve roles to package names |
| init roles workflow | [REUSE] | call after npm install |
| spawnSync execution | [REUSE] | run `npm install` |
| .agent/ scanning | [REUSE] | discover linked roles for `--roles *` |
| HelpfulError | [EXTEND] | `UpgradeExecutionError` |
| role linking | [REUSE] | called by initRolesFromPackages |
| specifier resolution | [REUSE] | handle role disambiguation |

---

## citations

[1] `src/contract/cli/invoke.ts:25-56` - CLI command registration via Commander.js
[2] `src/contract/cli/invokeInit.ts:95-134` - init command with flags and async action
[3] `src/domain.operations/init/discoverRolePackages.ts:11-21` - package.json dependency scanning
[4] `src/domain.operations/config/getRegistriesByConfigImplicit.ts:19-60` - manifest resolution
[5] `src/domain.operations/init/initRolesFromPackages.ts:27-136` - link + init workflow
[6] `src/domain.operations/invoke/init/execRoleInits.ts:37-47` - spawnSync shell execution
[7] `src/domain.operations/invoke/discoverInitExecutables.ts:27-87` - .agent/ directory scanning
[8] `src/domain.operations/invoke/executeInit.ts:11-25` - HelpfulError subclassing
[9] `src/domain.operations/invoke/link/execRoleLink.ts:20-50` - .agent/ symlink creation
