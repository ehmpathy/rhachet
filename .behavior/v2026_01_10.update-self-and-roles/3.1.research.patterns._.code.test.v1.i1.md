# research: test code patterns

## pattern.1 = acceptance test structure (given/when/then) [REUSE]

**file:** `accept.blackbox/cli/init.acceptance.test.ts:1-40`

```typescript
import { given, then, useBeforeAll, when } from 'test-fns';

import { genTestTempRepo } from '@/accept.blackbox/.test/infra/genTestTempRepo';
import { invokeRhachetCliBinary } from '@/accept.blackbox/.test/infra/invokeRhachetCliBinary';

describe('rhachet init', () => {
  given('[case1] repo without rhachet.use.ts', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'without-roles-packages' }),
    );

    when('[t0] init --roles mechanic', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['init', '--roles', 'mechanic'],
          cwd: repo.path,
          logOnError: false,
        }),
      );

      then('exits with non-zero status', () => {
        expect(result.status).not.toEqual(0);
      });
    });
  });
});
```
[1]

**relevance:** upgrade tests will follow identical structure with `given/when/then` from `test-fns`

---

## pattern.2 = genTestTempRepo fixture helper [REUSE]

**file:** `accept.blackbox/.test/infra/genTestTempRepo.ts:1-70`

```typescript
export const genTestTempRepo = (input: {
  /** fixture template to use */
  fixture: TestRepoFixture;
  /** optional unique suffix for the repo name */
  suffix?: string;
  /** run pnpm install after copy (for fixtures with package.json) */
  install?: boolean;
}): {
  /** absolute path to the test repo */
  path: string;
} => {
  // gen unique temp directory path
  const uniqueId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const suffix = input.suffix ? `-${input.suffix}` : '';
  const repoPath = join(tmpdir(), `rhachet-test-${uniqueId}${suffix}`);

  // copy fixture assets into temp repo
  const fixturePath = join(ASSETS_DIR, input.fixture);
  cpSync(fixturePath, repoPath, { recursive: true });

  // make shell skills executable
  setSkillsExecutable({ dir: repoPath });

  // init git repo (required for rhachet)
  execSync('git init', { cwd: repoPath, stdio: 'ignore' });

  // install dependencies if requested
  if (input.install && existsSync(join(repoPath, 'package.json'))) {
    execSync('bun install', {
      cwd: repoPath,
      stdio: 'inherit',
      timeout: 120000,
    });
  }

  return { path: repoPath };
};
```
[2]

**relevance:** upgrade tests need `install: true` to have real packages installed before testing upgrade

---

## pattern.3 = invokeRhachetCliBinary helper [REUSE]

**file:** `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:1-42`

```typescript
import { spawnSync, type SpawnSyncReturns } from 'node:child_process';
import { resolve } from 'node:path';

const RHACHET_BIN = resolve(__dirname, '../../../bin/run');

export const invokeRhachetCliBinary = (input: {
  /** CLI args after 'rhachet' (e.g., ['run', '--skill', 'foo']) */
  args: string[];
  /** working directory for the command */
  cwd: string;
  /** optional stdin data to pipe */
  stdin?: string;
  /** whether to log output on failure (default: true) */
  logOnError?: boolean;
  /** optional env vars to merge with process.env */
  env?: Record<string, string | undefined>;
}): SpawnSyncReturns<string> => {
  const result = spawnSync(RHACHET_BIN, input.args, {
    cwd: input.cwd,
    input: input.stdin,
    encoding: 'utf-8',
    shell: '/bin/bash',
    env: input.env ? { ...process.env, ...input.env } : undefined,
  });

  // log output for debug on failure
  const shouldLog = input.logOnError ?? true;
  if (shouldLog && result.status !== 0) {
    console.error('stderr:', result.stderr);
    console.error('stdout:', result.stdout);
  }

  return result;
};
```
[3]

**relevance:** upgrade tests invoke via `invokeRhachetCliBinary({ args: ['upgrade', '--self'], cwd: repo.path })`

---

## pattern.4 = test fixtures with package.json dependencies [REUSE]

**file:** `accept.blackbox/.test/assets/with-published-roles/package.json`

```json
{
  "name": "test-with-published-roles",
  "version": "0.0.0",
  "private": true,
  "dependencies": {
    "rhachet": "^1.19.0",
    "rhachet-roles-ehmpathy": "^1.17.0"
  }
}
```
[4]

**relevance:** upgrade tests need fixture with pinned versions to verify upgrade to @latest

---

## pattern.5 = testing with installed packages [REUSE]

**file:** `accept.blackbox/cli/roles.boot.published.acceptance.test.ts:1-53`

```typescript
describe('rhachet with published packages', () => {
  given('[case1] repo with published rhachet + rhachet-roles-ehmpathy via pnpm', () => {
    const repo = useBeforeAll(async () => {
      // create temp repo with package.json that depends on published packages
      // pnpm install runs to fetch the real published packages
      const r = genTestTempRepo({ fixture: 'with-published-roles', install: true });
      return r;
    });

    when('[t0] roles link --repo ehmpathy --role mechanic', () => {
      const result = useBeforeAll(async () => {
        return invokeRhachetCliBinary({
          args: ['roles', 'link', '--repo', 'ehmpathy', '--role', 'mechanic'],
          cwd: repo.path,
        });
      });

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });
    });
  });
});
```
[5]

**relevance:** pattern for testing real package installation with `install: true`

---

## pattern.6 = error case testing with logOnError: false [REUSE]

**file:** `accept.blackbox/cli/run.skill.acceptance.test.ts:60-80`

```typescript
when('[t2] run --skill nonexistent', () => {
  const result = useBeforeAll(async () =>
    invokeRhachetCliBinary({
      args: ['run', '--skill', 'nonexistent'],
      cwd: repo.path,
      logOnError: false,
    }),
  );

  then('exits with non-zero status', () => {
    expect(result.status).not.toEqual(0);
  });

  then('stderr contains error message', () => {
    expect(result.stderr).toContain('nonexistent');
  });
});
```
[6]

**relevance:** upgrade error tests (role not found, ambiguous role) use `logOnError: false`

---

## pattern.7 = multi-step setup in useBeforeAll [REUSE]

**file:** `accept.blackbox/cli/roles.init.acceptance.test.ts:1-40`

```typescript
given('[case1] repo with role that has no exec commands', () => {
  const repo = useBeforeAll(async () => {
    const tempRepo = genTestTempRepo({ fixture: 'with-inits' });

    // link role to create .agent/ directory (like a real project would)
    const linkResult = invokeRhachetCliBinary({
      args: ['roles', 'link', '--repo', 'test-repo', '--role', 'tester'],
      cwd: tempRepo.path,
    });

    if (linkResult.status !== 0) {
      throw new Error(
        `roles link failed: ${linkResult.stderr}\n${linkResult.stdout}`,
      );
    }

    return tempRepo;
  });
```
[7]

**relevance:** upgrade tests may need setup steps (e.g., link roles first, then test upgrade)

---

## pattern.8 = file system verification [REUSE]

**file:** `accept.blackbox/cli/run.init.acceptance.test.ts:160-175`

```typescript
then('init script executes and creates marker file', () => {
  const markerPath = resolve(repo.path, 'marker-file-created.txt');
  expect(existsSync(markerPath)).toBe(true);
});

then('stdout contains success message', () => {
  expect(result.stdout).toContain('init executed successfully');
});
```
[8]

**relevance:** upgrade tests verify package.json was modified, .agent/ symlinks updated

---

## pattern.9 = TestRepoFixture type enum [EXTEND]

**file:** `accept.blackbox/.test/infra/genTestTempRepo.ts:16-30`

```typescript
type TestRepoFixture =
  | 'minimal'
  | 'with-skills'
  | 'with-briefs'
  | 'with-registry'
  | 'with-inits'
  | 'with-published-roles'
  | 'with-roles-packages'
  | 'with-perf-test'
  | 'without-roles-packages';
```
[9]

**relevance:** add new fixture `with-upgradeable-packages` with pinned older versions

---

## pattern.10 = integration test with direct command parsing [REUSE]

**file:** `src/contract/cli/invokeInit.integration.test.ts:50-70`

```typescript
when(
  'invoked with --config and package.json that has rhachet-roles-* packages',
  () => {
    beforeEach(() => {
      writeFileSync(
        resolve(testDir, 'package.json'),
        JSON.stringify({
          name: 'test-project',
          dependencies: {
            'rhachet-roles-ehmpathy': '1.0.0',
          },
        }),
      );
    });

    then(
      'it should create rhachet.use.ts with discovered packages',
      async () => {
        await program.parseAsync(['init', '--config'], { from: 'user' });

        const configPath = resolve(testDir, 'rhachet.use.ts');
        expect(existsSync(configPath)).toBe(true);
      },
    );
  },
);
```
[10]

**relevance:** optional pattern for unit-level integration tests of invokeUpgrade

---

## pattern.11 = genTestTempDir for unit tests [REUSE]

**file:** `src/.test/infra/genTestTempDir.ts:1-30`

```typescript
export const genTestTempDir = (input: {
  base: string;
  name: string;
}): {
  path: string;
  setup: () => void;
  teardown: () => void;
  rm: (relativePath: string) => void;
} => {
  const testDir = resolve(input.base, './.temp', input.name);
  const originalCwd = process.cwd();

  return {
    path: testDir,

    setup: () => {
      rmSync(testDir, { recursive: true, force: true });
      mkdirSync(testDir, { recursive: true });
      process.chdir(testDir);
    },

    teardown: () => {
      process.chdir(originalCwd);
    },
  };
};
```
[11]

**relevance:** unit tests for upgrade subcomponents can use this for temp directories

---

## pattern.12 = setTestTempAsset for creating test files [REUSE]

**file:** `src/.test/infra/setTestTempAsset.ts:1-30`

```typescript
export const setTestTempAsset = (input: {
  dir: string;
  name: string;
  content: string;
  executable?: boolean;
}): {
  path: string;
} => {
  // guard: ensure we're writing to a temp directory
  if (!input.dir.includes('.temp'))
    throw new Error(
      `setTestTempAsset: dir must be under .temp for safety, got: ${input.dir}`,
    );

  const assetPath = resolve(input.dir, input.name);
  mkdirSync(dirname(assetPath), { recursive: true });
  writeFileSync(assetPath, input.content);

  const shouldExecute = input.executable ?? input.name.endsWith('.sh');
  if (shouldExecute) chmodSync(assetPath, '755');

  return { path: assetPath };
};
```
[12]

**relevance:** creating package.json or shell scripts dynamically in unit tests

---

## summary

| pattern | status | purpose for upgrade tests |
|---------|--------|---------------------------|
| given/when/then structure | [REUSE] | test organization |
| genTestTempRepo | [REUSE] | create isolated test repos |
| invokeRhachetCliBinary | [REUSE] | invoke CLI and capture output |
| fixtures with package.json | [REUSE] | test with real dependencies |
| install: true pattern | [REUSE] | run npm/bun install in fixture |
| logOnError: false | [REUSE] | suppress noise in error tests |
| multi-step useBeforeAll | [REUSE] | complex test setup |
| file system verification | [REUSE] | verify side effects |
| TestRepoFixture type | [EXTEND] | add `with-upgradeable-packages` |
| integration test parsing | [REUSE] | optional unit-level tests |
| genTestTempDir | [REUSE] | unit test temp dirs |
| setTestTempAsset | [REUSE] | create test files dynamically |

---

## new fixture needed

**`with-upgradeable-packages`** — fixture with pinned older versions:

```json
{
  "name": "test-with-upgradeable-packages",
  "version": "0.0.0",
  "private": true,
  "dependencies": {
    "rhachet": "1.19.0",
    "rhachet-roles-ehmpathy": "1.17.0"
  }
}
```

this enables testing that `npx rhachet upgrade` actually upgrades from old → latest

---

## citations

[1] `accept.blackbox/cli/init.acceptance.test.ts:1-40` - given/when/then structure
[2] `accept.blackbox/.test/infra/genTestTempRepo.ts:1-70` - temp repo generation
[3] `accept.blackbox/.test/infra/invokeRhachetCliBinary.ts:1-42` - CLI invocation helper
[4] `accept.blackbox/.test/assets/with-published-roles/package.json` - fixture with deps
[5] `accept.blackbox/cli/roles.boot.published.acceptance.test.ts:1-53` - install: true pattern
[6] `accept.blackbox/cli/run.skill.acceptance.test.ts:60-80` - error case testing
[7] `accept.blackbox/cli/roles.init.acceptance.test.ts:1-40` - multi-step setup
[8] `accept.blackbox/cli/run.init.acceptance.test.ts:160-175` - file system verification
[9] `accept.blackbox/.test/infra/genTestTempRepo.ts:16-30` - fixture type enum
[10] `src/contract/cli/invokeInit.integration.test.ts:50-70` - direct command parsing
[11] `src/.test/infra/genTestTempDir.ts:1-30` - unit test temp dirs
[12] `src/.test/infra/setTestTempAsset.ts:1-30` - dynamic test file creation
