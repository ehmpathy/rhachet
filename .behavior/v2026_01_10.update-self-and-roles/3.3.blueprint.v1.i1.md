# blueprint: npx rhachet upgrade

## overview

implement `npx rhachet upgrade` command that:
1. upgrades rhachet and/or role packages to @latest
2. re-initializes roles after upgrade (link + init)
3. defaults to upgrading everything when no flags provided

## blackbox criteria coverage

| usecase | description | covered by |
|---------|-------------|------------|
| 1 | upgrade everything (default) | `upgradeAll()` |
| 2 | upgrade rhachet only | `--self` flag |
| 3 | upgrade specific roles | `--roles mechanic` |
| 4 | upgrade all linked roles | `--roles *` |
| 5 | upgrade self + specific roles | `--self --roles mechanic` |
| 6 | error handling | fail-fast validation |
| 7 | discoverability | `update` ‚Üí `upgrade` suggestion |
| 8 | edge cases | dedup, no package.json, etc |

---

## files to create

### 0. `src/domain.objects/ContextCli.ts`

Simple context holding cwd for CLI operations.

```typescript
import { DomainLiteral } from 'domain-objects';

export interface ContextCli {
  cwd: string;
}

export class ContextCli extends DomainLiteral<ContextCli> implements ContextCli {}
```

### 1. `src/contract/cli/invokeUpgrade.ts`

CLI command registration following `invokeInit.ts` pattern.

```typescript
export const invokeUpgrade = ({ program }: { program: Command }): void => {
  program
    .command('upgrade')
    .description('upgrade rhachet and/or role packages to latest versions')
    .option('--self', 'upgrade rhachet itself')
    .option('--roles <roles...>', 'role specifiers to upgrade (* for all linked)')
    .action(async (options: { self?: boolean; roles?: string[] }) => {
      const context = new ContextCli({ cwd: process.cwd() });
      await execUpgrade(
        { self: options.self, roleSpecs: options.roles },
        context,
      );
    });
};
```

### 2. `src/domain.operations/upgrade/execUpgrade.ts`

Main orchestration function.

```typescript
export const execUpgrade = async (
  input: { self?: boolean; roleSpecs?: string[] },
  context: ContextCli,
): Promise<UpgradeResult> => {
  // 1. determine what to upgrade (default = --self --roles *)
  const self = input.self ?? (input.roleSpecs === undefined);
  const roleSpecs = input.roleSpecs ?? (input.self ? [] : ['*']);

  // 2. expand wildcard: discover linked roles
  const expandedRoles = expandRoleSpecs({ specs: roleSpecs }, context);

  // 3. resolve roles to package names
  const packages = await resolveRolesToPackages({ roles: expandedRoles }, context);

  // 4. build npm install command
  const installList = buildInstallList({ self, packages });

  // 5. execute npm install (fail fast)
  if (installList.length > 0) {
    await execNpmInstall({ packages: installList }, context);
  }

  // 6. re-init roles (link + init)
  if (expandedRoles.length > 0) {
    await initRolesFromPackages({ specifiers: expandedRoles }, context);
  }

  // 7. report success
  return { upgradedSelf: self, upgradedRoles: expandedRoles };
};
```

### 3. `src/domain.operations/upgrade/discoverLinkedRoles.ts`

Scan `.agent/` for linked roles (non-.this repos).

```typescript
export const discoverLinkedRoles = (
  _input: Empty,
  context: ContextCli,
): RoleLinkRef[] => {
  const agentDir = resolve(context.cwd, '.agent');
  if (!existsSync(agentDir)) return [];

  const roles: RoleLinkRef[] = [];

  const repoEntries = readdirSync(agentDir)
    .filter((e) => e.startsWith('repo=') && e !== 'repo=.this');

  for (const repoEntry of repoEntries) {
    const repoSlug = repoEntry.replace('repo=', '');
    const repoDir = resolve(agentDir, repoEntry);

    const roleEntries = readdirSync(repoDir).filter((e) => e.startsWith('role='));
    for (const roleEntry of roleEntries) {
      const roleSlug = roleEntry.replace('role=', '');
      roles.push({ repo: repoSlug, role: roleSlug });
    }
  }

  return roles;
};
```

### 4. `src/domain.operations/upgrade/resolveRolesToPackages.ts`

Map role refs to package names for npm install.

```typescript
export const resolveRolesToPackages = async (
  input: { roles: RoleLinkRef[] },
  context: ContextCli,
): Promise<string[]> => {
  if (input.roles.length === 0) return [];

  const { manifests } = await getRegistriesByConfigImplicit({ from: context.cwd });

  const packages = new Set<string>();

  for (const roleRef of input.roles) {
    const manifest = manifests.find((m) => m.slug === roleRef.repo);
    if (!manifest) {
      throw new BadRequestError(`role not found: ${roleRef.repo}/${roleRef.role}`);
    }
    // package name = rhachet-roles-{slug}
    packages.add(`rhachet-roles-${manifest.slug}`);
  }

  return [...packages];
};
```

### 5. `src/domain.operations/upgrade/execNpmInstall.ts`

Execute npm install with @latest.

```typescript
export const execNpmInstall = (
  input: { packages: string[] },
  context: ContextCli,
): void => {
  const packagesWithLatest = input.packages.map((p) => `${p}@latest`);
  const cmd = `npm install ${packagesWithLatest.join(' ')}`;

  console.log(`üì¶ upgrading: ${packagesWithLatest.join(', ')}`);

  const result = spawnSync(cmd, [], {
    cwd: context.cwd,
    stdio: [process.stdin, process.stdout, process.stderr],
    shell: '/bin/bash',
  });

  if (result.status !== 0) {
    throw new UpgradeExecutionError('npm install failed', {
      packages: input.packages,
      exitCode: result.status,
    });
  }
};
```

### 6. `src/domain.operations/upgrade/UpgradeExecutionError.ts`

Error class for upgrade failures.

```typescript
export class UpgradeExecutionError extends HelpfulError {
  public readonly exitCode: number;

  constructor(
    message: string,
    metadata: { packages: string[]; exitCode: number | null },
  ) {
    super(message, metadata);
    this.exitCode = metadata.exitCode ?? 1;
  }
}
```

### 7. `src/contract/cli/invokeUpdate.ts`

Discoverability: suggest `upgrade` when user types `update`.

```typescript
export const invokeUpdate = ({ program }: { program: Command }): void => {
  program
    .command('update')
    .description('see "upgrade"')
    .action(() => {
      console.error('');
      console.error('‚õàÔ∏è  "update" is not a valid command.');
      console.error('');
      console.error('   Did you mean: npx rhachet upgrade');
      console.error('');
      process.exit(1);
    });
};
```

---

## files to modify

### 1. `src/domain.operations/init/initRolesFromPackages.ts`

Update to use `(input, context)` pattern with `ContextCli`.

```diff
- export const initRolesFromPackages = async (input: {
-   specifiers: RoleSpecifier[];
-   from: string;
- }): Promise<InitRolesResult> => {
+ export const initRolesFromPackages = async (
+   input: { specifiers: RoleSpecifier[] },
+   context: ContextCli,
+ ): Promise<InitRolesResult> => {
```

### 2. `src/contract/cli/invoke.ts`

Register upgrade and update commands.

```diff
  invokeAsk({ program }, context);
  invokeAct({ program }, context);
+ invokeUpgrade({ program });
+ invokeUpdate({ program });

  // invoke it
  await program.parseAsync(input.args, { from: 'user' });
```

---

## test files to create

### acceptance tests

#### `accept.blackbox/cli/upgrade.acceptance.test.ts`

```typescript
import { given, then, useBeforeAll, when } from 'test-fns';
import { genTestTempRepo } from '@/blackbox/.test/infra/genTestTempRepo';
import { invokeRhachetCliBinary } from '@/blackbox/.test/infra/invokeRhachetCliBinary';

describe('rhachet upgrade', () => {
  // usecase.1: upgrade everything (default)
  given('[case1] repo with linked roles', () => {
    const repo = useBeforeAll(async () => {
      const r = genTestTempRepo({ fixture: 'with-published-roles', install: true });
      // link a role first
      invokeRhachetCliBinary({
        args: ['init', '--roles', 'mechanic'],
        cwd: r.path,
      });
      return r;
    });

    when('[t0] upgrade (no flags)', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({ args: ['upgrade'], cwd: repo.path }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });

      then('stdout mentions rhachet upgrade', () => {
        expect(result.stdout).toContain('rhachet');
      });

      then('stdout mentions role upgrade', () => {
        expect(result.stdout).toContain('mechanic');
      });
    });
  });

  // usecase.2: upgrade self only
  given('[case2] repo with rhachet installed', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-published-roles', install: true }),
    );

    when('[t0] upgrade --self', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({ args: ['upgrade', '--self'], cwd: repo.path }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });
    });
  });

  // usecase.3: upgrade specific roles
  given('[case3] repo with multiple roles linked', () => {
    const repo = useBeforeAll(async () => {
      const r = genTestTempRepo({ fixture: 'with-published-roles', install: true });
      invokeRhachetCliBinary({ args: ['init', '--roles', 'mechanic'], cwd: r.path });
      return r;
    });

    when('[t0] upgrade --roles mechanic', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['upgrade', '--roles', 'mechanic'],
          cwd: repo.path,
        }),
      );

      then('exits with status 0', () => {
        expect(result.status).toEqual(0);
      });
    });
  });

  // usecase.6: error handling - role not found
  given('[case6] repo without the specified role', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'with-published-roles', install: true }),
    );

    when('[t0] upgrade --roles nonexistent', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['upgrade', '--roles', 'nonexistent'],
          cwd: repo.path,
          logOnError: false,
        }),
      );

      then('exits with non-zero status', () => {
        expect(result.status).not.toEqual(0);
      });

      then('stderr contains error message', () => {
        expect(result.stderr).toContain('not found');
      });
    });
  });

  // usecase.7: discoverability
  given('[case7] user runs update instead of upgrade', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'minimal' }),
    );

    when('[t0] update', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['update'],
          cwd: repo.path,
          logOnError: false,
        }),
      );

      then('exits with non-zero status', () => {
        expect(result.status).not.toEqual(0);
      });

      then('stderr suggests upgrade', () => {
        expect(result.stderr).toContain('upgrade');
      });
    });
  });

  // usecase.8: edge case - no package.json
  given('[case8] directory without package.json', () => {
    const repo = useBeforeAll(async () =>
      genTestTempRepo({ fixture: 'minimal' }),
    );

    when('[t0] upgrade', () => {
      const result = useBeforeAll(async () =>
        invokeRhachetCliBinary({
          args: ['upgrade'],
          cwd: repo.path,
          logOnError: false,
        }),
      );

      then('exits with non-zero status', () => {
        expect(result.status).not.toEqual(0);
      });
    });
  });
});
```

### unit tests

#### `src/domain.operations/upgrade/discoverLinkedRoles.test.ts`

```typescript
describe('discoverLinkedRoles', () => {
  given('a repo with linked roles in .agent/', () => {
    const testDir = genTestTempDir({ base: __dirname, name: 'discoverLinkedRoles' });

    beforeAll(() => {
      testDir.setup();
      // create .agent/repo=ehmpathy/role=mechanic/
      mkdirSync('.agent/repo=ehmpathy/role=mechanic', { recursive: true });
      mkdirSync('.agent/repo=ehmpathy/role=tuner', { recursive: true });
      mkdirSync('.agent/repo=.this/role=any', { recursive: true });
    });

    afterAll(() => testDir.teardown());

    when('discoverLinkedRoles is called', () => {
      then('returns roles from non-.this repos', () => {
        const roles = discoverLinkedRoles({ from: testDir.path });
        expect(roles).toHaveLength(2);
        expect(roles).toContainEqual({ repo: 'ehmpathy', role: 'mechanic' });
        expect(roles).toContainEqual({ repo: 'ehmpathy', role: 'tuner' });
      });

      then('excludes .this repo', () => {
        const roles = discoverLinkedRoles({ from: testDir.path });
        expect(roles.find((r) => r.repo === '.this')).toBeUndefined();
      });
    });
  });

  given('a repo without .agent/', () => {
    when('discoverLinkedRoles is called', () => {
      then('returns empty array', () => {
        const roles = discoverLinkedRoles({ from: '/tmp/nonexistent' });
        expect(roles).toEqual([]);
      });
    });
  });
});
```

#### `src/domain.operations/upgrade/execUpgrade.test.ts`

```typescript
describe('execUpgrade', () => {
  given('no flags provided', () => {
    when('execUpgrade is called', () => {
      then('defaults to self=true and roleSpecs=["*"]', () => {
        // mock dependencies and verify default behavior
      });
    });
  });

  given('--self flag only', () => {
    when('execUpgrade is called', () => {
      then('upgrades rhachet only, no roles', () => {
        // verify initRolesFromPackages not called
      });
    });
  });

  given('--roles * flag', () => {
    when('execUpgrade is called', () => {
      then('expands wildcard via discoverLinkedRoles', () => {
        // verify discoverLinkedRoles called
      });
    });
  });

  given('duplicate roles specified', () => {
    when('execUpgrade is called', () => {
      then('deduplicates packages', () => {
        // verify single npm install per package
      });
    });
  });
});
```

### integration tests

#### `src/domain.operations/upgrade/execNpmInstall.integration.test.ts`

```typescript
describe('execNpmInstall (integration)', () => {
  given('a directory with package.json', () => {
    const testDir = genTestTempDir({ base: __dirname, name: 'execNpmInstall' });

    beforeAll(() => {
      testDir.setup();
      writeFileSync('package.json', JSON.stringify({
        name: 'test',
        version: '0.0.0',
        dependencies: {},
      }));
    });

    afterAll(() => testDir.teardown());

    when('execNpmInstall is called with valid package', () => {
      then('npm install succeeds', () => {
        // test with a small, fast package
        execNpmInstall({ packages: ['is-odd'], from: testDir.path });
        const pkg = JSON.parse(readFileSync('package.json', 'utf8'));
        expect(pkg.dependencies['is-odd']).toBeDefined();
      });
    });
  });
});
```

---

## test coverage matrix

| layer | file | coverage |
|-------|------|----------|
| acceptance | `upgrade.acceptance.test.ts` | usecases 1-8 |
| unit | `discoverLinkedRoles.test.ts` | linked role discovery |
| unit | `execUpgrade.test.ts` | orchestration logic |
| unit | `resolveRolesToPackages.test.ts` | role ‚Üí package mapping |
| integration | `execNpmInstall.integration.test.ts` | npm install execution |
| integration | `invokeUpgrade.integration.test.ts` | CLI ‚Üí domain flow |

---

## implementation order

1. **domain layer first** (testable in isolation)
   - `UpgradeExecutionError.ts`
   - `discoverLinkedRoles.ts` + unit test
   - `resolveRolesToPackages.ts` + unit test
   - `execNpmInstall.ts` + integration test
   - `execUpgrade.ts` + unit test

2. **contract layer** (CLI binding)
   - `invokeUpgrade.ts`
   - `invokeUpdate.ts`
   - modify `invoke.ts` to register commands

3. **acceptance tests** (end-to-end validation)
   - `upgrade.acceptance.test.ts`

4. **fixture** (if needed)
   - `with-upgradeable-packages` fixture with pinned older versions

---

## dependencies

reuses existing:
- `initRolesFromPackages` ‚Äî for link + init after upgrade
- `getRegistriesByConfigImplicit` ‚Äî for manifest resolution
- `discoverRolePackages` ‚Äî for finding installed packages
- `getGitRepoRoot` ‚Äî for locating package.json
- `HelpfulError` ‚Äî base error class
- `BadRequestError` ‚Äî for validation errors

---

## edge cases handled

| case | handling |
|------|----------|
| no flags | default to `--self --roles *` |
| no linked roles | skip role upgrade, succeed |
| no package.json | fail fast with clear error |
| duplicate roles | deduplicate before install |
| role not found | fail fast before npm install |
| ambiguous role | fail fast with disambiguation hint |
| npm install fails | propagate error, non-zero exit |
| `update` command | suggest `upgrade` |
